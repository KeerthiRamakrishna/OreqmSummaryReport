<?xml version="1.0" encoding="UTF-8"?>
<tracingresults>
  <environment>
    <toolname>ReqM2</toolname>
    <toolversion>1.30.0 (stable)</toolversion>
    <toolcopyright>Copyright 2010 - 2018 Elektrobit Automotive GmbH</toolcopyright>
    <libxmlversion>2.0207</libxmlversion>
    <libxml2compileversion>2.9.10</libxml2compileversion>
    <libxml2runtimeversion>20912</libxml2runtimeversion>
    <perlversion>v5.32.1</perlversion>
    <perlptrsize>64</perlptrsize>
    <commandline>-t -q -o asc_XcpR_tracing_cmdb.oreqm -O /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/TestProtocols/LogBase/requirements -c /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_PluginBuildEnv/common/config/AutoCoreReqM2Rules_RMP4_0.xml -s approved,rejected --wfatal WDUPLICATEID,WDUPLICATEIDANDVER /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/build/reqm/ReqM2_Native/asc_XcpR_public_modulereference_integration_req.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/build/reqm/ReqM2_Native/asc_XcpR_requirements_EB_Requirements.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/build/reqm/ReqM2_Native/asc_XcpR_test_XcpR_Manual_Verification.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/build/reqm/ReqM2_GenericImporter/reqm_DEV.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/build/reqm/ReqM2_GenericImporter/reqm_IMPL.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/build/reqm/ReqM2_GenericImporter/reqm_IMPLXML.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/build/reqm/ReqM2_DocBookImporter/reqm_SWDD.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/build/reqm/ReqM2_OldCImporter/reqm_SWUTS_LEGACY.reqm</commandline>
    <timestamp>Mon Jun 17 20:21:03 2024</timestamp>
  </environment>
  <cmdline>
    <cmdparam>
      <name>I</name>
      <values>
        <value>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/TestProtocols/LogBase/requirements</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>O</name>
      <values>
        <value>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/TestProtocols/LogBase/requirements</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>c</name>
      <values>
        <value>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_PluginBuildEnv/common/config/AutoCoreReqM2Rules_RMP4_0.xml</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>o</name>
      <values>
        <value>asc_XcpR_tracing_cmdb.oreqm</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>q</name>
    </cmdparam>
    <cmdparam>
      <name>s</name>
      <values>
        <value>approved</value>
        <value>rejected</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>t</name>
    </cmdparam>
    <cmdparam>
      <name>wfatal</name>
      <values>
        <value>WDUPLICATEID</value>
        <value>WDUPLICATEIDANDVER</value>
      </values>
    </cmdparam>
  </cmdline>
  <inputfiles>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/build/reqm/ReqM2_Native/asc_XcpR_public_modulereference_integration_req.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/build/reqm/ReqM2_Native/asc_XcpR_requirements_EB_Requirements.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/build/reqm/ReqM2_Native/asc_XcpR_test_XcpR_Manual_Verification.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/build/reqm/ReqM2_GenericImporter/reqm_DEV.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/build/reqm/ReqM2_GenericImporter/reqm_IMPL.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/build/reqm/ReqM2_GenericImporter/reqm_IMPLXML.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/build/reqm/ReqM2_DocBookImporter/reqm_SWDD.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/build/reqm/ReqM2_OldCImporter/reqm_SWUTS_LEGACY.reqm</inputfile>
  </inputfiles>
  <configuration>
    <doctypes>
    <regexs>
      <!-- external level -->
      <regex>creq</regex>       <!-- since 10/1018: introduced for updated tracing model-->

      <!-- product line level -->
      <regex>fea</regex>
      <regex>swpad</regex>      <!-- since 10/1018: introduced for updated tracing model-->
      <regex>swts</regex>

      <!-- bundle level -->
      <regex>swrs</regex>
      <regex>swad</regex>
      <regex>swintts</regex>

      <!-- module level -->
      <regex>swdd</regex>
      <regex>swurs</regex>      <!-- since 10/1018: introduced for updated tracing model-->
      <regex>swmts</regex>      <!-- since 01/1010: introduced for updated tracing model RMP4.0-->
      <regex>swuts</regex>
      <regex>impl</regex>

      <!-- legacy items -->
      <regex>dev</regex>
      <regex>man</regex>
      <regex>lim</regex>
    </regexs>
  </doctypes>
    <rules>
    <!-- The Ruleset for RMP4.0 is currently identical to the previous rule set. This rule is
        intoduce to show that the right file is uses. It will be removed when the RMP4.0 rule set is
    reworked -->
    <rule>
      <name>INFO.Rule set RMP4.0</name>
      <description>This rules indicates that RMP4.0 rule set is used.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(./status!='approved') and (./status!='rejected')]</applyto>
          <condition>false()</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>WRN.general.doctypes</name>
      <description>The used doctype is not part of the tracing model</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobjects/@doctype</applyto>
          <condition>((. != 'creq') or (. != 'fea') or (. != 'swpad') or (. != 'swts') or (. != 'swrs') or (. !='swad') or (. != 'swintts') or (.!= 'swdd') or (. != 'swurs') or (. != 'swmts') or (. != 'swuts') or (. != 'impl') or (. != 'dev') or (. != 'man') or (. != 'lim'))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.general.status</name>
      <description>All specification objects must be either in status=approved or in status=rejected. Other
        statuses are not allowed. How to fix: Set status to rejected or approved.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(./status!='approved') and (./status!='rejected')]</applyto>
          <condition>false()</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.general.rejected</name>
      <description>Status status=rejected is only allowed for requirements. How to fix: set to approved for specification object that are not requirements.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype!='swrs')  and (../@doctype!='swmrs') and (../@doctype!='swurs') and (./status='rejected')]</applyto>
          <condition>false()</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.general.comment</name>
      <description>Specification objects with status=rejected shall have a comment or rationale that
        starts with on of the following texts: "This requirement is informational only", "This requirement is not applicable".
        How to fix: Add some text starting with "This requirement is informational only"
        or "This requirement is not applicable" to either the comment or to the rationale.
        Comment: Implementation of check checks for contains instead of starts-with since there is
        no trim function in the used XPATH engine.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(./status='rejected')]</applyto>
          <condition>contains(./comment,"This requirement is informational only") or contains(./rationale,"This requirement is informational only") or contains(./comment,"This requirement is not applicable") or contains(./rationale,"This requirement is not applicable")</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.general.rejected.coverage</name>
      <description>Specification objects with status=rejected shall not need coverage. How to fix: remove need for coverage.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(./status='rejected')]</applyto>
          <condition>count(./needscoverage)=0</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swurs.needscoverage.count</name>
      <description>Unit requirements with status=approved need to be covered, exceptions from
      this rule: configuration requirements (postfix "_CONF" or "_Conf" or prefix "ECUC_") and requirements with
      a comment starting with "The adherence to this requirement is ensured by the following
      release check (URL to the checklist template plus ID of the check):".
      How to fix: Provide a needsobj element for those specobjects or comment according to the rule.
      </description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swurs') and (./status='approved') and count(./needscoverage/needsobj)=0 and count(./fulfilledby/ffbObj)=0]</applyto>
          <!--This condition is false if the id of a specification object does not end with '_Conf' or '_CONF' or does not start with ECUC_ -->
          <condition>substring-after(./id,"ECUC_")!="" or substring-before(./id,"_Conf")!="" or substring-before(./id,"_CONF")!="" or contains(./comment,"The adherence to this requirement is ensured by the following release check (URL to the checklist template plus ID of the check):")</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swurs.needscoverage.rationale</name>
      <description>Requirements with status=approved and without coverage needs that are
        configuration requirements (postfix "_CONF" or "_Conf" or prefix "ECUC_") shall have a comment or rationale
        with the following text: "This is a configuration parameter requirement without functional
        specification.". How to fix: Add some text starting with "This is a configuration parameter
        requirements without functional specification" to either the comment or to the rationale.</description>
      <regexchecks>
        <regexcheck>
          <applyto>//specobject[(../@doctype='swurs') and (./status='approved') and count(./needscoverage/needsobj)=0 and (substring-after(./id,"ECUC_")!="" or substring-before(./id,"_CONF")!="" or substring-before(./id,"_Conf")!="")]</applyto>
          <regex>This is a configuration parameter requirement without functional specification.</regex>
        </regexcheck>
      </regexchecks>
    </rule>

    <rule>
      <name>ERR.swrs.needscoverage.rationale</name>
      <description>Requirements with status=approved and without coverage needs that are
        configuration requirements (postfix "_CONF" or "_Conf" or prefix "ECUC_") shall have a comment or rationale
        with the following text: "This is a configuration parameter requirement without functional
        specification.". How to fix: Add some text starting with "This is a configuration parameter
        requirements without functional specification" to either the comment or to the rationale.</description>
      <regexchecks>
        <regexcheck>
          <applyto>//specobject[(../@doctype='swrs') and (./status='approved') and count(./needscoverage/needsobj)=0 and (substring-after(./id,"ECUC_")!="" or substring-before(./id,"_CONF")!="" or substring-before(./id,"_Conf")!="")]</applyto>
          <regex>This is a configuration parameter requirement without functional specification.</regex>
        </regexcheck>
      </regexchecks>
    </rule>

    <rule>
      <name>ERR.swurs.releases</name>
      <description>Requirements which originates from AUTOSAR (source tag contains term 'AUTOSAR_SWS', 'AUTOSAR_TPS',
        'AUTOSAR_ASWS' or 'AUTOSAR_TR') shall have their release tag set to 'AUTOSAR {major}.{minor}.{patch}' (e.g. 'AUTOSAR 4.3.0').
        Other requirements (including refinements of AUTOSAR requirements) must not contain any of the listed prefixes as
        part of the source tag.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swurs') and (contains(./source,'AUTOSAR_SWS') or contains(./source,'AUTOSAR_TPS') or contains(./source,'AUTOSAR_ASWS') or contains(./source,'AUTOSAR_TR'))]</applyto>
          <condition>contains(./releases/release,'AUTOSAR')</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swrs.releases</name>
      <description>Requirements which originates from AUTOSAR (source tag contains term 'AUTOSAR_SWS', 'AUTOSAR_TPS',
        'AUTOSAR_ASWS' or 'AUTOSAR_TR') shall have their release tag set to 'AUTOSAR {major}.{minor}.{patch}' (e.g. 'AUTOSAR 4.3.0').
        Other requirements (including refinements of AUTOSAR requirements) must not contain any of the listed prefixes as
        part of the source tag.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swrs') and (contains(./source,'AUTOSAR_SWS') or contains(./source,'AUTOSAR_TPS') or contains(./source,'AUTOSAR_ASWS') or contains(./source,'AUTOSAR_TR'))]</applyto>
          <condition>contains(./releases/release,'AUTOSAR')</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swdd.needscoverage.count</name>
      <description>Design elements with status=approved need to be covered.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swdd') and (./status='approved') and count(./needscoverage/needsobj)=0]</applyto>
          <condition>false()</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swurs.needscoverage.doctypes</name>
      <description>Requirements can be covered only by swurs, swad, dev, lim, swdd, impl, swuts, swmts, or man</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swurs')]</applyto>
          <condition>(./needscoverage/needsobj="swurs" or ./needscoverage/needsobj="swad" or ./needscoverage/needsobj="dev" or ./needscoverage/needsobj="lim" or ./needscoverage/needsobj="swdd" or ./needscoverage/needsobj="impl" or ./needscoverage/needsobj="swuts" or ./needscoverage/needsobj="swmts" or ./needscoverage/needsobj="man" or (count(./needscoverage/needsobj)=0))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swrs.needscoverage.doctypes</name>
      <description>Requirements of type swrs can be covered only by swrs, swurs, swad, swintts or man</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swrs')]</applyto>
          <condition>(./needscoverage/needsobj="swrs" or ./needscoverage/needsobj="swurs" or ./needscoverage/needsobj="swad" or ./needscoverage/needsobj="swuts" or ./needscoverage/needsobj="swintts" or ./needscoverage/needsobj="man" or (count(./needscoverage/needsobj)=0))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swdd.needscoverage.doctypes</name>
      <description>Design elements of type swdd can only be covered by swdd, swurs, impl, swuts, lim or man</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swdd')]</applyto>
          <condition>(./needscoverage/needsobj="swdd" or ./needscoverage/needsobj="swurs" or ./needscoverage/needsobj="impl" or ./needscoverage/needsobj="swuts" or ./needscoverage/needsobj="swmts" or ./needscoverage/needsobj="lim" or ./needscoverage/needsobj="man" or (count(./needscoverage/needsobj)=0))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.dev.needscoverage.count</name>
      <description>Deviations shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='dev')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swuts.needscoverage.count</name>
      <description>Test case sepecifications shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swuts')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swmts.needscoverage.count</name>
      <description>Test case sepecifications shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swmts')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swintts.needscoverage.count</name>
      <description>Test case sepecifications shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swintts')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swts.needscoverage.count</name>
      <description>Test case sepecifications shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swts')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.man.needscoverage.count</name>
      <description>Manual test cases shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='man')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.impl.needscoverage.count</name>
      <description>Source code shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='impl')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.lim.needscoverage.count</name>
      <description>Limitations shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='lim')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.fea.needscoverage.test</name>
      <description>Features shall be tested by software test ('swts') or manuel test ('man'). If no test is planned a justification shall be given.
                   A justification can be given in the futherinfo tag. The justification shall start with this rule name.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='fea')]</applyto>
          <condition>(
               ./needscoverage/needsobj="swts" or ./needscoverage/needsobj="man" or ./fulfilledby/ffbObj/ffbType="swts" or ./fulfilledby/ffbObj/ffbType="man" or contains(./furtherinfo,"fea.needscoverage.test") or contains(./furtherinfo,"fea.needscoverage.doctypes"))</condition>
        </conditioncheck>
      </conditionchecks>
          </rule>

    <rule>
      <name>WRN.fea.needscoverage.impl</name>
      <description>Features shall be covered by implementation fea, swrs, swad, swpad, swurs, man and swts. For lagacy features a justification is acceppted. A justification can be given in the futherinfo tag. The justification shall start with this rule name.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='fea')]</applyto>
          <condition>( ./needscoverage/needsobj="swrs" or ./fulfilledby/ffbObj/ffbType="swrs" or ./fulfilledby/ffbObj/ffbType="swad" or ./needscoverage/needsobj="swpad" or ./fulfilledby/ffbObj/ffbType="swpad" or ./needscoverage/needsobj="swurs" or ./fulfilledby/ffbObj/ffbType="swurs" or ./needscoverage/needsobj="fea" or ./fulfilledby/ffbObj/ffbType="fea" or contains(./furtherinfo,"fea.needscoverage.impl"))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>


    <rule>
      <name>ERR.swad.fulfilledby.doctypes</name>
      <description>Architectural design objects of type swad can only be covered by swurs, swad, swdd, swintts, man, otherwise they should be refined with swrs</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swad')]</applyto>
          <condition>(./fulfilledby/ffbObj/ffbType="swurs" or ./needscoverage/needsobj="swurs" or ./fulfilledby/ffbObj/ffbType="req" or ./needscoverage/needsobj="req" or ./fulfilledby/ffbObj/ffbType="swad" or ./needscoverage/needsobj="swad" or ./fulfilledby/ffbObj/ffbType="swdd" or ./fulfilledby/ffbObj/ffbType="swintts" or ./needscoverage/needsobj="swintts" or ./fulfilledby/ffbObj/ffbType="man" or ./needscoverage/needsobj="man") </condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swmts.providescoverage.doctypes</name>
      <description>Test case specifications (tcs) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='tcs')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.man.providescoverage.doctypes</name>
      <description>Manual test case specification (man) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='man')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

   <rule>
      <name>ERR.swuts.providescoverage.doctypes</name>
      <description>Software unit test case specification (swuts) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swuts')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

   <rule>
      <name>ERR.swintts.providescoverage.doctypes</name>
      <description>Software integration test case specification (swintts) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swintts')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

   <rule>
      <name>ERR.swts.providescoverage.doctypes</name>
      <description>Software test case specification (swts) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swts')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

  </rules>
    <oreqmRules>

        <rule>
            <name>WRN.swts.needscoverage.count</name>
            <description>Violated if there are more than 10 swts specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swts']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swts']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swts.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>
        <rule>
            <name>WRN.man.needscoverage.count</name>
            <description>Violated if there are more than 10 man specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='man']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='man']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>man.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>
        <rule>
            <name>WRN.swintts.needscoverage.count</name>
            <description>Violated if there are more than 10 swintts specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swintts']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swintts']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swintts.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>
        <rule>
            <name>WRN.swmts.needscoverage.count</name>
            <description>Violated if there are more than 10 swmts specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swmts']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swmts']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swmts.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swuts.needscoverage.count</name>
            <description>Violated if there are more than 10 swuts specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swuts']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swuts']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swuts.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swpad.needscoverage.count</name>
            <description>Violated if there are more than 10 swpad specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swpad']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swpad']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swpad.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swrs.needscoverage.count</name>
            <description>Violated if there are more than 10 swrs specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swrs']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swrs']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swrs.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swad.needscoverage.count</name>
            <description>Violated if there are more than 10 swad specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swad']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swad']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swad.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swurs.needscoverage.count</name>
            <description>Violated if there are more than 10 swurs specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swurs']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swurs']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swurs.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swdd.needscoverage.count</name>
            <description>Violated if there are more than 10 swdd specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swdd']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swdd']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swdd.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.impl.needscoverage.count</name>
            <description>Violated if there are more than 10 impl specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='impl']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='impl']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>impl.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swrs.fulfilledby.count</name>
            <description>Violated if there are more than 10 swrs specobjects as fulfilledby link to one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swrs'])) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swrs'])) &gt; 10]/furtherinfo</applyto>
                                        <regex>swrs.fulfilledby.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swad.fulfilledby.count</name>
            <description>Violated if there are more than 10 swad specobjects as fulfilledby link to one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swad'])) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swad'])) &gt; 10]/furtherinfo</applyto>
                                        <regex>swad.fulfilledby.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swurs.fulfilledby.count</name>
            <description>Violated if there are more than 10 swurs specobjects as fulfilledby link to one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swurs'])) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swurs'])) &gt; 10]/furtherinfo</applyto>
                                        <regex>swurs.fulfilledby.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swdd.fulfilledby.count</name>
            <description>Violated if there are more than 10 swdd specobjects as fulfilledby link to one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swdd'])) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swdd'])) &gt; 10]/furtherinfo</applyto>
                                        <regex>swdd.fulfilledby.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>
  </oreqmRules>
  </configuration>
  <specdocument>
    <specobjects doctype="swurs">
    <specobject>
      <id>intgr.XcpR.EB_INTREQ_XcpR_0001</id>
      <status>approved</status>
      <source>EB integration requirement</source>
      <version>1</version>
      <description>
        The Routing Paths for requests from the Xcp master to the Xcp slave and for responses from Xcp slave to Xcp master,
        shall be unique between configured Connection Groups.
      </description>
      <rationale>
        Each configured Connection Group is composed of at least one Routing Path for requests from Xcp master to Xcp slave
        and for responses from Xcp slave to Xcp master.
        After XcpR is in state CONNECTED, the Active Connection Group is saved based on these two Routing Paths.
        When a XcpR_RxIndication() request is made, it is accepted only if it is part of the Active Connection Group.
        If these two Routing Paths are not unique for each Connection Group, XcpR cannot determine which Connection Group shall
        be used for forwarding messages.
      </rationale>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_3016</srcid><srcstatus/><internalId>393</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>0</internalId></specobject>
    <specobject>
      <id>intgr.XcpR.EB_INTREQ_XcpR_0002</id>
      <status>approved</status>
      <source>EB integration requirement</source>
      <version>1</version>
      <description>
        The master Xcp shall have MaxCto set as the minimum between MaxCto from the local Xcp slave
        and remote Xcp slave, otherwise messages won't be correctly received.
      </description>
      <comment>
        The adherence to this requirement is ensured by the following release check (URL to the checklist template plus ID of the check):
        this requirement is only used as a guideline for integration and cannot be traced.
      </comment>
      <tags>
        <tag>Integration requirement</tag>
      </tags>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1</internalId></specobject>
    <specobject>
      <id>intgr.XcpR.EB_INTREQ_XcpR_0003</id>
      <status>approved</status>
      <source>EB integration requirement</source>
      <version>2</version>
      <description>
        If "packing of multiple messages in one frame" is enabled on a remote Xcp instance, both XcpR Source and Destination connected
        to that particular Xcp instance shall have "packing of multiple messages in one frame" enabled.
      </description>
      <rationale>
        Xcp supports the "packing of multiple messages in one frame" feature.
        XcpR also supports this feature, but it can be enabled either for a Source, either for a Destination.
      </rationale>
      <comment>
        The adherence to this requirement is ensured by the following release check (URL to the checklist template plus ID of the check):
        this requirement is only used as a guideline for integration and cannot be traced.
      </comment>
      <tags>
        <tag>Integration requirement</tag>
      </tags>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2</internalId></specobject>
    <specobject>
      <id>intgr.XcpR.EB_INTREQ_XcpR_0004</id>
      <status>approved</status>
      <source>EB integration requirement</source>
      <version>1</version>
      <description>
        If XcpR supports "packing of multiple messages in one frame" for the connection to Master Xcp but not for the connection
        to the slave Xcp, the XcpR Source from slave Xcp shall have the "receive from rx indication" option enabled and the
        Master Xcp shall have "packing of multiple messages in one frame" enabled.
      </description>
      <rationale>
        If one frame with multiple messages received from master Xcp, and the slave Xcp replies with multiple responses,
        if "receive from rx indication" option is not enabled, the second response will be sent with the same PduId,
        and the buffer for this PduId is locked in XcpR.
      </rationale>
      <comment>
        The adherence to this requirement is ensured by the following release check (URL to the checklist template plus ID of the check):
        this requirement is only used as a guideline for integration and cannot be traced.
      </comment>
      <tags>
        <tag>Integration requirement</tag>
      </tags>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>3</internalId></specobject>
    <specobject>
      <id>intgr.XcpR.EB_INTREQ_XcpR_0005</id>
      <status>approved</status>
      <source>EB integration requirement</source>
      <version>1</version>
      <description>
        The bus timeout for TxConfirmation in Xcp shall be configured with a higher value than the one in XcpR.
      </description>
      <rationale>
        XcpR will forward the messages from Xcp and will wait for TxConfirmation which it forwards to Xcp, so 
        Xcp should not disconnect before XcpR.
      </rationale>
      <comment>
        The adherence to this requirement is ensured by the following release check (URL to the checklist template plus ID of the check):
        this requirement is only used as a guideline for integration and cannot be traced.
      </comment>
      <tags>
        <tag>Integration requirement</tag>
      </tags>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>4</internalId></specobject>
    <specobject>
      <id>intgr.XcpR.EB_INTREQ_XcpR_0006</id>
      <status>approved</status>
      <source>EB integration requirement</source>
      <version>2</version>
      <description>
        If FlexRay sequence correction is enabled for a source, then it shall be enabled for its linked remote Xcp destination
        and also for the Master Xcp.
      </description>
      <comment>
        The adherence to this requirement is ensured by the following release check (URL to the checklist template plus ID of the check):
        this requirement is only used as a guideline for integration and cannot be traced.
      </comment>
      <tags>
        <tag>Integration requirement</tag>
      </tags>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>5</internalId></specobject>
    <specobject>
      <id>intgr.XcpR.EB_INTREQ_XcpR_0007</id>
      <status>approved</status>
      <source>EB integration requirement</source>
      <version>1</version>
      <description>
        For connections over CDD, the Upper Layer short name and Upper Layer header file, shall have UpperLayer Cdd Short name
        and UpperLayer Cdd Header file need to have the same values in all configured Rx Destinations.
      </description>
      <rationale>
        Examples for connection over CDD with a upper layer Xcp module are: Xcp and XcpOnCdd_Cbk.h
      </rationale>
      <comment>
        The adherence to this requirement is ensured by the following release check (URL to the checklist template plus ID of the check):
        this requirement is only used as a guideline for integration and cannot be traced.
      </comment>
      <tags>
        <tag>Integration requirement</tag>
      </tags>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>6</internalId></specobject>
    <specobject>
      <id>intgr.XcpR.EB_INTREQ_XcpR_0008</id>
      <status>approved</status>
      <source>EB integration requirement</source>
      <version>1</version>
      <description>
        If multiple CDD destinations are configured, then all these destinations
        shall use the same callback functions.
      </description>
      <comment>
        The adherence to this requirement is ensured by the following release check (URL to the checklist template plus ID of the check):
        this requirement is only used as a guideline for integration and cannot be traced.
      </comment>
      <tags>
        <tag>Integration requirement</tag>
      </tags>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>7</internalId></specobject>
    <specobject>
      <id>intgr.XcpR.EB_INTREQ_XcpR_0009</id>
      <status>approved</status>
      <source>EB integration requirement</source>
      <version>1</version>
      <description>
        In the XcpR routing paths list, one source shall be linked to either one destination,
        or a maximum of 2 destinations: one Rx destination and one Tx destination. A source cannot
        be linked to 2 Rx destinations or 2 Tx destinations.
      </description>
      <comment>
        The adherence to this requirement is ensured by the following release check (URL to the checklist template plus ID of the check):
        this requirement is only used as a guideline for integration and cannot be traced.
      </comment>
      <tags>
        <tag>Integration requirement</tag>
      </tags>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>8</internalId></specobject>

    <specobject>
      <id>intgr.XcpR.EB_INTREQ_XcpR_0010</id>
      <status>approved</status>
      <source>EB integration requirement</source>
      <version>1</version>
      <description>
        Connections between XcpR and a master Xcp, or between XcpR and a slave Xcp, shall have the same bus-type attributes and PDU attributes.
      </description>
      <rationale>
        For XcpR to be connected, for example, to a master Xcp on FlexRay, it needs to configure a XcpR source on Fr and a XcpR
        destination on Fr. This source shall have the same characteristics as the destination (i.e. Multiple packing enabled, package alignment, MaxCto etc.)
      </rationale>
      <comment>
        The adherence to this requirement is ensured by the following release check (URL to the checklist template plus ID of the check):
        this requirement is only used as a guideline for integration and cannot be traced.
      </comment>
      <tags>
        <tag>Integration requirement</tag>
      </tags>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>9</internalId></specobject>
<!--
    <specobject>
      <id>intgr.XcpR.EB_INTREQ_XcpR_0011</id>
      <status>approved</status>
      <source>EB integration requirement</source>
      <version>1</version>
      <description>
        Configured DAQ destinations from XcpR to a master Xcp shall have the same bus-type attributes and PDU attributes as the configured destination from XcpR to a master Xcp for CMD/RES packages.
      </description>
      <rationale>
        XcpR cannot use different attributes for a DAQ destination to a master Xcp, for example, on FlexRay, compared to the one configured for CMD/RES packages, because of differences in frame construction (package alignment, multiple packing enabled, disabled, MaxCto etc. )
      </rationale>
      <tags>
        <tag>Integration requirement</tag>
      </tags>
    </specobject>

    <specobject>
      <id>intgr.XcpR.EB_INTREQ_XcpR_0012</id>
      <status>approved</status>
      <source>EB integration requirement</source>
      <version>1</version>
      <description>
        Configured STIM sources to XcpR from a master Xcp shall have the same bus-type attributes and PDU attributes as the configured source to XcpR from a master Xcp for CMD/RES packages.
      </description>
      <rationale>
        XcpR cannot use different attributes for a STIM source from a master Xcp, for example, on FlexRay, compared to the one configured for CMD/RES packages, because of differences in frame construction (package alignment, multiple packing enabled, disabled, MaxCto etc. )
      </rationale>
      <tags>
        <tag>Integration requirement</tag>
      </tags>
    </specobject>
-->
  </specobjects>
    <specobjects doctype="swurs">

  <!--
    +++++++++++++++++++++++++++++++++++++++++
    Requirements for configuration parameters
    +++++++++++++++++++++++++++++++++++++++++
  -->

    <specobject>
      <id>XcpR.Config.XcpRGeneral</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Container name:           XcpRGeneral
        Description:              This container contains the general configuration
                                  parameters of the XCPR.
        Multiplicity:             1
        Configuration Parameters: XcpRMultipleSlavesEnabled
                                  XcpRDevErrorDetect
                                  XcpRVersionInfoApi
                                  XcpRMainFunctionPeriod
                                  XcpRQueueSize
                                  XcpRTxRetryCount
                                  XcpRTxBusRetry
                                  XcpRTxBusTimeout
                                  XcpREventPacketEnabled
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_36</srcid><srcstatus/><internalId>287</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>10</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRGeneral.XcpRMultipleSlavesEnabled</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:             XcpRMultipleSlavesEnabled
        Parent Container: XcpRGeneral
        Description:      This configuration parameter permits to enable/disable the XcpR multiple slaves functionality
        Multiplicity:     1
        Type:             EcucBooleanParamDef
        Default value:    false
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_40</srcid><srcstatus/><internalId>288</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>11</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRGeneral.XcpRDevErrorDetect</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:             XcpRDevErrorDetect
        Parent Container: XcpRGeneral
        Description:      Switches the Default Error Tracer (Det) detection and notification ON or OFF.
                            * true:  enabled (ON).
                            * false: disabled (OFF).
        Multiplicity:     1
        Type:             EcucBooleanParamDef
        Default value:    true
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_67</srcid><srcstatus/><internalId>289</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>12</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRGeneral.XcpRVersionInfoApi</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:             XcpRVersionInfoApi {XCPR_VERSION_INFO_API}
        Parent Container: XcpRGeneral
        Description:      Activates the XcpR_GetVersionInfo() API.
                            TRUE: Enables the XcpR_GetVersionInfo() API.
                            FALSE: XcpR_GetVersionInfo() API is not included.
        Multiplicity:     1
        Type:             EcucBooleanParamDef
        Default value:    false
        Scope / Dependency scope: local
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_103</srcid><srcstatus/><internalId>290</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>13</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRGeneral.XcpRMainFunctionPeriod</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:          XcpRMainFunctionPeriod {XCPR_MAIN_FUNCTION_PERIOD}
        Description:   This parameter defines the processing cycle of the main function of XcpR
                       module in seconds.
        Multiplicity:  1
        Type:          EcucFloatParamDef
        Range:         0.001 .. 255
        Default value: 0.005
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_127</srcid><srcstatus/><internalId>291</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>14</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRGeneral.XcpRQueueSize</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:          XcpRQueueSize {XCPR_MSG_QUEUE_SIZE}
        Description:   This parameter defines the queue size for XcpR messages to be
                       processed during the main function of XcpR.
        Multiplicity:  1
        Type:          EcucIntegerParamDef
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_158</srcid><srcstatus/><internalId>292</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>15</internalId></specobject>

     <specobject>
      <id>XcpR.Config.XcpRGeneral.XcpRTxRetryCount</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:             XcpRTxRetryCount
        Parent Container: XcpRGeneral
        Description:      This parameter defines the number of times the data will be retried for transmission
        Multiplicity:     1
        Range:            0 .. 255
        Type:             EcucIntegerParamDef
        Default value:    0
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_193</srcid><srcstatus/><internalId>294</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>16</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRGeneral.XcpRTxBusRetry</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:             XcpRTxBusRetry
        Parent Container: XcpRGeneral
        Description:      This parameter defines the number of retries the Xcp slave performs in order to transmit a Pdu.
        Multiplicity:     1
        Range:            0 .. 255
        Type:             EcucIntegerParamDef
        Default value:    0
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_235</srcid><srcstatus/><internalId>295</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>17</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRGeneral.XcpRTxBusTimeout</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:             XcpRTxBusTimeout
        Parent Container: XcpRGeneral
        Description:      Defines the maximum allowed time frame for a message to be transmitted
                          from the XcpR to the Xcp Slave or Xcp Master.
        Multiplicity:     1
        Range:            0.001 .. 255
        Type:             EcucIntegerParamDef
        Default value:    2.0
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_286</srcid><srcstatus/><internalId>296</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>18</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRGeneral.XcpREventPacketEnabled</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:             XcpREventPacketEnabled
        Parent Container: XcpRGeneral
        Description:      Controls the transmission of EV_SESSION_TERMINATED events when XcpR is automatic disconnected.
                            * true:  enabled (ON).
                            * false: disabled (OFF).
        Multiplicity:     1
        Type:             EcucBooleanParamDef
        Default value:    true
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_330</srcid><srcstatus/><internalId>297</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectPosRes_FromRemoteXcp</srcid><srcstatus/><internalId>574</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectPosRes_FromLocalXcp</srcid><srcstatus/><internalId>575</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>19</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRGeneral.XcpRSourcePDUConfiguration</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Container Name:     XcpRSourcePDUConfiguration
        Description:        Groups PDU information related to a connection via a specified
                            bus (Can/CanFD/FlexRay/Ethernet/CDD).
                            Multiple connection via the same bus type shall be allowed to be
                            configured.
        Multiplicity:       1..*
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_358</srcid><srcstatus/><internalId>298</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>20</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRSourcePDUConfiguration.XcpRSourceInterfaceType</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Choice container name: XcpRSourceInterfaceType
        Description:           Choice container used to select the connection type:
                               * XcpRConnectionOverCAN: only PDUs mapped to the referenced
                               CanIf/Configuration container the selected connection configuration
                               * XcpRConnectionOverCANFD: only PDUs mapped to the referenced
                               CanIf/Configuration container the selected connection configuration
                               * XcpRConnectionOverFlexRay: only PDUs mapped to the same FlexRay
                               controller are accepted to the selected connection configuration.
                               * XcpRConnectionOverEthernet: only PDUs mapped to the same Socket
                               connection group are accepted to the selected connection configuration.
                               * XcpRConnectionOverCdd: only PDUs referenced from a CDD configuration
                               are accepted to the selected connection configuration.
        Multiplicity:          1
      </description>
      <rationale>
        Each connection has specific requirements and dependencies, depending on the type of the used transport layer.
      </rationale>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_374</srcid><srcstatus/><internalId>299</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>21</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRSourceInterfaceType.XcpRSourceConnectionOverCAN</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Container Name:           XcpRSourceConnectionOverCAN
        Description:              This container specifies connection information required by
                                  communication over the CAN transport layer from source PDU.
        Configuration Parameters: XcpRSourceConnectionCanIfCfgRef
        Multiplicity:             0..1
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_398</srcid><srcstatus/><internalId>300</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>22</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRSourceConnectionOverCAN.XcpRSourceConnectionCanIfCfgRef</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:               XcpRSourceConnectionCanIfCfgRef
        Parent Container:   XcpRSourceConnectionOverCAN
        Description:        Reference to the CanIf interface where the Source/Destination PDUs,
                            configured for the selected connection, can be found
        Multiplicity:       1
        Type:               EcucReferenceDef
        Multiplicity:       1
        Scope / Dependency: The XcpR connection type value has to be XcpRConnectionOverCAN.
                            A valid CanIf configuration has to be available for selection.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_400</srcid><srcstatus/><internalId>301</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>23</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRSourceInterfaceType.XcpRSourceConnectionOverCANFD</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Container Name:           XcpRSourceConnectionOverCANFD
        Description:              This container specifies connection information required by
                                  communication over the CANFD transport layer from source PDU.
        Multiplicity:             0..1
        Configuration Parameters: XcpRSourceCanFdMaxDlcRequired
                                  XcpRSourceCanFdMaxDlc
                                  XcpRSourceConnectionCanFdCanIfCfgRef
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_433</srcid><srcstatus/><internalId>302</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>24</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRSourceConnectionOverCANFD.XcpRSourceCanFdMaxDlcRequired</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:               XcpRSourceCanFdMaxDlcRequired
        Parent Container:   XcpRSourceConnectionOverCANFD
        Description:        Defines if the length of the XcpR packages shall always be aligned to configured
                            maximum data length by adding fill bytes.
        Multiplicity:       1
        Type:               EcucBooleanParamDef
        Multiplicity:       0..1
        Scope / Dependency: This parameter is available only if the XcpRSourceInterfaceType choice is XcpRSourceConnectionOverCANFD.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_435</srcid><srcstatus/><internalId>303</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>25</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRSourceConnectionOverCANFD.XcpRSourceCanFdMaxDlc</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:               XcpRSourceCanFdMaxDlc
        Parent Container:   XcpRSourceConnectionOverCANFD
        Description:        Defines the value of maximum data length of a CAN-FD frame
        Multiplicity:       1
        Type:               EcucIntegerParamDef
        Range:              [8, 12, 16, 20, 24, 32, 48, 64]
        Default value:      64
        Scope / Dependency: This parameter is available only if the XcpRSourceInterfaceType choice is XcpRSourceConnectionOverCANFD.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_461</srcid><srcstatus/><internalId>304</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>26</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRSourceConnectionOverCANFD.XcpRSourceConnectionCanFdCanIfCfgRef</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:               XcpRSourceConnectionCanFdCanIfCfgRef
        Parent Container:   XcpRSourceConnectionOverCANFD
        Description:        Reference to the CanIf interface where the Source or Destination PDUs,
                            configured for the selected connection, can be found
        Multiplicity:       1
        Type:               EcucReferenceDef
        Scope / Dependency: The XcpR connection type value has to be XcpRConnectionOverCANFD.
                            A valid CanIf configuration has to be available for selection.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_502</srcid><srcstatus/><internalId>305</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>27</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRSourceInterfaceType.XcpRSourceConnectionOverFlexRay</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Container Name:           XcpRSourceConnectionOverFlexRay
        Description:              This container specifies connection information required by
                                  communication over the FlexRay transport layer from source PDU.
        Multiplicity:             0..1
        Configuration Parameters: XcpRSourceFlxNodeAddress
                                  XcpRSourceFlxHeaderAlignment
                                  XcpRSourcePackMultiMsgInOneFlexRayFrame
                                  XcpRSourceSequenceCorrectionEnabled
                                  XcpRSourceMaxFlexMsgLength
                                  XcpRSourceConnectionFrIfCfgRef
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_535</srcid><srcstatus/><internalId>306</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>28</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRSourceConnectionOverFlexRay.XcpRSourceFlxNodeAddress</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:               XcpRSourceFlxNodeAddress
        Parent Container:   XcpRSourceConnectionOverFlexRay
        Description:        Defines the node address for XcpR (NAX) that is used
        Multiplicity:       1
        Type:               EcucIntegerParamDef
        Range:              0 to 255
        Default value:      0
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_537</srcid><srcstatus/><internalId>307</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>29</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRSourceConnectionOverFlexRay.XcpRSourceFlxHeaderAlignment</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:               XcpRSourceFlxHeaderAlignment
        Parent Container:   XcpRSourceConnectionOverFlexRay
        Description:        Defines the alignment of the FlexRay XcpR header
        Multiplicity:       1
        Type:               EcucEnumerationParamDef
        Range:              | PACKET_ALIGNMENT_8  | 8 bit alignment is used  |
                            | PACKET_ALIGNMENT_16 | 16 bit alignment is used |
                            | PACKET_ALIGNMENT_32 | 32 bit alignment is used |
        Default value:      PACKET_ALIGNMENT_8
      </description>
      <comment>
        Selecting a smaller value for this parameter reduces the RAM consumption of
        the module code.
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_569</srcid><srcstatus/><internalId>308</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>30</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRSourceConnectionOverFlexRay.XcpRSourcePackMultiMsgInOneFlexRayFrame</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:             XcpRSourcePackMultiMsgInOneFlexRayFrame
        Parent Container: XcpRSourceConnectionOverFlexRay
        Description:      Enables the concatenation of multiple XcpR messages in one frame, for
                          FlexRay communication
        Multiplicity:     1
        Type:             EcucBooleanParamDef
        Default value:    false
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_609</srcid><srcstatus/><internalId>309</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>31</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRSourceConnectionOverFlexRay.XcpRSourceSequenceCorrectionEnabled</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:             XcpRSourceSequenceCorrectionEnabled
        Parent Container: XcpRSourceConnectionOverFlexRay
        Description:      Enables the sequence correction. Each sent frame will contain a counter
                          that is incremented for each XcpR packet
        Multiplicity:     1
        Type:             EcucBooleanParamDef
        Default value:    false
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_630</srcid><srcstatus/><internalId>310</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>32</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRSourceConnectionOverFlexRay.XcpRSourceMaxFlexMsgLength</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:               XcpRSourceMaxFlexMsgLength
        Parent Container:   XcpRSourceConnectionOverFlexRay
        Description:        Defines the initial maximum data length of a FlexRay frame that a specific
                            slave is able to receive or transmit in a specific XcpR-dedicated buffer.
        Multiplicity:       1
        Type:               EcucIntegerParamDef
        Range:              8 .. 255
        Default value:      8
        Scope / Dependency: This parameter is available only if the XcpRSourceInterfaceType choice is XcpRSourceConnectionOverFlexRay and
                            XcpRDestinationPackMultiMsgInOneFlexRayFrame is enabled.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_651</srcid><srcstatus/><internalId>311</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>33</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRSourceConnectionOverFlexRay.XcpRSourceConnectionFrIfCfgRef</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:               XcpRSourceConnectionFrIfCfgRef
        Parent Container:   XcpRSourceConnectionOverFlexRay
        Description:        Reference to the FrIf interface where the Source or Destination PDUs,
                            configured for the selected connection, can be found. This reference is
                            used to validate/generate PDUs information for the assigned PDUs for
                            the selected connection over FlexRay.
        Multiplicity:       1
        Type:               EcucReferenceDef
        Scope / Dependency: The XcpR connection type value has to be XcpRConnectionOverFlexRay.
                            A valid FrIf configuration has to be available for selection.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_706</srcid><srcstatus/><internalId>312</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>34</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRSourceInterfaceType.XcpRSourceConnectionOverEthernet</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Container Name:           XcpRSourceConnectionOverEthernet
        Description:              This container specifies connection information required by
                                  communication over the Ethernet transport layer from source PDU.
        Multiplicity:             0..1
        Configuration Parameters: XcpRSourceOpenSoCon
                                  XcpRSourcePackMultiMsgInOneEthernetFrame
                                  XcpRSourceMaxEthernetMsgLength
                                  XcpRSourceConnectionSoAdConfigRef
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_739</srcid><srcstatus/><internalId>313</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>35</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRSourceConnectionOverEthernet.XcpRSourceOpenSoCon</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:               XcpRSourceOpenSoCon
        Parent Container:   XcpRSourceConnectionOverEthernet
        Description:        Enables automatic opening of the Ethernet socket(s) during startup.
                            If this parameter is enabled SoAd_OpenSoCon() will be called during XcpR_Init()
                            for each configured socket.
        Multiplicity:       1
        Type:               EcucBooleanParamDef
        Default value:      true
        Scope / Dependency: The XcpR connection type value has to be XcpRConnectionOverEthernet.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_742</srcid><srcstatus/><internalId>314</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>36</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRSourceConnectionOverEthernet.XcpRSourcePackMultiMsgInOneEthernetFrame</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:               XcpRSourcePackMultiMsgInOneEthernetFrame
        Parent Container:   XcpRSourceConnectionOverEthernet
        Description:        Enables the concatenation of multiple XcpR messages in one frame,
                            for Ethernet communication
        Multiplicity:       1
        Type:               EcucBooleanParamDef
        Default value:      false
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_820</srcid><srcstatus/><internalId>315</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>37</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRSourceConnectionOverEthernet.XcpRSourceMaxEthernetMsgLength</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:               XcpRSourceMaxEthernetMsgLength
        Parent Container:   XcpRSourceConnectionOverEthernet
        Description:        Defines the initial maximum data length of a Ethernet frame that a specific
                            slave is able to receive or transmit in a frame.
        Multiplicity:       1
        Type:               EcucIntegerParamDef
        Range:              8 .. 1454
        Default value:      8
        Scope / Dependency: This parameter is available only if the XcpRSourceInterfaceType choice is XcpRSourceConnectionOverEthernet and
                            XcpRSourcePackMultiMsgInOneEthernetFrame is enabled.
      </description>
      <comment>
        Hint this parameter should be high enough to be able to accommodate at least
        2 maximum size DTOs
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_848</srcid><srcstatus/><internalId>316</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>38</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRSourceConnectionOverEthernet.XcpRSourceConnectionSoAdConfigRef</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:               XcpRSourceConnectionSoAdConfigRef
        Parent Container:   XcpRSourceConnectionOverEthernet
        Description:        Reference to the SoAd interface where the Source or Destination PDUs, configured for
                            the selected connection, can be found. This reference is used to validate/generate
                            PDUs information for the assigned PDUs for the selected connection over Ethernet.
        Multiplicity:       1
        Type:               EcucReferenceDef
        Scope / Dependency: The XcpR connection type value has to be XcpRConnectionOverEthernet.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_898</srcid><srcstatus/><internalId>317</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>39</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRSourceInterfaceType.XcpRSourceConnectionOverCDD</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Container Name:           XcpRSourceConnectionOverCDD
        Description:              This container specifies connection information required by
                                  communication over a Complex Device Driver from source PDU.
        Multiplicity:             0..1
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_983</srcid><srcstatus/><internalId>318</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>40</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRSourceInterfaceType.XcpRIsSrcMasterConnection</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:               XcpRIsSrcMasterConnection
        Parent Container:   XcpRSourceInterfaceType
        Description:        This parameter defines this source as the connection to the master Xcp.
        Multiplicity:       1
        Type:               EcucBooleanParamDef
        Default value:      false
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_987</srcid><srcstatus/><internalId>319</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>41</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRSourcePDUConfiguration.XcpRPdu</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Choice container name: XcpRPdu
        Description:           Choice container used to select the connection type:
                               * XcpRRxPdu: Reference to Rx PDu.
                               * XcpRTxPdu: Reference to Tx Pdu.
        Multiplicity:          1

      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_1014</srcid><srcstatus/><internalId>320</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>42</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRSourcePDUConfiguration.XcpRPdu.XcpRRxPdu</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Container Name:           XcpRRxPdu
        Description:              Defines the Rx PDUs.
        Multiplicity:             0..1
        Configuration Parameters: XcpRRxSourcePduReference
                                  XcpRRxSourcePduId
                                  XcpRSrcPduSupportRxFromRxIndication
                                  XcpRRxSrcPduSupportTxFromRxIndication
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_1028</srcid><srcstatus/><internalId>321</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>43</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRSourcePDUConfiguration.XcpRPdu.XcpRRxPdu.XcpRRxSourcePduReference</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:               XcpRRxSourcePduReference
        Parent Container:   XcpRRxPdu
        Description:        Reference to Rx PDU
        Multiplicity:       1
        Type:               EcucReferenceDef
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_1041</srcid><srcstatus/><internalId>322</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>44</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRSourcePDUConfiguration.XcpRPdu.XcpRRxPdu.XcpRRxSourcePduId</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:               XcpRRxSourcePduId
        Parent Container:   XcpRRxPdu
        Description:        Defines the ID of the PDU that will be received via a XcpR_&lt;module&gt;RxIndication.
                            A symbolic value (preprocessor macro) is also generated for each PDU ID.
                            The XcpR's Rx Pdu ids has to be zero based and consecutive.
        Multiplicity:       1
        Type:               EcucIntegerParamDef
        Range:              0 .. 65535
        Default value:      -
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_1088</srcid><srcstatus/><internalId>323</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_1218</srcid><srcstatus/><internalId>328</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>45</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRSourcePDUConfiguration.XcpRPdu.XcpRRxPdu.XcpRSrcPduSupportRxFromRxIndication</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:               XcpRSrcPduSupportRxFromRxIndication
        Parent Container:   XcpRRxPdu
        Description:        If this parameter is enabled a reception for this PDU will be triggered
                            when RxIndication is executed.
        Multiplicity:       1
        Type:               EcucBooleanParamDef
        Default value:      false
        Dependency:         None
      </description>
      <comment>
        Enabling this feature for several PDUs might have impact on the run-time by
        creating a big overhead in the system.
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_1125</srcid><srcstatus/><internalId>324</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>46</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRSourcePDUConfiguration.XcpRPdu.XcpRRxPdu.XcpRRxSrcPduSupportTxFromRxIndication</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:               XcpRRxSrcPduSupportTxFromRxIndication
        Parent Container:   XcpRRxPdu
        Description:        If this parameter is enabled and if reception from RxIndication is enabled
                            for this PDU, a transmission will be triggered
                            when RxIndication is executed.
        Multiplicity:       1
        Type:               EcucBooleanParamDef
        Default value:      false
        Dependency:         XcpRSrcPduSupportRxFromRxIndication
      </description>
      <comment>
        Enabling this feature for several PDUs might have impact on the run-time by
        creating a big overhead in the system.
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_1147</srcid><srcstatus/><internalId>325</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>47</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRSourcePDUConfiguration.XcpRPdu.XcpRTxPdu</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Container Name:           XcpRTxPdu
        Description:              Defines the Tx PDUs.
        Multiplicity:             0..1
        Configuration Parameters: XcpRTxSourcePduReference
                                  XcpRTxSourcePduId
                                  XcpRSrcPduSupportRxFromXcpRTransmit
                                  XcpRTxSrcPduSupportTxFromXcpRTransmit
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_1174</srcid><srcstatus/><internalId>326</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>48</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRSourcePDUConfiguration.XcpRPdu.XcpRTxPdu.XcpRTxSourcePduReference</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:               XcpRTxSourcePduReference
        Parent Container:   XcpRTxPdu
        Description:        Reference to Tx PDU
        Multiplicity:       1
        Type:               EcucReferenceDef
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_1189</srcid><srcstatus/><internalId>327</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>49</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRSourcePDUConfiguration.XcpRPdu.XcpRTxPdu.XcpRTxSourcePduId</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:               XcpRTxSourcePduId
        Parent Container:   XcpRTxPdu
        Description:        Defines the ID of the PDU that will be received via a XcpR_&lt;module&gt;TxConfirmation.
                            A symbolic value (preprocessor macro) is also generated for each PDU ID.
                            The XcpR's Tx Pdu ids has to be zero based and consecutive.
        Multiplicity:       1
        Type:               EcucIntegerParamDef
        Range:              0 .. 65535
        Default value:      -
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_1219</srcid><srcstatus/><internalId>329</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>50</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRSourcePDUConfiguration.XcpRPdu.XcpRRxPdu.XcpRSrcPduSupportRxFromXcpRTransmit</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:               XcpRSrcPduSupportRxFromXcpRTransmit
        Parent Container:   XcpRTxPdu
        Description:        If this parameter is enabled a reception for this PDU will be triggered
                            when XcpR_Transmit is executed.
        Multiplicity:       1
        Type:               EcucBooleanParamDef
        Default value:      false
        Dependency:         None
      </description>
      <comment>
        Enabling this feature for several PDUs might have impact on the run-time by
        creating a big overhead in the system.
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_1256</srcid><srcstatus/><internalId>330</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>51</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRSourcePDUConfiguration.XcpRPdu.XcpRRxPdu.XcpRTxSrcPduSupportTxFromXcpRTransmit</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:               XcpRTxSrcPduSupportTxFromXcpRTransmit
        Parent Container:   XcpRTxPdu
        Description:        If this parameter is enabled and if reception from XcpR_Transmit is enabled
                            for this PDU, a transmission will be triggered
                            when XcpR_Transmit is executed.
        Multiplicity:       1
        Type:               EcucBooleanParamDef
        Default value:      false
        Dependency:         XcpRSrcPduSupportRxFromXcpRTransmit
      </description>
      <comment>
        Enabling this feature for several PDUs might have impact on the run-time by
        creating a big overhead in the system.
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_1278</srcid><srcstatus/><internalId>331</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>52</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRSourcePDUConfiguration.XcpRSourcePDUAttributes</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Container Name:           XcpRSourcePDUAttributes
        Parent Container:         XcpRSourcePDUConfiguration
        Description:              This container contains the general configuration
                                  parameters of the source PDU.
        Multiplicity:             1
        Configuration Parameters: XcpRSrcMaxCto
                                  XcpRSrcMaxDto
                                  XcpRSrcMaxCtoPgm
                                  XcpRSrcTimestampType
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_1306</srcid><srcstatus/><internalId>332</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>53</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRSourcePDUAttributes.XcpRSrcMaxCto</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:               XcpRSrcMaxCto
        Parent Container:   XcpRSourcePDUAttributes
        Description:        This parameter shows the maximum length of a CTO packet in bytes.
        Multiplicity:       1
        Type:               EcucIntegerParamDef
        Range:              8 to 255
        Default value:      8
        Scope / Dependency: Module
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_1317</srcid><srcstatus/><internalId>333</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>54</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRSourcePDUAttributes.XcpRSrcMaxDto</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:               XcpRSrcMaxDto
        Parent Container:   XcpRSourcePDUAttributes
        Description:        This parameter shows the maximum length of a DTO packet in bytes.
        Multiplicity:       1
        Type:               EcucIntegerParamDef
        Range:              8 .. 65535
        Default value:      8
        Scope / Dependency: Module
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_1382</srcid><srcstatus/><internalId>334</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>55</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRSourcePDUAttributes.XcpRSrcMaxCtoPgm</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:               XcpRSrcMaxCtoPgm
        Parent Container:   XcpRSourcePDUAttributes
        Description:        Defines the maximum length of XcpR command transfer objects (CTO) in
                            bytes for flash programming from source PDU.
        Multiplicity:       0..1
        Type:               EcucIntegerParamDef
        Range:              8.. depends on communication layer
        Default value:      -
        Scope / Dependency: ECU
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_1460</srcid><srcstatus/><internalId>335</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>56</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRSourcePDUAttributes.XcpRSrcTimestampType</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:               XcpRSrcTimestampType
        Parent Container:   XcpRSourcePDUAttributes
        Description:        This parameter Enable/Disable the configured XcpR User Timestamp from source PDU.
        Multiplicity:       1
        Type:               ENUMERATION
        Default value:      NO_TIME_STAMP
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_1526</srcid><srcstatus/><internalId>336</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>57</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRGeneral.XcpRDestinationPDUConfiguration</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Container Name:     XcpRDestinationPDUConfiguration
        Description:        Groups PDU information related to a connection via a specified
                            bus (Can/CanFD/FlexRay/Ethernet). Multiple connection via the same bus
                            type can be configured.
        Multiplicity:       1..*
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_1573</srcid><srcstatus/><internalId>337</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>58</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRDestinationPDUConfiguration.XcpRDestinationInterfaceType</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Choice container name: XcpRDestinationInterfaceType
        Description:           Choice container used to select the connection type:
                               * XcpRConnectionOverCAN: only PDUs mapped to the referenced
                               CanIf/Configuration container the selected connection configuration
                               * XcpRConnectionOverCANFD: only PDUs mapped to the referenced
                               CanIf/Configuration container the selected connection configuration
                               * XcpRConnectionOverFlexRay: only PDUs mapped to the same FlexRay
                               controller are accepted to the selected connection configuration.
                               * XcpRConnectionOverEthernet: only PDUs mapped to the same Socket
                               connection group are accepted to the selected connection configuration.
                               * XcpRConnectionOverCdd: only PDUs referenced from a CDD configuration
                               are accepted to the selected connection configuration.
        Multiplicity:          1
      </description>
      <rationale>
        Each connection has specific requirements and dependencies, depending on the type of the used transport layer.
      </rationale>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_1589</srcid><srcstatus/><internalId>338</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>59</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRDestinationInterfaceType.XcpRDestinationConnectionOverCAN</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Container Name:           XcpRDestinationConnectionOverCAN
        Description:              This container specifies connection information required by
                                  communication over the CAN transport layer from destination PDU.
        Multiplicity:             0..1
        Configuration Parameters: XcpRDestinationConnectionCanIfCfgRef
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_1613</srcid><srcstatus/><internalId>339</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>60</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRDestinationConnectionOverCAN.XcpRDestinationConnectionCanIfCfgRef</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:               XcpRDestinationConnectionCanIfCfgRef
        Parent Container:   XcpRDestinationConnectionOverCAN
        Description:        Reference to the CanIf interface where the Source/Destination PDUs,
                            configured for the selected connection, can be found.
        Multiplicity:       1
        Type:               EcucReferenceDef
        Scope / Dependency: The XcpR connection type value has to be XcpRConnectionOverCAN.
                            A valid CanIf configuration has to be available for selection.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_1615</srcid><srcstatus/><internalId>340</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>61</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRDestinationInterfaceType.XcpRDestinationConnectionOverCANFD</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Container Name:           XcpRDestinationConnectionOverCANFD
        Description:              This container specifies connection information required by
                                  communication over the CANFD transport layer from destination PDU.
        Multiplicity:             0..1
        Configuration Parameters: XcpRDestinationCanFdMaxDlcRequired
                                  XcpRDestinationCanFdMaxDlc
                                  XcpRDestinationCanFdFillValue
                                  XcpRDestinationConnectionCanFdCanIfCfgRef
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_1648</srcid><srcstatus/><internalId>341</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>62</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRDestinationConnectionOverCANFD.XcpRDestinationCanFdMaxDlcRequired</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:               XcpRDestinationCanFdMaxDlcRequired
        Parent Container:   XcpRDestinationConnectionOverCANFD
        Description:        Defines if the length of the XcpR packages is given by XcpRDestinationCanFdMaxDlc or not
        Multiplicity:       1
        Type:               EcucBooleanParamDef
        Default value:      -
        Scope / Dependency: This parameter is available only if the XcpRDestinationInterfaceType choice is XcpRDestinationConnectionOverCANFD.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_1650</srcid><srcstatus/><internalId>342</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>63</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRDestinationConnectionOverCANFD.XcpRDestinationCanFdMaxDlc</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:               XcpRDestinationCanFdMaxDlc
        Parent Container:   XcpRDestinationConnectionOverCANFD
        Description:        Defines the value of maximum data length of a CAN-FD frame
        Multiplicity:       1
        Type:               EcucIntegerParamDef
        Range:              [8, 12, 16, 20, 24, 32, 48, 64]
        Default value:      64
        Scope / Dependency: This parameter is available only if the XcpRDestinationInterfaceType choice is XcpRDestinationConnectionOverCANFD.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_1676</srcid><srcstatus/><internalId>343</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>64</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRDestinationConnectionOverCANFD.XcpRDestinationCanFdFillValue</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:               XcpRDestinationCanFdFillValue
        Parent Container:   XcpRDestinationConnectionOverCANFD
        Description:        Defines value used for the fill bytes of CANFD packages
        Multiplicity:       1
        Type:               EcucIntegerParamDef
        Range:              0 .. 255
        Default value:      255
        Scope / Dependency: This parameter is available only if the XcpRDestinationInterfaceType choice is XcpRDestinationConnectionOverCANFD.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_1717</srcid><srcstatus/><internalId>344</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>65</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRDestinationConnectionOverCANFD.XcpRDestinationConnectionCanFdCanIfCfgRef</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:               XcpRDestinationConnectionCanFdCanIfCfgRef
        Parent Container:   XcpRDestinationConnectionOverCANFD
        Description:        Reference to the CanIf interface where the Source or Destination PDUs,
                            configured for the selected connection, can be found
        Multiplicity:       1
        Type:               EcucReferenceDef
        Scope / Dependency: The XcpR connection type value has to be XcpRConnectionOverCANFD.
                            A valid CanIf configuration has to be available for selection.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_1747</srcid><srcstatus/><internalId>345</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>66</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRDestinationInterfaceType.XcpRDestinationConnectionOverFlexRay</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Container Name:           XcpRDestinationConnectionOverFlexRay
        Description:              This container specifies connection information required by
                                  communication over the FlexRay transport layer from destination PDU
        Multiplicity:             0..1
        Configuration Parameters: XcpRDestinationFlxNodeAddress
                                  XcpRDestinationFlxHeaderAlignment
                                  XcpRDestinationPackMultiMsgInOneFlexRayFrame
                                  XcpRDestinationSequenceCorrectionEnabled
                                  XcpRDestinationMaxFlexMsgLength
                                  XcpRDestinationConnectionFrIfCfgRef
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_1780</srcid><srcstatus/><internalId>346</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>67</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRDestinationConnectionOverFlexRay.XcpRDestinationFlxNodeAddress</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:               XcpRDestinationFlxNodeAddress
        Parent Container:   XcpRDestinationConnectionOverFlexRay
        Description:        Defines the node address for XcpR (NAX) that is used
        Multiplicity:       1
        Type:               EcucIntegerParamDef
        Range:              0 .. 255
        Default value:      0
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_1782</srcid><srcstatus/><internalId>347</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>68</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRDestinationConnectionOverFlexRay.XcpRDestinationFlxHeaderAlignment</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:               XcpRDestinationFlxHeaderAlignment
        Parent Container:   XcpRDestinationConnectionOverFlexRay
        Description:        Defines the alignment of the FlexRay XcpR header
        Multiplicity:       1
        Type:               EcucEnumerationParamDef
        Range:              | PACKET_ALIGNMENT_8  | 8 bit alignment is used  |
                            | PACKET_ALIGNMENT_16 | 16 bit alignment is used |
                            | PACKET_ALIGNMENT_32 | 32 bit alignment is used |
        Default value:      PACKET_ALIGNMENT_8
      </description>
      <comment>
        Selecting a smaller value for this parameter reduces the RAM consumption of
        the module code.
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_1814</srcid><srcstatus/><internalId>348</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>69</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRDestinationConnectionOverFlexRay.XcpRDestinationPackMultiMsgInOneFlexRayFrame</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:             XcpRDestinationPackMultiMsgInOneFlexRayFrame
        Parent Container: XcpRDestinationConnectionOverFlexRay
        Description:      Enables the concatenation of multiple XcpR messages in one frame, for
                          FlexRay communication
        Multiplicity:     1
        Type:             EcucBooleanParamDef
        Default value:    false
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_1854</srcid><srcstatus/><internalId>349</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>70</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRDestinationConnectionOverFlexRay.XcpRDestinationSequenceCorrectionEnabled</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:             XcpRDestinationSequenceCorrectionEnabled
        Parent Container: XcpRDestinationConnectionOverFlexRay
        Description:      Enables the sequence correction. Each sent frame will contain a counter
                          that is incremented for each XcpR packet
        Multiplicity:     1
        Type:             EcucBooleanParamDef
        Default value:    false
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_1875</srcid><srcstatus/><internalId>350</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>71</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRDestinationConnectionOverFlexRay.XcpRDestinationMaxFlexMsgLength</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:               XcpRDestinationMaxFlexMsgLength
        Parent Container:   XcpRDestinationConnectionOverFlexRay
        Description:        Defines the initial maximum data length of a FlexRay frame that a specific
                            slave is able to receive or transmit in a specific XcpR-dedicated buffer.
        Multiplicity:       1
        Type:               EcucIntegerParamDef
        Range:              8 .. 255
        Default value:      false
        Scope / Dependency: This parameter is available only if the XcpRDestinationInterfaceType choice is XcpRDestinationConnectionOverFlexRay and
                            XcpRDestinationPackMultiMsgInOneFlexRayFrame is enabled.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_1896</srcid><srcstatus/><internalId>351</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>72</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRDestinationConnectionOverFlexRay.XcpRDestinationConnectionFrIfCfgRef</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:               XcpRDestinationConnectionFrIfCfgRef
        Parent Container:   XcpRDestinationConnectionOverFlexRay
        Description:        Reference to the FrIf interface where the Source or Destination PDUs,
                            configured for the selected connection, can be found. This reference is
                            used to validate/generate PDUs information for the assigned PDUs for
                            the selected connection over FlexRay.
        Multiplicity:       1
        Type:               EcucReferenceDef
        Scope / Dependency: The XcpR connection type value has to be XcpRConnectionOverFlexRay.
                            A valid FrIf configuration has to be available for selection.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_1951</srcid><srcstatus/><internalId>352</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>73</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRDestinationInterfaceType.XcpRDestinationConnectionOverEthernet</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Container Name:           XcpRDestinationConnectionOverEthernet
        Description:              This container specifies connection information required by
                                  communication over the Ethernet transport layer from destination PDU.
        Multiplicity:             0..1
        Configuration Parameters: XcpRDestinationOpenSoCon
                                  XcpRDestinationPackMultiMsgInOneEthernetFrame
                                  XcpRDestinationMaxEthernetMsgLength
                                  XcpRDestinationConnectionSoAdConfigRef
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_1984</srcid><srcstatus/><internalId>353</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>74</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRDestinationConnectionOverEthernet.XcpRDestinationOpenSoCon</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:               XcpRDestinationOpenSoCon
        Parent Container:   XcpRDestinationConnectionOverEthernet
        Description:        Enables automatic opening of the Ethernet socket(s) during startup.
                            If this parameter is enabled SoAd_OpenSoCon() will be called during XcpR_Init()
                            for each configured socket.
        Multiplicity:       1
        Type:               EcucBooleanParamDef
        Default value:      true
        Scope / Dependency: The XcpR connection type value has to be XcpRConnectionOverEthernet.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_1987</srcid><srcstatus/><internalId>354</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>75</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRDestinationConnectionOverEthernet.XcpRDestinationPackMultiMsgInOneEthernetFrame</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:               XcpRDestinationPackMultiMsgInOneEthernetFrame
        Parent Container:   XcpRDestinationConnectionOverEthernet
        Description:        Enables the concatenation of multiple XcpR messages in one frame,
                            for Ethernet communication
        Multiplicity:       1
        Type:               EcucBooleanParamDef
        Default value:      false
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_2035</srcid><srcstatus/><internalId>355</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>76</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRDestinationConnectionOverEthernet.XcpRDestinationMaxEthernetMsgLength</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:               XcpRDestinationMaxEthernetMsgLength
        Parent Container:   XcpRDestinationConnectionOverEthernet
        Description:        Defines the initial maximum data length of a Ethernet frame that a specific
                            slave is able to receive or transmit in a frame.
        Multiplicity:       1
        Type:               EcucIntegerParamDef
        Range:              8 .. 1454
        Default value:      8
        Scope / Dependency: This parameter is available only if the XcpRDestinationInterfaceType choice is XcpRDestinationConnectionOverEthernet and
                            XcpRDestinationPackMultiMsgInOneEthernetFrame is enabled.
      </description>
      <comment>
        Hint this parameter should be high enough to be able to accommodate at least
        2 maximum size DTOs
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_2063</srcid><srcstatus/><internalId>356</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>77</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRDestinationConnectionOverEthernet.XcpRDestinationConnectionSoAdConfigRef</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:               XcpRDestinationConnectionSoAdConfigRef
        Parent Container:   XcpRDestinationConnectionOverEthernet
        Description:        Reference to the SoAd interface where the Source or Destination PDUs, configured for
                            the selected connection, can be found. This reference is used to validate/generate
                            PDUs information for the assigned PDUs for the selected connection over Ethernet.
        Multiplicity:       1
        Type:               EcucReferenceDef
        Scope / Dependency: The XcpR connection type value has to be XcpRConnectionOverEthernet.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_2113</srcid><srcstatus/><internalId>357</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>78</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRDestinationInterfaceType.XcpRDestinationConnectionOverCDD</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Container Name:           XcpRDestinationConnectionOverCDD
        Description:              This container specifies connection information required by
                                  communication over a Complex Device Driver from destination PDU.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_2198</srcid><srcstatus/><internalId>358</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>79</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRDestinationConnectionOverCDD.XcpRCddInformation</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Container Name:           XcpRCddInformation
        Configuration Parameters: XcpRCddShortName
                                  XcpRCddHeaderFile
                                  XcpRCddTransmitFunctionName
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_2200</srcid><srcstatus/><internalId>359</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>80</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRCddInformation.XcpRCddShortName</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:               XcpRCddShortName
        Description:        Defines Short Name of the CDD module interacting with XcpR
        Multiplicity:       0..1
        Type:               EcucIdentifiableParamDef
        Default:            Cdd
        ConfigurationClass: Pre-compile time X All variants
                            Link time -
                            Post-build time -
        Scope / Dependency: This parameter can be enabled only if a connection over CDD is used.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_2204</srcid><srcstatus/><internalId>361</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>81</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRCddInformation.XcpRCddHeaderFile</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:               XcpRCddHeaderFile
        Description:        Defines the header file for the CDD interface APIs.
        Multiplicity:       0..1
        Type:               EcucIdentifiableParamDef
        Default:            Cdd
        ConfigurationClass: Pre-compile time X All variants
                            Link time -
                            Post-build time -
        Scope / Dependency: This parameter can be enabled only if a connection over CDD is used.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_2227</srcid><srcstatus/><internalId>362</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>82</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRCddInformation.XcpRCddTransmitFunctionName</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:               XcpRCddTransmitFunctionName
        Description:        This parameter defines the name of the &amp;lt;Cdd&amp;gt;_Transmit
        Multiplicity:       0..1
        Type:               EcucIdentifiableParamDef
        Default:            Cdd
        ConfigurationClass: Pre-compile time X All variants
                            Link time -
                            Post-build time -
        Scope / Dependency: This parameter can be enabled only if a connection over CDD is used.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_2248</srcid><srcstatus/><internalId>363</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>83</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRDestinationInterfaceType.XcpRIsDestMasterConnection</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:               XcpRIsDestMasterConnection
        Parent Container:   XcpRDestinationInterfaceType
        Description:        This parameter defines this destination as the connection to the master Xcp.
        Multiplicity:       1
        Type:               EcucBooleanParamDef
        Default value:      false
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_2279</srcid><srcstatus/><internalId>364</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>84</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRDestinationInterfaceType.XcpRPdu</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Choice container name: XcpRPdu
        Description:           Choice container used to select the connection type:
                               * XcpRRxPdu: Reference to Rx PDu.
                               * XcpRTxPdu: Reference to Tx Pdu.
        Multiplicity:          1

      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_2306</srcid><srcstatus/><internalId>365</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>85</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRDestinationInterfaceType.XcpRPdu.XcpRRxPdu</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Container Name:           XcpRRxPdu
        Description:              Defines the Rx PDUs.
        Multiplicity:             0..1
        Configuration Parameters: XcpRRxDestinationPduReference
                                  XcpRUpperLayerDestinationPduId
                                  XcpRDestPduSupportRxFromRxIndication
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_2320</srcid><srcstatus/><internalId>366</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>86</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRDestinationInterfaceType.XcpRPdu.XcpRRxPdu.XcpRRxDestinationPduReference</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:               XcpRRxDestinationPduReference
        Parent Container:   XcpRRxPdu
        Description:        Reference to Rx PDU
        Multiplicity:       1
        Type:               EcucReferenceDef
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_2336</srcid><srcstatus/><internalId>368</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>87</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRDestinationInterfaceType.XcpRPdu.XcpRTxPdu</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Container Name:           XcpRTxPdu
        Description:              Defines the Tx PDUs.
        Multiplicity:             0..1
        Configuration Parameters: XcpRTxDestinationPduReference
                                  XcpRTxDestinationPduSupportForCddTriggerTransmit
                                  XcpRTxDestinationPduSupportForFrTriggerTransmit
                                  XcpRLowerLayerDestinationPduId
                                  XcpRTxDestinationPduId
                                  XcpRDestPduSupportTxFromTxConfirmation
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_2359</srcid><srcstatus/><internalId>369</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>88</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRDestinationInterfaceType.XcpRPdu.XcpRTxPdu.XcpRTxDestinationPduReference</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:               XcpRTxDestinationPduReference
        Parent Container:   XcpRTxPdu
        Description:        Reference to Tx PDU
        Multiplicity:       1
        Type:               EcucReferenceDef
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_2372</srcid><srcstatus/><internalId>370</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>89</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRDestinationInterfaceType.XcpRPdu.XcpRTxPdu.XcpRTxDestinationPduSupportForCddTriggerTransmit</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:               XcpRTxDestinationPduSupportForCddTriggerTransmit
        Parent Container:   XcpRTxPdu
        Description:        This parameter enables the Tx PDU to support TriggerTransmit functionality over a CDD connection.
        Multiplicity:       1
        Type:               EcucReferenceDef
        Default value:      -
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_2406</srcid><srcstatus/><internalId>371</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>90</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRDestinationInterfaceType.XcpRPdu.XcpRTxPdu.XcpRTxDestinationPduSupportForFrTriggerTransmit</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:               XcpRSrcPduSupportTxFromTxConfirmation
        Parent Container:   XcpRTxPdu
        Description:        This parameter enables the Tx PDU to support TriggerTransmit functionality over a FR connection.
        Multiplicity:       1
        Type:               EcucBooleanParamDef
        Default value:      false
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_2428</srcid><srcstatus/><internalId>372</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>91</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRDestinationInterfaceType.XcpRPdu.XcpRTxPdu.XcpRLowerLayerDestinationPduId</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:               XcpRLowerLayerDestinationPduId
        Parent Container:   XcpRTxPdu
        Description:        Defines the ID of the PDU that will used for outgoing LL_RxIndicationcalls
        Multiplicity:       1
        Type:               EcucIntegerParamDef
        Range:              0 .. 65535
        Default value:      -
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_2450</srcid><srcstatus/><internalId>373</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>92</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRDestinationInterfaceType.XcpRPdu.XcpRTxPdu.XcpRTxDestinationPduId</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:               XcpRTxDestinationPduId
        Parent Container:   XcpRTxPdu
        Description:        Defines the PDU identifier, which has to be used by the lower
                            layer BSW module for TxConfirmations or TriggerTransmits.
        Multiplicity:       1
        Type:               EcucIntegerParamDef
        Range:              0 .. 65535
        Default value:      -
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_2475</srcid><srcstatus/><internalId>374</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>93</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRDestinationInterfaceType.XcpRPdu.XcpRTxPdu.XcpRDestPduSupportTxFromTxConfirmation</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:               XcpRDestPduSupportTxFromTxConfirmation
        Parent Container:   XcpRTxPdu
        Description:        If this configuration parameter is enabled then a new transmission for this PDU will be
                            triggered when TxConfirmation is executed.
        Multiplicity:       1
        Type:               EcucIntegerParamDef
        Range:              0 .. 65535
        Default value:      -
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_2512</srcid><srcstatus/><internalId>375</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>94</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRDestinationPDUConfiguration.XcpRDestUpperLayerInformation</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Container Name::    XcpRDestUpperLayerInformation
        Parent Container:   XcpRDestinationPDUConfiguration
        Description:        Upper layer information
        Multiplicity:       1
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_2536</srcid><srcstatus/><internalId>376</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>95</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRDestUpperLayerInformation.XcpRUpperLayerModuleShortName</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:               XcpRUpperLayerModuleShortName
        Description:        Short Name of the upper layer module interacting with XcpR
        Multiplicity:       1
        Type:               EcucIdentifiableParamDef
        Default:            Xcp
        ConfigurationClass: Pre-compile time X All variants
                            Link time -
                            Post-build time -
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_2541</srcid><srcstatus/><internalId>378</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>96</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRDestUpperLayerInformation.XcpRUpperLayerHeaderFile</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:               XcpRUpperLayerHeaderFile
        Description:        This parameter defines the header file for the upper layer
                            module interface APIs
        Multiplicity:       0 .. 1
        Type:               EcucIdentifiableParamDef
        Default:            Xcp.h
        ConfigurationClass: Pre-compile time X All variants
                            Link time -
                            Post-build time -
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_2564</srcid><srcstatus/><internalId>379</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>97</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRDestUpperLayerInformation.XcpRRxIndicationFunctionName</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:               XcpRRxIndicationFunctionName
        Description:        This parameter defines the name of the &amp;lt;UL&amp;gt;_RxIndication
        Multiplicity:       1
        Type:               EcucIdentifiableParamDef
        Default:            Xcp_RxIndication
        ConfigurationClass: Pre-compile time X All variants
                            Link time -
                            Post-build time -
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_2586</srcid><srcstatus/><internalId>380</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>98</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRDestUpperLayerInformation.XcpRTxConfirmationFunctionName</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:               XcpRTxConfirmationFunctionName
        Description:        This parameter defines the name of the &amp;lt;UL&amp;gt;_TxConfirmation
        Multiplicity:       1
        Type:               EcucIdentifiableParamDef
        Default:            Xcp_TxConfirmation
        ConfigurationClass: Pre-compile time X All variants
                            Link time -
                            Post-build time -
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_2614</srcid><srcstatus/><internalId>381</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>99</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRDestUpperLayerInformation.XcpRTriggerTransmitFunctionName</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:               XcpRTriggerTransmitFunctionName
        Description:        This parameter defines the name of the &amp;lt;UL&amp;gt;_TriggerTransmit
        Multiplicity:       1
        Type:               EcucIdentifiableParamDef
        Default:            Xcp_FrTriggerTransmit
        ConfigurationClass: Pre-compile time X All variants
                            Link time -
                            Post-build time -
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_2642</srcid><srcstatus/><internalId>382</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>100</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRDestinationPDUConfiguration.XcpRDestinationPDUAttributes</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Container Name:           XcpRDestinationPDUAttributes
        Parent Container:         XcpRDestinationPDUConfiguration
        Description:              This container contains the general configuration
                                  parameters of the destination PDU.
        Multiplicity:             1
        Configuration Parameters: XcpRDestMaxCto
                                  XcpRDestMaxDto
                                  XcpRDestMaxCtoPgm
                                  XcpRDestTimestampType
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_2671</srcid><srcstatus/><internalId>383</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>101</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRDestinationPDUAttributes.XcpRDestMaxCto</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:               XcpRDestMaxCto
        Parent Container:   XcpRDestinationPDUAttributes
        Description:        This parameter shows the maximum length of a CTO packet in bytes.
        Multiplicity:       1
        Type:               EcucIntegerParamDef
        Range:              8 .. 255
        Default value:      8
        ConfigurationClass: Pre-compile time  X  All Variants
                            Link time         -
                            Post-build time   -
        Scope / Dependency  Module
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_2682</srcid><srcstatus/><internalId>384</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>102</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRDestinationPDUAttributes.XcpRDestMaxDto</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:               XcpRDestMaxDto
        Parent Container:   XcpRDestinationPDUAttributes
        Description:        Maximum length of a DTO packet in bytes to be sent.
        Multiplicity:       1
        Type:               EcucIntegerParamDef
        Range:              8 .. 65535
        Default value:      8
        ConfigurationClass: Pre-compile time  X  All Variants
                            Link time -
                            Post-build time -
        Scope / Dependency: Module
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_2747</srcid><srcstatus/><internalId>385</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>103</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRDestinationPDUAttributes.XcpRDestMaxCtoPgm</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:               XcpRDestMaxCtoPgm
        Parent Container:   XcpRDestinationPDUAttributes
        Description:        Defines the maximum length of XcpR command transfer objects (CTO) in
                            bytes for flash programming from destination PDU.
        Multiplicity:       0..1
        Type:               EcucIntegerParamDef
        Range:              8.. depends on communication layer
        Default value:      -
        ConfigurationClass: Pre-compile time X All variants
                            Link time -
                            Post-build time -
        Scope / Dependency: ECU
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_2824</srcid><srcstatus/><internalId>386</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>104</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRDestinationPDUAttributes.XcpRDestTimestampType</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:               XcpRDestTimestampType
        Parent Container:   XcpRDestinationPDUAttributes
        Description:        This parameter defines the type of timestamp XcpR Destination is using.
        Multiplicity:       1
        Type:               ENUMERATION
        Default value:      NO_TIME_STAMP
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_2890</srcid><srcstatus/><internalId>387</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>105</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRGeneral.XcpRRoutingPaths</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Container Name:           XcpRRoutingPaths
        Description:              Defines PDU mapping between a XcpR source and destination.
                                  A PDU may be either a transmission (Tx) PDU or a reception (Rx) PDU.
        Multiplicity:             1..*
        Configuration Parameters: XcpRSourcePduRef
                                  XcpRDestinationPduRef
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_2937</srcid><srcstatus/><internalId>388</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>106</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRRoutingPaths.XcpRSourcePduRef</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:               XcpRSourcePduRef
        Parent Container:   XcpRRoutingPaths
        Description:        Reference to the external Rx PDU definition in the EcuC module
        Multiplicity:       1
        Type:               EcucReferenceDef
        Scope / Dependency: A valid reference to EcuC's Pdu parameters has to be provided.
                            A unique EcuC PDU has to be provided as reference for each XcpR Rx Pdu.
                            It is not allowed to configure bidirectional XcpR PDUs(the same PDU
                            cannot be given as reference for both XcpRRxPdu and XcpRTxPdu).
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_2955</srcid><srcstatus/><internalId>390</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>107</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRRoutingPaths.XcpRDestinationPduRef</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:               XcpRDestinationPduRef
        Parent Container:   XcpRRoutingPaths
        Description:        Reference to the external Rx PDU definition in the EcuC module.
        Multiplicity:       1
        Type:               EcucReferenceDef
        Scope / Dependency: A valid reference to EcuC's Pdu parameters has to be provided.
                            A unique EcuC PDU has to be provided as reference for each XcpR Rx Pdu.
                            It is not allowed to configure bidirectional XcpR PDUs(the same PDU cannot be given
                            as reference for both XcpRRxPdu and XcpRTxPdu).
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_2984</srcid><srcstatus/><internalId>392</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>108</internalId></specobject>

    <specobject>
      <id>XcpR.Config.Timestamp.ConfigurationRoutingPath</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The source and destination of a configured routing path shall have the same configured
        timestamp type.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_2950</srcid><srcstatus/><internalId>389</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>109</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRGeneral.XcpRRoutingToConnectionMapping</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Container Name:           XcpRRoutingToConnectionMapping
        Description:              Defines Connection Groups, which logically groups configured Routing Paths.
        Multiplicity:             0..*
        Configuration Parameters: XcpRRoutingMapping
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_3017</srcid><srcstatus/><internalId>394</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>110</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRGeneral.XcpRRoutingToConnectionMapping.XcpRRoutingMapping</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Container Name:           XcpRRoutingMapping
        Parent Container:         XcpRRoutingToConnectionMapping
        Description:              Container holding a reference to a configured XcpR Routing Path.
        Multiplicity:             2..*
        Configuration Parameters: XcpRRoutingPathRef
        Scope / Dependency:       At least 2 XcpRRoutingMapping shall be configured for each XcpRRoutingToConnectionMapping entry.
                                  One for requests from Xcp master to Xcp slave and one for responses from Xcp slave to Xcp master.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_3040</srcid><srcstatus/><internalId>395</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>111</internalId></specobject>

    <specobject>
      <id>XcpR.Config.XcpRGeneral.XcpRRoutingToConnectionMapping.XcpRRoutingMapping.XcpRRoutingPathRef</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Container Name:           XcpRRoutingPathRef
        Parent Container:         XcpRRoutingMapping
        Description:              Reference to a configured XcpR Routing Path.
        Multiplicity:             1
        Type:                     EcucReferenceDef
        Scope / Dependency:       A valid reference to a XcpR Routing Path has to be provided.
                                  A unique Routing Path has to be provided as reference for each XcpRRoutingMapping container.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_3065</srcid><srcstatus/><internalId>396</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>112</internalId></specobject>

  <!--
    +++++++++++++++++++++++++++++++++++++++++
    Requirements for XcpR's API
    +++++++++++++++++++++++++++++++++++++++++
  -->

    <specobject>
      <id>XcpR.API.Init</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Service name:       XcpR_Init
        Syntax:             void XcpR_Init( void )
        Service ID[hex]:    0x00
        Sync/Async:         Synchronous
        Reentrancy:         Non-Reentrant
        Parameters (in):    None
        Parameters (inout): None
        Parameters (out):   None
        Return value:       None
        Description:        This function initializes interfaces and variables of the XCPR module.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/XcpR.c_153</srcid><srcstatus/><internalId>215</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>113</internalId></specobject>

    <specobject>
      <id>XcpR.API.Transmit</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Service name:       XcpR_Transmit
        Syntax:             Std_ReturnType XcpR_Transmit( PduIdType TxPduId,
                                                         PduInfoType PduInfoPtr);
        Service ID[hex]:    0x06
        Sync/Async:         Synchronous
        Reentrancy:         Reentrant for different PduIds. Non reentrant for the same PduId.
        Parameters (in):    TxPduId       ID of the SDU that is requested to be transmitted.
                            PduInfoPtr    Contains a pointer to a buffer to where the
                                          SDU data shall be copied, and the available buffer size in SduLengh.
                                          On return, the service will indicate the length of the copied SDU
                                          data in SduLength.
        Parameters (inout): None
        Parameters (out):   None
        Return value:       Std_ReturnType  E_OK:     SDU has been copied and SduLength indicates the number
                                                      of copied bytes.
                                            E_NOT_OK: No SDU data has been copied. PduInfoPtr must not be used
                                                      since it may contain a NULL pointer or point to invalid data.
        Description:        Transmit Pdu via transport layer bus.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/XcpR.c_333</srcid><srcstatus/><internalId>218</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>114</internalId></specobject>

    <specobject>
      <id>XcpR.API.MainFunction</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Service name:       XcpR_MainFunction
        Syntax:             void XcpR_MainFunction( void )
        Service ID[hex]:    0x04
        Timing:             FIXED_CYCLIC
        Parameters (in):    None
        Parameters (inout): None
        Parameters (out):   None
        Return value:       None
        Description:        Scheduled function of the XCPR module.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/XcpR.c_218</srcid><srcstatus/><internalId>216</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>115</internalId></specobject>

    <specobject>
      <id>XcpR.API.RxIndication</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
         Service name:       XcpR_RxIndication
         Syntax:             void XcpR_RxIndication( PduIdType XcpRRxPduId, const PduInfoType* XcpRRxPduPtr )
         Service ID[hex]:    0x03
         Sync/Async:         Synchronous
         Reentrancy:         Reentrant for different XcpRRxPduIds, non reentrant for the same XcpRRxPduId.
         Parameters (in):    XcpRRxPduId   PDU-ID that has been received
                             XcpRRxPduPtr  Pointer to SDU (Buffer of received payload)
         Parameters (inout): None
         Parameters (out):   None
         Return value:       void
         Description:        This function is called by the lower layers (i.e. FlexRay Interface, CAN
                             Interface and Socket Adaptor or CDD) when an PDU has been received.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/XcpR_Cbk.h_32</srcid><srcstatus/><internalId>210</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/XcpR.c_252</srcid><srcstatus/><internalId>217</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>116</internalId></specobject>

    <specobject>
      <id>XcpR.API.TxConfirmation</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
         Service name:       XcpR_TxConfirmation
         Syntax:             void XcpR_TxConfirmation (PduIdType XcpRTxPduId, Std_ReturnType XcpRResult)
         Service ID[hex]:    0x02
         Sync/Async:         Synchronous
         Reentrancy:         Reentrant for different XcpRTxPduIds, non reentrant for the same XcpRTxPduId
         Parameters (in):    XcpRTxPduId PDU-ID that has been transmitted
         Parameters (in):    XcpRResult Result of transmission confirmation
         Parameters (inout): None
         Parameters (out):   None
         Return value:       void
         Description:        This function is called by the lower layers (i.e. FlexRay Interface, CAN
                             Interface and Socket Adaptor or CDD) when an PDU has been transmitted.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/XcpR_Cbk.h_48</srcid><srcstatus/><internalId>211</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/XcpR.c_406</srcid><srcstatus/><internalId>219</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>117</internalId></specobject>

    <specobject>
      <id>XcpR.API.TriggerTransmit</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Service name:       XcpR_TriggerTransmit
        Syntax:             Std_ReturnType XcpR_TriggerTransmit( PduIdType TxPduId, PduInfoType* PduInfoPtr )
        Service ID[hex]:    0x05
        Sync/Async:         Synchronous
        Reentrancy:         Non-Reentrant
        Parameters (in):    TxPduId    ID of the SDU that is requested to be transmitted
                            PduInfoPtr Contains a pointer to a buffer (SduDataPtr) to where the SDU
                                    shall be copied to. On return, the service will indicate the length of
                                    the copied SDU data in SduLength.
        Parameters (inout): None
        Parameters (out):   None
        Return value:       Std_ReturnType  E_OK:     SDU has been copied and SduLength indicates the number
                                                      of copied bytes.
                                            E_NOT_OK: No SDU has been copied. PduInfoPtr must not be used since
                                                      it may contain a NULL pointer or point to invalid data.
        Scope / Dependency: This API is available only if either XcpRDestinationPduSupportForCddTriggerTransmit
                            or FrIfConfirm parameter is enabled.
      </description>
      <comment>
        Note: The callback function XcpR_TriggerTransmit is called by the Bus Interfaces,
              Ethernet Socket Adaptor or CDD and is implemented by the XcpR module.
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/XcpR_Cbk.h_69</srcid><srcstatus/><internalId>212</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/XcpR.c_440</srcid><srcstatus/><internalId>221</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>118</internalId></specobject>

    <specobject>
      <id>XcpR.API.GetVersionInfo</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Service name:       XcpR_GetVersionInfo
        Syntax:             void XcpR_GetVersionInfo( Std_VersionInfoType* versioninfo )
        Service ID[hex]:    0x01
        Sync/Async:         Synchronous
        Reentrancy:         Reentrant
        Parameters (in):    None
        Parameters (inout): None
        Parameters (out):   versioninfo:  Pointer to where to store the version information of this
                                          module.
        Return value:       void
        Description:        Returns the version information of this module.
        Scope / Dependency: This API is available only if the XcpRVersionInfoApi parameters is enabled.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/XcpR.h_322</srcid><srcstatus/><internalId>209</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/XcpR.c_127</srcid><srcstatus/><internalId>214</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_DetOn_GetVersionInfoTest</srcid><srcstatus/><internalId>482</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>119</internalId></specobject>

  <!--
    +++++++++++++++++++++++++++++++++++++++++
    Requirements for XcpR functionality
    +++++++++++++++++++++++++++++++++++++++++
  -->

    <specobject>
      <id>XcpR.Impl.CheckStatusConnection</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The XcpR module shall check if the connection is established (Xcp slave answers with a positive response)
        after a CONNECT command is received from the Xcp master.
      </description>
      <furtherinfo>WRN.swuts.needscoverage.count - This requirement is verified in different situations for every
        possible bus.</furtherinfo>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_CanFdMaxDlcRequired_Slave</srcid><srcstatus/><internalId>476</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_FrToCanFd_MaxDlcReqDisabled_HigherDlc</srcid><srcstatus/><internalId>477</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ConnectionGroup</srcid><srcstatus/><internalId>478</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SimulateConnectCMD_PosResponse_Mode_1</srcid><srcstatus/><internalId>492</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SimulateConnectCMD_PosResponse_Mode_0</srcid><srcstatus/><internalId>495</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ChangeMode_SwitchRemoteXcpToLocalXcp</srcid><srcstatus/><internalId>497</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SwitchConections</srcid><srcstatus/><internalId>498</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_NewCONNECTCmd_RemoteXcpSlave</srcid><srcstatus/><internalId>499</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_NewCONNECTCmd_LocalXcpSlave</srcid><srcstatus/><internalId>500</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_InternalQueue_DifferentDestinations</srcid><srcstatus/><internalId>501</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_ONLINE_MasterToRemote</srcid><srcstatus/><internalId>502</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_OFFLINE_MasterToRemote</srcid><srcstatus/><internalId>503</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_WrongId_MasterToRemote</srcid><srcstatus/><internalId>504</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_OpenSocketConnection_FAILED</srcid><srcstatus/><internalId>506</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TcpIp_CannotGetRemoteAddress</srcid><srcstatus/><internalId>507</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_ONLINE_Remote</srcid><srcstatus/><internalId>508</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_OFFLINE_Remote</srcid><srcstatus/><internalId>509</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_WrongId_Remote</srcid><srcstatus/><internalId>510</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_EthUdp_ReconfiguredSocket</srcid><srcstatus/><internalId>512</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_EthUdp_CannotSetRemoteAddress</srcid><srcstatus/><internalId>513</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_EthUdp_CommandDifferentIp</srcid><srcstatus/><internalId>514</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_EthUdp_RespondOnlyToConnectIpAddress</srcid><srcstatus/><internalId>515</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_CannotGetRemoteAddress</srcid><srcstatus/><internalId>516</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_CONNECTcmd_CannotSetRemoteAddress</srcid><srcstatus/><internalId>517</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_EthUdp_PortAlready_0_SetRemoteAddrNotCalled</srcid><srcstatus/><internalId>518</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRInternalQueue</srcid><srcstatus/><internalId>520</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRInternalQueue_LastIndexes</srcid><srcstatus/><internalId>521</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_LocalXcpSlave_InvalidConnectMode_TransmissionRx</srcid><srcstatus/><internalId>522</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_LocalXcpSlave_InvalidConnectMode</srcid><srcstatus/><internalId>523</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame</srcid><srcstatus/><internalId>525</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame_DifferentSources</srcid><srcstatus/><internalId>527</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame_Master</srcid><srcstatus/><internalId>528</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame_ToLocalXcp</srcid><srcstatus/><internalId>529</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame_RemoteXcpSlave</srcid><srcstatus/><internalId>530</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdus_TxConf</srcid><srcstatus/><internalId>531</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ReceptionFromRx_RemoteXcpSlave</srcid><srcstatus/><internalId>533</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ReceptionFromRx_LocalXcpSlave</srcid><srcstatus/><internalId>534</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_RxIndicationFromRx_TwoMessages_FirstDisconnectCmd</srcid><srcstatus/><internalId>535</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_RemoteXcpSlave_InvalidConnectMode</srcid><srcstatus/><internalId>536</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_RxIndication_TxConfirmation_LocalXcp</srcid><srcstatus/><internalId>537</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_RxIndication_TxConfirmation_RemoteXcp</srcid><srcstatus/><internalId>538</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_RxIndication_TxConfirmation_LinkedPduId</srcid><srcstatus/><internalId>539</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SameBusType_SimulateConnectCMD_PosResponse_Mode_1</srcid><srcstatus/><internalId>540</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_CddBusType_SimulateConnectCMD_PosResponse_Mode_0</srcid><srcstatus/><internalId>542</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_CddBusType_ChangeMode_SwitchRemoteXcpToLocalXcp</srcid><srcstatus/><internalId>544</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SeqCorr_MultiplePdusInOneFrame</srcid><srcstatus/><internalId>545</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SeqCorr_MultiplePdusInOneFrame_Master</srcid><srcstatus/><internalId>546</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SeqCorr_MultiplePdusInOneFrame_RemoteXcpSlave</srcid><srcstatus/><internalId>547</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SeqCorr</srcid><srcstatus/><internalId>548</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TransmissionRx_MultiplePdusInOneFrame</srcid><srcstatus/><internalId>549</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TransmissionRx_MultiplePdusInOneFrame_Master</srcid><srcstatus/><internalId>550</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TransmissionRx_MultiplePdusInOneFrame_RemoteXcpSlave</srcid><srcstatus/><internalId>551</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TransmissionRx</srcid><srcstatus/><internalId>552</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_DataStim_PacketGreaterThan255Bytes</srcid><srcstatus/><internalId>553</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_AcqData_PacketGreaterThan255Bytes</srcid><srcstatus/><internalId>554</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_FrToCdd_TrigTrans_PackPdus_RemoteXcpSlave</srcid><srcstatus/><internalId>555</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_FlexRay_TrigTrans_PackPdus_SeqCor_RemoteXcpSlave</srcid><srcstatus/><internalId>556</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_FlexRay_TrigTrans_SeqCor_RemoteXcpSlave</srcid><srcstatus/><internalId>557</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ConnectCmd_PosRes_RemoteXcp_TriggerTransmit</srcid><srcstatus/><internalId>558</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ConnectCmd_PosRes_LocalXcp_TriggerTransmit</srcid><srcstatus/><internalId>560</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ConnectCmd_NegRes_LocalXcp_TriggerTransmit</srcid><srcstatus/><internalId>561</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_LocalXcp_TriggerTransmit_NegRes</srcid><srcstatus/><internalId>562</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SwitchLocalXcpToRemoteXcp_TriggerTransmit</srcid><srcstatus/><internalId>563</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TriggerTransmit_TxRetries_MessageCmd</srcid><srcstatus/><internalId>564</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TriggerTransmit_RemoteXcpSlave</srcid><srcstatus/><internalId>565</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxBusRetries_MasterNoTxConf_LocalXcp</srcid><srcstatus/><internalId>566</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxBusRetries_MasterNoTxConf_RemoteXcp</srcid><srcstatus/><internalId>568</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxBusRetries_MasterENotOkTxConf_RemoteXcp</srcid><srcstatus/><internalId>569</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxBusRetries_MasterNoTxConfConnect_RemoteXcp</srcid><srcstatus/><internalId>570</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxBusRetries_MessageCmd_RemoteXcpNoTxConf</srcid><srcstatus/><internalId>571</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxBusRetries_ConnectCmd_RemoteXcpNoTxConf</srcid><srcstatus/><internalId>572</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxBusRetries_BeforeReachingDisconnectTriggerPoint</srcid><srcstatus/><internalId>573</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectPosRes_FromRemoteXcp</srcid><srcstatus/><internalId>574</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectPosRes_FromLocalXcp</srcid><srcstatus/><internalId>575</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectCmd_ToRemoteXcp</srcid><srcstatus/><internalId>576</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_successfullyTransmit_ToRemoteXcp</srcid><srcstatus/><internalId>577</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectSuccedes</srcid><srcstatus/><internalId>578</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_MessagePosRes_FromLocalXcp</srcid><srcstatus/><internalId>579</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_MessageCmd_ToRemoteXcp</srcid><srcstatus/><internalId>581</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_DisconnectPosRes_FromRemoteXcp</srcid><srcstatus/><internalId>582</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_DisconnectPosRes_FromLocalXcp</srcid><srcstatus/><internalId>583</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_TwoConnectCmds_ToRemoteXcp</srcid><srcstatus/><internalId>584</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_NoAutonomousDisconnect</srcid><srcstatus/><internalId>585</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectPosRes_FromRemoteXcp_PackMaster</srcid><srcstatus/><internalId>586</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_MessagePosRes_FromLocalXcp_PackMaster</srcid><srcstatus/><internalId>587</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_MultipleMessagesReceived_FromLocalAndMaster</srcid><srcstatus/><internalId>588</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectPosRes_FromRemoteXcp_Pack</srcid><srcstatus/><internalId>589</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectPosRes_FromRemoteXcp_PackRemoteSlave</srcid><srcstatus/><internalId>590</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_NotificationsToULXcp</srcid><srcstatus/><internalId>591</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_NotificationsToULXcp_DifferentPduIds</srcid><srcstatus/><internalId>592</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>120</internalId></specobject>

    <specobject>
      <id>XcpR.Impl.TransmissionOfConsecutiveMessages</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If the connection was established (Xcp Slave answers with a positive response) then all consecutive messages
        shall be sent to the same XCP slave until a new DISCONNECT command is used.
      </description>
      <furtherinfo>WRN.swuts.needscoverage.count - This requirement is verified in different situations for every
        possible bus.</furtherinfo>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_CanFdMaxDlcRequired_Slave</srcid><srcstatus/><internalId>476</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_FrToCanFd_MaxDlcReqDisabled_HigherDlc</srcid><srcstatus/><internalId>477</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ConnectionGroup</srcid><srcstatus/><internalId>478</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SimulateConnectCMD_PosResponse_Mode_1</srcid><srcstatus/><internalId>492</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SimulateConnectCMD_PosResponse_Mode_0</srcid><srcstatus/><internalId>495</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ChangeMode_SwitchRemoteXcpToLocalXcp</srcid><srcstatus/><internalId>497</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SwitchConections</srcid><srcstatus/><internalId>498</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_NewCONNECTCmd_LocalXcpSlave</srcid><srcstatus/><internalId>500</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_ONLINE_MasterToRemote</srcid><srcstatus/><internalId>502</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_WrongId_MasterToRemote</srcid><srcstatus/><internalId>504</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_OpenSocketConnection_FAILED</srcid><srcstatus/><internalId>506</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TcpIp_CannotGetRemoteAddress</srcid><srcstatus/><internalId>507</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_ONLINE_Remote</srcid><srcstatus/><internalId>508</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_WrongId_Remote</srcid><srcstatus/><internalId>510</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_EthUdp_ReconfiguredSocket</srcid><srcstatus/><internalId>512</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_EthUdp_CannotSetRemoteAddress</srcid><srcstatus/><internalId>513</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_EthUdp_RespondOnlyToConnectIpAddress</srcid><srcstatus/><internalId>515</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_CannotGetRemoteAddress</srcid><srcstatus/><internalId>516</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_CONNECTcmd_CannotSetRemoteAddress</srcid><srcstatus/><internalId>517</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_EthUdp_PortAlready_0_SetRemoteAddrNotCalled</srcid><srcstatus/><internalId>518</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRInternalQueue</srcid><srcstatus/><internalId>520</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRInternalQueue_LastIndexes</srcid><srcstatus/><internalId>521</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame</srcid><srcstatus/><internalId>525</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame_RxIndication</srcid><srcstatus/><internalId>526</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame_DifferentSources</srcid><srcstatus/><internalId>527</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame_Master</srcid><srcstatus/><internalId>528</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame_ToLocalXcp</srcid><srcstatus/><internalId>529</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame_RemoteXcpSlave</srcid><srcstatus/><internalId>530</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdus_TxConf</srcid><srcstatus/><internalId>531</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ReceptionFromRx_RemoteXcpSlave</srcid><srcstatus/><internalId>533</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ReceptionFromRx_LocalXcpSlave</srcid><srcstatus/><internalId>534</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_RxIndicationFromRx_TwoMessages_FirstDisconnectCmd</srcid><srcstatus/><internalId>535</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_RxIndication_TxConfirmation_LocalXcp</srcid><srcstatus/><internalId>537</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SameBusType_SimulateConnectCMD_PosResponse_Mode_1</srcid><srcstatus/><internalId>540</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_CddBusType_SimulateConnectCMD_PosResponse_Mode_0</srcid><srcstatus/><internalId>542</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_CddBusType_ChangeMode_SwitchRemoteXcpToLocalXcp</srcid><srcstatus/><internalId>544</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SeqCorr_MultiplePdusInOneFrame</srcid><srcstatus/><internalId>545</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SeqCorr_MultiplePdusInOneFrame_Master</srcid><srcstatus/><internalId>546</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SeqCorr_MultiplePdusInOneFrame_RemoteXcpSlave</srcid><srcstatus/><internalId>547</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SeqCorr</srcid><srcstatus/><internalId>548</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TransmissionRx_MultiplePdusInOneFrame_Master</srcid><srcstatus/><internalId>550</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TransmissionRx_MultiplePdusInOneFrame_RemoteXcpSlave</srcid><srcstatus/><internalId>551</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TransmissionRx</srcid><srcstatus/><internalId>552</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_DataStim_PacketGreaterThan255Bytes</srcid><srcstatus/><internalId>553</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_AcqData_PacketGreaterThan255Bytes</srcid><srcstatus/><internalId>554</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_FrToCdd_TrigTrans_PackPdus_RemoteXcpSlave</srcid><srcstatus/><internalId>555</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_FlexRay_TrigTrans_PackPdus_SeqCor_RemoteXcpSlave</srcid><srcstatus/><internalId>556</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_FlexRay_TrigTrans_SeqCor_RemoteXcpSlave</srcid><srcstatus/><internalId>557</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ConnectCmd_PosRes_RemoteXcp_TriggerTransmit</srcid><srcstatus/><internalId>558</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ConnectCmd_PosRes_LocalXcp_TriggerTransmit</srcid><srcstatus/><internalId>560</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ConnectCmd_NegRes_LocalXcp_TriggerTransmit</srcid><srcstatus/><internalId>561</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SwitchLocalXcpToRemoteXcp_TriggerTransmit</srcid><srcstatus/><internalId>563</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TriggerTransmit_RemoteXcpSlave</srcid><srcstatus/><internalId>565</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxBusRetries_MasterNoTxConf_LocalXcp</srcid><srcstatus/><internalId>566</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxBusRetries_MasterENotOkTxConf_LocalXcp</srcid><srcstatus/><internalId>567</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxBusRetries_MasterNoTxConf_RemoteXcp</srcid><srcstatus/><internalId>568</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxBusRetries_MasterENotOkTxConf_RemoteXcp</srcid><srcstatus/><internalId>569</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxBusRetries_MessageCmd_RemoteXcpNoTxConf</srcid><srcstatus/><internalId>571</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxBusRetries_ConnectCmd_RemoteXcpNoTxConf</srcid><srcstatus/><internalId>572</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxBusRetries_BeforeReachingDisconnectTriggerPoint</srcid><srcstatus/><internalId>573</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectPosRes_FromRemoteXcp</srcid><srcstatus/><internalId>574</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectPosRes_FromLocalXcp</srcid><srcstatus/><internalId>575</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectCmd_ToRemoteXcp</srcid><srcstatus/><internalId>576</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_successfullyTransmit_ToRemoteXcp</srcid><srcstatus/><internalId>577</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectSuccedes</srcid><srcstatus/><internalId>578</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_MessagePosRes_FromLocalXcp</srcid><srcstatus/><internalId>579</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_DisconnectPosRes_FromRemoteXcp</srcid><srcstatus/><internalId>582</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_DisconnectPosRes_FromLocalXcp</srcid><srcstatus/><internalId>583</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_TwoConnectCmds_ToRemoteXcp</srcid><srcstatus/><internalId>584</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectPosRes_FromRemoteXcp_PackMaster</srcid><srcstatus/><internalId>586</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_MessagePosRes_FromLocalXcp_PackMaster</srcid><srcstatus/><internalId>587</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectPosRes_FromRemoteXcp_Pack</srcid><srcstatus/><internalId>589</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectPosRes_FromRemoteXcp_PackRemoteSlave</srcid><srcstatus/><internalId>590</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>121</internalId></specobject>

    <specobject>
      <id>XcpR.Impl.XcpRMultipleSlaves.Mode_0</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If XcpRMultipleSlavesEnabled parameter is enabled and the CONNECT command is requested with
        MODE = 0 then XcpR shall connect to the XCP instance on the local ECU.
      </description>
      <furtherinfo>WRN.swuts.needscoverage.count - This requirement is verified in different situations for every
        possible bus.</furtherinfo>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_SimulateConnectCMD_PosResponse_Mode_0</srcid><srcstatus/><internalId>495</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SimulateConnectCMD_NegResponse_Mode_0</srcid><srcstatus/><internalId>496</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ChangeMode_SwitchRemoteXcpToLocalXcp</srcid><srcstatus/><internalId>497</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SwitchConections</srcid><srcstatus/><internalId>498</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_NewCONNECTCmd_LocalXcpSlave</srcid><srcstatus/><internalId>500</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_LocalXcpSlave_InvalidConnectMode_TransmissionRx</srcid><srcstatus/><internalId>522</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_LocalXcpSlave_InvalidConnectMode</srcid><srcstatus/><internalId>523</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame_ToLocalXcp</srcid><srcstatus/><internalId>529</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ReceptionFromRx_LocalXcpSlave</srcid><srcstatus/><internalId>534</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_RxIndication_TxConfirmation_LocalXcp</srcid><srcstatus/><internalId>537</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_CddBusType_SimulateConnectCMD_PosResponse_Mode_0</srcid><srcstatus/><internalId>542</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_CddBusType_SimulateConnectCMD_NegResponse_Mode_0</srcid><srcstatus/><internalId>543</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_CddBusType_ChangeMode_SwitchRemoteXcpToLocalXcp</srcid><srcstatus/><internalId>544</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ConnectCmd_PosRes_LocalXcp_TriggerTransmit</srcid><srcstatus/><internalId>560</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ConnectCmd_NegRes_LocalXcp_TriggerTransmit</srcid><srcstatus/><internalId>561</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_LocalXcp_TriggerTransmit_NegRes</srcid><srcstatus/><internalId>562</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SwitchLocalXcpToRemoteXcp_TriggerTransmit</srcid><srcstatus/><internalId>563</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxBusRetries_MasterNoTxConf_LocalXcp</srcid><srcstatus/><internalId>566</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectPosRes_FromLocalXcp</srcid><srcstatus/><internalId>575</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_MessagePosRes_FromLocalXcp</srcid><srcstatus/><internalId>579</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_DisconnectPosRes_FromLocalXcp</srcid><srcstatus/><internalId>583</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_MessagePosRes_FromLocalXcp_PackMaster</srcid><srcstatus/><internalId>587</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_MultipleMessagesReceived_FromLocalAndMaster</srcid><srcstatus/><internalId>588</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_NotificationsToULXcp</srcid><srcstatus/><internalId>591</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_NotificationsToULXcp_DifferentPduIds</srcid><srcstatus/><internalId>592</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>122</internalId></specobject>

    <specobject>
      <id>XcpR.Impl.XcpRMultipleSlaves.Mode_1</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If XcpRMultipleSlavesEnabled parameter is enabled and the CONNECT command is requested with
        MODE = 1 then XcpR shall connect to the Xcp Slave on the remote ECU.
      </description>
      <furtherinfo>WRN.swuts.needscoverage.count - This requirement is verified in different situations for every
        possible bus.</furtherinfo>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_CanFdMaxDlcRequired_Slave</srcid><srcstatus/><internalId>476</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_FrToCanFd_MaxDlcReqDisabled_HigherDlc</srcid><srcstatus/><internalId>477</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ConnectionGroup</srcid><srcstatus/><internalId>478</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SimulateConnectCMD_PosResponse_Mode_1</srcid><srcstatus/><internalId>492</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SimulateConnectCMD_NegResponse_Mode_1</srcid><srcstatus/><internalId>493</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ChangeMode_SwitchRemoteXcpToLocalXcp</srcid><srcstatus/><internalId>497</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SwitchConections</srcid><srcstatus/><internalId>498</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_NewCONNECTCmd_RemoteXcpSlave</srcid><srcstatus/><internalId>499</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_ONLINE_MasterToRemote</srcid><srcstatus/><internalId>502</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_OFFLINE_MasterToRemote</srcid><srcstatus/><internalId>503</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_WrongId_MasterToRemote</srcid><srcstatus/><internalId>504</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_OpenSocketConnection_FAILED</srcid><srcstatus/><internalId>506</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TcpIp_CannotGetRemoteAddress</srcid><srcstatus/><internalId>507</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_ONLINE_Remote</srcid><srcstatus/><internalId>508</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_OFFLINE_Remote</srcid><srcstatus/><internalId>509</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_WrongId_Remote</srcid><srcstatus/><internalId>510</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_EthUdp_ReconfiguredSocket</srcid><srcstatus/><internalId>512</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_EthUdp_CannotSetRemoteAddress</srcid><srcstatus/><internalId>513</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_EthUdp_CommandDifferentIp</srcid><srcstatus/><internalId>514</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_EthUdp_RespondOnlyToConnectIpAddress</srcid><srcstatus/><internalId>515</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_CannotGetRemoteAddress</srcid><srcstatus/><internalId>516</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_CONNECTcmd_CannotSetRemoteAddress</srcid><srcstatus/><internalId>517</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_EthUdp_PortAlready_0_SetRemoteAddrNotCalled</srcid><srcstatus/><internalId>518</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRInternalQueue</srcid><srcstatus/><internalId>520</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRInternalQueue_LastIndexes</srcid><srcstatus/><internalId>521</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MainFunctionPeriod</srcid><srcstatus/><internalId>524</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame</srcid><srcstatus/><internalId>525</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame_RxIndication</srcid><srcstatus/><internalId>526</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame_DifferentSources</srcid><srcstatus/><internalId>527</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame_Master</srcid><srcstatus/><internalId>528</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame_RemoteXcpSlave</srcid><srcstatus/><internalId>530</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdus_TxConf</srcid><srcstatus/><internalId>531</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_InternalQueueStress</srcid><srcstatus/><internalId>532</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ReceptionFromRx_RemoteXcpSlave</srcid><srcstatus/><internalId>533</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_RxIndicationFromRx_TwoMessages_FirstDisconnectCmd</srcid><srcstatus/><internalId>535</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_RemoteXcpSlave_InvalidConnectMode</srcid><srcstatus/><internalId>536</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_RxIndication_TxConfirmation_RemoteXcp</srcid><srcstatus/><internalId>538</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_RxIndication_TxConfirmation_LinkedPduId</srcid><srcstatus/><internalId>539</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SameBusType_SimulateConnectCMD_PosResponse_Mode_1</srcid><srcstatus/><internalId>540</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SameBusType_SimulateConnectCMD_NegResponse_Mode_1</srcid><srcstatus/><internalId>541</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_CddBusType_ChangeMode_SwitchRemoteXcpToLocalXcp</srcid><srcstatus/><internalId>544</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SeqCorr_MultiplePdusInOneFrame</srcid><srcstatus/><internalId>545</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SeqCorr_MultiplePdusInOneFrame_Master</srcid><srcstatus/><internalId>546</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SeqCorr_MultiplePdusInOneFrame_RemoteXcpSlave</srcid><srcstatus/><internalId>547</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SeqCorr</srcid><srcstatus/><internalId>548</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TransmissionRx_MultiplePdusInOneFrame</srcid><srcstatus/><internalId>549</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TransmissionRx_MultiplePdusInOneFrame_Master</srcid><srcstatus/><internalId>550</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TransmissionRx_MultiplePdusInOneFrame_RemoteXcpSlave</srcid><srcstatus/><internalId>551</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TransmissionRx</srcid><srcstatus/><internalId>552</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_DataStim_PacketGreaterThan255Bytes</srcid><srcstatus/><internalId>553</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_AcqData_PacketGreaterThan255Bytes</srcid><srcstatus/><internalId>554</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_FrToCdd_TrigTrans_PackPdus_RemoteXcpSlave</srcid><srcstatus/><internalId>555</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_FlexRay_TrigTrans_PackPdus_SeqCor_RemoteXcpSlave</srcid><srcstatus/><internalId>556</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_FlexRay_TrigTrans_SeqCor_RemoteXcpSlave</srcid><srcstatus/><internalId>557</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ConnectCmd_PosRes_RemoteXcp_TriggerTransmit</srcid><srcstatus/><internalId>558</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ConnectCmd_NegRes_RemoteXcp_TriggerTransmit</srcid><srcstatus/><internalId>559</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SwitchLocalXcpToRemoteXcp_TriggerTransmit</srcid><srcstatus/><internalId>563</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TriggerTransmit_TxRetries_MessageCmd</srcid><srcstatus/><internalId>564</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TriggerTransmit_RemoteXcpSlave</srcid><srcstatus/><internalId>565</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxBusRetries_MasterNoTxConf_RemoteXcp</srcid><srcstatus/><internalId>568</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxBusRetries_MasterENotOkTxConf_RemoteXcp</srcid><srcstatus/><internalId>569</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxBusRetries_MasterNoTxConfConnect_RemoteXcp</srcid><srcstatus/><internalId>570</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxBusRetries_MessageCmd_RemoteXcpNoTxConf</srcid><srcstatus/><internalId>571</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxBusRetries_ConnectCmd_RemoteXcpNoTxConf</srcid><srcstatus/><internalId>572</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxBusRetries_BeforeReachingDisconnectTriggerPoint</srcid><srcstatus/><internalId>573</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectPosRes_FromRemoteXcp</srcid><srcstatus/><internalId>574</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectCmd_ToRemoteXcp</srcid><srcstatus/><internalId>576</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_successfullyTransmit_ToRemoteXcp</srcid><srcstatus/><internalId>577</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectSuccedes</srcid><srcstatus/><internalId>578</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_MessageCmd_ToRemoteXcp</srcid><srcstatus/><internalId>581</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_DisconnectPosRes_FromRemoteXcp</srcid><srcstatus/><internalId>582</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_TwoConnectCmds_ToRemoteXcp</srcid><srcstatus/><internalId>584</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_NoAutonomousDisconnect</srcid><srcstatus/><internalId>585</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectPosRes_FromRemoteXcp_PackMaster</srcid><srcstatus/><internalId>586</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectPosRes_FromRemoteXcp_Pack</srcid><srcstatus/><internalId>589</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectPosRes_FromRemoteXcp_PackRemoteSlave</srcid><srcstatus/><internalId>590</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>123</internalId></specobject>

    <specobject>
      <id>XcpR.Impl.XcpRMultipleSlaves.Disabled</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If XcpRMultipleSlavesEnabled parameter is disabled there shall be always one source and one destination for a configured routing path.
      </description>
      <furtherinfo>WRN.swuts.needscoverage.count - This requirement is verified in different situations for every
        possible bus.</furtherinfo>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_2975</srcid><srcstatus/><internalId>391</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_CanFdMaxDlcRequired_Slave</srcid><srcstatus/><internalId>476</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_FrToCanFd_MaxDlcReqDisabled_HigherDlc</srcid><srcstatus/><internalId>477</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ConnectionGroup</srcid><srcstatus/><internalId>478</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_LocalXcpSlave_InvalidConnectMode_TransmissionRx</srcid><srcstatus/><internalId>522</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_LocalXcpSlave_InvalidConnectMode</srcid><srcstatus/><internalId>523</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame</srcid><srcstatus/><internalId>525</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame_RxIndication</srcid><srcstatus/><internalId>526</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame_DifferentSources</srcid><srcstatus/><internalId>527</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame_RemoteXcpSlave</srcid><srcstatus/><internalId>530</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SeqCorr_MultiplePdusInOneFrame</srcid><srcstatus/><internalId>545</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SeqCorr_MultiplePdusInOneFrame_Master</srcid><srcstatus/><internalId>546</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SeqCorr_MultiplePdusInOneFrame_RemoteXcpSlave</srcid><srcstatus/><internalId>547</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SeqCorr</srcid><srcstatus/><internalId>548</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TriggerTransmit_RemoteXcpSlave</srcid><srcstatus/><internalId>565</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>124</internalId></specobject>

    <specobject>
      <id>XcpR.Impl.XcpRMultipleSlaves.Enabled.TwoDestinationPDUs</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        When XcpRMultipleSlaves is enabled it shall be possible to configure two destination PDUs for
        one source reception path (the destination depends on the received MODE on the CONNECT command).
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_SimulateConnectCMD_PosResponse_Mode_0</srcid><srcstatus/><internalId>495</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SimulateConnectCMD_NegResponse_Mode_0</srcid><srcstatus/><internalId>496</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ChangeMode_SwitchRemoteXcpToLocalXcp</srcid><srcstatus/><internalId>497</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SwitchConections</srcid><srcstatus/><internalId>498</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_CddBusType_ChangeMode_SwitchRemoteXcpToLocalXcp</srcid><srcstatus/><internalId>544</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SwitchLocalXcpToRemoteXcp_TriggerTransmit</srcid><srcstatus/><internalId>563</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>125</internalId></specobject>

    <specobject>
      <id>XcpR.Impl.ConcatMessagesFlexRayUnpackMultipleMessages</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        When concatenation in one FlexRay frame is enabled, XcpR shall unpack all XCP messages received in one frame
        and send each message on the configured destination bus-type to the slave Xcp.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame_RemoteXcpSlave</srcid><srcstatus/><internalId>530</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdus_TxConf</srcid><srcstatus/><internalId>531</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/XcpR_SourceProcessor.c_1128</srcid><srcstatus/><internalId>284</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>126</internalId></specobject>

    <specobject>
      <id>XcpR.Impl.ConcatMessagesEthernetUnpackMultipleMessages</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        When concatenation in one Ethernet frame is enabled, XcpR shall unpack all XCP messages received in one frame
        and send each message on the configured destination bus-type to the slave Xcp.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame_RemoteXcpSlave</srcid><srcstatus/><internalId>530</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdus_TxConf</srcid><srcstatus/><internalId>531</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/XcpR_SourceProcessor.c_1186</srcid><srcstatus/><internalId>286</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>127</internalId></specobject>

    <specobject>
      <id>XcpR.Impl.ConcatMessagesFlexRayPackMultipleMessages</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        When concatenation in one frame is enabled, XcpR shall pack all XCP messages received in one frame
        and send the message on the configured destination bus-type to slave Xcp.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame_RemoteXcpSlave</srcid><srcstatus/><internalId>530</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/XcpR_DestinationProcessor.c_1686</srcid><srcstatus/><internalId>233</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>128</internalId></specobject>

    <specobject>
      <id>XcpR.Impl.ConcatMessagesEthernetPackMultipleMessages</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        When concatenation in one Ethernet frame is enabled, XcpR shall pack all XCP messages received in one frame
        and send the message on the configured destination bus-type to slave Xcp.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame_RemoteXcpSlave</srcid><srcstatus/><internalId>530</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/XcpR_DestinationProcessor.c_1687</srcid><srcstatus/><internalId>234</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>129</internalId></specobject>

    <specobject>
      <id>XcpR.Impl.GenerateA2L</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The XCP Router module has to generate A2L which contains the transport layer configuration of the master network and
        the protocol layer configuration of the remote network.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.XcpRGenerateA2L</srcid><srcstatus/><internalId>203</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>130</internalId></specobject>

    <specobject>
      <id>XcpR.Impl.DisconnectedState.CommandResponse</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        When the XcpR is in disconnected state, all received commands
        except CONNECT command shall be ignored  without any response.
      </description>
      <furtherinfo>WRN.swuts.needscoverage.count - This requirement is verified in different situations for every
        possible bus.</furtherinfo>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_CanFdMaxDlcRequired_Slave</srcid><srcstatus/><internalId>476</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_FrToCanFd_MaxDlcReqDisabled_HigherDlc</srcid><srcstatus/><internalId>477</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ConnectionGroup</srcid><srcstatus/><internalId>478</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SimulateConnectCMD_PosResponse_Mode_1</srcid><srcstatus/><internalId>492</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SimulateConnectCMD_NegResponse_Mode_1</srcid><srcstatus/><internalId>493</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SimulateConnectCMD_PosResponse_Mode_0</srcid><srcstatus/><internalId>495</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SimulateConnectCMD_NegResponse_Mode_0</srcid><srcstatus/><internalId>496</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ChangeMode_SwitchRemoteXcpToLocalXcp</srcid><srcstatus/><internalId>497</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SwitchConections</srcid><srcstatus/><internalId>498</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_NewCONNECTCmd_RemoteXcpSlave</srcid><srcstatus/><internalId>499</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_NewCONNECTCmd_LocalXcpSlave</srcid><srcstatus/><internalId>500</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_InternalQueue_DifferentDestinations</srcid><srcstatus/><internalId>501</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_ONLINE_MasterToRemote</srcid><srcstatus/><internalId>502</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_OFFLINE_MasterToRemote</srcid><srcstatus/><internalId>503</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_WrongId_MasterToRemote</srcid><srcstatus/><internalId>504</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_NoConnectionEstablished</srcid><srcstatus/><internalId>505</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_OpenSocketConnection_FAILED</srcid><srcstatus/><internalId>506</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TcpIp_CannotGetRemoteAddress</srcid><srcstatus/><internalId>507</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_ONLINE_Remote</srcid><srcstatus/><internalId>508</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_OFFLINE_Remote</srcid><srcstatus/><internalId>509</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_WrongId_Remote</srcid><srcstatus/><internalId>510</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_EthUdp_ReconfiguredSocket</srcid><srcstatus/><internalId>512</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_EthUdp_CannotSetRemoteAddress</srcid><srcstatus/><internalId>513</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_EthUdp_CommandDifferentIp</srcid><srcstatus/><internalId>514</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_CannotGetRemoteAddress</srcid><srcstatus/><internalId>516</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_CONNECTcmd_CannotSetRemoteAddress</srcid><srcstatus/><internalId>517</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SoAd_OpenSoCon</srcid><srcstatus/><internalId>519</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRInternalQueue</srcid><srcstatus/><internalId>520</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRInternalQueue_LastIndexes</srcid><srcstatus/><internalId>521</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_LocalXcpSlave_InvalidConnectMode_TransmissionRx</srcid><srcstatus/><internalId>522</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_LocalXcpSlave_InvalidConnectMode</srcid><srcstatus/><internalId>523</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame</srcid><srcstatus/><internalId>525</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame_RxIndication</srcid><srcstatus/><internalId>526</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame_DifferentSources</srcid><srcstatus/><internalId>527</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame_Master</srcid><srcstatus/><internalId>528</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame_ToLocalXcp</srcid><srcstatus/><internalId>529</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame_RemoteXcpSlave</srcid><srcstatus/><internalId>530</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdus_TxConf</srcid><srcstatus/><internalId>531</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ReceptionFromRx_RemoteXcpSlave</srcid><srcstatus/><internalId>533</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ReceptionFromRx_LocalXcpSlave</srcid><srcstatus/><internalId>534</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_RxIndicationFromRx_TwoMessages_FirstDisconnectCmd</srcid><srcstatus/><internalId>535</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_RemoteXcpSlave_InvalidConnectMode</srcid><srcstatus/><internalId>536</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_RxIndication_TxConfirmation_LocalXcp</srcid><srcstatus/><internalId>537</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_RxIndication_TxConfirmation_RemoteXcp</srcid><srcstatus/><internalId>538</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_RxIndication_TxConfirmation_LinkedPduId</srcid><srcstatus/><internalId>539</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SameBusType_SimulateConnectCMD_PosResponse_Mode_1</srcid><srcstatus/><internalId>540</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SameBusType_SimulateConnectCMD_NegResponse_Mode_1</srcid><srcstatus/><internalId>541</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_CddBusType_SimulateConnectCMD_PosResponse_Mode_0</srcid><srcstatus/><internalId>542</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_CddBusType_SimulateConnectCMD_NegResponse_Mode_0</srcid><srcstatus/><internalId>543</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_CddBusType_ChangeMode_SwitchRemoteXcpToLocalXcp</srcid><srcstatus/><internalId>544</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SeqCorr_MultiplePdusInOneFrame</srcid><srcstatus/><internalId>545</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SeqCorr_MultiplePdusInOneFrame_Master</srcid><srcstatus/><internalId>546</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SeqCorr_MultiplePdusInOneFrame_RemoteXcpSlave</srcid><srcstatus/><internalId>547</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SeqCorr</srcid><srcstatus/><internalId>548</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TransmissionRx_MultiplePdusInOneFrame</srcid><srcstatus/><internalId>549</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TransmissionRx_MultiplePdusInOneFrame_Master</srcid><srcstatus/><internalId>550</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TransmissionRx_MultiplePdusInOneFrame_RemoteXcpSlave</srcid><srcstatus/><internalId>551</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TransmissionRx</srcid><srcstatus/><internalId>552</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_FrToCdd_TrigTrans_PackPdus_RemoteXcpSlave</srcid><srcstatus/><internalId>555</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_FlexRay_TrigTrans_PackPdus_SeqCor_RemoteXcpSlave</srcid><srcstatus/><internalId>556</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_FlexRay_TrigTrans_SeqCor_RemoteXcpSlave</srcid><srcstatus/><internalId>557</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ConnectCmd_PosRes_RemoteXcp_TriggerTransmit</srcid><srcstatus/><internalId>558</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ConnectCmd_NegRes_RemoteXcp_TriggerTransmit</srcid><srcstatus/><internalId>559</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ConnectCmd_PosRes_LocalXcp_TriggerTransmit</srcid><srcstatus/><internalId>560</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ConnectCmd_NegRes_LocalXcp_TriggerTransmit</srcid><srcstatus/><internalId>561</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_LocalXcp_TriggerTransmit_NegRes</srcid><srcstatus/><internalId>562</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SwitchLocalXcpToRemoteXcp_TriggerTransmit</srcid><srcstatus/><internalId>563</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TriggerTransmit_TxRetries_MessageCmd</srcid><srcstatus/><internalId>564</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TriggerTransmit_RemoteXcpSlave</srcid><srcstatus/><internalId>565</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxBusRetries_MasterNoTxConf_LocalXcp</srcid><srcstatus/><internalId>566</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxBusRetries_MasterNoTxConf_RemoteXcp</srcid><srcstatus/><internalId>568</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxBusRetries_MasterENotOkTxConf_RemoteXcp</srcid><srcstatus/><internalId>569</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxBusRetries_MessageCmd_RemoteXcpNoTxConf</srcid><srcstatus/><internalId>571</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxBusRetries_ConnectCmd_RemoteXcpNoTxConf</srcid><srcstatus/><internalId>572</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxBusRetries_BeforeReachingDisconnectTriggerPoint</srcid><srcstatus/><internalId>573</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectPosRes_FromRemoteXcp</srcid><srcstatus/><internalId>574</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectPosRes_FromLocalXcp</srcid><srcstatus/><internalId>575</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectCmd_ToRemoteXcp</srcid><srcstatus/><internalId>576</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_MessagePosRes_FromLocalXcp</srcid><srcstatus/><internalId>579</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_MessageCmd_ToRemoteXcp</srcid><srcstatus/><internalId>581</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_DisconnectPosRes_FromRemoteXcp</srcid><srcstatus/><internalId>582</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_DisconnectPosRes_FromLocalXcp</srcid><srcstatus/><internalId>583</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_TwoConnectCmds_ToRemoteXcp</srcid><srcstatus/><internalId>584</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_NoAutonomousDisconnect</srcid><srcstatus/><internalId>585</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectPosRes_FromRemoteXcp_PackMaster</srcid><srcstatus/><internalId>586</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_MessagePosRes_FromLocalXcp_PackMaster</srcid><srcstatus/><internalId>587</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectPosRes_FromRemoteXcp_Pack</srcid><srcstatus/><internalId>589</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectPosRes_FromRemoteXcp_PackRemoteSlave</srcid><srcstatus/><internalId>590</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>131</internalId></specobject>

    <specobject>
      <id>XcpR.Impl.SourceProcessing.BusyState</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        While the source processor is in BUSY state (the assigned source Pdu buffer is full),
        if a new message is received, the new message shall be ignored.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_SimulateConnectCMD_PosResponse_Mode_1</srcid><srcstatus/><internalId>492</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>132</internalId></specobject>

    <specobject>
      <id>XcpR.Impl.DestinationProcessing.BusyState</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        While the destination processor is in BUSY state,
        if a new message needs transmission, the new message shall be ignored.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_InternalQueue_DifferentDestinations</srcid><srcstatus/><internalId>501</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_RxIndication_TxConfirmation_RemoteXcp</srcid><srcstatus/><internalId>538</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>133</internalId></specobject>

    <specobject>
      <id>XcpR.Impl.MainFunction.InitCheck</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The XcpR_MainFunction() shall check if the module is initialized before
        performing any actions. If the module is not initialized, it shall
        directly abort the execution without doing anything else. It shall not
        report the Det error XCPR_E_NOT_INITIALIZED in this case.
      </description>
      <rationale>
        The SchM module may schedule the module's main function before the
        module is initialized. This would result in lots of Det errors
        during start up. Therefore the module's main function does not
        throw a Det error if the module is not yet initialized and simply
        returns in this case.
      </rationale>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_SimulateConnectCMD_PosResponse_Mode_1</srcid><srcstatus/><internalId>492</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_InternalQueue_DifferentDestinations</srcid><srcstatus/><internalId>501</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame_Master</srcid><srcstatus/><internalId>528</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ReceptionFromRx_RemoteXcpSlave</srcid><srcstatus/><internalId>533</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_RxIndicationFromRx_TwoMessages_FirstDisconnectCmd</srcid><srcstatus/><internalId>535</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>134</internalId></specobject>

    <specobject>
      <id>XcpR.Impl.Transmit.From.Tx.Context.Configuration</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The transmission of a pending PDU from Tx confirmation shall be configurable
        for each Tx Pdu channel.
      </description>
      <rationale>
        With this approach the user has the possibility to configure the amount of
        processing overhead which can be introduced by enabling this feature.
        The system may be designed to be more predictable in this way.
      </rationale>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_SimulateConnectCMD_PosResponse_Mode_1</srcid><srcstatus/><internalId>492</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdus_TxConf</srcid><srcstatus/><internalId>531</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_RxIndication_TxConfirmation_LocalXcp</srcid><srcstatus/><internalId>537</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_RxIndication_TxConfirmation_RemoteXcp</srcid><srcstatus/><internalId>538</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_CddBusType_ChangeMode_SwitchRemoteXcpToLocalXcp</srcid><srcstatus/><internalId>544</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>135</internalId></specobject>

    <specobject>
      <id>XcpR.Impl.Reception.From.Rx.Context.Configuration</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The reception of a pending PDU from Rx indication shall be configurable
        for each Rx Pdu channel.
      </description>
      <rationale>
        With this approach the user has the possibility to configure the amount of
        reception overhead which can be introduced by enabling this feature.
        The system may be designed to be more predictable in this way.
      </rationale>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_SimulateConnectCMD_NegResponse_Mode_1</srcid><srcstatus/><internalId>493</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ChangeMode_SwitchRemoteXcpToLocalXcp</srcid><srcstatus/><internalId>497</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdus_TxConf</srcid><srcstatus/><internalId>531</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ReceptionFromRx_RemoteXcpSlave</srcid><srcstatus/><internalId>533</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_CddBusType_ChangeMode_SwitchRemoteXcpToLocalXcp</srcid><srcstatus/><internalId>544</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>136</internalId></specobject>

    <specobject>
      <id>XcpR.Impl.Communication.FlexRay.ImmediateAccess</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        XcpR shall support the immediate access buffer mode of transmission for FlexRay.
      </description>
      <comment>
        Immediate transmission mode, as opposed to decoupled transmission mode, means that
        FrIf does not need to call XcpR_FrIfTriggerTransmit() after every call of FrIf_Transmit()
        to get the data to be transmitted.
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/XcpR_DestinationProcessor.c_1285</srcid><srcstatus/><internalId>229</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_ConnectionGroup</srcid><srcstatus/><internalId>478</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SimulateConnectCMD_PosResponse_Mode_1</srcid><srcstatus/><internalId>492</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SimulateConnectCMD_NegResponse_Mode_1</srcid><srcstatus/><internalId>493</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_InternalQueue_DifferentDestinations</srcid><srcstatus/><internalId>501</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame</srcid><srcstatus/><internalId>525</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame_Master</srcid><srcstatus/><internalId>528</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame_ToLocalXcp</srcid><srcstatus/><internalId>529</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>137</internalId></specobject>

    <specobject>
      <id>XcpR.Impl.Communication.FlexRay.DecoupledAccess</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        XcpR shall support the decoupled access buffer mode of transmission for FlexRay.
      </description>
      <comment>
        Decoupled transmission mode, as opposed to immediate transmission mode, means that FrIf needs
        to call XcpR_FrIfTriggerTransmit() after every call of FrIf_Transmit() to get the data to be
        transmitted.
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/XcpR_DestinationProcessor.c_1277</srcid><srcstatus/><internalId>227</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_ConnectCmd_PosRes_RemoteXcp_TriggerTransmit</srcid><srcstatus/><internalId>558</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ConnectCmd_NegRes_RemoteXcp_TriggerTransmit</srcid><srcstatus/><internalId>559</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SwitchLocalXcpToRemoteXcp_TriggerTransmit</srcid><srcstatus/><internalId>563</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>138</internalId></specobject>

    <specobject>
      <id>XcpR.Impl.Communication.CDD.ImmediateAccess</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        XcpR shall support the immediate access buffer mode of transmission for a CDD.
      </description>
      <comment>
        Immediate transmission mode, as opposed to decoupled transmission mode, means that a CDD
        does not need to call XcpR_CddTriggerTransmit() after every call of Cdd_Transmit() to get
        the data to be transmitted.
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/XcpR_DestinationProcessor.c_1286</srcid><srcstatus/><internalId>230</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_LocalXcpSlave_InvalidConnectMode_TransmissionRx</srcid><srcstatus/><internalId>522</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_LocalXcpSlave_InvalidConnectMode</srcid><srcstatus/><internalId>523</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_CddBusType_SimulateConnectCMD_PosResponse_Mode_0</srcid><srcstatus/><internalId>542</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_CddBusType_SimulateConnectCMD_NegResponse_Mode_0</srcid><srcstatus/><internalId>543</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_CddBusType_ChangeMode_SwitchRemoteXcpToLocalXcp</srcid><srcstatus/><internalId>544</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>139</internalId></specobject>

    <specobject>
      <id>XcpR.Impl.Communication.CDD.DecoupledAccess</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        XcpR shall support the decoupled access buffer mode of transmission for a CDD.
      </description>
      <comment>
        Decoupled transmission mode, as opposed to immediate transmission mode, means that a CDD
        needs to call XcpR_FrIfTriggerTransmit() after every call of Cdd_Transmit() to get the
        data to be transmitted.
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/XcpR_DestinationProcessor.c_1278</srcid><srcstatus/><internalId>228</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_ConnectCmd_PosRes_RemoteXcp_TriggerTransmit</srcid><srcstatus/><internalId>558</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ConnectCmd_NegRes_RemoteXcp_TriggerTransmit</srcid><srcstatus/><internalId>559</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SwitchLocalXcpToRemoteXcp_TriggerTransmit</srcid><srcstatus/><internalId>563</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>140</internalId></specobject>

    <specobject>
      <id>XcpR.Impl.PublicHeader</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The implementation of the XcpR module shall provide the header file XcpR.h,
        which is the main module interface file. It shall contain all types and
        function prototypes required by the XcpR module's environment.
      </description>
      <furtherinfo>WRN.swuts.needscoverage.count - This requirement is verified in different situations for every
        possible bus.</furtherinfo>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_SimulateConnectCMD_PosResponse_Mode_0</srcid><srcstatus/><internalId>495</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_InternalQueue_DifferentDestinations</srcid><srcstatus/><internalId>501</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRInternalQueue</srcid><srcstatus/><internalId>520</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_LocalXcpSlave_InvalidConnectMode_TransmissionRx</srcid><srcstatus/><internalId>522</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ReceptionFromRx_RemoteXcpSlave</srcid><srcstatus/><internalId>533</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ConnectCmd_PosRes_RemoteXcp_TriggerTransmit</srcid><srcstatus/><internalId>558</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectPosRes_FromRemoteXcp</srcid><srcstatus/><internalId>574</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectPosRes_FromRemoteXcp_Pack</srcid><srcstatus/><internalId>589</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>141</internalId></specobject>

    <specobject>
      <id>XcpR.Impl.DevelopmentErrors</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        In case development error detection is enabled for the XcpR module, the XcpR
        module shall report detected development errors to the DET.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_DetOn_RxIndication_InvalidPduLength</srcid><srcstatus/><internalId>483</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_DetOn_Transmit_InvalidPduLength</srcid><srcstatus/><internalId>484</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_DetOn_AllAPI_NullPointerData</srcid><srcstatus/><internalId>485</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_DetOn_RxIndication_ZeroPduLength</srcid><srcstatus/><internalId>486</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_DetOn_Transmit_ZeroPduLength</srcid><srcstatus/><internalId>487</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_DetOn_Unused_Sources</srcid><srcstatus/><internalId>488</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_DetOn_InvalidMessageLength_PduHeader</srcid><srcstatus/><internalId>489</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_FlexRay_NoPackedMessage_InvalidPduLength</srcid><srcstatus/><internalId>490</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_FlexRay_UnpackedMessage_InvalidPduLength</srcid><srcstatus/><internalId>491</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>142</internalId></specobject>

    <specobject>
      <id>XcpR.Impl.RuntimeErrors</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        In case runtime error detection is enabled for the XcpR module, the XcpR
        module shall report detected runtime errors to the DET.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_TriggerTransmit_TxRetries_MessageCmd</srcid><srcstatus/><internalId>564</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxBusRetries_MasterNoTxConfConnect_RemoteXcp</srcid><srcstatus/><internalId>570</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxBusRetries_MessageCmd_RemoteXcpNoTxConf</srcid><srcstatus/><internalId>571</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxBusRetries_BeforeReachingDisconnectTriggerPoint</srcid><srcstatus/><internalId>573</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectPosRes_FromRemoteXcp</srcid><srcstatus/><internalId>574</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_MessagePosRes_FromRemoteXcp</srcid><srcstatus/><internalId>580</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_DisconnectPosRes_FromLocalXcp</srcid><srcstatus/><internalId>583</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectPosRes_FromRemoteXcp_PackMaster</srcid><srcstatus/><internalId>586</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_MessagePosRes_FromLocalXcp_PackMaster</srcid><srcstatus/><internalId>587</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectPosRes_FromRemoteXcp_PackRemoteSlave</srcid><srcstatus/><internalId>590</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>143</internalId></specobject>

    <specobject>
      <id>XcpR.Impl.RemoveBusRelatedInfo</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        When XcpR receives bus messages via XcpR_RxIndication() or XcpR_Transmit(),
        it shall remove bus-related information such as header or tail
        before internally storing the message.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/XcpR_SourceProcessor.c_535</srcid><srcstatus/><internalId>275</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>144</internalId></specobject>

    <specobject>
      <id>XcpR.Impl.StoreDataBytesOnly</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        After XcpR removes header and tail information from a received PDU, it shall
        enqueue only message data bytes in an internal ring-buffer.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/XcpR_SourceProcessor.c_593</srcid><srcstatus/><internalId>278</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>145</internalId></specobject>

    <specobject>
      <id>XcpR.Impl.Store.Internal.Meta.Data</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        For each message stored, XcpR shall also store data regarding the source PduId, PduLength and Pdu type.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/XcpR_SourceProcessor.c_566</srcid><srcstatus/><internalId>276</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>146</internalId></specobject>

    <specobject>
      <id>XcpR.Impl.AdaptBusInfo</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        XcpR shall dequeue stored data from its internal ring buffer and adapt the
        bus information according to the configured destination bus-type.
      </description>
      <furtherinfo>WRN.swuts.needscoverage.count - This requirement is verified in different situations for every
        possible bus.</furtherinfo>
      <comment>
        I.e. For a FlexRay destination, bus information could be related to the
        FlexRay header, tail, possible package alignment or sequence correction.
        For a CAN-FD Destination, bus information could be related to CAN-FD fill bytes
        based on MaxDlc.
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/XcpR_DestinationProcessor.c_1718</srcid><srcstatus/><internalId>235</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/XcpR_DestinationProcessor.c_1869</srcid><srcstatus/><internalId>236</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/XcpR_DestinationProcessor.c_1902</srcid><srcstatus/><internalId>237</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/XcpR_DestinationProcessor.c_1913</srcid><srcstatus/><internalId>238</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/XcpR_DestinationProcessor.c_1935</srcid><srcstatus/><internalId>239</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_CanFdMaxDlcRequired_Slave</srcid><srcstatus/><internalId>476</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_FrToCanFd_MaxDlcReqDisabled_HigherDlc</srcid><srcstatus/><internalId>477</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_FlexRay_NoPackedMessage_InvalidPduLength</srcid><srcstatus/><internalId>490</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SimulateConnectCMD_PosResponse_Mode_1</srcid><srcstatus/><internalId>492</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SimulateConnectCMD_NegResponse_Mode_1</srcid><srcstatus/><internalId>493</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SimulateInvalidConnectCMD</srcid><srcstatus/><internalId>494</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_NewCONNECTCmd_RemoteXcpSlave</srcid><srcstatus/><internalId>499</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_InternalQueue_DifferentDestinations</srcid><srcstatus/><internalId>501</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_ONLINE_MasterToRemote</srcid><srcstatus/><internalId>502</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_OFFLINE_MasterToRemote</srcid><srcstatus/><internalId>503</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_WrongId_MasterToRemote</srcid><srcstatus/><internalId>504</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_OpenSocketConnection_FAILED</srcid><srcstatus/><internalId>506</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TcpIp_CannotGetRemoteAddress</srcid><srcstatus/><internalId>507</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_ONLINE_Remote</srcid><srcstatus/><internalId>508</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_OFFLINE_Remote</srcid><srcstatus/><internalId>509</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_WrongId_Remote</srcid><srcstatus/><internalId>510</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_EthUdp_ReconfiguredSocket</srcid><srcstatus/><internalId>512</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_EthUdp_CannotSetRemoteAddress</srcid><srcstatus/><internalId>513</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_EthUdp_CommandDifferentIp</srcid><srcstatus/><internalId>514</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_EthUdp_RespondOnlyToConnectIpAddress</srcid><srcstatus/><internalId>515</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_CannotGetRemoteAddress</srcid><srcstatus/><internalId>516</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_CONNECTcmd_CannotSetRemoteAddress</srcid><srcstatus/><internalId>517</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_EthUdp_PortAlready_0_SetRemoteAddrNotCalled</srcid><srcstatus/><internalId>518</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame_ToLocalXcp</srcid><srcstatus/><internalId>529</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SeqCorr_MultiplePdusInOneFrame</srcid><srcstatus/><internalId>545</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SeqCorr_MultiplePdusInOneFrame_Master</srcid><srcstatus/><internalId>546</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SeqCorr_MultiplePdusInOneFrame_RemoteXcpSlave</srcid><srcstatus/><internalId>547</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SeqCorr</srcid><srcstatus/><internalId>548</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_FlexRay_TrigTrans_PackPdus_SeqCor_RemoteXcpSlave</srcid><srcstatus/><internalId>556</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_FlexRay_TrigTrans_SeqCor_RemoteXcpSlave</srcid><srcstatus/><internalId>557</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ConnectCmd_NegRes_RemoteXcp_TriggerTransmit</srcid><srcstatus/><internalId>559</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ConnectCmd_NegRes_LocalXcp_TriggerTransmit</srcid><srcstatus/><internalId>561</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_LocalXcp_TriggerTransmit_NegRes</srcid><srcstatus/><internalId>562</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TriggerTransmit_TxRetries_MessageCmd</srcid><srcstatus/><internalId>564</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxBusRetries_MessageCmd_RemoteXcpNoTxConf</srcid><srcstatus/><internalId>571</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxBusRetries_BeforeReachingDisconnectTriggerPoint</srcid><srcstatus/><internalId>573</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectCmd_ToRemoteXcp</srcid><srcstatus/><internalId>576</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_successfullyTransmit_ToRemoteXcp</srcid><srcstatus/><internalId>577</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectSuccedes</srcid><srcstatus/><internalId>578</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_MessageCmd_ToRemoteXcp</srcid><srcstatus/><internalId>581</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_TwoConnectCmds_ToRemoteXcp</srcid><srcstatus/><internalId>584</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_NoAutonomousDisconnect</srcid><srcstatus/><internalId>585</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_NotificationsToULXcp</srcid><srcstatus/><internalId>591</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_NotificationsToULXcp_DifferentPduIds</srcid><srcstatus/><internalId>592</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>147</internalId></specobject>

    <specobject>
      <id>XcpR.Impl.ConfigurableInternalQueue</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The XcpR internal ring buffer used for storing received PDUs shall have a configurable size.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_159</srcid><srcstatus/><internalId>293</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_XcpRInternalQueue</srcid><srcstatus/><internalId>520</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRInternalQueue_LastIndexes</srcid><srcstatus/><internalId>521</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_InternalQueueStress</srcid><srcstatus/><internalId>532</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MSG_QUEUE_7</srcid><srcstatus/><internalId>597</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MSG_QUEUE_6</srcid><srcstatus/><internalId>598</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MSG_QUEUE_5</srcid><srcstatus/><internalId>599</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MSG_QUEUE_4</srcid><srcstatus/><internalId>600</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MSG_QUEUE_3</srcid><srcstatus/><internalId>601</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MSG_QUEUE_2</srcid><srcstatus/><internalId>602</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MSG_QUEUE_1</srcid><srcstatus/><internalId>603</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>148</internalId></specobject>

    <specobject>
      <id>XcpR.Impl.CddLocalConnectionsOnly</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If XcpR is configured as a layer between the master Xcp and a slave Xcp located on the same
        ECU, it shall only allow configurations with connections over CDD as interface with
        the slave Xcp.
      </description>
      <furtherinfo>WRN.swuts.needscoverage.count - This requirement is verified in multiple test cases
        for checking functionality on the local Xcp instance.</furtherinfo>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_2333</srcid><srcstatus/><internalId>367</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_SimulateConnectCMD_PosResponse_Mode_0</srcid><srcstatus/><internalId>495</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SimulateConnectCMD_NegResponse_Mode_0</srcid><srcstatus/><internalId>496</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ChangeMode_SwitchRemoteXcpToLocalXcp</srcid><srcstatus/><internalId>497</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SwitchConections</srcid><srcstatus/><internalId>498</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_NewCONNECTCmd_LocalXcpSlave</srcid><srcstatus/><internalId>500</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_LocalXcpSlave_InvalidConnectMode_TransmissionRx</srcid><srcstatus/><internalId>522</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_LocalXcpSlave_InvalidConnectMode</srcid><srcstatus/><internalId>523</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame_ToLocalXcp</srcid><srcstatus/><internalId>529</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ReceptionFromRx_LocalXcpSlave</srcid><srcstatus/><internalId>534</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_RxIndication_TxConfirmation_LocalXcp</srcid><srcstatus/><internalId>537</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_CddBusType_SimulateConnectCMD_PosResponse_Mode_0</srcid><srcstatus/><internalId>542</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_CddBusType_SimulateConnectCMD_NegResponse_Mode_0</srcid><srcstatus/><internalId>543</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_CddBusType_ChangeMode_SwitchRemoteXcpToLocalXcp</srcid><srcstatus/><internalId>544</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ConnectCmd_PosRes_LocalXcp_TriggerTransmit</srcid><srcstatus/><internalId>560</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ConnectCmd_NegRes_LocalXcp_TriggerTransmit</srcid><srcstatus/><internalId>561</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_LocalXcp_TriggerTransmit_NegRes</srcid><srcstatus/><internalId>562</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SwitchLocalXcpToRemoteXcp_TriggerTransmit</srcid><srcstatus/><internalId>563</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxBusRetries_MasterNoTxConf_LocalXcp</srcid><srcstatus/><internalId>566</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxBusRetries_MasterENotOkTxConf_LocalXcp</srcid><srcstatus/><internalId>567</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>149</internalId></specobject>

    <specobject>
      <id>XcpR.Impl.BusTypesRemoteConnections</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If XcpR is configured as a layer between the master Xcp and a slave Xcp located on a
        remote ECU, it shall allow configurations with connections over CAN, CAN-FD, FlexRay or CDD,
        as interface with the slave Xcp.
      </description>
      <furtherinfo>WRN.swuts.needscoverage.count - This requirement is verified in different situations for every
        possible bus.</furtherinfo>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_CanFdMaxDlcRequired_Slave</srcid><srcstatus/><internalId>476</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_FrToCanFd_MaxDlcReqDisabled_HigherDlc</srcid><srcstatus/><internalId>477</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ConnectionGroup</srcid><srcstatus/><internalId>478</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SimulateConnectCMD_PosResponse_Mode_1</srcid><srcstatus/><internalId>492</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SimulateConnectCMD_NegResponse_Mode_1</srcid><srcstatus/><internalId>493</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SimulateInvalidConnectCMD</srcid><srcstatus/><internalId>494</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ChangeMode_SwitchRemoteXcpToLocalXcp</srcid><srcstatus/><internalId>497</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SwitchConections</srcid><srcstatus/><internalId>498</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_NewCONNECTCmd_RemoteXcpSlave</srcid><srcstatus/><internalId>499</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_InternalQueue_DifferentDestinations</srcid><srcstatus/><internalId>501</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_ONLINE_MasterToRemote</srcid><srcstatus/><internalId>502</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_OFFLINE_MasterToRemote</srcid><srcstatus/><internalId>503</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_WrongId_MasterToRemote</srcid><srcstatus/><internalId>504</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_NoConnectionEstablished</srcid><srcstatus/><internalId>505</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_OpenSocketConnection_FAILED</srcid><srcstatus/><internalId>506</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TcpIp_CannotGetRemoteAddress</srcid><srcstatus/><internalId>507</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_ONLINE_Remote</srcid><srcstatus/><internalId>508</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_OFFLINE_Remote</srcid><srcstatus/><internalId>509</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_WrongId_Remote</srcid><srcstatus/><internalId>510</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_EthUdp_ReconfiguredSocket</srcid><srcstatus/><internalId>512</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_EthUdp_CannotSetRemoteAddress</srcid><srcstatus/><internalId>513</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_EthUdp_CommandDifferentIp</srcid><srcstatus/><internalId>514</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_EthUdp_RespondOnlyToConnectIpAddress</srcid><srcstatus/><internalId>515</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_CannotGetRemoteAddress</srcid><srcstatus/><internalId>516</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_CONNECTcmd_CannotSetRemoteAddress</srcid><srcstatus/><internalId>517</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_EthUdp_PortAlready_0_SetRemoteAddrNotCalled</srcid><srcstatus/><internalId>518</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SoAd_OpenSoCon</srcid><srcstatus/><internalId>519</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRInternalQueue</srcid><srcstatus/><internalId>520</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRInternalQueue_LastIndexes</srcid><srcstatus/><internalId>521</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame</srcid><srcstatus/><internalId>525</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame_RxIndication</srcid><srcstatus/><internalId>526</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame_DifferentSources</srcid><srcstatus/><internalId>527</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame_Master</srcid><srcstatus/><internalId>528</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame_RemoteXcpSlave</srcid><srcstatus/><internalId>530</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdus_TxConf</srcid><srcstatus/><internalId>531</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_InternalQueueStress</srcid><srcstatus/><internalId>532</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ReceptionFromRx_RemoteXcpSlave</srcid><srcstatus/><internalId>533</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_RemoteXcpSlave_InvalidConnectMode</srcid><srcstatus/><internalId>536</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_RxIndication_TxConfirmation_RemoteXcp</srcid><srcstatus/><internalId>538</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_RxIndication_TxConfirmation_LinkedPduId</srcid><srcstatus/><internalId>539</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SameBusType_SimulateConnectCMD_PosResponse_Mode_1</srcid><srcstatus/><internalId>540</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SameBusType_SimulateConnectCMD_NegResponse_Mode_1</srcid><srcstatus/><internalId>541</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_CddBusType_ChangeMode_SwitchRemoteXcpToLocalXcp</srcid><srcstatus/><internalId>544</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SeqCorr_MultiplePdusInOneFrame</srcid><srcstatus/><internalId>545</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SeqCorr_MultiplePdusInOneFrame_Master</srcid><srcstatus/><internalId>546</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SeqCorr_MultiplePdusInOneFrame_RemoteXcpSlave</srcid><srcstatus/><internalId>547</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SeqCorr</srcid><srcstatus/><internalId>548</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TransmissionRx_MultiplePdusInOneFrame</srcid><srcstatus/><internalId>549</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TransmissionRx_MultiplePdusInOneFrame_Master</srcid><srcstatus/><internalId>550</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TransmissionRx_MultiplePdusInOneFrame_RemoteXcpSlave</srcid><srcstatus/><internalId>551</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TransmissionRx</srcid><srcstatus/><internalId>552</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_DataStim_PacketGreaterThan255Bytes</srcid><srcstatus/><internalId>553</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_AcqData_PacketGreaterThan255Bytes</srcid><srcstatus/><internalId>554</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ConnectCmd_PosRes_RemoteXcp_TriggerTransmit</srcid><srcstatus/><internalId>558</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ConnectCmd_NegRes_RemoteXcp_TriggerTransmit</srcid><srcstatus/><internalId>559</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SwitchLocalXcpToRemoteXcp_TriggerTransmit</srcid><srcstatus/><internalId>563</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TriggerTransmit_RemoteXcpSlave</srcid><srcstatus/><internalId>565</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxBusRetries_MasterNoTxConf_RemoteXcp</srcid><srcstatus/><internalId>568</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxBusRetries_MasterENotOkTxConf_RemoteXcp</srcid><srcstatus/><internalId>569</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxBusRetries_MessageCmd_RemoteXcpNoTxConf</srcid><srcstatus/><internalId>571</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxBusRetries_BeforeReachingDisconnectTriggerPoint</srcid><srcstatus/><internalId>573</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectPosRes_FromRemoteXcp</srcid><srcstatus/><internalId>574</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectPosRes_FromRemoteXcp_PackMaster</srcid><srcstatus/><internalId>586</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectPosRes_FromRemoteXcp_Pack</srcid><srcstatus/><internalId>589</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectPosRes_FromRemoteXcp_PackRemoteSlave</srcid><srcstatus/><internalId>590</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>150</internalId></specobject>

    <specobject>
      <id>XcpR.Impl.UpperLayerRxIndicationPduId</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If XcpR is configured as a layer between the master Xcp and a slave Xcp located on the same
        ECU, XcpR shall derive the Upper Layer PduId for a UL_RxIndication() notification based
        on the configured EcuC RxPdu reference from a XcpR Rx destination.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate/src/XcpR_Cfg.c_584</srcid><srcstatus/><internalId>207</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_SimulateConnectCMD_PosResponse_Mode_0</srcid><srcstatus/><internalId>495</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SimulateConnectCMD_NegResponse_Mode_0</srcid><srcstatus/><internalId>496</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ChangeMode_SwitchRemoteXcpToLocalXcp</srcid><srcstatus/><internalId>497</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame_ToLocalXcp</srcid><srcstatus/><internalId>529</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ReceptionFromRx_LocalXcpSlave</srcid><srcstatus/><internalId>534</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_RxIndication_TxConfirmation_LocalXcp</srcid><srcstatus/><internalId>537</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_CddBusType_SimulateConnectCMD_PosResponse_Mode_0</srcid><srcstatus/><internalId>542</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_CddBusType_ChangeMode_SwitchRemoteXcpToLocalXcp</srcid><srcstatus/><internalId>544</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>151</internalId></specobject>

    <specobject>
      <id>XcpR.Impl.UpperLayerTxConfirmationPduId</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If XcpR is configured as a layer between the master Xcp and a slave Xcp located on the same
        ECU, XcpR shall derive the Upper Layer PduId for a UL_TxConfirmation() notification based on
        the configured EcuC TxPdu reference from a XcpR Tx source.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate/src/XcpR_Cfg.c_408</srcid><srcstatus/><internalId>206</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_SimulateConnectCMD_PosResponse_Mode_0</srcid><srcstatus/><internalId>495</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SimulateConnectCMD_NegResponse_Mode_0</srcid><srcstatus/><internalId>496</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ChangeMode_SwitchRemoteXcpToLocalXcp</srcid><srcstatus/><internalId>497</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame_ToLocalXcp</srcid><srcstatus/><internalId>529</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ReceptionFromRx_LocalXcpSlave</srcid><srcstatus/><internalId>534</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_RxIndication_TxConfirmation_LocalXcp</srcid><srcstatus/><internalId>537</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_CddBusType_SimulateConnectCMD_PosResponse_Mode_0</srcid><srcstatus/><internalId>542</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_CddBusType_ChangeMode_SwitchRemoteXcpToLocalXcp</srcid><srcstatus/><internalId>544</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>152</internalId></specobject>

    <specobject>
      <id>XcpR.Impl.DisconnectedState.ConnectMode</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If XcpR is in state DISCONNECTED, it shall check the MODE parameter of a CONNECT command,
        so it can route the information to the correct destination.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/XcpR_DestinationProcessor.c_1086</srcid><srcstatus/><internalId>226</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_SimulateConnectCMD_PosResponse_Mode_0</srcid><srcstatus/><internalId>495</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SimulateConnectCMD_NegResponse_Mode_0</srcid><srcstatus/><internalId>496</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ChangeMode_SwitchRemoteXcpToLocalXcp</srcid><srcstatus/><internalId>497</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_NewCONNECTCmd_LocalXcpSlave</srcid><srcstatus/><internalId>500</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ReceptionFromRx_LocalXcpSlave</srcid><srcstatus/><internalId>534</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_RxIndication_TxConfirmation_LocalXcp</srcid><srcstatus/><internalId>537</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SameBusType_SimulateConnectCMD_PosResponse_Mode_1</srcid><srcstatus/><internalId>540</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_CddBusType_ChangeMode_SwitchRemoteXcpToLocalXcp</srcid><srcstatus/><internalId>544</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>153</internalId></specobject>

    <specobject>
      <id>XcpR.Impl.ActiveRoutingPath</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If XcpR receives a positive response from a slave Xcp, after a CONNECT command,
        it shall save the currently active routing path in the XcpR_Status runtime data.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/XcpR_DestinationProcessor.c_1499</srcid><srcstatus/><internalId>232</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_SimulateConnectCMD_PosResponse_Mode_1</srcid><srcstatus/><internalId>492</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SimulateConnectCMD_PosResponse_Mode_0</srcid><srcstatus/><internalId>495</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SimulateConnectCMD_NegResponse_Mode_0</srcid><srcstatus/><internalId>496</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_InternalQueue_DifferentDestinations</srcid><srcstatus/><internalId>501</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SameBusType_SimulateConnectCMD_PosResponse_Mode_1</srcid><srcstatus/><internalId>540</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_CddBusType_SimulateConnectCMD_PosResponse_Mode_0</srcid><srcstatus/><internalId>542</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>154</internalId></specobject>

    <specobject>
      <id>XcpR.Impl.RemoteConnections.ConnectMode</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        When the received CONNECT MODE is 1 the XcpR shall set the MODE to 0 before
        sending the package on the remote network to the remote Xcp Slave.
      </description>
      <furtherinfo>WRN.swuts.needscoverage.count - This requirement is verified in different situations for every
        possible bus.</furtherinfo>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/XcpR_DestinationProcessor.c_2476</srcid><srcstatus/><internalId>244</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_CanFdMaxDlcRequired_Slave</srcid><srcstatus/><internalId>476</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_FrToCanFd_MaxDlcReqDisabled_HigherDlc</srcid><srcstatus/><internalId>477</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ConnectionGroup</srcid><srcstatus/><internalId>478</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SimulateConnectCMD_PosResponse_Mode_1</srcid><srcstatus/><internalId>492</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SimulateConnectCMD_NegResponse_Mode_1</srcid><srcstatus/><internalId>493</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ChangeMode_SwitchRemoteXcpToLocalXcp</srcid><srcstatus/><internalId>497</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SwitchConections</srcid><srcstatus/><internalId>498</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_NewCONNECTCmd_RemoteXcpSlave</srcid><srcstatus/><internalId>499</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_InternalQueue_DifferentDestinations</srcid><srcstatus/><internalId>501</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_ONLINE_MasterToRemote</srcid><srcstatus/><internalId>502</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_OFFLINE_MasterToRemote</srcid><srcstatus/><internalId>503</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_WrongId_MasterToRemote</srcid><srcstatus/><internalId>504</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_OpenSocketConnection_FAILED</srcid><srcstatus/><internalId>506</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TcpIp_CannotGetRemoteAddress</srcid><srcstatus/><internalId>507</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_ONLINE_Remote</srcid><srcstatus/><internalId>508</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_OFFLINE_Remote</srcid><srcstatus/><internalId>509</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_WrongId_Remote</srcid><srcstatus/><internalId>510</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_EthUdp_ReconfiguredSocket</srcid><srcstatus/><internalId>512</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_EthUdp_CannotSetRemoteAddress</srcid><srcstatus/><internalId>513</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_EthUdp_CommandDifferentIp</srcid><srcstatus/><internalId>514</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_EthUdp_RespondOnlyToConnectIpAddress</srcid><srcstatus/><internalId>515</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_CannotGetRemoteAddress</srcid><srcstatus/><internalId>516</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_CONNECTcmd_CannotSetRemoteAddress</srcid><srcstatus/><internalId>517</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_EthUdp_PortAlready_0_SetRemoteAddrNotCalled</srcid><srcstatus/><internalId>518</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRInternalQueue</srcid><srcstatus/><internalId>520</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRInternalQueue_LastIndexes</srcid><srcstatus/><internalId>521</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame</srcid><srcstatus/><internalId>525</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame_RxIndication</srcid><srcstatus/><internalId>526</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame_DifferentSources</srcid><srcstatus/><internalId>527</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame_Master</srcid><srcstatus/><internalId>528</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame_RemoteXcpSlave</srcid><srcstatus/><internalId>530</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdus_TxConf</srcid><srcstatus/><internalId>531</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_InternalQueueStress</srcid><srcstatus/><internalId>532</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ReceptionFromRx_RemoteXcpSlave</srcid><srcstatus/><internalId>533</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_RxIndicationFromRx_TwoMessages_FirstDisconnectCmd</srcid><srcstatus/><internalId>535</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_RemoteXcpSlave_InvalidConnectMode</srcid><srcstatus/><internalId>536</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_RxIndication_TxConfirmation_RemoteXcp</srcid><srcstatus/><internalId>538</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_RxIndication_TxConfirmation_LinkedPduId</srcid><srcstatus/><internalId>539</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SameBusType_SimulateConnectCMD_PosResponse_Mode_1</srcid><srcstatus/><internalId>540</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SameBusType_SimulateConnectCMD_NegResponse_Mode_1</srcid><srcstatus/><internalId>541</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_CddBusType_ChangeMode_SwitchRemoteXcpToLocalXcp</srcid><srcstatus/><internalId>544</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SeqCorr_MultiplePdusInOneFrame</srcid><srcstatus/><internalId>545</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SeqCorr_MultiplePdusInOneFrame_Master</srcid><srcstatus/><internalId>546</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SeqCorr_MultiplePdusInOneFrame_RemoteXcpSlave</srcid><srcstatus/><internalId>547</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SeqCorr</srcid><srcstatus/><internalId>548</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TransmissionRx_MultiplePdusInOneFrame</srcid><srcstatus/><internalId>549</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TransmissionRx_MultiplePdusInOneFrame_Master</srcid><srcstatus/><internalId>550</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TransmissionRx_MultiplePdusInOneFrame_RemoteXcpSlave</srcid><srcstatus/><internalId>551</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TransmissionRx</srcid><srcstatus/><internalId>552</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_DataStim_PacketGreaterThan255Bytes</srcid><srcstatus/><internalId>553</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_AcqData_PacketGreaterThan255Bytes</srcid><srcstatus/><internalId>554</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_FrToCdd_TrigTrans_PackPdus_RemoteXcpSlave</srcid><srcstatus/><internalId>555</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_FlexRay_TrigTrans_PackPdus_SeqCor_RemoteXcpSlave</srcid><srcstatus/><internalId>556</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_FlexRay_TrigTrans_SeqCor_RemoteXcpSlave</srcid><srcstatus/><internalId>557</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ConnectCmd_PosRes_RemoteXcp_TriggerTransmit</srcid><srcstatus/><internalId>558</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ConnectCmd_NegRes_RemoteXcp_TriggerTransmit</srcid><srcstatus/><internalId>559</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SwitchLocalXcpToRemoteXcp_TriggerTransmit</srcid><srcstatus/><internalId>563</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TriggerTransmit_TxRetries_MessageCmd</srcid><srcstatus/><internalId>564</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TriggerTransmit_RemoteXcpSlave</srcid><srcstatus/><internalId>565</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxBusRetries_MasterNoTxConf_RemoteXcp</srcid><srcstatus/><internalId>568</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxBusRetries_MasterENotOkTxConf_RemoteXcp</srcid><srcstatus/><internalId>569</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxBusRetries_MessageCmd_RemoteXcpNoTxConf</srcid><srcstatus/><internalId>571</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxBusRetries_ConnectCmd_RemoteXcpNoTxConf</srcid><srcstatus/><internalId>572</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxBusRetries_BeforeReachingDisconnectTriggerPoint</srcid><srcstatus/><internalId>573</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectPosRes_FromRemoteXcp</srcid><srcstatus/><internalId>574</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectCmd_ToRemoteXcp</srcid><srcstatus/><internalId>576</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_successfullyTransmit_ToRemoteXcp</srcid><srcstatus/><internalId>577</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectSuccedes</srcid><srcstatus/><internalId>578</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_MessageCmd_ToRemoteXcp</srcid><srcstatus/><internalId>581</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_DisconnectPosRes_FromRemoteXcp</srcid><srcstatus/><internalId>582</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_TwoConnectCmds_ToRemoteXcp</srcid><srcstatus/><internalId>584</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_NoAutonomousDisconnect</srcid><srcstatus/><internalId>585</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectPosRes_FromRemoteXcp_PackMaster</srcid><srcstatus/><internalId>586</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectPosRes_FromRemoteXcp_Pack</srcid><srcstatus/><internalId>589</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectPosRes_FromRemoteXcp_PackRemoteSlave</srcid><srcstatus/><internalId>590</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>155</internalId></specobject>

    <specobject>
      <id>XcpR.Impl.ConfigurableLoweyLayer.CddConnections</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If a connection over CDD is configured for a Tx destination, XcpR shall
        allow configurable names for the CDD's name, header file and transmit function.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_2201</srcid><srcstatus/><internalId>360</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_SimulateConnectCMD_PosResponse_Mode_1</srcid><srcstatus/><internalId>492</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SimulateConnectCMD_NegResponse_Mode_1</srcid><srcstatus/><internalId>493</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ChangeMode_SwitchRemoteXcpToLocalXcp</srcid><srcstatus/><internalId>497</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_InternalQueue_DifferentDestinations</srcid><srcstatus/><internalId>501</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SameBusType_SimulateConnectCMD_PosResponse_Mode_1</srcid><srcstatus/><internalId>540</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_CddBusType_ChangeMode_SwitchRemoteXcpToLocalXcp</srcid><srcstatus/><internalId>544</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>156</internalId></specobject>

    <specobject>
      <id>XcpR.Impl.ConfigurableUpperLayer.CddConnections</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If a connection over CDD is configured for a Rx destination, XcpR shall allow
        configurable names for the upper layer module's name, header file and callback functions.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/XcpR.xdm.m4_2537</srcid><srcstatus/><internalId>377</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_CddBusType_SimulateConnectCMD_PosResponse_Mode_0</srcid><srcstatus/><internalId>542</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_CddBusType_SimulateConnectCMD_NegResponse_Mode_0</srcid><srcstatus/><internalId>543</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>157</internalId></specobject>

    <specobject>
      <id>XcpR.Impl.SaveConnectedState</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        XcpR shall change its state to CONNECTED only after receiving a TxConfirmation after
        sending a CONNECT positive response to the master Xcp.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/XcpR_DestinationProcessor.c_2666</srcid><srcstatus/><internalId>252</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_SimulateConnectCMD_PosResponse_Mode_0</srcid><srcstatus/><internalId>495</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_NewCONNECTCmd_LocalXcpSlave</srcid><srcstatus/><internalId>500</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_CddBusType_SimulateConnectCMD_PosResponse_Mode_0</srcid><srcstatus/><internalId>542</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>158</internalId></specobject>

    <specobject>
      <id>XcpR.Impl.ResetRoutingPath</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        XcpR shall reset its state and all its internal routing data after receiving
        a TxConfirmation as a result of notifying the master Xcp of a positive DISCONNECT response.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/XcpR_DestinationProcessor.c_2697</srcid><srcstatus/><internalId>255</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_ChangeMode_SwitchRemoteXcpToLocalXcp</srcid><srcstatus/><internalId>497</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SwitchConections</srcid><srcstatus/><internalId>498</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_RxIndicationFromRx_TwoMessages_FirstDisconnectCmd</srcid><srcstatus/><internalId>535</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>159</internalId></specobject>

    <specobject>
      <id>XcpR.Impl.TxConfirmation.UpperLayer</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If XcpR is connected over CDD to a slave Xcp located on the same ECU, it shall notify
        the local slave Xcp with a TxConfirmation only if the messages are successfully stored
        in the XcpR internal queue.
      </description>
      <furtherinfo>WRN.swuts.needscoverage.count - This requirement is verified in
        different configurations.</furtherinfo>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/XcpR_SourceProcessor.c_619</srcid><srcstatus/><internalId>280</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_SimulateConnectCMD_PosResponse_Mode_0</srcid><srcstatus/><internalId>495</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ChangeMode_SwitchRemoteXcpToLocalXcp</srcid><srcstatus/><internalId>497</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SwitchConections</srcid><srcstatus/><internalId>498</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_LocalXcpSlave_InvalidConnectMode_TransmissionRx</srcid><srcstatus/><internalId>522</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_LocalXcpSlave_InvalidConnectMode</srcid><srcstatus/><internalId>523</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ReceptionFromRx_LocalXcpSlave</srcid><srcstatus/><internalId>534</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_RxIndication_TxConfirmation_LocalXcp</srcid><srcstatus/><internalId>537</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_CddBusType_SimulateConnectCMD_PosResponse_Mode_0</srcid><srcstatus/><internalId>542</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_CddBusType_ChangeMode_SwitchRemoteXcpToLocalXcp</srcid><srcstatus/><internalId>544</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ConnectCmd_PosRes_LocalXcp_TriggerTransmit</srcid><srcstatus/><internalId>560</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ConnectCmd_NegRes_LocalXcp_TriggerTransmit</srcid><srcstatus/><internalId>561</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_LocalXcp_TriggerTransmit_NegRes</srcid><srcstatus/><internalId>562</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SwitchLocalXcpToRemoteXcp_TriggerTransmit</srcid><srcstatus/><internalId>563</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxBusRetries_MasterNoTxConf_LocalXcp</srcid><srcstatus/><internalId>566</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxBusRetries_MasterENotOkTxConf_LocalXcp</srcid><srcstatus/><internalId>567</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectPosRes_FromLocalXcp</srcid><srcstatus/><internalId>575</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_MessagePosRes_FromLocalXcp</srcid><srcstatus/><internalId>579</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_DisconnectPosRes_FromLocalXcp</srcid><srcstatus/><internalId>583</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_MessagePosRes_FromLocalXcp_PackMaster</srcid><srcstatus/><internalId>587</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_NotificationsToULXcp</srcid><srcstatus/><internalId>591</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_NotificationsToULXcp_DifferentPduIds</srcid><srcstatus/><internalId>592</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>160</internalId></specobject>

    <specobject>
      <id>XcpR.Impl.TriggerTransmit.UpperLayer</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If XcpR is connected to a slave Xcp located on the same ECU and TriggerTransmit
        functionality is enabled by the slave Xcp for its connection over CDD with the XcpR,
        then XcpR shall request a TriggerTransmit from the local Xcp slave before storing
        the data in its internal buffer.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/XcpR_SourceProcessor.c_584</srcid><srcstatus/><internalId>277</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_ConnectCmd_PosRes_LocalXcp_TriggerTransmit</srcid><srcstatus/><internalId>560</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SwitchLocalXcpToRemoteXcp_TriggerTransmit</srcid><srcstatus/><internalId>563</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_NotificationsToULXcp</srcid><srcstatus/><internalId>591</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>161</internalId></specobject>

    <specobject>
      <id>XcpR.Impl.DoNotForward.TxConfirmation.LowerLayer</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If XcpR is connected to a slave Xcp located on a remote ECU, it shall not forward
        TxConfirmation notifications from the master Xcp to the remote slave Xcp.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_SimulateConnectCMD_PosResponse_Mode_1</srcid><srcstatus/><internalId>492</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ChangeMode_SwitchRemoteXcpToLocalXcp</srcid><srcstatus/><internalId>497</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SwitchConections</srcid><srcstatus/><internalId>498</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>162</internalId></specobject>

    <specobject>
      <id>XcpR.Impl.DoNotForward.TriggerTransmit.LowerLayer</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If XcpR is connected to a slave Xcp located on a remote ECU and TriggerTransmit
        functionality is enabled for either a FR or a CDD bus-type, it shall not forward
        TriggerTransmit requests from the master Xcp to the remote slave Xcp.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_ConnectCmd_PosRes_RemoteXcp_TriggerTransmit</srcid><srcstatus/><internalId>558</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>163</internalId></specobject>

    <specobject>
      <id>XcpR.Impl.TransmitFromRxIndication</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If XcpR has the "transmission from RxIndication/XcpR_Transmit" functionality enabled,
        XcpR shall process the received message and it shall also transmit the message to the
        configured destination.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/XcpR_SourceProcessor.c_695</srcid><srcstatus/><internalId>281</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_TransmissionRx_MultiplePdusInOneFrame</srcid><srcstatus/><internalId>549</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TransmissionRx_MultiplePdusInOneFrame_Master</srcid><srcstatus/><internalId>550</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TransmissionRx_MultiplePdusInOneFrame_RemoteXcpSlave</srcid><srcstatus/><internalId>551</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TransmissionRx</srcid><srcstatus/><internalId>552</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>164</internalId></specobject>

    <specobject>
      <id>XcpR.Impl.TransmitFromTxConfirmation</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If XcpR has the "transmission from TxConfirmation" functionality enabled, a new transmission
        for this PDU should be triggered, when TxConfirmation is executed for the selected Pdu
        channel, and there are pending messages in the XcpR internal queue waiting for transmission,
        which are supported by the selected PDU channel.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/XcpR_DestinationProcessor.c_2741</srcid><srcstatus/><internalId>257</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_MultiplePdus_TxConf</srcid><srcstatus/><internalId>531</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_RxIndication_TxConfirmation_LocalXcp</srcid><srcstatus/><internalId>537</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_RxIndication_TxConfirmation_RemoteXcp</srcid><srcstatus/><internalId>538</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_RxIndication_TxConfirmation_LinkedPduId</srcid><srcstatus/><internalId>539</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>165</internalId></specobject>

    <specobject>
      <id>XcpR.Impl.ConnectionGroups.Disabled</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If there are no entries in the Connection To Routing Mapping list, the Connection Group functionality shall be disabled.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate/include/XcpR_Int_Cfg.h_36</srcid><srcstatus/><internalId>204</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_SimulateConnectCMD_PosResponse_Mode_1</srcid><srcstatus/><internalId>492</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>166</internalId></specobject>

    <specobject>
      <id>XcpR.Impl.ConnectionGroups.Enabled</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If there is at least one entry in the Connection To Routing Mapping list, the Connection Group functionality shall be enabled.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate/include/XcpR_Int_Cfg.h_37</srcid><srcstatus/><internalId>205</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_ConnectionGroup</srcid><srcstatus/><internalId>478</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_InternalQueue_DifferentDestinations</srcid><srcstatus/><internalId>501</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>167</internalId></specobject>

    <specobject>
      <id>XcpR.Impl.ConnectionGroups.ActiveGroupId</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If the Connection Group functionality is enabled, when the CONNECTED state is saved for the XcpR module, an "active" connection group id shall be saved.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/XcpR_DestinationProcessor.c_2678</srcid><srcstatus/><internalId>253</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>168</internalId></specobject>

     <specobject>
      <id>XcpR.Impl.ConnectionGroups.ActiveGroupInformation</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If the Connection Group functionality is enabled, the "active" connection group shall contain information related to the all Source Pdu IDs and their linked
        Destination entries, which are part of the "active" connection group.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate/src/XcpR_Cfg.c_655</srcid><srcstatus/><internalId>208</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>169</internalId></specobject>

     <specobject>
      <id>XcpR.Impl.ConnectionGroups.ActiveGroupInformationReset</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If the Connection Group functionality is enabled, the information from the "active" connection group shall be reset when XcpR is set into DISCONNECTED state.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/XcpR_DestinationProcessor.c_2727</srcid><srcstatus/><internalId>256</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_ConnectionGroup</srcid><srcstatus/><internalId>478</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>170</internalId></specobject>

     <specobject>
      <id>XcpR.Impl.ConnectionGroups.ActiveGroupNewRxRequest</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If the Connection Group functionality is enabled and XcpR is in STATE CONNECTED, a new XcpR_RxIndication() request shall be accepted only if the Source Pdu Id and its linked destination are part of the currently active connection group.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/XcpR_SourceProcessor.c_341</srcid><srcstatus/><internalId>272</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_ConnectionGroup</srcid><srcstatus/><internalId>478</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>171</internalId></specobject>

    <specobject>
      <id>XcpR.Ethernet.AddressMethod</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The XcpR connected by Ethernet and TCP/IP or UDP/IP is addressed by
        its IP Address and Port number.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_EthUdp_ReconfiguredSocket</srcid><srcstatus/><internalId>512</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_EthUdp_CannotSetRemoteAddress</srcid><srcstatus/><internalId>513</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_EthUdp_CommandDifferentIp</srcid><srcstatus/><internalId>514</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_EthUdp_RespondOnlyToConnectIpAddress</srcid><srcstatus/><internalId>515</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>172</internalId></specobject>

    <specobject>
      <id>XcpR.Ethernet.SoAdAPIs</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        For the XcpR data sent and received via Ethernet, the corresponding PDUs have to be
        transmitted and received using the transmitting and receive APIs provided by the
        AUTOSAR Socket Adaptor according to Specification of Socket Adaptor 'AUTOSAR_SWS_SocketAdaptor'.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_ONLINE_MasterToRemote</srcid><srcstatus/><internalId>502</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_OFFLINE_MasterToRemote</srcid><srcstatus/><internalId>503</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_WrongId_MasterToRemote</srcid><srcstatus/><internalId>504</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_ONLINE_Remote</srcid><srcstatus/><internalId>508</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_OFFLINE_Remote</srcid><srcstatus/><internalId>509</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_WrongId_Remote</srcid><srcstatus/><internalId>510</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>173</internalId></specobject>

    <specobject>
      <id>XcpR.Ethernet.Header.DataLength</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The XcpR has to generate a value for the packet's data length in its header, consisting of 2 bytes,
        for all packets that are being sent.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_ONLINE_MasterToRemote</srcid><srcstatus/><internalId>502</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_OFFLINE_MasterToRemote</srcid><srcstatus/><internalId>503</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_WrongId_MasterToRemote</srcid><srcstatus/><internalId>504</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_ONLINE_Remote</srcid><srcstatus/><internalId>508</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_OFFLINE_Remote</srcid><srcstatus/><internalId>509</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_WrongId_Remote</srcid><srcstatus/><internalId>510</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>174</internalId></specobject>

    <specobject>
      <id>XcpR.Ethernet.Header.Ctr</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The XcpR has to generate a CTR value in its header, after the value for the data length, consisting of 2 bytes, 
        for all packets that are being sent.
        This CTR value shall be increased for each packet.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_ONLINE_MasterToRemote</srcid><srcstatus/><internalId>502</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_OFFLINE_MasterToRemote</srcid><srcstatus/><internalId>503</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_WrongId_MasterToRemote</srcid><srcstatus/><internalId>504</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_ONLINE_Remote</srcid><srcstatus/><internalId>508</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_OFFLINE_Remote</srcid><srcstatus/><internalId>509</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_WrongId_Remote</srcid><srcstatus/><internalId>510</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>175</internalId></specobject>

    <specobject>
      <id>XcpR.Ethernet.Tcp.SoConModeChg.Disconnect</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If the Tcp socket is closed while XcpR is in connected state, the XcpR will perform an autonomous
        disconnect, which means that communication will be stopped.
      </description>
      <comment>
        The XcpR device is the listener. It will only accept one connection at the time.
        This requirement applies to the TCP protocol only and not for UDP.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_OFFLINE_MasterToRemote</srcid><srcstatus/><internalId>503</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_WrongId_MasterToRemote</srcid><srcstatus/><internalId>504</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_OFFLINE_Remote</srcid><srcstatus/><internalId>509</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_WrongId_Remote</srcid><srcstatus/><internalId>510</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>176</internalId></specobject>

    <specobject>
      <id>XcpR.Ethernet.Tcp.Disconnect</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If XcpR cannot get the remote address of the Tcp socket adapter, it  will perform an autonomous
        disconnect, which means that communication will be stopped.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_TcpIp_CannotGetRemoteAddress</srcid><srcstatus/><internalId>507</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>177</internalId></specobject>

    <specobject>
      <id>XcpR.Ethernet.Udp.Disconnect</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If the Udp socket adapter remote address cannot be set, the XcpR will perform an autonomous
        disconnect, which means that communication will be stopped.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_EthUdp_CannotSetRemoteAddress</srcid><srcstatus/><internalId>513</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_CannotGetRemoteAddress</srcid><srcstatus/><internalId>516</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_CONNECTcmd_CannotSetRemoteAddress</srcid><srcstatus/><internalId>517</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>178</internalId></specobject>
    
    <specobject>
      <id>XcpR.Ethernet.Udp.Communication</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        While not connected, for UDP interfaces, the XcpR will answer upon a CONNECT command by sending
        the response to the IP address and port of the sender of the command. It will continue to
        answer to this IP address and port for all subsequent responses.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_EthUdp_RespondOnlyToConnectIpAddress</srcid><srcstatus/><internalId>515</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>179</internalId></specobject>

    <specobject>
      <id>XcpR.Ethernet.Udp.DifferentPort</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        When connected, for UDP interfaces, XcpR will respond only to messages from the IP address which has sent the
        CONNECT command even if another port is used.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_EthUdp_RespondOnlyToConnectIpAddress</srcid><srcstatus/><internalId>515</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>180</internalId></specobject>

    <specobject>
      <id>XcpR.Ethernet.Udp.DifferentIp</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        When connected, for UDP interfaces, XcpR will not respond to command packets received from an IP different 
        than the one from which the connection originated (via command CONNECT).
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_EthUdp_CommandDifferentIp</srcid><srcstatus/><internalId>514</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>181</internalId></specobject>

    <specobject>
      <id>XcpR.Ethernet.Tcp.DifferentPort</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        When connected, for TCP interfaces, XcpR will not respond to command packets received using a port different 
        than the one from which the connection originated (via command CONNECT).
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_TcpIp_CannotGetRemoteAddress</srcid><srcstatus/><internalId>507</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>182</internalId></specobject>

    <specobject>
      <id>XcpR.Ethernet.Tcp.DifferentIp</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        When connected, for TCP interfaces, XcpR will not respond to command packets received from an IP different 
        than the one from which the connection originated (via command CONNECT).
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_TcpIp_CannotGetRemoteAddress</srcid><srcstatus/><internalId>507</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>183</internalId></specobject>

  <!--
    +++++++++++++++++++++++++++++++++++++++++
    Manual requirements
    +++++++++++++++++++++++++++++++++++++++++
  -->

    <specobject>
      <id>XcpR.Impl.RxIndication.InterruptContext</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The XcpR_RxIndication() function shall be safe to be called in an interrupt
        context.
      </description>
      <needscoverage>
        <needscov><needsobj>man</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>XcpR_Rev_RxIndication_Interrupt</srcid><srcstatus/><internalId>198</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>184</internalId></specobject>

    <specobject>
      <id>XcpR.Impl.TriggerTransmit.InterruptContext</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The XcpR_TriggerTransmit() function shall be safe to be called in an interrupt
        context.
      </description>
      <needscoverage>
        <needscov><needsobj>man</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>XcpR_Rev_TriggerTransmit_Interrupt</srcid><srcstatus/><internalId>199</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>185</internalId></specobject>

    <specobject>
      <id>XcpR.Impl.TxConfirmation.InterruptContext</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The XcpR_TxConfirmation() function shall be safe to be called in an interrupt
        context.
      </description>
      <needscoverage>
        <needscov><needsobj>man</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>XcpR_Rev_TxConfirmation_Interrupt</srcid><srcstatus/><internalId>200</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>186</internalId></specobject>

    <specobject>
      <id>XcpR.Impl.MemoryMappingSections</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Code, test code, variables and constants shall be mapped to their corresponding memory section
        by means of memory mapping mechanisms.
      </description>
      <needscoverage>
        <needscov><needsobj>man</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>XcpR_Rev_MemMap</srcid><srcstatus/><internalId>201</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>187</internalId></specobject>

  <!--
    +++++++++++++++++++++++++++++++++++++++++
    Requirements linked in Design
    +++++++++++++++++++++++++++++++++++++++++
  -->

    <specobject>
      <id>XcpR.Impl.DevelopmentErrorValues</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        Development error values are of type uint8.
        Type or error                              |  Relevance      |   Related error code                |   Value [hex]
      ---------------------------------------------------------------------------------------------------------
      Null pointer has been passed as an argument  |  Development    | XCPR_E_NULL_POINTER                 |     0x02
      </description>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>XcpR.dsn.GetVersionInfo.API.DetOn.ErrorCodeNullPointer</srcid><srcstatus/><internalId>412</internalId></linkedfrom><linkedfrom><srcid>XcpR.dsn.RxIndication.API.DetOn.ErrorCodeNullPointer</srcid><srcstatus/><internalId>445</internalId></linkedfrom><linkedfrom><srcid>XcpR.dsn.Transmit.API.DetOn.ErrorCodeNullPointer</srcid><srcstatus/><internalId>459</internalId></linkedfrom><linkedfrom><srcid>XcpR.dsn.TriggerTransmit.API.DetOn.ErrorCodeNullPointer</srcid><srcstatus/><internalId>463</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>188</internalId></specobject>

    <specobject>
      <id>XcpR.Impl.RuntimeErrorValues</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Runtime error values are of type uint8.
        Type or error                                      |  Relevance      |   Related error code                |   Value [hex]
      ----------------------------------------------------------------------------------------------------------------------------
      Module not initialized as an argument                |  Runtime        | XCPR_E_NOT_INITIALIZED              |     0x01
      API call with wrong PDU ID                           |  Runtime        | XCPR_E_INVALID_PDUID                |     0x10
      Message does not fit in available length             |  Runtime        | XCPR_E_INVALID_LENGTH               |     0x11
      API call with wrong Rx PDU ID length                 |  Runtime        | XCPR_E_INVALID_RX_PDU_LENGTH        |     0x12
      API call with wrong Tx PDU ID length                 |  Runtime        | XCPR_E_INVALID_TX_PDU_LENGTH        |     0x13
      There is no linked Rx or Tx dest                     |  Runtime        | XCPR_E_INVALID_CONNECT_MODE         |     0x14
      for the connect mode 0 or 1.                         |                 |                                     |
      Received PID is not CONNECT                          |  Runtime        | XCPR_E_PDU_LOST                     |     0x20
      Unexpected message when XcpR is disconnected         |  Runtime        | XCPR_E_UNEXPECTED_MSG               |     0x21
      Attempt to write more data than                      |  Runtime        | XCPR_E_INTERNAL_BUFFER_OVERFLOW     |     0x22
      available in the XcpR buffer                         |                 |                                     |
      Transmission on the internal bus cannot be done      |  Runtime        | XCPR_E_INTERNAL_BUS                 |     0x23
      Transmission on the external bus cannot be done      |  Runtime        | XCPR_E_EXTERNAL_BUS                 |     0x24
      TxConfirmation from remote Xcp is not received       |  Runtime        | XCPR_E_NO_TX_INTERNAL_BUS           |     0x25
      TxConfirmation from master Xcp is not received       |  Runtime        | XCPR_E_NO_TX_EXTERNAL_BUS           |     0x26
      The receive Pdu buffer is full                       |  Runtime        | XCPR_E_PDU_BUFFER_FULL              |     0x27
      Data length is bigger than MaxCto/                   |                 |                                     |
      MaxDto/MaxCtoPgm of all sources                      |  Runtime        | XCPR_E_INVALID_MESSAGE_LENGTH       |     0x28
      Pdu is not part of the active                        |                 |                                     |
      Connection group                                     |  Runtime        | XCPR_E_PDU_OUTSIDE_CONNECTION_GROUP |     0x29
      </description>
      <furtherinfo>WRN.swdd.needscoverage.count - The details regarding every error that can be reported by XcpR are
        provided in other atomic requirements which fullfill this requirement.</furtherinfo>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>XcpR.dsn.BusMonitor.DetOn.ErrorCodeNoTxExternalBus</srcid><srcstatus/><internalId>399</internalId></linkedfrom><linkedfrom><srcid>XcpR.dsn.BusMonitor.DetOn.ErrorCodeNoTxInternalBus</srcid><srcstatus/><internalId>400</internalId></linkedfrom><linkedfrom><srcid>XcpR.dsn.DisconnectedState.DetOn.ErrorCodePduLost</srcid><srcstatus/><internalId>408</internalId></linkedfrom><linkedfrom><srcid>XcpR.dsn.DisconnectedState.DetOn.ErrorCodeUnexpectedMessage</srcid><srcstatus/><internalId>409</internalId></linkedfrom><linkedfrom><srcid>XcpR.dsn.InternalQueue.DetOn.ErrorCodeOverflow</srcid><srcstatus/><internalId>413</internalId></linkedfrom><linkedfrom><srcid>XcpR.dsn.InvalidConnectMode.DetOn.ErrorCodeInvalidConnectMode</srcid><srcstatus/><internalId>418</internalId></linkedfrom><linkedfrom><srcid>XcpR.dsn.LocalConnectMode.DetOn.ErrorCodeInvalidConnectMode</srcid><srcstatus/><internalId>419</internalId></linkedfrom><linkedfrom><srcid>XcpR.dsn.NegativeResponseConnect.DetOn.ErrorCodePduLost</srcid><srcstatus/><internalId>420</internalId></linkedfrom><linkedfrom><srcid>XcpR.dsn.NegativeResponseDisconnect.DetOn.ErrorCodePduLost</srcid><srcstatus/><internalId>421</internalId></linkedfrom><linkedfrom><srcid>XcpR.dsn.PackMessage.DetOn.ErrorCodeInvalidLength</srcid><srcstatus/><internalId>422</internalId></linkedfrom><linkedfrom><srcid>XcpR.dsn.ProcessSource.API.DetOn.ErrorCodeInvalidMessageLength</srcid><srcstatus/><internalId>424</internalId></linkedfrom><linkedfrom><srcid>XcpR.dsn.RemoteConnectMode.DetOn.ErrorCodeInvalidConnectMode</srcid><srcstatus/><internalId>439</internalId></linkedfrom><linkedfrom><srcid>XcpR.dsn.RxIndication.API.DetOn.ErrorCodeInvalidActiveDestination</srcid><srcstatus/><internalId>440</internalId></linkedfrom><linkedfrom><srcid>XcpR.dsn.RxIndication.API.DetOn.ErrorCodeInvalidMessageHeaderLength</srcid><srcstatus/><internalId>441</internalId></linkedfrom><linkedfrom><srcid>XcpR.dsn.RxIndication.API.DetOn.ErrorCodeInvalidPduID</srcid><srcstatus/><internalId>442</internalId></linkedfrom><linkedfrom><srcid>XcpR.dsn.RxIndication.API.DetOn.ErrorCodeInvalidRxLength</srcid><srcstatus/><internalId>443</internalId></linkedfrom><linkedfrom><srcid>XcpR.dsn.RxIndication.API.DetOn.ErrorCodeNotInitialized</srcid><srcstatus/><internalId>444</internalId></linkedfrom><linkedfrom><srcid>XcpR.dsn.RxIndication.API.DetOn.ErrorCodePduOutsideConnectionGroup</srcid><srcstatus/><internalId>446</internalId></linkedfrom><linkedfrom><srcid>XcpR.dsn.RxIndication.API.DetOn.ErrorCodeZeroRxLength</srcid><srcstatus/><internalId>447</internalId></linkedfrom><linkedfrom><srcid>XcpR.dsn.RxIndication.DetOn.PduBufferFull</srcid><srcstatus/><internalId>448</internalId></linkedfrom><linkedfrom><srcid>XcpR.dsn.SoAdSoConModeChg.API.DetOn.ErrorCodeNotInitialized</srcid><srcstatus/><internalId>450</internalId></linkedfrom><linkedfrom><srcid>XcpR.dsn.TcpConnected.DiffAddr.DetOn.ErrorCodePduLost</srcid><srcstatus/><internalId>451</internalId></linkedfrom><linkedfrom><srcid>XcpR.dsn.TcpConnected.DiffPort.DetOn.ErrorCodePduLost</srcid><srcstatus/><internalId>452</internalId></linkedfrom><linkedfrom><srcid>XcpR.dsn.Transmission.DetOn.ErrorCodeExternalBus</srcid><srcstatus/><internalId>453</internalId></linkedfrom><linkedfrom><srcid>XcpR.dsn.Transmission.DetOn.ErrorCodeInternalBus</srcid><srcstatus/><internalId>454</internalId></linkedfrom><linkedfrom><srcid>XcpR.dsn.Transmit.API.DetOn.ErrorCodeInvalidActiveDestination</srcid><srcstatus/><internalId>456</internalId></linkedfrom><linkedfrom><srcid>XcpR.dsn.Transmit.API.DetOn.ErrorCodeInvalidPduID</srcid><srcstatus/><internalId>457</internalId></linkedfrom><linkedfrom><srcid>XcpR.dsn.Transmit.API.DetOn.ErrorCodeNotInitialized</srcid><srcstatus/><internalId>458</internalId></linkedfrom><linkedfrom><srcid>XcpR.dsn.Transmit.API.DetOn.ErrorCodeZeroTxLength</srcid><srcstatus/><internalId>460</internalId></linkedfrom><linkedfrom><srcid>XcpR.dsn.TriggerTransmit.API.DetOn.ErrorCodeInvalidPduID</srcid><srcstatus/><internalId>461</internalId></linkedfrom><linkedfrom><srcid>XcpR.dsn.TriggerTransmit.API.DetOn.ErrorCodeNotInitialized</srcid><srcstatus/><internalId>462</internalId></linkedfrom><linkedfrom><srcid>XcpR.dsn.TxConfirmation.API.DetOn.ErrorCodeInvalidPduID</srcid><srcstatus/><internalId>465</internalId></linkedfrom><linkedfrom><srcid>XcpR.dsn.TxConfirmation.API.DetOn.ErrorCodeNotInitialized</srcid><srcstatus/><internalId>466</internalId></linkedfrom><linkedfrom><srcid>XcpR.dsn.UdpConnected.DiffAddr.DetOn.ErrorCodePduLost</srcid><srcstatus/><internalId>473</internalId></linkedfrom><linkedfrom><srcid>XcpR.dsn.XcpRTransmit.API.DetOn.ErrorCodeInvalidTxLength</srcid><srcstatus/><internalId>474</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>189</internalId></specobject>

    <specobject>
      <id>XcpR.Impl.ReceptionMultipleFlexRayMessagesInOneFrame</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        XcpR shall support reception of a FlexRay frame with multiple messages
        from a configured XcpR source over FlexRay.
      </description>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>XcpR.dsn.ReceptionPackedFrame.AbortUnpacking</srcid><srcstatus/><internalId>433</internalId></linkedfrom><linkedfrom><srcid>XcpR.dsn.ReceptionPackedFrame.CheckTxConfirmation</srcid><srcstatus/><internalId>434</internalId></linkedfrom><linkedfrom><srcid>XcpR.dsn.ReceptionPackedFrame.SendMessageIndependently</srcid><srcstatus/><internalId>435</internalId></linkedfrom><linkedfrom><srcid>XcpR.dsn.ReceptionPackedFrame.StoreMessageInternally</srcid><srcstatus/><internalId>436</internalId></linkedfrom><linkedfrom><srcid>XcpR.dsn.ReceptionPackedFrame.TransmissionPackedFrame.AddHeaderInfo</srcid><srcstatus/><internalId>437</internalId></linkedfrom><linkedfrom><srcid>XcpR.dsn.ReceptionPackedFrame.TransmissionPackedFrame.PackAtLeastOneMsg</srcid><srcstatus/><internalId>438</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>190</internalId></specobject>

    <specobject>
      <id>XcpR.Impl.ReceptionMultipleEthernetMessagesInOneFrame</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        XcpR shall support reception of an Ethernet frame with multiple messages
        from a configured XcpR source over Ethernet.
      </description>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>XcpR.dsn.ReceptionPackedFrame.AbortUnpacking</srcid><srcstatus/><internalId>433</internalId></linkedfrom><linkedfrom><srcid>XcpR.dsn.ReceptionPackedFrame.CheckTxConfirmation</srcid><srcstatus/><internalId>434</internalId></linkedfrom><linkedfrom><srcid>XcpR.dsn.ReceptionPackedFrame.SendMessageIndependently</srcid><srcstatus/><internalId>435</internalId></linkedfrom><linkedfrom><srcid>XcpR.dsn.ReceptionPackedFrame.StoreMessageInternally</srcid><srcstatus/><internalId>436</internalId></linkedfrom><linkedfrom><srcid>XcpR.dsn.ReceptionPackedFrame.TransmissionPackedFrame.AddHeaderInfo</srcid><srcstatus/><internalId>437</internalId></linkedfrom><linkedfrom><srcid>XcpR.dsn.ReceptionPackedFrame.TransmissionPackedFrame.PackAtLeastOneMsg</srcid><srcstatus/><internalId>438</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>191</internalId></specobject>

    <specobject>
      <id>XcpR.Impl.TransmissionMultipleFlexRayMessagesInOneFrame</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        XcpR shall support transmission of a FlexRay frame with multiple messages
        to a configured XcpR destination over FlexRay.
      </description>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>XcpR.dsn.ReceptionFromRxIndication.TransmissionPackedFrame.PackMsgIntoFrame</srcid><srcstatus/><internalId>432</internalId></linkedfrom><linkedfrom><srcid>XcpR.dsn.ReceptionPackedFrame.TransmissionPackedFrame.AddHeaderInfo</srcid><srcstatus/><internalId>437</internalId></linkedfrom><linkedfrom><srcid>XcpR.dsn.ReceptionPackedFrame.TransmissionPackedFrame.PackAtLeastOneMsg</srcid><srcstatus/><internalId>438</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>192</internalId></specobject>

    <specobject>
      <id>XcpR.Impl.TransmissionMultipleEthernetMessagesInOneFrame</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        XcpR shall support transmission of an Ethernet frame with multiple messages
        to a configured XcpR destination over Ethernet.
      </description>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>XcpR.dsn.ReceptionFromRxIndication.TransmissionPackedFrame.PackMsgIntoFrame</srcid><srcstatus/><internalId>432</internalId></linkedfrom><linkedfrom><srcid>XcpR.dsn.ReceptionPackedFrame.TransmissionPackedFrame.AddHeaderInfo</srcid><srcstatus/><internalId>437</internalId></linkedfrom><linkedfrom><srcid>XcpR.dsn.ReceptionPackedFrame.TransmissionPackedFrame.PackAtLeastOneMsg</srcid><srcstatus/><internalId>438</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>193</internalId></specobject>

    <specobject>
      <id>XcpR.Impl.ReceptionFromRxIndication</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        XcpR shall support the reception from RxIndication/XcpR_Transmit functionality.
      </description>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>XcpR.dsn.ReceptionFromRxIndication.DiscardMessage</srcid><srcstatus/><internalId>429</internalId></linkedfrom><linkedfrom><srcid>XcpR.dsn.ReceptionFromRxIndication.SendIndependentMessage</srcid><srcstatus/><internalId>430</internalId></linkedfrom><linkedfrom><srcid>XcpR.dsn.ReceptionFromRxIndication.StoreMessageInternally</srcid><srcstatus/><internalId>431</internalId></linkedfrom><linkedfrom><srcid>XcpR.dsn.ReceptionFromRxIndication.TransmissionPackedFrame.PackMsgIntoFrame</srcid><srcstatus/><internalId>432</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>194</internalId></specobject>

    <specobject>
      <id>XcpR.Impl.BusMonitor.Functionality</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        XcpR shall support the bus monitor functionality.
      </description>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>XcpR.dsn.BusMonitor.DisconnectAfterFailedRetries</srcid><srcstatus/><internalId>401</internalId></linkedfrom><linkedfrom><srcid>XcpR.dsn.BusMonitor.RetryTransmisionWithoutAutonDisconnect</srcid><srcstatus/><internalId>402</internalId></linkedfrom><linkedfrom><srcid>XcpR.dsn.BusMonitor.RetryTransmission</srcid><srcstatus/><internalId>403</internalId></linkedfrom><linkedfrom><srcid>XcpR.dsn.BusMonitor.RuntimeError.DisconnectAfterFailedRetries</srcid><srcstatus/><internalId>404</internalId></linkedfrom><linkedfrom><srcid>XcpR.dsn.BusMonitor.SendSessionTerminatedEvent</srcid><srcstatus/><internalId>405</internalId></linkedfrom><linkedfrom><srcid>XcpR.dsn.BusMonitor.TriggerAutonomousDisconnect</srcid><srcstatus/><internalId>406</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>195</internalId></specobject>

    <specobject>
      <id>XcpR.Impl.TxRetry.Functionality</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        XcpR shall support the retry transmission functionality.
      </description>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>XcpR.dsn.TxRetry.DiscardMessage</srcid><srcstatus/><internalId>467</internalId></linkedfrom><linkedfrom><srcid>XcpR.dsn.TxRetry.RuntimeError.MasterToSlave</srcid><srcstatus/><internalId>468</internalId></linkedfrom><linkedfrom><srcid>XcpR.dsn.TxRetry.RuntimeError.SlaveToMaster</srcid><srcstatus/><internalId>469</internalId></linkedfrom><linkedfrom><srcid>XcpR.dsn.TxRetry.SlaveToMaster.DisconnectXcpR</srcid><srcstatus/><internalId>470</internalId></linkedfrom><linkedfrom><srcid>XcpR.dsn.TxRetry.SlaveToMaster.TriggerAutonomousDisconnect</srcid><srcstatus/><internalId>471</internalId></linkedfrom><linkedfrom><srcid>XcpR.dsn.TxRetry.TriggerAutonomousDisconnect</srcid><srcstatus/><internalId>472</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>196</internalId></specobject>

    <specobject>
      <id>XcpR.Impl.TxConfirmation.E_NOT_OK</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        XcpR shall ignore Tx confirmations with status E_NOT_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/XcpR.c_429</srcid><srcstatus/><internalId>220</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_TxBusRetries_MasterENotOkTxConf_LocalXcp</srcid><srcstatus/><internalId>567</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxBusRetries_MasterENotOkTxConf_RemoteXcp</srcid><srcstatus/><internalId>569</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>197</internalId></specobject>

  </specobjects>
    <specobjects doctype="man">
    <specobject>
      <id>XcpR_Rev_RxIndication_Interrupt</id>
      <status>approved</status>
      <version>1</version>
      <description>This review verifies the XcpR_RxIndication() function
        being safe to be called in interrupt context.</description>
      <furtherinfo>This review shall be carried out for each external release.</furtherinfo>
      <verifycrit>
        1. The function shall not call any Os functions other than those that are explicitly
        allowed to be called in category 1 interrupt context (i.e., DisableAllInterrupts(),
        EnableAllInterrupts(), SuspendAllInterrupts(), ResumeAllInterrupts(), SuspendOSInterrupts(),
        and ResumeOSInterrupts()).
        2. The function shall not call any other function that is not itself defined to be callable
        in interrupt context.
        3. The static and global variables that are shared by this function with other functions
        must be accessed in each function either within critical sections or
        by atomic read-modify-write instructions or, otherwise, be protected by documented 
        concurrency rules.
      </verifycrit>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.RxIndication.InterruptContext</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>184</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>198</internalId></specobject>

    <specobject>
      <id>XcpR_Rev_TriggerTransmit_Interrupt</id>
      <status>approved</status>
      <version>1</version>
      <description>This review verifies the XcpR_TriggerTransmit() function
        being safe to be called in interrupt context.</description>
      <furtherinfo>This review shall be carried out for each external release.</furtherinfo>
      <verifycrit>
        1. The function shall not call any Os functions other than those that are explicitly
        allowed to be called in category 1 interrupt context (i.e., DisableAllInterrupts(),
        EnableAllInterrupts(), SuspendAllInterrupts(), ResumeAllInterrupts(), SuspendOSInterrupts(),
        and ResumeOSInterrupts()) (see BSWM_C_057).
        2. The function shall not call any other function that is not itself defined to be callable
        in interrupt context (see BSWM_C_057).
        3. The static and global variables that are shared by this function with other functions
        must be accessed in each function either within critical sections or
        by atomic read-modify-write instructions or, otherwise, be protected by documented 
        concurrency rules.
      </verifycrit>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.TriggerTransmit.InterruptContext</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>185</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>199</internalId></specobject>

    <specobject>
      <id>XcpR_Rev_TxConfirmation_Interrupt</id>
      <status>approved</status>
      <version>1</version>
      <description>This review verifies the XcpR_TxConfirmation() function
        being safe to be called in interrupt context.</description>
      <furtherinfo>This review shall be carried out for each external release.</furtherinfo>
      <verifycrit>
        1. The function shall not call any Os functions other than those that are explicitly
        allowed to be called in category 1 interrupt context (i.e., DisableAllInterrupts(),
        EnableAllInterrupts(), SuspendAllInterrupts(), ResumeAllInterrupts(), SuspendOSInterrupts(),
        and ResumeOSInterrupts()) (see BSWM_C_057).
        2. The function shall not call any other function that is not itself defined to be callable
        in interrupt context (see BSWM_C_057).
        3. The static and global variables that are shared by this function with other functions
        must be accessed in each function either within critical sections or
        by atomic read-modify-write instructions or, otherwise, be protected by documented 
        concurrency rules.
      </verifycrit>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.TxConfirmation.InterruptContext</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>186</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>200</internalId></specobject>

    <specobject>
      <id>XcpR_Rev_MemMap</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>This review verifies that XcpR applies the memory mapping abstraction mechanisms
      correctly.</description>
      <furtherinfo>This review shall be carried out for each external release.</furtherinfo>
      <verifycrit>
        Check the C code.
      </verifycrit>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.MemoryMappingSections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>187</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>201</internalId></specobject>

    <specobject>
      <id>TS_XcpR_ResourceConsumption</id>
      <status>approved</status>
      <source>EB manual test</source>
      <version>1</version>
      <description>
        01: Get RAM/ROM consumption of the reference tests
        02 VP(XcpR.EB.Dsn.ROMConsumption_RefCfg1): Check the ROM consumption of
           the test run against the threshold specified in the requirement.
        03 VP(XcpR.EB.Dsn.RAMConsumption_RefCfg1): Check the RAM consumption of
           the test run against the threshold specified in the requirement.
        Action if test any verification point is not fulfilled:
        If the consumption exceeds the threshold, an analysis shall be started to find the cause
        of the additional resource consumption.
        The result of the analysis shall trigger either:
        * an update of the resource view in the design and the existing threshold if there is a
          rationale for the additional resource consumption.
        OR
        * measurements to reduce the additional resource consumption below the existing threshold
          if there is no rationale for the additional resource consumption.
      </description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.EB.Dsn.ROMConsumption_RefCfg1</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>397</internalId></provcov>
        <provcov>
          <linksto>XcpR.EB.Dsn.RAMConsumption_RefCfg1</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>398</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>202</internalId></specobject>
  </specobjects>
    <specobjects doctype="dev">
    <specobject>
      <id>dev.XcpRGenerateA2L</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>19</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.GenerateA2L</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>130</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>203</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/generate/include/XcpR_Int_Cfg.h_36</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/generate/include/XcpR_Int_Cfg.h</sourcefile>
      <sourceline>36</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.ConnectionGroups.Disabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>166</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>204</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate/include/XcpR_Int_Cfg.h_37</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/generate/include/XcpR_Int_Cfg.h</sourcefile>
      <sourceline>37</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.ConnectionGroups.Enabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>167</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>205</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/generate/src/XcpR_Cfg.c_408</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/generate/src/XcpR_Cfg.c</sourcefile>
      <sourceline>408</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.UpperLayerTxConfirmationPduId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>152</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>206</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate/src/XcpR_Cfg.c_584</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/generate/src/XcpR_Cfg.c</sourcefile>
      <sourceline>584</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.UpperLayerRxIndicationPduId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>151</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>207</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate/src/XcpR_Cfg.c_655</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/generate/src/XcpR_Cfg.c</sourcefile>
      <sourceline>655</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.ConnectionGroups.ActiveGroupInformation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>169</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>208</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/include/XcpR.h_322</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/include/XcpR.h</sourcefile>
      <sourceline>322</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.API.GetVersionInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>119</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>209</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/include/XcpR_Cbk.h_32</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/include/XcpR_Cbk.h</sourcefile>
      <sourceline>32</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.API.RxIndication</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>116</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>210</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/XcpR_Cbk.h_48</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/include/XcpR_Cbk.h</sourcefile>
      <sourceline>48</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.API.TxConfirmation</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>117</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>211</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/XcpR_Cbk.h_69</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/include/XcpR_Cbk.h</sourcefile>
      <sourceline>69</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.API.TriggerTransmit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>118</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>212</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/include/XcpR_Int.h.m4_13</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/include/XcpR_Int.h.m4</sourcefile>
      <sourceline>13</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.dsn.DetInclusion</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>407</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>213</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/src/XcpR.c_127</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR.c</sourcefile>
      <sourceline>127</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.API.GetVersionInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>119</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>214</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/XcpR.c_153</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR.c</sourcefile>
      <sourceline>153</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.API.Init</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>113</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>215</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/XcpR.c_218</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR.c</sourcefile>
      <sourceline>218</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.API.MainFunction</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>115</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>216</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/XcpR.c_252</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR.c</sourcefile>
      <sourceline>252</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.API.RxIndication</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>116</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>217</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/XcpR.c_333</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR.c</sourcefile>
      <sourceline>333</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.API.Transmit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>114</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>218</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/XcpR.c_406</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR.c</sourcefile>
      <sourceline>406</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.API.TxConfirmation</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>117</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>219</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/XcpR.c_429</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR.c</sourcefile>
      <sourceline>429</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.TxConfirmation.E_NOT_OK</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>197</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>220</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/XcpR.c_440</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR.c</sourcefile>
      <sourceline>440</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.API.TriggerTransmit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>118</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>221</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/src/XcpR_DestinationProcessor.c_25</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR_DestinationProcessor.c</sourcefile>
      <sourceline>25</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.dsn.SchMInclusion</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>449</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>222</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/XcpR_DestinationProcessor.c_672</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR_DestinationProcessor.c</sourcefile>
      <sourceline>672</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.dsn.ExclusiveArea_GlobalData</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>410</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>223</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/XcpR_DestinationProcessor.c_762</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR_DestinationProcessor.c</sourcefile>
      <sourceline>762</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.dsn.ExclusiveArea_GlobalData</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>410</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>224</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/XcpR_DestinationProcessor.c_789</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR_DestinationProcessor.c</sourcefile>
      <sourceline>789</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.dsn.TransmissionOngoing.QueuedMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>455</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>225</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/XcpR_DestinationProcessor.c_1086</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR_DestinationProcessor.c</sourcefile>
      <sourceline>1086</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>153</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>226</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/XcpR_DestinationProcessor.c_1277</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR_DestinationProcessor.c</sourcefile>
      <sourceline>1277</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.Communication.FlexRay.DecoupledAccess</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>138</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>227</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/XcpR_DestinationProcessor.c_1278</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR_DestinationProcessor.c</sourcefile>
      <sourceline>1278</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.Communication.CDD.DecoupledAccess</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>140</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>228</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/XcpR_DestinationProcessor.c_1285</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR_DestinationProcessor.c</sourcefile>
      <sourceline>1285</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.Communication.FlexRay.ImmediateAccess</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>137</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>229</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/XcpR_DestinationProcessor.c_1286</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR_DestinationProcessor.c</sourcefile>
      <sourceline>1286</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.Communication.CDD.ImmediateAccess</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>139</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>230</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/XcpR_DestinationProcessor.c_1366</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR_DestinationProcessor.c</sourcefile>
      <sourceline>1366</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.dsn.InternalState.PreviousCommandConnect</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>414</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>231</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/XcpR_DestinationProcessor.c_1499</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR_DestinationProcessor.c</sourcefile>
      <sourceline>1499</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.ActiveRoutingPath</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>154</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>232</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/XcpR_DestinationProcessor.c_1686</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR_DestinationProcessor.c</sourcefile>
      <sourceline>1686</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.ConcatMessagesFlexRayPackMultipleMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>233</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/XcpR_DestinationProcessor.c_1687</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR_DestinationProcessor.c</sourcefile>
      <sourceline>1687</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.ConcatMessagesEthernetPackMultipleMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>129</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>234</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/XcpR_DestinationProcessor.c_1718</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR_DestinationProcessor.c</sourcefile>
      <sourceline>1718</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.AdaptBusInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>147</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>235</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/XcpR_DestinationProcessor.c_1869</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR_DestinationProcessor.c</sourcefile>
      <sourceline>1869</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.AdaptBusInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>147</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>236</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/XcpR_DestinationProcessor.c_1902</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR_DestinationProcessor.c</sourcefile>
      <sourceline>1902</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.AdaptBusInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>147</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>237</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/XcpR_DestinationProcessor.c_1913</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR_DestinationProcessor.c</sourcefile>
      <sourceline>1913</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.AdaptBusInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>147</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>238</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/XcpR_DestinationProcessor.c_1935</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR_DestinationProcessor.c</sourcefile>
      <sourceline>1935</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.AdaptBusInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>147</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>239</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/XcpR_DestinationProcessor.c_2416</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR_DestinationProcessor.c</sourcefile>
      <sourceline>2416</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.dsn.InternalState.PreviousCommandConnect</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>414</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>240</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/XcpR_DestinationProcessor.c_2425</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR_DestinationProcessor.c</sourcefile>
      <sourceline>2425</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.dsn.InternalState.WaitingConnectConfirmation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>417</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>241</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/XcpR_DestinationProcessor.c_2451</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR_DestinationProcessor.c</sourcefile>
      <sourceline>2451</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.dsn.ExclusiveArea_GlobalData</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>410</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>242</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/XcpR_DestinationProcessor.c_2467</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR_DestinationProcessor.c</sourcefile>
      <sourceline>2467</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.dsn.ExclusiveArea_GlobalData</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>410</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>243</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/XcpR_DestinationProcessor.c_2476</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR_DestinationProcessor.c</sourcefile>
      <sourceline>2476</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>244</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/XcpR_DestinationProcessor.c_2509</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR_DestinationProcessor.c</sourcefile>
      <sourceline>2509</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.dsn.TxRetry.DiscardMessage</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>467</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>245</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/XcpR_DestinationProcessor.c_2553</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR_DestinationProcessor.c</sourcefile>
      <sourceline>2553</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.dsn.TxRetry.RuntimeError.MasterToSlave</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>468</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>246</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/XcpR_DestinationProcessor.c_2561</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR_DestinationProcessor.c</sourcefile>
      <sourceline>2561</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.dsn.TxRetry.RuntimeError.SlaveToMaster</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>469</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>247</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/XcpR_DestinationProcessor.c_2574</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR_DestinationProcessor.c</sourcefile>
      <sourceline>2574</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.dsn.TxRetry.SlaveToMaster.DisconnectXcpR</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>470</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>248</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/XcpR_DestinationProcessor.c_2597</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR_DestinationProcessor.c</sourcefile>
      <sourceline>2597</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.dsn.TxRetry.TriggerAutonomousDisconnect</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>472</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>249</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/XcpR_DestinationProcessor.c_2604</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR_DestinationProcessor.c</sourcefile>
      <sourceline>2604</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.dsn.BusMonitor.SendSessionTerminatedEvent</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>405</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>250</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/XcpR_DestinationProcessor.c_2637</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR_DestinationProcessor.c</sourcefile>
      <sourceline>2637</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.dsn.ExclusiveArea_GlobalData</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>410</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>251</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/XcpR_DestinationProcessor.c_2666</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR_DestinationProcessor.c</sourcefile>
      <sourceline>2666</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.SaveConnectedState</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>158</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>252</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/XcpR_DestinationProcessor.c_2678</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR_DestinationProcessor.c</sourcefile>
      <sourceline>2678</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.ConnectionGroups.ActiveGroupId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>168</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>253</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/XcpR_DestinationProcessor.c_2692</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR_DestinationProcessor.c</sourcefile>
      <sourceline>2692</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.dsn.ExclusiveArea_GlobalData</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>410</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>254</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/XcpR_DestinationProcessor.c_2697</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR_DestinationProcessor.c</sourcefile>
      <sourceline>2697</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.ResetRoutingPath</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>159</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>255</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/XcpR_DestinationProcessor.c_2727</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR_DestinationProcessor.c</sourcefile>
      <sourceline>2727</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.ConnectionGroups.ActiveGroupInformationReset</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>170</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>256</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/XcpR_DestinationProcessor.c_2741</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR_DestinationProcessor.c</sourcefile>
      <sourceline>2741</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.TransmitFromTxConfirmation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>165</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>257</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/XcpR_DestinationProcessor.c_2872</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR_DestinationProcessor.c</sourcefile>
      <sourceline>2872</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.dsn.BusMonitor.SendSessionTerminatedEvent</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>405</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>258</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/XcpR_DestinationProcessor.c_2913</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR_DestinationProcessor.c</sourcefile>
      <sourceline>2913</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.dsn.TxRetry.SlaveToMaster.TriggerAutonomousDisconnect</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>471</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>259</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/XcpR_DestinationProcessor.c_2916</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR_DestinationProcessor.c</sourcefile>
      <sourceline>2916</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.dsn.ExclusiveArea_GlobalData</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>410</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>260</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/XcpR_DestinationProcessor.c_2957</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR_DestinationProcessor.c</sourcefile>
      <sourceline>2957</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.dsn.ExclusiveArea_GlobalData</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>410</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>261</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/XcpR_DestinationProcessor.c_3063</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR_DestinationProcessor.c</sourcefile>
      <sourceline>3063</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.dsn.BusMonitor.RetryTransmission</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>403</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>262</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/XcpR_DestinationProcessor.c_3071</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR_DestinationProcessor.c</sourcefile>
      <sourceline>3071</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.dsn.BusMonitor.RetryTransmisionWithoutAutonDisconnect</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>402</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>263</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/XcpR_DestinationProcessor.c_3101</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR_DestinationProcessor.c</sourcefile>
      <sourceline>3101</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.dsn.BusMonitor.SendSessionTerminatedEvent</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>405</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>264</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/XcpR_DestinationProcessor.c_3107</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR_DestinationProcessor.c</sourcefile>
      <sourceline>3107</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.dsn.BusMonitor.DisconnectAfterFailedRetries</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>401</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>265</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/XcpR_DestinationProcessor.c_3125</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR_DestinationProcessor.c</sourcefile>
      <sourceline>3125</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.dsn.BusMonitor.TriggerAutonomousDisconnect</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>406</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>266</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/XcpR_DestinationProcessor.c_3132</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR_DestinationProcessor.c</sourcefile>
      <sourceline>3132</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.dsn.BusMonitor.RuntimeError.DisconnectAfterFailedRetries</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>404</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>267</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/XcpR_DestinationProcessor.c_3208</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR_DestinationProcessor.c</sourcefile>
      <sourceline>3208</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.dsn.ExclusiveArea_GlobalData</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>410</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>268</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/XcpR_DestinationProcessor.c_3233</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR_DestinationProcessor.c</sourcefile>
      <sourceline>3233</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.dsn.InternalState.TransmissionFailed.WaitingConnectConfirmation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>416</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>269</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/XcpR_DestinationProcessor.c_3239</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR_DestinationProcessor.c</sourcefile>
      <sourceline>3239</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.dsn.InternalState.TransmissionFailed.PreviousCommandConnect</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>415</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>270</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/src/XcpR_SourceProcessor.c_50</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR_SourceProcessor.c</sourcefile>
      <sourceline>50</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.dsn.SchMInclusion</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>449</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>271</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/XcpR_SourceProcessor.c_341</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR_SourceProcessor.c</sourcefile>
      <sourceline>341</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.ConnectionGroups.ActiveGroupNewRxRequest</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>171</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>272</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/XcpR_SourceProcessor.c_361</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR_SourceProcessor.c</sourcefile>
      <sourceline>361</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.dsn.ExclusiveArea_GlobalData</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>410</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>273</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/XcpR_SourceProcessor.c_496</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR_SourceProcessor.c</sourcefile>
      <sourceline>496</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.dsn.ExclusiveArea_GlobalData</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>410</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>274</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/XcpR_SourceProcessor.c_535</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR_SourceProcessor.c</sourcefile>
      <sourceline>535</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.RemoveBusRelatedInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>144</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>275</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/XcpR_SourceProcessor.c_566</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR_SourceProcessor.c</sourcefile>
      <sourceline>566</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.Store.Internal.Meta.Data</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>146</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>276</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/XcpR_SourceProcessor.c_584</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR_SourceProcessor.c</sourcefile>
      <sourceline>584</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.TriggerTransmit.UpperLayer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>161</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>277</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/XcpR_SourceProcessor.c_593</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR_SourceProcessor.c</sourcefile>
      <sourceline>593</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.StoreDataBytesOnly</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>145</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>278</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/XcpR_SourceProcessor.c_606</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR_SourceProcessor.c</sourcefile>
      <sourceline>606</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.dsn.Queueing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>425</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>279</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/XcpR_SourceProcessor.c_619</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR_SourceProcessor.c</sourcefile>
      <sourceline>619</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.TxConfirmation.UpperLayer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>160</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>280</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/XcpR_SourceProcessor.c_695</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR_SourceProcessor.c</sourcefile>
      <sourceline>695</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.TransmitFromRxIndication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>164</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>281</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/XcpR_SourceProcessor.c_876</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR_SourceProcessor.c</sourcefile>
      <sourceline>876</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.dsn.ExclusiveArea_GlobalData</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>410</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>282</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/XcpR_SourceProcessor.c_1127</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR_SourceProcessor.c</sourcefile>
      <sourceline>1127</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.dsn.ReceptionPackedFrame.StoreMessageInternally</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>436</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>283</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/XcpR_SourceProcessor.c_1128</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR_SourceProcessor.c</sourcefile>
      <sourceline>1128</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.ConcatMessagesFlexRayUnpackMultipleMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>126</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>284</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/XcpR_SourceProcessor.c_1185</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR_SourceProcessor.c</sourcefile>
      <sourceline>1185</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.dsn.ReceptionPackedFrame.StoreMessageInternally</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>436</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>285</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/XcpR_SourceProcessor.c_1186</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/src/XcpR_SourceProcessor.c</sourcefile>
      <sourceline>1186</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.ConcatMessagesEthernetUnpackMultipleMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>127</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>286</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_36</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>36</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRGeneral</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>10</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>287</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_40</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>40</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRGeneral.XcpRMultipleSlavesEnabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>11</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>288</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_67</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>67</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRGeneral.XcpRDevErrorDetect</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>12</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>289</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_103</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>103</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRGeneral.XcpRVersionInfoApi</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>13</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>290</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_127</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>127</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRGeneral.XcpRMainFunctionPeriod</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>14</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>291</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_158</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>158</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRGeneral.XcpRQueueSize</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>15</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>292</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_159</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>159</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.ConfigurableInternalQueue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>148</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>293</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_193</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>193</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRGeneral.XcpRTxRetryCount</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>16</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>294</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_235</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>235</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRGeneral.XcpRTxBusRetry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>17</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>295</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_286</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>286</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRGeneral.XcpRTxBusTimeout</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>18</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>296</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_330</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>330</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRGeneral.XcpREventPacketEnabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>19</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>297</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_358</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>358</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRGeneral.XcpRSourcePDUConfiguration</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>20</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>298</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_374</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>374</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRSourcePDUConfiguration.XcpRSourceInterfaceType</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>21</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>299</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_398</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>398</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRSourceInterfaceType.XcpRSourceConnectionOverCAN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>22</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>300</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_400</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>400</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRSourceConnectionOverCAN.XcpRSourceConnectionCanIfCfgRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>23</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>301</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_433</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>433</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRSourceInterfaceType.XcpRSourceConnectionOverCANFD</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>24</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>302</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_435</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>435</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRSourceConnectionOverCANFD.XcpRSourceCanFdMaxDlcRequired</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>25</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>303</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_461</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>461</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRSourceConnectionOverCANFD.XcpRSourceCanFdMaxDlc</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>26</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>304</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_502</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>502</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRSourceConnectionOverCANFD.XcpRSourceConnectionCanFdCanIfCfgRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>27</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>305</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_535</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>535</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRSourceInterfaceType.XcpRSourceConnectionOverFlexRay</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>28</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>306</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_537</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>537</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRSourceConnectionOverFlexRay.XcpRSourceFlxNodeAddress</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>29</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>307</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_569</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>569</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRSourceConnectionOverFlexRay.XcpRSourceFlxHeaderAlignment</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>30</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>308</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_609</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>609</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRSourceConnectionOverFlexRay.XcpRSourcePackMultiMsgInOneFlexRayFrame</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>31</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>309</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_630</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>630</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRSourceConnectionOverFlexRay.XcpRSourceSequenceCorrectionEnabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>32</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>310</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_651</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>651</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRSourceConnectionOverFlexRay.XcpRSourceMaxFlexMsgLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>33</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>311</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_706</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>706</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRSourceConnectionOverFlexRay.XcpRSourceConnectionFrIfCfgRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>34</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>312</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_739</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>739</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRSourceInterfaceType.XcpRSourceConnectionOverEthernet</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>35</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>313</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_742</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>742</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRSourceConnectionOverEthernet.XcpRSourceOpenSoCon</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>36</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>314</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_820</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>820</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRSourceConnectionOverEthernet.XcpRSourcePackMultiMsgInOneEthernetFrame</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>37</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>315</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_848</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>848</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRSourceConnectionOverEthernet.XcpRSourceMaxEthernetMsgLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>38</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>316</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_898</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>898</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRSourceConnectionOverEthernet.XcpRSourceConnectionSoAdConfigRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>39</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>317</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_983</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>983</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRSourceInterfaceType.XcpRSourceConnectionOverCDD</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>40</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>318</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_987</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>987</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRSourceInterfaceType.XcpRIsSrcMasterConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>41</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>319</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_1014</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>1014</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRSourcePDUConfiguration.XcpRPdu</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>42</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>320</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_1028</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>1028</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRSourcePDUConfiguration.XcpRPdu.XcpRRxPdu</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>43</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>321</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_1041</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>1041</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRSourcePDUConfiguration.XcpRPdu.XcpRRxPdu.XcpRRxSourcePduReference</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>44</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>322</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_1088</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>1088</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRSourcePDUConfiguration.XcpRPdu.XcpRRxPdu.XcpRRxSourcePduId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>45</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>323</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_1125</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>1125</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRSourcePDUConfiguration.XcpRPdu.XcpRRxPdu.XcpRSrcPduSupportRxFromRxIndication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>46</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>324</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_1147</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>1147</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRSourcePDUConfiguration.XcpRPdu.XcpRRxPdu.XcpRRxSrcPduSupportTxFromRxIndication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>47</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>325</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_1174</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>1174</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRSourcePDUConfiguration.XcpRPdu.XcpRTxPdu</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>48</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>326</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_1189</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>1189</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRSourcePDUConfiguration.XcpRPdu.XcpRTxPdu.XcpRTxSourcePduReference</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>49</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>327</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_1218</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>1218</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRSourcePDUConfiguration.XcpRPdu.XcpRRxPdu.XcpRRxSourcePduId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>45</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>328</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_1219</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>1219</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRSourcePDUConfiguration.XcpRPdu.XcpRTxPdu.XcpRTxSourcePduId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>50</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>329</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_1256</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>1256</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRSourcePDUConfiguration.XcpRPdu.XcpRRxPdu.XcpRSrcPduSupportRxFromXcpRTransmit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>51</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>330</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_1278</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>1278</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRSourcePDUConfiguration.XcpRPdu.XcpRRxPdu.XcpRTxSrcPduSupportTxFromXcpRTransmit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>52</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>331</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_1306</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>1306</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRSourcePDUConfiguration.XcpRSourcePDUAttributes</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>53</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>332</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_1317</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>1317</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRSourcePDUAttributes.XcpRSrcMaxCto</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>54</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>333</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_1382</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>1382</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRSourcePDUAttributes.XcpRSrcMaxDto</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>55</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>334</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_1460</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>1460</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRSourcePDUAttributes.XcpRSrcMaxCtoPgm</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>56</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>335</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_1526</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>1526</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRSourcePDUAttributes.XcpRSrcTimestampType</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>57</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>336</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_1573</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>1573</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRGeneral.XcpRDestinationPDUConfiguration</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>58</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>337</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_1589</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>1589</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRDestinationPDUConfiguration.XcpRDestinationInterfaceType</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>59</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>338</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_1613</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>1613</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRDestinationInterfaceType.XcpRDestinationConnectionOverCAN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>60</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>339</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_1615</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>1615</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRDestinationConnectionOverCAN.XcpRDestinationConnectionCanIfCfgRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>61</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>340</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_1648</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>1648</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRDestinationInterfaceType.XcpRDestinationConnectionOverCANFD</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>62</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>341</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_1650</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>1650</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRDestinationConnectionOverCANFD.XcpRDestinationCanFdMaxDlcRequired</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>63</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>342</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_1676</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>1676</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRDestinationConnectionOverCANFD.XcpRDestinationCanFdMaxDlc</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>64</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>343</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_1717</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>1717</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRDestinationConnectionOverCANFD.XcpRDestinationCanFdFillValue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>65</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>344</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_1747</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>1747</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRDestinationConnectionOverCANFD.XcpRDestinationConnectionCanFdCanIfCfgRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>66</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>345</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_1780</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>1780</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRDestinationInterfaceType.XcpRDestinationConnectionOverFlexRay</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>67</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>346</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_1782</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>1782</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRDestinationConnectionOverFlexRay.XcpRDestinationFlxNodeAddress</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>68</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>347</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_1814</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>1814</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRDestinationConnectionOverFlexRay.XcpRDestinationFlxHeaderAlignment</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>69</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>348</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_1854</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>1854</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRDestinationConnectionOverFlexRay.XcpRDestinationPackMultiMsgInOneFlexRayFrame</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>70</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>349</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_1875</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>1875</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRDestinationConnectionOverFlexRay.XcpRDestinationSequenceCorrectionEnabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>71</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>350</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_1896</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>1896</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRDestinationConnectionOverFlexRay.XcpRDestinationMaxFlexMsgLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>72</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>351</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_1951</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>1951</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRDestinationConnectionOverFlexRay.XcpRDestinationConnectionFrIfCfgRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>73</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>352</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_1984</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>1984</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRDestinationInterfaceType.XcpRDestinationConnectionOverEthernet</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>74</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>353</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_1987</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>1987</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRDestinationConnectionOverEthernet.XcpRDestinationOpenSoCon</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>75</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>354</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_2035</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>2035</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRDestinationConnectionOverEthernet.XcpRDestinationPackMultiMsgInOneEthernetFrame</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>76</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>355</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_2063</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>2063</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRDestinationConnectionOverEthernet.XcpRDestinationMaxEthernetMsgLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>77</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>356</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_2113</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>2113</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRDestinationConnectionOverEthernet.XcpRDestinationConnectionSoAdConfigRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>78</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>357</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_2198</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>2198</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRDestinationInterfaceType.XcpRDestinationConnectionOverCDD</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>79</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>358</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_2200</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>2200</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRDestinationConnectionOverCDD.XcpRCddInformation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>80</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>359</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_2201</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>2201</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.ConfigurableLoweyLayer.CddConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>156</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>360</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_2204</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>2204</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRCddInformation.XcpRCddShortName</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>81</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>361</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_2227</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>2227</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRCddInformation.XcpRCddHeaderFile</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>82</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>362</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_2248</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>2248</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRCddInformation.XcpRCddTransmitFunctionName</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>83</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>363</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_2279</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>2279</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRDestinationInterfaceType.XcpRIsDestMasterConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>84</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>364</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_2306</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>2306</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRDestinationInterfaceType.XcpRPdu</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>85</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>365</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_2320</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>2320</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRDestinationInterfaceType.XcpRPdu.XcpRRxPdu</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>86</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>366</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_2333</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>2333</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.CddLocalConnectionsOnly</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>149</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>367</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_2336</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>2336</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRDestinationInterfaceType.XcpRPdu.XcpRRxPdu.XcpRRxDestinationPduReference</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>87</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>368</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_2359</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>2359</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRDestinationInterfaceType.XcpRPdu.XcpRTxPdu</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>88</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>369</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_2372</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>2372</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRDestinationInterfaceType.XcpRPdu.XcpRTxPdu.XcpRTxDestinationPduReference</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>89</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>370</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_2406</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>2406</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRDestinationInterfaceType.XcpRPdu.XcpRTxPdu.XcpRTxDestinationPduSupportForCddTriggerTransmit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>90</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>371</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_2428</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>2428</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRDestinationInterfaceType.XcpRPdu.XcpRTxPdu.XcpRTxDestinationPduSupportForFrTriggerTransmit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>91</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>372</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_2450</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>2450</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRDestinationInterfaceType.XcpRPdu.XcpRTxPdu.XcpRLowerLayerDestinationPduId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>92</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>373</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_2475</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>2475</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRDestinationInterfaceType.XcpRPdu.XcpRTxPdu.XcpRTxDestinationPduId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>93</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>374</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_2512</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>2512</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRDestinationInterfaceType.XcpRPdu.XcpRTxPdu.XcpRDestPduSupportTxFromTxConfirmation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>94</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>375</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_2536</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>2536</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRDestinationPDUConfiguration.XcpRDestUpperLayerInformation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>95</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>376</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_2537</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>2537</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.ConfigurableUpperLayer.CddConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>157</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>377</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_2541</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>2541</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRDestUpperLayerInformation.XcpRUpperLayerModuleShortName</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>96</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>378</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_2564</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>2564</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRDestUpperLayerInformation.XcpRUpperLayerHeaderFile</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>97</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>379</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_2586</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>2586</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRDestUpperLayerInformation.XcpRRxIndicationFunctionName</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>98</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>380</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_2614</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>2614</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRDestUpperLayerInformation.XcpRTxConfirmationFunctionName</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>99</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>381</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_2642</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>2642</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRDestUpperLayerInformation.XcpRTriggerTransmitFunctionName</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>100</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>382</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_2671</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>2671</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRDestinationPDUConfiguration.XcpRDestinationPDUAttributes</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>101</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>383</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_2682</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>2682</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRDestinationPDUAttributes.XcpRDestMaxCto</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>102</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>384</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_2747</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>2747</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRDestinationPDUAttributes.XcpRDestMaxDto</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>103</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>385</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_2824</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>2824</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRDestinationPDUAttributes.XcpRDestMaxCtoPgm</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>104</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>386</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_2890</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>2890</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRDestinationPDUAttributes.XcpRDestTimestampType</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>105</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>387</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_2937</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>2937</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRGeneral.XcpRRoutingPaths</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>106</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>388</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_2950</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>2950</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.Timestamp.ConfigurationRoutingPath</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>109</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>389</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_2955</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>2955</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRRoutingPaths.XcpRSourcePduRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>107</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>390</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_2975</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>2975</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Disabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>124</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>391</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_2984</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>2984</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRRoutingPaths.XcpRDestinationPduRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>108</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>392</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_3016</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>3016</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>intgr.XcpR.EB_INTREQ_XcpR_0001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>0</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>393</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_3017</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>3017</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRGeneral.XcpRRoutingToConnectionMapping</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>110</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>394</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_3040</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>3040</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRGeneral.XcpRRoutingToConnectionMapping.XcpRRoutingMapping</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>111</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>395</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/XcpR.xdm.m4_3065</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/src/Autosar/config/XcpR.xdm.m4</sourcefile>
      <sourceline>3065</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Config.XcpRGeneral.XcpRRoutingToConnectionMapping.XcpRRoutingMapping.XcpRRoutingPathRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>112</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>396</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd">
    <specobject>
      <id>XcpR.EB.Dsn.ROMConsumption_RefCfg1</id>
      <status>approved</status>
      <source>Elektrobit Automotive GmbH</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>8191</sourceline>
      <version>2</version>
      <description>
                  The ROM consumption for reference configuration for code and configuration
                  must not exceed 6850 bytes.
                </description>
      <rationale>
                  The defined ROM consumption is the result of all analysed configuration
                  parameters of reference configuration.
                </rationale>
      <needscoverage>
        <needscov><needsobj>man</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XcpR_ResourceConsumption</srcid><srcstatus/><internalId>202</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XcpR_ComTest_ResourceConsumption</srcid><srcstatus/><internalId>475</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>397</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd">
    <specobject>
      <id>XcpR.EB.Dsn.RAMConsumption_RefCfg1</id>
      <status>approved</status>
      <source>Elektrobit Automotive GmbH</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>8219</sourceline>
      <version>2</version>
      <description>
                  The RAM consumption for reference configuration must not exceed 350 bytes.
                </description>
      <rationale>
                  The defined RAM consumption is the result of all analyzed configuration
                  parameters of reference configuration.
                </rationale>
      <needscoverage>
        <needscov><needsobj>man</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XcpR_ResourceConsumption</srcid><srcstatus/><internalId>202</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XcpR_ComTest_ResourceConsumption</srcid><srcstatus/><internalId>475</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>398</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd">
    <specobject>
      <id>XcpR.dsn.BusMonitor.DetOn.ErrorCodeNoTxExternalBus</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>8252</sourceline>
      <version>1</version>
      <description>If XcpR is executing the BusMonitor functionality and a TxConfirmation from the master Xcp is not received, it shall inform Det with the error XCPR_E_NO_TX_EXTERNAL_BUS.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_TxBusRetries_MasterNoTxConf_RemoteXcp</srcid><srcstatus/><internalId>568</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxBusRetries_MasterENotOkTxConf_RemoteXcp</srcid><srcstatus/><internalId>569</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxBusRetries_MasterNoTxConfConnect_RemoteXcp</srcid><srcstatus/><internalId>570</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.RuntimeErrorValues</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>189</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>399</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.BusMonitor.DetOn.ErrorCodeNoTxInternalBus</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>8268</sourceline>
      <version>1</version>
      <description>If XcpR is executing the BusMonitor functionality and a TxConfirmation from the remote slave Xcp is not received, it shall inform Det with the error XCPR_E_NO_TX_INTERNAL_BUS.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_TxBusRetries_MessageCmd_RemoteXcpNoTxConf</srcid><srcstatus/><internalId>571</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxBusRetries_ConnectCmd_RemoteXcpNoTxConf</srcid><srcstatus/><internalId>572</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.RuntimeErrorValues</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>189</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>400</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.BusMonitor.DisconnectAfterFailedRetries</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>8284</sourceline>
      <version>1</version>
      <description>If the transmission of a packet to the Xcp Master is accepted by the underlying communication, but the XcpR still timeouts waiting for the TxConfirmation for the configured amount of retries, the XcpR shall disconnect. </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/XcpR_DestinationProcessor.c_3107</srcid><srcstatus/><internalId>265</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_TxBusRetries_MasterNoTxConf_LocalXcp</srcid><srcstatus/><internalId>566</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxBusRetries_MasterENotOkTxConf_LocalXcp</srcid><srcstatus/><internalId>567</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxBusRetries_MasterNoTxConf_RemoteXcp</srcid><srcstatus/><internalId>568</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxBusRetries_MasterENotOkTxConf_RemoteXcp</srcid><srcstatus/><internalId>569</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxBusRetries_MasterNoTxConfConnect_RemoteXcp</srcid><srcstatus/><internalId>570</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.BusMonitor.Functionality</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>195</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>401</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.BusMonitor.RetryTransmisionWithoutAutonDisconnect</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>8301</sourceline>
      <version>1</version>
      <description>If the configured amount of times to retry the transmission is 255, the XcpR shall retry the transmission indefinitely and no autonomous disconnect shall occur.</description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/XcpR_DestinationProcessor.c_3071</srcid><srcstatus/><internalId>263</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_TxRetries_NoAutonomousDisconnect</srcid><srcstatus/><internalId>585</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.BusMonitor.Functionality</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>195</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>402</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.BusMonitor.RetryTransmission</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>8318</sourceline>
      <version>1</version>
      <description>If the transmission of a packet is accepted by the underlying communication, but the XcpR timeouts waiting for the TxConfirmation, the XcpR shall retry the transmission for a configured amount of times.</description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/XcpR_DestinationProcessor.c_3063</srcid><srcstatus/><internalId>262</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_TxBusRetries_MasterNoTxConf_LocalXcp</srcid><srcstatus/><internalId>566</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxBusRetries_MasterENotOkTxConf_LocalXcp</srcid><srcstatus/><internalId>567</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxBusRetries_MasterNoTxConf_RemoteXcp</srcid><srcstatus/><internalId>568</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxBusRetries_MasterENotOkTxConf_RemoteXcp</srcid><srcstatus/><internalId>569</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxBusRetries_MasterNoTxConfConnect_RemoteXcp</srcid><srcstatus/><internalId>570</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxBusRetries_MessageCmd_RemoteXcpNoTxConf</srcid><srcstatus/><internalId>571</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.BusMonitor.Functionality</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>195</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>403</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.BusMonitor.RuntimeError.DisconnectAfterFailedRetries</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>8335</sourceline>
      <version>1</version>
      <description>If the transmission of a packet to the Xcp Slave is accepted by the underlying communication, but the XcpR still timeouts waiting for the TxConfirmation for the configured amount of retries, the XcpR  shall report a runtime error.</description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/XcpR_DestinationProcessor.c_3132</srcid><srcstatus/><internalId>267</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_TxBusRetries_MasterNoTxConf_LocalXcp</srcid><srcstatus/><internalId>566</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxBusRetries_MasterENotOkTxConf_LocalXcp</srcid><srcstatus/><internalId>567</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxBusRetries_MasterNoTxConf_RemoteXcp</srcid><srcstatus/><internalId>568</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxBusRetries_MasterENotOkTxConf_RemoteXcp</srcid><srcstatus/><internalId>569</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxBusRetries_MasterNoTxConfConnect_RemoteXcp</srcid><srcstatus/><internalId>570</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxBusRetries_MessageCmd_RemoteXcpNoTxConf</srcid><srcstatus/><internalId>571</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.BusMonitor.Functionality</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>195</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>404</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.BusMonitor.SendSessionTerminatedEvent</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>8352</sourceline>
      <version>1</version>
      <description>If autonomous disconnect is triggered by the XcpR, a disconnect request is sent to the Xcp Slave, and upon receiving the response, the XcpR internal state is set to DISCONNECTED and a Session terminated event is emitted to the Xcp Master.</description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/XcpR_DestinationProcessor.c_2604</srcid><srcstatus/><internalId>250</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/XcpR_DestinationProcessor.c_2872</srcid><srcstatus/><internalId>258</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/XcpR_DestinationProcessor.c_3101</srcid><srcstatus/><internalId>264</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_OFFLINE_MasterToRemote</srcid><srcstatus/><internalId>503</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_WrongId_MasterToRemote</srcid><srcstatus/><internalId>504</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TcpIp_CannotGetRemoteAddress</srcid><srcstatus/><internalId>507</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_OFFLINE_Remote</srcid><srcstatus/><internalId>509</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_WrongId_Remote</srcid><srcstatus/><internalId>510</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_EthUdp_CannotSetRemoteAddress</srcid><srcstatus/><internalId>513</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_CannotGetRemoteAddress</srcid><srcstatus/><internalId>516</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_CONNECTcmd_CannotSetRemoteAddress</srcid><srcstatus/><internalId>517</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxBusRetries_MasterNoTxConf_LocalXcp</srcid><srcstatus/><internalId>566</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxBusRetries_MasterENotOkTxConf_LocalXcp</srcid><srcstatus/><internalId>567</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxBusRetries_MasterNoTxConf_RemoteXcp</srcid><srcstatus/><internalId>568</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxBusRetries_MasterENotOkTxConf_RemoteXcp</srcid><srcstatus/><internalId>569</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxBusRetries_MasterNoTxConfConnect_RemoteXcp</srcid><srcstatus/><internalId>570</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectPosRes_FromRemoteXcp</srcid><srcstatus/><internalId>574</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectPosRes_FromLocalXcp</srcid><srcstatus/><internalId>575</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectPosRes_FromRemoteXcp_PackMaster</srcid><srcstatus/><internalId>586</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectPosRes_FromRemoteXcp_Pack</srcid><srcstatus/><internalId>589</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectPosRes_FromRemoteXcp_PackRemoteSlave</srcid><srcstatus/><internalId>590</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.BusMonitor.Functionality</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>195</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations><ruleid>WRN.swuts.needscoverage.count</ruleid></oreqmViolations><covstatus>covered</covstatus><internalId>405</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.BusMonitor.TriggerAutonomousDisconnect</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>8369</sourceline>
      <version>1</version>
      <description>If XcpR is connected to the remote Xcp and it does not receive a confirmation in the configured amount of retries from the Xcp Master for a message which is not the response to a disconnect request, XcpR shall trigger the autonomously disconnect.</description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/XcpR_DestinationProcessor.c_3125</srcid><srcstatus/><internalId>266</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_TxBusRetries_MasterNoTxConf_RemoteXcp</srcid><srcstatus/><internalId>568</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxBusRetries_MasterENotOkTxConf_RemoteXcp</srcid><srcstatus/><internalId>569</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxBusRetries_MasterNoTxConfConnect_RemoteXcp</srcid><srcstatus/><internalId>570</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.BusMonitor.Functionality</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>195</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>406</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.DetInclusion</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>8386</sourceline>
      <version>2</version>
      <description>The Det public header file shall always be included in order to have access to the Det runtime error functions.</description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/XcpR_Int.h.m4_13</srcid><srcstatus/><internalId>213</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>407</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.DisconnectedState.DetOn.ErrorCodePduLost</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>8396</sourceline>
      <version>1</version>
      <description>If XcpR is in state DISCONNECTED, and it receives a command from the master Xcp different than CONNECT, it shall reject the message and inform DET with a runtime error XCPR_E_PDU_LOST</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_XcpRInternalQueue</srcid><srcstatus/><internalId>520</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_LocalXcpSlave_InvalidConnectMode_TransmissionRx</srcid><srcstatus/><internalId>522</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdus_TxConf</srcid><srcstatus/><internalId>531</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ReceptionFromRx_RemoteXcpSlave</srcid><srcstatus/><internalId>533</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ReceptionFromRx_LocalXcpSlave</srcid><srcstatus/><internalId>534</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_RemoteXcpSlave_InvalidConnectMode</srcid><srcstatus/><internalId>536</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_RxIndication_TxConfirmation_LocalXcp</srcid><srcstatus/><internalId>537</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_RxIndication_TxConfirmation_RemoteXcp</srcid><srcstatus/><internalId>538</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_RxIndication_TxConfirmation_LinkedPduId</srcid><srcstatus/><internalId>539</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.RuntimeErrorValues</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>189</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>408</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.DisconnectedState.DetOn.ErrorCodeUnexpectedMessage</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>8412</sourceline>
      <version>1</version>
      <description>If XcpR is in state DISCONNECTED, and it receives a a message from a slave Xcp, but the previous command was not a CONNECT command, it shall reject the message and inform DET with a runtime error XCPR_E_UNEXPECTED_MSG.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_ReceptionFromRx_LocalXcpSlave</srcid><srcstatus/><internalId>534</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.RuntimeErrorValues</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>189</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>409</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.ExclusiveArea_GlobalData</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>8428</sourceline>
      <version>1</version>
      <description>Any update of the RAM global data data shall be protected with a critical section.</description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/XcpR_DestinationProcessor.c_672</srcid><srcstatus/><internalId>223</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/XcpR_DestinationProcessor.c_762</srcid><srcstatus/><internalId>224</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/XcpR_DestinationProcessor.c_2451</srcid><srcstatus/><internalId>242</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/XcpR_DestinationProcessor.c_2467</srcid><srcstatus/><internalId>243</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/XcpR_DestinationProcessor.c_2637</srcid><srcstatus/><internalId>251</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/XcpR_DestinationProcessor.c_2692</srcid><srcstatus/><internalId>254</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/XcpR_DestinationProcessor.c_2916</srcid><srcstatus/><internalId>260</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/XcpR_DestinationProcessor.c_2957</srcid><srcstatus/><internalId>261</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/XcpR_DestinationProcessor.c_3208</srcid><srcstatus/><internalId>268</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/XcpR_SourceProcessor.c_361</srcid><srcstatus/><internalId>273</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/XcpR_SourceProcessor.c_496</srcid><srcstatus/><internalId>274</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/XcpR_SourceProcessor.c_876</srcid><srcstatus/><internalId>282</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations><ruleid>WRN.impl.needscoverage.count</ruleid></oreqmViolations><covstatus>covered</covstatus><internalId>410</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.GeneralDescription</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>8438</sourceline>
      <version>1</version>
      <description>XcpR module shall be used as an upper layer of the &amp;amp;lt;Bus&amp;amp;gt;If (communication on the master network) and/or CDD.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_CanFdMaxDlcRequired_Slave</srcid><srcstatus/><internalId>476</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRInternalQueue</srcid><srcstatus/><internalId>520</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MainFunctionPeriod</srcid><srcstatus/><internalId>524</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame_RemoteXcpSlave</srcid><srcstatus/><internalId>530</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_InternalQueueStress</srcid><srcstatus/><internalId>532</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_AcqData_PacketGreaterThan255Bytes</srcid><srcstatus/><internalId>554</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_GEN_InvalidRef_SoAdRxSocketConnOrSocketConnBundleRef</srcid><srcstatus/><internalId>593</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_GEN_InvalidSoAdConfiguration_SameEcuCPdu</srcid><srcstatus/><internalId>594</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_GEN_InvalidXdmCheck_LocalXcpNotShareSimilarTxPduId</srcid><srcstatus/><internalId>595</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_GEN_InvalidXdmCheck_LocalXcpNotShareSimilarRxPduId</srcid><srcstatus/><internalId>596</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>411</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.GetVersionInfo.API.DetOn.ErrorCodeNullPointer</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>8448</sourceline>
      <version>1</version>
      <description>When XcpR_GetVersionInfo() function is called with the NULL pointer as parameter, it shall return without any effect and inform DET with the error XCPR_E_NULL_POINTER.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_DetOn_AllAPI_NullPointer</srcid><srcstatus/><internalId>481</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.DevelopmentErrorValues</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>188</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>412</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.InternalQueue.DetOn.ErrorCodeOverflow</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>8464</sourceline>
      <version>1</version>
      <description>If XcpR is processing a source, if there is an attempt to write more data in the circular XcpR internal queue, than set in the XcpRQueueSize configuration parameter, execution shall return without any effect and inform DET with the error XCPR_E_INTERNAL_BUFFER_OVERFLOW.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_InternalQueueStress</srcid><srcstatus/><internalId>532</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.RuntimeErrorValues</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>189</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>413</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.InternalState.PreviousCommandConnect</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>8480</sourceline>
      <version>1</version>
      <description>If a connect command is prepared for transmission to the Xcp slave, XcpR shall set its internal state to is previous command connect.</description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/XcpR_DestinationProcessor.c_1366</srcid><srcstatus/><internalId>231</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/XcpR_DestinationProcessor.c_2416</srcid><srcstatus/><internalId>240</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>414</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.InternalState.TransmissionFailed.PreviousCommandConnect</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>8490</sourceline>
      <version>1</version>
      <description>If a transmission of a connect command fails, XcpR shall reset its internal state of previous command connect.</description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/XcpR_DestinationProcessor.c_3239</srcid><srcstatus/><internalId>270</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectSuccedes</srcid><srcstatus/><internalId>578</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>415</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.InternalState.TransmissionFailed.WaitingConnectConfirmation</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>8501</sourceline>
      <version>1</version>
      <description>If a transmission of a positive response for connect command fails, XcpR shall reset its internal state of waiting for connect confirmation.</description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/XcpR_DestinationProcessor.c_3233</srcid><srcstatus/><internalId>269</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectSuccedes</srcid><srcstatus/><internalId>578</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>416</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.InternalState.WaitingConnectConfirmation</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>8512</sourceline>
      <version>1</version>
      <description>If a response for a Connect command is prepared for transmission to the Xcp Master, XcpR shall set its internal state to is waiting for connect confirmation.</description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/XcpR_DestinationProcessor.c_2425</srcid><srcstatus/><internalId>241</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>417</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.InvalidConnectMode.DetOn.ErrorCodeInvalidConnectMode</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>8522</sourceline>
      <version>1</version>
      <description>If XcpR receives an invalid CONNECT command then execution shall return without any effect and inform DET with the error XCPR_E_INVALID_CONNECT_MODE.
</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_Ethernet_SimulateInvalidConnectCMD</srcid><srcstatus/><internalId>511</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.RuntimeErrorValues</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>189</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>418</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.LocalConnectMode.DetOn.ErrorCodeInvalidConnectMode</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>8539</sourceline>
      <version>1</version>
      <description>If XcpR receives a CONNECT command with Mode 0, but there is no Rx destination linked to this source, then execution shall return without any effect and inform DET with the error XCPR_E_INVALID_CONNECT_LOCAL_XCP.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame</srcid><srcstatus/><internalId>525</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame_RxIndication</srcid><srcstatus/><internalId>526</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame_DifferentSources</srcid><srcstatus/><internalId>527</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_RemoteXcpSlave_InvalidConnectMode</srcid><srcstatus/><internalId>536</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.RuntimeErrorValues</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>189</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>419</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.NegativeResponseConnect.DetOn.ErrorCodePduLost</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>8555</sourceline>
      <version>1</version>
      <description>If XcpR routes a CONNECT command from the master Xcp to a slave Xcp, but the received response is negative, it shall keep XcpR in DISCONNECTED state and inform  DET with a runtime error XCPR_E_PDU_LOST.
</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_SimulateConnectCMD_NegResponse_Mode_1</srcid><srcstatus/><internalId>493</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SimulateConnectCMD_NegResponse_Mode_0</srcid><srcstatus/><internalId>496</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SameBusType_SimulateConnectCMD_NegResponse_Mode_1</srcid><srcstatus/><internalId>541</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_CddBusType_SimulateConnectCMD_NegResponse_Mode_0</srcid><srcstatus/><internalId>543</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.RuntimeErrorValues</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>189</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>420</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.NegativeResponseDisconnect.DetOn.ErrorCodePduLost</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>8572</sourceline>
      <version>1</version>
      <description>If XcpR routes a DISCONNECT command from the master Xcp to a slave Xcp, but the received response is negative, it shall keep XcpR in CONNECTED state and inform  DET with a runtime error XCPR_E_PDU_LOST.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_SwitchLocalXcpToRemoteXcp_TriggerTransmit</srcid><srcstatus/><internalId>563</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.RuntimeErrorValues</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>189</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>421</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.PackMessage.DetOn.ErrorCodeInvalidLength</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>8588</sourceline>
      <version>1</version>
      <description>When XcpR is processing a destination for transmission, and it attempts to pack a message in the transmit buffer, but the message does not fit in the configured  destination's length, then execution shall return without any effect and inform DET with the error XCPR_E_INVALID_LENGTH.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_FlexRay_NoPackedMessage_InvalidPduLength</srcid><srcstatus/><internalId>490</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_LocalXcpSlave_InvalidConnectMode_TransmissionRx</srcid><srcstatus/><internalId>522</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_LocalXcpSlave_InvalidConnectMode</srcid><srcstatus/><internalId>523</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.RuntimeErrorValues</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>189</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>422</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.PrecompileTimeConfig</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>8604</sourceline>
      <version>1</version>
      <description>The XcpR shall provide a precompile-time configuration as defined in the Data Structure View.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_ConnectionGroup</srcid><srcstatus/><internalId>478</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_InternalQueue_DifferentDestinations</srcid><srcstatus/><internalId>501</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_OFFLINE_Remote</srcid><srcstatus/><internalId>509</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_WrongId_Remote</srcid><srcstatus/><internalId>510</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame_RemoteXcpSlave</srcid><srcstatus/><internalId>530</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_GEN_InvalidRef_SoAdRxSocketConnOrSocketConnBundleRef</srcid><srcstatus/><internalId>593</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_GEN_InvalidSoAdConfiguration_SameEcuCPdu</srcid><srcstatus/><internalId>594</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_GEN_InvalidXdmCheck_LocalXcpNotShareSimilarTxPduId</srcid><srcstatus/><internalId>595</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_GEN_InvalidXdmCheck_LocalXcpNotShareSimilarRxPduId</srcid><srcstatus/><internalId>596</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>423</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.ProcessSource.API.DetOn.ErrorCodeInvalidMessageLength</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>8614</sourceline>
      <version>1</version>
      <description>If DET errors are enabled, XcpR_RxIndication() or XcpR_MainFunction() API shall report the DET error code XCPR_E_INVALID_MESSAGE_LENGTH if the data length of the unpacked message is bigger than the maximum between MaxCto/MaxDto/MaxCtoPgm of all configured XcpR sources.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame</srcid><srcstatus/><internalId>525</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ReceptionFromRx_RemoteXcpSlave</srcid><srcstatus/><internalId>533</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.RuntimeErrorValues</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>189</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>424</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.Queueing</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>8630</sourceline>
      <version>1</version>
      <description>The XcpR shall implement a mechanism to enqueue received messages via configured XcpR sources into an internal queue.</description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/XcpR_SourceProcessor.c_606</srcid><srcstatus/><internalId>279</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>425</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.ReceiveFromLocalSlave</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>8640</sourceline>
      <version>1</version>
      <description>The XcpR shall implement a mechanism to receive messages from a slave Xcp, located on the local ECU, via the XcpR_Transmit() API.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_ChangeMode_SwitchRemoteXcpToLocalXcp</srcid><srcstatus/><internalId>497</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SwitchConections</srcid><srcstatus/><internalId>498</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_RxIndication_TxConfirmation_LocalXcp</srcid><srcstatus/><internalId>537</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_CddBusType_ChangeMode_SwitchRemoteXcpToLocalXcp</srcid><srcstatus/><internalId>544</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>426</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.ReceiveFromMaster</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>8650</sourceline>
      <version>1</version>
      <description>The XcpR shall implement a mechanism to receive messages from the master Xcp, via the XcpR_RxIndication API</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_FrToCanFd_MaxDlcReqDisabled_HigherDlc</srcid><srcstatus/><internalId>477</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ChangeMode_SwitchRemoteXcpToLocalXcp</srcid><srcstatus/><internalId>497</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SwitchConections</srcid><srcstatus/><internalId>498</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_RxIndication_TxConfirmation_LocalXcp</srcid><srcstatus/><internalId>537</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_RxIndication_TxConfirmation_RemoteXcp</srcid><srcstatus/><internalId>538</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_CddBusType_ChangeMode_SwitchRemoteXcpToLocalXcp</srcid><srcstatus/><internalId>544</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>427</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.ReceiveFromRemoteSlave</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>8660</sourceline>
      <version>1</version>
      <description>The XcpR shall implement a mechanism to receive messages from a slave Xcp, located on a remote ECU, via the XcpR_RxIndication() API.
</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_FrToCanFd_MaxDlcReqDisabled_HigherDlc</srcid><srcstatus/><internalId>477</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ChangeMode_SwitchRemoteXcpToLocalXcp</srcid><srcstatus/><internalId>497</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SwitchConections</srcid><srcstatus/><internalId>498</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_RxIndication_TxConfirmation_RemoteXcp</srcid><srcstatus/><internalId>538</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_CddBusType_ChangeMode_SwitchRemoteXcpToLocalXcp</srcid><srcstatus/><internalId>544</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>428</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.ReceptionFromRxIndication.DiscardMessage</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>8671</sourceline>
      <version>1</version>
      <description>If XcpR has the reception from RxIndication/XcpR_Transmit functionality disabled, XcpR shall not accept another XcpR_RxIndication/XcpR_Transmit() call using the same PduId, until this source Pdu
is processed at XcpR_MainFunction().</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_SimulateConnectCMD_PosResponse_Mode_1</srcid><srcstatus/><internalId>492</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.ReceptionFromRxIndication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>194</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>429</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.ReceptionFromRxIndication.SendIndependentMessage</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>8688</sourceline>
      <version>1</version>
      <description>If XcpR has the reception from RxIndication/XcpR_Transmit functionality enabled, and the configured destination Pdu has the "packing of multiple messages in one frame" functionality disabled, each internally stored message shall be sent independently to the configured destination.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_ReceptionFromRx_RemoteXcpSlave</srcid><srcstatus/><internalId>533</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ReceptionFromRx_LocalXcpSlave</srcid><srcstatus/><internalId>534</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_RxIndication_TxConfirmation_LocalXcp</srcid><srcstatus/><internalId>537</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.ReceptionFromRxIndication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>194</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>430</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.ReceptionFromRxIndication.StoreMessageInternally</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>8704</sourceline>
      <version>1</version>
      <description>If XcpR has the reception from RxIndication/XcpR_Transmit functionality enabled, XcpR shall process the received Pdu in the context of RxIndication/XcpR_Transmit() and store each message internally.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_ReceptionFromRx_RemoteXcpSlave</srcid><srcstatus/><internalId>533</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ReceptionFromRx_LocalXcpSlave</srcid><srcstatus/><internalId>534</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.ReceptionFromRxIndication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>194</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>431</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.ReceptionFromRxIndication.TransmissionPackedFrame.PackMsgIntoFrame</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>8720</sourceline>
      <version>1</version>
      <description>If XcpR has the reception from RxIndication/XcpR_Transmit functionality enabled, and transmission of a packed frame is enabled for a configured Pdu, each message shall be packed in a frame before sending the packet to the configured destination.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame_Master</srcid><srcstatus/><internalId>528</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame_ToLocalXcp</srcid><srcstatus/><internalId>529</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame_RemoteXcpSlave</srcid><srcstatus/><internalId>530</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SeqCorr_MultiplePdusInOneFrame_Master</srcid><srcstatus/><internalId>546</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SeqCorr_MultiplePdusInOneFrame_RemoteXcpSlave</srcid><srcstatus/><internalId>547</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_FrToCdd_TrigTrans_PackPdus_RemoteXcpSlave</srcid><srcstatus/><internalId>555</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.TransmissionMultipleEthernetMessagesInOneFrame</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>193</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionMultipleFlexRayMessagesInOneFrame</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>192</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.ReceptionFromRxIndication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>194</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>432</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.ReceptionPackedFrame.AbortUnpacking</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>8744</sourceline>
      <version>1</version>
      <description>If reception of a FlexRay packed frame is enabled, the unpacking process is aborted when the first consecutive packed Pdu with LEN 0 is detected.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_ConnectionGroup</srcid><srcstatus/><internalId>478</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame</srcid><srcstatus/><internalId>525</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame_Master</srcid><srcstatus/><internalId>528</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame_ToLocalXcp</srcid><srcstatus/><internalId>529</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame_RemoteXcpSlave</srcid><srcstatus/><internalId>530</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SeqCorr_MultiplePdusInOneFrame</srcid><srcstatus/><internalId>545</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SeqCorr_MultiplePdusInOneFrame_Master</srcid><srcstatus/><internalId>546</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SeqCorr_MultiplePdusInOneFrame_RemoteXcpSlave</srcid><srcstatus/><internalId>547</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SeqCorr</srcid><srcstatus/><internalId>548</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.ReceptionMultipleFlexRayMessagesInOneFrame</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>190</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.ReceptionMultipleEthernetMessagesInOneFrame</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>191</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>433</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.ReceptionPackedFrame.CheckTxConfirmation</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>8764</sourceline>
      <version>1</version>
      <description>If reception of a FlexRay packed frame is enabled, and transmission of a packed frame is disabled for a configured Pdu, then XcpR shall check if the transmit buffer is available, before attempting to dequeue the next message from the internal queue.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame_Master</srcid><srcstatus/><internalId>528</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame_ToLocalXcp</srcid><srcstatus/><internalId>529</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame_RemoteXcpSlave</srcid><srcstatus/><internalId>530</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SeqCorr_MultiplePdusInOneFrame_Master</srcid><srcstatus/><internalId>546</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SeqCorr_MultiplePdusInOneFrame_RemoteXcpSlave</srcid><srcstatus/><internalId>547</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.ReceptionMultipleEthernetMessagesInOneFrame</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>191</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.ReceptionMultipleFlexRayMessagesInOneFrame</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>190</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>434</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.ReceptionPackedFrame.SendMessageIndependently</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>8784</sourceline>
      <version>1</version>
      <description>If reception of a FlexRay packed frame is enabled, and transmission of a packed frame is disabled for a configured Pdu, then each message shall be sent independently to the configured destination.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame_Master</srcid><srcstatus/><internalId>528</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame_ToLocalXcp</srcid><srcstatus/><internalId>529</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame_RemoteXcpSlave</srcid><srcstatus/><internalId>530</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SeqCorr_MultiplePdusInOneFrame_Master</srcid><srcstatus/><internalId>546</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SeqCorr_MultiplePdusInOneFrame_RemoteXcpSlave</srcid><srcstatus/><internalId>547</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TransmissionRx_MultiplePdusInOneFrame_Master</srcid><srcstatus/><internalId>550</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TransmissionRx_MultiplePdusInOneFrame_RemoteXcpSlave</srcid><srcstatus/><internalId>551</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_FrToCdd_TrigTrans_PackPdus_RemoteXcpSlave</srcid><srcstatus/><internalId>555</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.ReceptionMultipleEthernetMessagesInOneFrame</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>191</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.ReceptionMultipleFlexRayMessagesInOneFrame</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>190</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>435</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.ReceptionPackedFrame.StoreMessageInternally</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>8804</sourceline>
      <version>1</version>
      <description>If reception of a FlexRay packed frame is enabled, XcpR shall store each message independently in the XcpR internal ring-buffer.</description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/XcpR_SourceProcessor.c_1127</srcid><srcstatus/><internalId>283</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/XcpR_SourceProcessor.c_1185</srcid><srcstatus/><internalId>285</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.ReceptionMultipleEthernetMessagesInOneFrame</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>191</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.ReceptionMultipleFlexRayMessagesInOneFrame</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>190</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>436</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.ReceptionPackedFrame.TransmissionPackedFrame.AddHeaderInfo</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>8824</sourceline>
      <version>1</version>
      <description>If reception of a FlexRay packed frame is enabled, and transmission of a packed frame is enabled for a configured Pdu, then the received messages shall be packed in one frame with the header information derived from the configured destination.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame</srcid><srcstatus/><internalId>525</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame_RxIndication</srcid><srcstatus/><internalId>526</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame_DifferentSources</srcid><srcstatus/><internalId>527</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SeqCorr_MultiplePdusInOneFrame</srcid><srcstatus/><internalId>545</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TransmissionRx_MultiplePdusInOneFrame</srcid><srcstatus/><internalId>549</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_FlexRay_TrigTrans_PackPdus_SeqCor_RemoteXcpSlave</srcid><srcstatus/><internalId>556</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.TransmissionMultipleEthernetMessagesInOneFrame</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>193</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.ReceptionMultipleFlexRayMessagesInOneFrame</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>190</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionMultipleFlexRayMessagesInOneFrame</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>192</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.ReceptionMultipleEthernetMessagesInOneFrame</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>191</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>437</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.ReceptionPackedFrame.TransmissionPackedFrame.PackAtLeastOneMsg</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>8852</sourceline>
      <version>1</version>
      <description>If reception of a FlexRay packed frame is enabled and transmission of a packed frame is enabled for a configured Pdu, if there is enough available space in the Destination frame, at least one XcpR package shall be concatenated inside the Destination frame.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_ConnectionGroup</srcid><srcstatus/><internalId>478</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_MultiplePdusInOneFrame</srcid><srcstatus/><internalId>525</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SeqCorr_MultiplePdusInOneFrame</srcid><srcstatus/><internalId>545</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TransmissionRx_MultiplePdusInOneFrame</srcid><srcstatus/><internalId>549</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.ReceptionMultipleFlexRayMessagesInOneFrame</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>190</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.ReceptionMultipleEthernetMessagesInOneFrame</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>191</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionMultipleFlexRayMessagesInOneFrame</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>192</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionMultipleEthernetMessagesInOneFrame</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>193</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>438</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.RemoteConnectMode.DetOn.ErrorCodeInvalidConnectMode</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>8880</sourceline>
      <version>1</version>
      <description>If XcpR receives a CONNECT command with Mode 1, but there is no Tx destination linked to this source, then execution shall return without any effect and inform DET with the error XCPR_E_INVALID_CONNECT_REMOTE_XCP.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_LocalXcpSlave_InvalidConnectMode_TransmissionRx</srcid><srcstatus/><internalId>522</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_LocalXcpSlave_InvalidConnectMode</srcid><srcstatus/><internalId>523</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.RuntimeErrorValues</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>189</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>439</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.RxIndication.API.DetOn.ErrorCodeInvalidActiveDestination</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>8896</sourceline>
      <version>1</version>
      <description>When XcpR_RxIndication() function is called with an PDUID for unused configured source, it shall inform DET with the error XCPR_E_INVALID_ACTIVE_DESTINATION.

</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_DetOn_Unused_Sources</srcid><srcstatus/><internalId>488</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.RuntimeErrorValues</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>189</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>440</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.RxIndication.API.DetOn.ErrorCodeInvalidMessageHeaderLength</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>8914</sourceline>
      <version>1</version>
      <description>If DET errors are enabled, XcpR_RxInndication() API shall report the DET error code XCPR_E_INVALID_MESSAGE_LENGTH if the length of the received Pdu is less than or equal to BUS Header (Ethernet/FlexRay) for the incoming PDU.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_DetOn_InvalidMessageLength_PduHeader</srcid><srcstatus/><internalId>489</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.RuntimeErrorValues</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>189</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>441</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.RxIndication.API.DetOn.ErrorCodeInvalidPduID</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>8930</sourceline>
      <version>1</version>
      <description>When XcpR_RxIndication() function is called with invalid PDUID, it shall inform DET with the error XCPR_E_INVALID_PDUID.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_DetOn_AllAPI_OutOfRangeParam</srcid><srcstatus/><internalId>480</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_DetOn_AllAPI_NullPointerData</srcid><srcstatus/><internalId>485</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.RuntimeErrorValues</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>189</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>442</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.RxIndication.API.DetOn.ErrorCodeInvalidRxLength</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>8946</sourceline>
      <version>1</version>
      <description>If DET errors are enabled, XcpR_RxIndication() API shall report the DET error code XCPR_E_INVALID_RX_PDU_LENGTH if the length of the received Pdu is greater than maximum configured buffer size for the incoming PDUs.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_DetOn_RxIndication_InvalidPduLength</srcid><srcstatus/><internalId>483</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.RuntimeErrorValues</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>189</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>443</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.RxIndication.API.DetOn.ErrorCodeNotInitialized</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>8962</sourceline>
      <version>1</version>
      <description>If the external API XcpR_RxIndication() is called before XcpR_Init (XcpR module state is UNINITIALIZED), the function shall return without any effect and report XCPR_E_NOT_INITIALIZED to DET.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_DetOn_AllAPI_UninitializedXcpR</srcid><srcstatus/><internalId>479</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.RuntimeErrorValues</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>189</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>444</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.RxIndication.API.DetOn.ErrorCodeNullPointer</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>8978</sourceline>
      <version>1</version>
      <description>When XcpR_RxIndication() function is called with the NULL pointer as parameter, it shall return without any effect and inform DET with the error XCPR_E_NULL_POINTER.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_DetOn_AllAPI_NullPointer</srcid><srcstatus/><internalId>481</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.DevelopmentErrorValues</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>188</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>445</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.RxIndication.API.DetOn.ErrorCodePduOutsideConnectionGroup</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>8994</sourceline>
      <version>1</version>
      <description>If the Connection Group functionality is enabled XcpR_RxIndication() API shall report the DET error code XCPR_E_PDU_OUTSIDE_CONNECTION_GROUP if the PduId is not accepted because is not part of the currently active Connection Group.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_ConnectionGroup</srcid><srcstatus/><internalId>478</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.RuntimeErrorValues</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>189</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>446</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.RxIndication.API.DetOn.ErrorCodeZeroRxLength</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>9010</sourceline>
      <version>1</version>
      <description>If DET errors are enabled, XcpR_RxIndication() API shall report the DET error code XCPR_E_INVALID_RX_PDU_LENGTH if the length of the received Pdu is equal to zero for the incoming PDU.

</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_DetOn_RxIndication_ZeroPduLength</srcid><srcstatus/><internalId>486</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.RuntimeErrorValues</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>189</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>447</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.RxIndication.DetOn.PduBufferFull</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>9028</sourceline>
      <version>1</version>
      <description>If DET errors are enabled, XcpR_RxIndication() API shall report the DET error code XCPR_E_PDU_BUFFER_FULL if the message is discarded because the assigned receive Pdu buffer is full.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_ConnectCmd_PosRes_LocalXcp_TriggerTransmit</srcid><srcstatus/><internalId>560</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.RuntimeErrorValues</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>189</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>448</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.SchMInclusion</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>9044</sourceline>
      <version>1</version>
      <description>SchM_XcpR.h shall be included in all XcpR source files in order to have access to the critical section function prototype</description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/XcpR_DestinationProcessor.c_25</srcid><srcstatus/><internalId>222</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/XcpR_SourceProcessor.c_50</srcid><srcstatus/><internalId>271</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>449</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.SoAdSoConModeChg.API.DetOn.ErrorCodeNotInitialized</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>9054</sourceline>
      <version>1</version>
      <description>If the external API XcpR_SoAdSoConModeChg() is called before XcpR_Init (XcpR module state is UNINITIALIZED), the function shall return without any effect and report XCPR_E_NOT_INITIALIZED to DET.
</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_DetOn_AllAPI_UninitializedXcpR</srcid><srcstatus/><internalId>479</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_ONLINE_MasterToRemote</srcid><srcstatus/><internalId>502</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_XcpRSoAdSoConModeChg_ONLINE_Remote</srcid><srcstatus/><internalId>508</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.RuntimeErrorValues</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>189</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>450</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.TcpConnected.DiffAddr.DetOn.ErrorCodePduLost</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>9071</sourceline>
      <version>1</version>
      <description>If XcpR is CONNECTED over a TCP interface, it shall discard a packet received from an address different than the one from which the connection originated (via command CONNECT) and inform DET with a runtime error XCPR_E_PDU_LOST.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_TcpIp_CannotGetRemoteAddress</srcid><srcstatus/><internalId>507</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.RuntimeErrorValues</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>189</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>451</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.TcpConnected.DiffPort.DetOn.ErrorCodePduLost</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>9087</sourceline>
      <version>1</version>
      <description>If XcpR is CONNECTED over a TCP interface, it shall discard a packet received from a port different than the one from which the connection originated (via command CONNECT) and inform DET with a runtime error XCPR_E_PDU_LOST.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_TcpIp_CannotGetRemoteAddress</srcid><srcstatus/><internalId>507</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.RuntimeErrorValues</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>189</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>452</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.Transmission.DetOn.ErrorCodeExternalBus</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>9103</sourceline>
      <version>1</version>
      <description>If XcpR is processing a destination to the master Xcp, but the transmission cannot be done, it shall inform DET with the error XCPR_E_EXTERNAL_BUS.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_TriggerTransmit_TxRetries_MessageCmd</srcid><srcstatus/><internalId>564</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectPosRes_FromRemoteXcp</srcid><srcstatus/><internalId>574</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectPosRes_FromLocalXcp</srcid><srcstatus/><internalId>575</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_MessagePosRes_FromLocalXcp</srcid><srcstatus/><internalId>579</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_MessageCmd_ToRemoteXcp</srcid><srcstatus/><internalId>581</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectPosRes_FromRemoteXcp_PackMaster</srcid><srcstatus/><internalId>586</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_MultipleMessagesReceived_FromLocalAndMaster</srcid><srcstatus/><internalId>588</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectPosRes_FromRemoteXcp_Pack</srcid><srcstatus/><internalId>589</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectPosRes_FromRemoteXcp_PackRemoteSlave</srcid><srcstatus/><internalId>590</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.RuntimeErrorValues</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>189</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>453</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.Transmission.DetOn.ErrorCodeInternalBus</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>9119</sourceline>
      <version>1</version>
      <description>If XcpR is processing a destination to a remote slave Xcp, but the transmission cannot be done, it shall inform DET with the error XCPR_E_INTERNAL_BUS.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectCmd_ToRemoteXcp</srcid><srcstatus/><internalId>576</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.RuntimeErrorValues</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>189</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>454</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.TransmissionOngoing.QueuedMessages</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>9135</sourceline>
      <version>1</version>
      <description>If XcpR receives messages while transmission buffer for that PduId is not empty, the messages shall be kept in the internal message queue until the transmission buffer is free.</description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/XcpR_DestinationProcessor.c_789</srcid><srcstatus/><internalId>225</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_TxRetries_successfullyTransmit_ToRemoteXcp</srcid><srcstatus/><internalId>577</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>455</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.Transmit.API.DetOn.ErrorCodeInvalidActiveDestination</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>9146</sourceline>
      <version>1</version>
      <description>When XcpR_Transmit() function is called with an PDUID for unused configured source, it shall inform DET with the error XCPR_E_INVALID_ACTIVE_DESTINATION.
</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_DetOn_Unused_Sources</srcid><srcstatus/><internalId>488</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.RuntimeErrorValues</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>189</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>456</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.Transmit.API.DetOn.ErrorCodeInvalidPduID</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>9163</sourceline>
      <version>1</version>
      <description>When XcpR_Transmit() function is called with invalid PDUID, it shall inform DET with the error XCPR_E_INVALID_PDUID</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_DetOn_AllAPI_OutOfRangeParam</srcid><srcstatus/><internalId>480</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_DetOn_AllAPI_NullPointerData</srcid><srcstatus/><internalId>485</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.RuntimeErrorValues</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>189</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>457</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.Transmit.API.DetOn.ErrorCodeNotInitialized</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>9179</sourceline>
      <version>1</version>
      <description>If the external API XcpR_Transmit is called before XcpR_Init (XcpR module state is UNINITIALIZED), the function shall return without any effect and report XCPR_E_NOT_INITIALIZED to DET.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_DetOn_AllAPI_UninitializedXcpR</srcid><srcstatus/><internalId>479</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.RuntimeErrorValues</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>189</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>458</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.Transmit.API.DetOn.ErrorCodeNullPointer</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>9195</sourceline>
      <version>1</version>
      <description>When XcpR_Transmit() function is called with the NULL pointer as parameter, it shall return without any effect and inform DET with the error XCPR_E_NULL_POINTER.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_DetOn_AllAPI_NullPointer</srcid><srcstatus/><internalId>481</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.DevelopmentErrorValues</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>188</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>459</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.Transmit.API.DetOn.ErrorCodeZeroTxLength</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>9211</sourceline>
      <version>1</version>
      <description>If DET errors are enabled, XcpR_Transmit() API shall report the DET error code XCPR_E_INVALID_TX_PDU_LENGTH if the length of the received Pdu is equal to zero for the incoming PDU.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_DetOn_Transmit_ZeroPduLength</srcid><srcstatus/><internalId>487</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.RuntimeErrorValues</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>189</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>460</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.TriggerTransmit.API.DetOn.ErrorCodeInvalidPduID</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>9227</sourceline>
      <version>1</version>
      <description>When XcpR_TriggerTransmit() function is called with invalid PDUID, it shall return without any effect and inform DET with the error XCPR_E_INVALID_PDUID.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_DetOn_AllAPI_OutOfRangeParam</srcid><srcstatus/><internalId>480</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_DetOn_AllAPI_NullPointerData</srcid><srcstatus/><internalId>485</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.RuntimeErrorValues</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>189</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>461</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.TriggerTransmit.API.DetOn.ErrorCodeNotInitialized</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>9243</sourceline>
      <version>1</version>
      <description> If the external API XcpR_TriggerTransmit is called before XcpR_Init (XcpR module state is UNINITIALIZED), the function shall return without any effect and report XCPR_E_NOT_INITIALIZED to DET.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_DetOn_AllAPI_UninitializedXcpR</srcid><srcstatus/><internalId>479</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.RuntimeErrorValues</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>189</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>462</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.TriggerTransmit.API.DetOn.ErrorCodeNullPointer</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>9259</sourceline>
      <version>1</version>
      <description>When XcpR_TriggerTransmit() function is called with the NULL pointer as parameter, it shall return without any effect and inform DET with the error XCPR_E_NULL_POINTER.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_DetOn_AllAPI_NullPointer</srcid><srcstatus/><internalId>481</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.DevelopmentErrorValues</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>188</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>463</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.TxConfirmation</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>9275</sourceline>
      <version>1</version>
      <description>The XcpR shall implement a mechanism to confirm a transmission using the XcpR_TxConfirmation API.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_SimulateConnectCMD_PosResponse_Mode_0</srcid><srcstatus/><internalId>495</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SimulateConnectCMD_NegResponse_Mode_0</srcid><srcstatus/><internalId>496</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_ChangeMode_SwitchRemoteXcpToLocalXcp</srcid><srcstatus/><internalId>497</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_SwitchConections</srcid><srcstatus/><internalId>498</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_CddBusType_SimulateConnectCMD_PosResponse_Mode_0</srcid><srcstatus/><internalId>542</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_CddBusType_ChangeMode_SwitchRemoteXcpToLocalXcp</srcid><srcstatus/><internalId>544</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>464</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.TxConfirmation.API.DetOn.ErrorCodeInvalidPduID</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>9285</sourceline>
      <version>1</version>
      <description>When XcpR_TxConfirmation() function is called with invalid PDUID, it shall return without any effect and inform DET with the error XCPR_E_INVALID_PDUID.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_DetOn_AllAPI_OutOfRangeParam</srcid><srcstatus/><internalId>480</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_DetOn_AllAPI_NullPointerData</srcid><srcstatus/><internalId>485</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.RuntimeErrorValues</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>189</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>465</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.TxConfirmation.API.DetOn.ErrorCodeNotInitialized</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>9301</sourceline>
      <version>1</version>
      <description>If the external API XcpR_TxConfirmation is called before XcpR_Init (XcpR module state is UNINITIALIZED), the function shall return without any effect and report XCPR_E_NOT_INITIALIZED to DET.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_DetOn_AllAPI_UninitializedXcpR</srcid><srcstatus/><internalId>479</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.RuntimeErrorValues</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>189</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>466</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.TxRetry.DiscardMessage</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>9317</sourceline>
      <version>1</version>
      <description>If XcpR cannot transmit a message for the configured number of times, XcpR shall discard the message.</description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/XcpR_DestinationProcessor.c_2509</srcid><srcstatus/><internalId>245</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_TriggerTransmit_TxRetries_MessageCmd</srcid><srcstatus/><internalId>564</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectPosRes_FromRemoteXcp</srcid><srcstatus/><internalId>574</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectPosRes_FromLocalXcp</srcid><srcstatus/><internalId>575</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_MessagePosRes_FromLocalXcp</srcid><srcstatus/><internalId>579</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_MessageCmd_ToRemoteXcp</srcid><srcstatus/><internalId>581</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_DisconnectPosRes_FromRemoteXcp</srcid><srcstatus/><internalId>582</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectPosRes_FromRemoteXcp_PackMaster</srcid><srcstatus/><internalId>586</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_MessagePosRes_FromLocalXcp_PackMaster</srcid><srcstatus/><internalId>587</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectPosRes_FromRemoteXcp_Pack</srcid><srcstatus/><internalId>589</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectPosRes_FromRemoteXcp_PackRemoteSlave</srcid><srcstatus/><internalId>590</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.TxRetry.Functionality</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>196</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>467</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.TxRetry.RuntimeError.MasterToSlave</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>9334</sourceline>
      <version>1</version>
      <description>If XcpR cannot forward packets from Xcp Master to the remote Xcp Slave, XcpR shall report a runtime error.</description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/XcpR_DestinationProcessor.c_2553</srcid><srcstatus/><internalId>246</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_TriggerTransmit_TxRetries_MessageCmd</srcid><srcstatus/><internalId>564</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectCmd_ToRemoteXcp</srcid><srcstatus/><internalId>576</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_MessageCmd_ToRemoteXcp</srcid><srcstatus/><internalId>581</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_TwoConnectCmds_ToRemoteXcp</srcid><srcstatus/><internalId>584</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.TxRetry.Functionality</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>196</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>468</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.TxRetry.RuntimeError.SlaveToMaster</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>9351</sourceline>
      <version>1</version>
      <description>If XcpR cannot forward packets from the remote Xcp Slave to Xcp Master, XcpR shall report a runtime error.</description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/XcpR_DestinationProcessor.c_2561</srcid><srcstatus/><internalId>247</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectPosRes_FromRemoteXcp</srcid><srcstatus/><internalId>574</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectPosRes_FromLocalXcp</srcid><srcstatus/><internalId>575</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_MessagePosRes_FromLocalXcp</srcid><srcstatus/><internalId>579</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectPosRes_FromRemoteXcp_PackMaster</srcid><srcstatus/><internalId>586</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_MessagePosRes_FromLocalXcp_PackMaster</srcid><srcstatus/><internalId>587</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_MultipleMessagesReceived_FromLocalAndMaster</srcid><srcstatus/><internalId>588</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectPosRes_FromRemoteXcp_Pack</srcid><srcstatus/><internalId>589</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectPosRes_FromRemoteXcp_PackRemoteSlave</srcid><srcstatus/><internalId>590</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.TxRetry.Functionality</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>196</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>469</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.TxRetry.SlaveToMaster.DisconnectXcpR</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>9368</sourceline>
      <version>1</version>
      <description>If XcpR cannot send the positive response for disconnect command from the remote Xcp to the Xcp Master, XcpR shall set its state to Disconnected.</description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/XcpR_DestinationProcessor.c_2574</srcid><srcstatus/><internalId>248</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_TxRetries_DisconnectPosRes_FromRemoteXcp</srcid><srcstatus/><internalId>582</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.TxRetry.Functionality</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>196</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>470</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.TxRetry.SlaveToMaster.TriggerAutonomousDisconnect</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>9385</sourceline>
      <version>1</version>
      <description>If XcpR cannot send the positive response for connect command from the remote Xcp to the Xcp Master, XcpR shall trigger the autonomous Disconnect by sending a request to Xcp Slave.</description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/XcpR_DestinationProcessor.c_2913</srcid><srcstatus/><internalId>259</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectPosRes_FromRemoteXcp</srcid><srcstatus/><internalId>574</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectPosRes_FromRemoteXcp_PackMaster</srcid><srcstatus/><internalId>586</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectPosRes_FromRemoteXcp_Pack</srcid><srcstatus/><internalId>589</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectPosRes_FromRemoteXcp_PackRemoteSlave</srcid><srcstatus/><internalId>590</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.TxRetry.Functionality</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>196</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>471</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.TxRetry.TriggerAutonomousDisconnect</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>9402</sourceline>
      <version>1</version>
      <description>If XcpR is either connected or on pending connection state to the local Xcp and it cannot transmit a message to the Xcp Master, XcpR shall trigger the autonomous Disconnect by sending a request to Xcp Slave.</description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/XcpR_DestinationProcessor.c_2597</srcid><srcstatus/><internalId>249</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_TxRetries_ConnectPosRes_FromLocalXcp</srcid><srcstatus/><internalId>575</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_MessagePosRes_FromLocalXcp</srcid><srcstatus/><internalId>579</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_MessagePosRes_FromLocalXcp_PackMaster</srcid><srcstatus/><internalId>587</internalId></linkedfrom><linkedfrom><srcid>TS_XCPR_TxRetries_MultipleMessagesReceived_FromLocalAndMaster</srcid><srcstatus/><internalId>588</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.TxRetry.Functionality</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>196</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>472</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.UdpConnected.DiffAddr.DetOn.ErrorCodePduLost</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>9419</sourceline>
      <version>1</version>
      <description>If XcpR is CONNECTED over a UDP interface, it shall discard a packet received from an address different than the one from which the connection originated (via command CONNECT) and inform DET with a runtime error XCPR_E_PDU_LOST.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_EthUdp_CommandDifferentIp</srcid><srcstatus/><internalId>514</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.RuntimeErrorValues</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>189</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>473</internalId></specobject>
    <specobject>
      <id>XcpR.dsn.XcpRTransmit.API.DetOn.ErrorCodeInvalidTxLength</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/doc/project/design/pdf/XcpR_Design-profiled.xml</sourcefile>
      <sourceline>9435</sourceline>
      <version>1</version>
      <description>If DET errors are enabled, XcpR_Transmit() API shall report the DET error code XCPR_E_INVALID_TX_PDU_LENGTH if the length of the received Pdu is greater than maximum configured buffer size for the incoming PDU.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_XCPR_DetOn_Transmit_InvalidPduLength</srcid><srcstatus/><internalId>484</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.RuntimeErrorValues</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>189</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>474</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_XcpR_ComTest_ResourceConsumption</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Compile/IN/XcpR_ComTest_ResourceConsumption/source/application/test_config.h</sourcefile>
      <sourceline>17</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Run the compile test in order to measure resource consumption (RAM/ROM) resources
    Get RAM/ROM consumption for ComM
    VP(XcpR.EB.Dsn.ROMConsumption_RefCfg1): Check the ROM consumption of
      the test run against the threshold specified in the requirement.
    VP(XcpR.EB.Dsn.RAMConsumption_RefCfg1): Check the RAM consumption of
      the test run against the threshold specified in the requirement.
  
Test Object: None.
Test Precondition: None
Test Execution: None.
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.EB.Dsn.ROMConsumption_RefCfg1</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>397</internalId></provcov>
        <provcov>
          <linksto>XcpR.EB.Dsn.RAMConsumption_RefCfg1</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>398</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>475</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_XCPR_CanFdMaxDlcRequired_Slave</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_CanFd_01/source/application/EbTest.c.m4</sourcefile>
      <sourceline>42</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Check that messages are forwarded when CAN-FD Max DLC required functionality is enabled. 
      Verifies "CAN-FD fill byte" functionality and the data length is equal to the MAX_DLC_REQUIRED value.
      * MASTER NETWORK: PM_Tst_Master_Bus_Type
      * REMOTE SLAVE NETWORK: CAN-FD
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    Remote slave network: 
      XcpRSourceCanFdMaxDlcRequired      is enabled.
      XcpRDestinationCanFdMaxDlcRequired is enabled.
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a package consisting in command different than CONNECT command
        on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called) when no connection is established.
    03. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the slave is DISCONNECTED.
    04. Simulate reception of a CONNECT command with MODE = 1 on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called
        and command 0xFF, MODE = 1).
    05. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode, XcpR.Impl.AdaptBusInfo): Check that the XcpR calls
        the transmit interface of the lower layer (e.g PM_Tst_Slave_Bus_Type\-::-/Transmit is called and the XCP package is
        the same with the one received from XCP but header is adapted).
    06. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    07. VP(XcpR.Impl.CheckStatusConnection, XcpR.Impl.AdaptBusInfo): Verify that the XcpR calls the transmit interface of the lower layer
        (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package is the same with the one received
        from remote XCP slave).
    08. Simulate reception, on PM_Tst_Master_Bus_Type bus, of SET_DAQ_LIST_MODE command.
    09. VP (XcpR.Impl.TransmissionOfConsecutiveMessages, XcpR.Impl.AdaptBusInfo) Verify that
        the package is routed to the Xcp instance on the remote ECU (CanIf_Transmit is called).
    10. Simulate that remote XCP slave responses, on CanFD bus, with a positive response for 
        SET_DAQ_LIST_MODE command (remote Xcp slave calls XcpR_RxIndication).
    11. VP(XcpR.Impl.AdaptBusInfo): Verify that the XcpR calls the transmit interface of the lower layer (e.g PM_Tst_Master_Bus_Type\-::-/Transmit
        is called and the XCP data package is the same with the one received from XCP but header is adapted).
    12. Simulate reception, on PM_Tst_Master_Bus_Type bus, of one START_STOP_DAQ_LIST command.
    13. VP (XcpR.Impl.AdaptBusInfo) Verify that the package is routed to the Xcp instance on the
        remote ECU (CanIf_Transmit is called ).
    14. Simulate that remote XCP slave responses, on CAN-FD bus, with a positive response for 
        START_STOP_DAQ_LIST command (remote Xcp slave calls XcpR_RxIndication).
    15. VP(XcpR.Impl.AdaptBusInfo): Verify that the XcpR calls the transmit interface of the lower layer
        (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP data package is the same with the one received
        from XCP but header is adapted).
    16. Simulate reception, on PM_Tst_Master_Bus_Type bus, a simulation data packet
        to be sent from Xcp master to remote Xcp slave.
    17. VP (XcpR.Impl.AdaptBusInfo) Verify that the package is routed to the Xcp instance on the remote ECU
        (CanIf_Transmit is called ).
    18. Set the result as success.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Disabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>124</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.BusTypesRemoteConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.GeneralDescription</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>411</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.AdaptBusInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>147</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>476</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_XCPR_FrToCanFd_MaxDlcReqDisabled_HigherDlc</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_CanFd_02/source/application/EbTest.c</sourcefile>
      <sourceline>43</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Verifies "CAN-FD fill byte" functionality is correctly implemented when MAX_DLC_REQUIRED is
      not set and the data length is greater than the defined DLC value of CAN-FD.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a package consisting in command different than CONNECT command
        on FlexRay (XcpR_RxIndication() is called) when no connection is established.
    03. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the slave is DISCONNECTED.
    04. Simulate reception of a CONNECT command with MODE = 1 on FlexRay (XcpR_RxIndication() is called
        and command 0xFF, MODE = 1).
    05. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode): Check that the XcpR
        calls the transmit interface of the lower layer (e.g CanIf_Transmit is called and the XCP package is the
        same with the one received from XCP but header is adapted).
    06. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    07. VP(XcpR.Impl.CheckStatusConnection): Verify that the XcpR calls the transmit interface of the lower layer
        (e.g FrIf_Transmit is called and the XCP package is the same with the one received
        from XCP).
    08. Simulate reception, on FlexRay bus, of the WRITE_DAQ_MULTIPLE command.
    09. VP(XcpR.Impl.TransmissionOfConsecutiveMessages, XcpR.Impl.AdaptBusInfo): Check
        that the XcpR calls the transmit interface of the lower layer (e.g CanIf_Transmit is called and the XCP package
        is the same with the one received from XCP but header is adapted).
    10. Set the result as success.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Disabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>124</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.BusTypesRemoteConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.ReceiveFromMaster</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>427</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.ReceiveFromRemoteSlave</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>428</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.AdaptBusInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>147</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>477</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_XCPR_ConnectionGroup</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_ConnectionGroup/source/application/EbTest.c</sourcefile>
      <sourceline>60</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Tests that only requests from PDUs mapped to a Active Connection Group are accepted.
        Master network
          Enable multiple XcpR messages in one FlexRay frame.
          Alignment: PACKET_ALIGNMENT_8
        Remote network
          Enable multiple XcpR messages in one FlexRay frame.
          Alignment: PACKET_ALIGNMENT_8
        Local network: CDD
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    XcpR Rx Src Pdu Ids 0,1,2 and 3 are mapped to a Connection Group.
    XcpR Rx Src Pdu Id 4 is not part of the active Connection Group.
  
Test Execution: 

  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Disabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>124</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.BusTypesRemoteConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.PrecompileTimeConfig</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>423</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.ReceptionPackedFrame.AbortUnpacking</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>433</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.ReceptionPackedFrame.TransmissionPackedFrame.PackAtLeastOneMsg</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>438</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.Communication.FlexRay.ImmediateAccess</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>137</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.RxIndication.API.DetOn.ErrorCodePduOutsideConnectionGroup</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>446</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.ConnectionGroups.Enabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>167</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.ConnectionGroups.ActiveGroupInformationReset</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>170</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.ConnectionGroups.ActiveGroupNewRxRequest</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>171</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>478</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_XCPR_DetOn_AllAPI_UninitializedXcpR</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_DetOn/source/application/EbTest.c.m4</sourcefile>
      <sourceline>70</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      The test should prove that if the XcpR module is not initialized functions XcpR_RxIndication, XcpR_TxConfirmation,
      XcpR_TriggerTransmit, XcpR_Transmit should return XCPR_E_NOT_INITIALIZED.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    XcpR shall not be initialized.
    XcpRDetRuntimeChecks is enabled.
  
Test Execution: 
    01. Call XcpR_RxIndication without initializing XcpR.
    02. VP(XcpR.dsn.RxIndication.API.DetOn.ErrorCodeNotInitialized): Check that XcpR_RxIndication()
        throws the runtime error XCPR_E_NOT_INITIALIZED.
    03. Call XcpR_TxConfirmation without initializing XcpR.
    04. VP(XcpR.dsn.TxConfirmation.API.DetOn.ErrorCodeNotInitialized): Check that XcpR_TxConfirmation()
        throws the runtime error XCPR_E_NOT_INITIALIZED.
    05. Call XcpR_TriggerTransmit without initializing XcpR.
    06. VP(XcpR.dsn.TriggerTransmit.API.DetOn.ErrorCodeNotInitialized): Check that XcpR_TriggerTransmit()
        throws the runtime error XCPR_E_NOT_INITIALIZED.
    07. Call XcpR_Transmit without initializing XcpR.
    08. VP(XcpR.dsn.Transmit.API.DetOn.ErrorCodeNotInitialized): Check that XcpR_Transmit()
        throws the runtime error XCPR_E_NOT_INITIALIZED.
    09. Call XcpR_SoAdSoConModeChg without initializing XcpR.
    10. VP(XcpR.dsn.SoAdSoConModeChg.API.DetOn.ErrorCodeNotInitialized): Check that XcpR_SoAdSoConModeChg()
        throws the runtime error XCPR_E_NOT_INITIALIZED.
    11. Set the result as success.
  
Test Input: None.
Test Output: 
    Specific DET errors shall be reported.
  </description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.dsn.RxIndication.API.DetOn.ErrorCodeNotInitialized</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>444</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.TxConfirmation.API.DetOn.ErrorCodeNotInitialized</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>466</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.TriggerTransmit.API.DetOn.ErrorCodeNotInitialized</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>462</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.Transmit.API.DetOn.ErrorCodeNotInitialized</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>458</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.SoAdSoConModeChg.API.DetOn.ErrorCodeNotInitialized</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>450</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>479</internalId></specobject>
    <specobject>
      <id>TS_XCPR_DetOn_AllAPI_OutOfRangeParam</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_DetOn/source/application/EbTest.c.m4</sourcefile>
      <sourceline>178</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      The test should prove that functions XcpR_RxIndication, XcpR_TxConfirmation,
      XcpR_TriggerTransmit, XcpR_Transmit should return XCPR_E_INVALID_PDUID if
      APIs are called with out of range parameters.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    XcpRDetRuntimeChecks is enabled.
  
Test Execution: 
    01. Initialize XcpR Module.
    02. Call XcpR_RxIndication with invalid pdu id.
    03. VP(XcpR.dsn.RxIndication.API.DetOn.ErrorCodeInvalidPduID): Check that XcpR_RxIndication()
        throws the runtime error XCPR_E_INVALID_PDUID.
    04. Call XcpR_TxConfirmation with invalid pdu id.
    05. VP(XcpR.dsn.TxConfirmation.API.DetOn.ErrorCodeInvalidPduID): Check that XcpR_TxConfirmation()
        throws the runtime error XCPR_E_INVALID_PDUID.
    06. Call XcpR_TriggerTransmit with invalid pdu id.
    07. VP(XcpR.dsn.TriggerTransmit.API.DetOn.ErrorCodeInvalidPduID): Check that XcpR_TriggerTransmit()
        throws the runtime error XCPR_E_INVALID_PDUID.
    08. Call XcpR_Transmit with invalid pdu id.
    09. VP(XcpR.dsn.Transmit.API.DetOn.ErrorCodeInvalidPduID): Check that XcpR_Transmit()
        throws the runtime error XCPR_E_INVALID_PDUID.
    10. Set the result as success.
  
Test Input: None.
Test Output: 
    DET error reported with "XCPR_E_INVALID_PDUID"
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.dsn.RxIndication.API.DetOn.ErrorCodeInvalidPduID</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>442</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.TxConfirmation.API.DetOn.ErrorCodeInvalidPduID</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>465</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.TriggerTransmit.API.DetOn.ErrorCodeInvalidPduID</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>461</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.Transmit.API.DetOn.ErrorCodeInvalidPduID</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>457</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>480</internalId></specobject>
    <specobject>
      <id>TS_XCPR_DetOn_AllAPI_NullPointer</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_DetOn/source/application/EbTest.c.m4</sourcefile>
      <sourceline>275</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      The test should prove that functions XcpR_RxIndication, XcpR_TriggerTransmit, XcpR_Transmit
      should return XCPR_E_NULL_POINTER if APIs are called with the NULL pointer as parameter.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    XcpRDevErrorDetect is enabled.
  
Test Execution: 
    01. Call XcpR_RxIndication() with NULL pointer.
    02. VP(XcpR.dsn.RxIndication.API.DetOn.ErrorCodeNullPointer): Should report the DET error: XCPR_E_NULL_POINTER.
    03. Call XcpR_TriggerTransmit() with NULL pointer.
    04. VP(XcpR.dsn.TriggerTransmit.API.DetOn.ErrorCodeNullPointer): Should report the DET error: XCPR_E_NULL_POINTER.
    05. Call XcpR_Transmit() with NULL pointer.
    06. VP(XcpR.dsn.Transmit.API.DetOn.ErrorCodeNullPointer): Should report the DET error: XCPR_E_NULL_POINTER.
    07. Call XcpR_GetVersionInfo() with NULL pointer.
    08. VP(XcpR.dsn.GetVersionInfo.API.DetOn.ErrorCodeNullPointer): Should report the DET error: XCPR_E_NULL_POINTER.
    09. Set the result as success.
  
Test Input: None.
Test Output: 
    DET errors "XCPR_E_NULL_POINTER" shall be reported for each erroneous call.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.dsn.RxIndication.API.DetOn.ErrorCodeNullPointer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>445</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.TriggerTransmit.API.DetOn.ErrorCodeNullPointer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>463</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.Transmit.API.DetOn.ErrorCodeNullPointer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>459</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.GetVersionInfo.API.DetOn.ErrorCodeNullPointer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>412</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>481</internalId></specobject>
    <specobject>
      <id>TS_XCPR_DetOn_GetVersionInfoTest</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_DetOn/source/application/EbTest.c.m4</sourcefile>
      <sourceline>354</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      To test the XcpR GetVersionInfo API with valid pointer as parameter.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    XcpRVersionInfoApi is enabled.
  
Test Execution: 
    01. Set version information values preset to invalid values before the call of XcpR_GetVersionInfo.
    02. Call XcpR_GetVersionInfo with a valid pointer.
    03. VP(XcpR.API.GetVersionInfo): Verify the return valuess.
  
Test Input: 
    None
  
Test Output: 
    The version information returned are those that are configured/hardcoded in the module.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.API.GetVersionInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>119</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>482</internalId></specobject>
    <specobject>
      <id>TS_XCPR_DetOn_RxIndication_InvalidPduLength</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_DetOn/source/application/EbTest.c.m4</sourcefile>
      <sourceline>423</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      The test should prove that functions XcpR_RxIndication should return XCPR_E_INVALID_RX_PDU_LENGTH
      in case the length of the PDU is greater than the configured length for incoming PDUs.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    XcpRDetRuntimeChecks is enabled.
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Call XcpR_RxIndication with invalid length for the pdu.
    03. VP(XcpR.dsn.RxIndication.API.DetOn.ErrorCodeInvalidRxLength): Should report the DET error: XCPR_E_INVALID_RX_PDU_LENGTH.
    04. Set the result as success.
  
Test Input: 
  
Test Output: 
    DET error reported with "XCPR_E_INVALID_RX_PDU_LENGTH"
  </description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.DevelopmentErrors</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>142</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.RxIndication.API.DetOn.ErrorCodeInvalidRxLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>443</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>483</internalId></specobject>
    <specobject>
      <id>TS_XCPR_DetOn_Transmit_InvalidPduLength</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_DetOn/source/application/EbTest.c.m4</sourcefile>
      <sourceline>483</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      The test should prove that functions XcpR_Transmit should return XCPR_E_INVALID_TX_PDU_LENGTH
      in case the length of the PDU is greater than the configured length for incoming PDUs.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    XcpRDetRuntimeChecks is enabled.
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Call XcpR_Transmit with invalid length for the pdu.
    03. VP(XcpR.dsn.XcpRTransmit.API.DetOn.ErrorCodeInvalidTxLength): Should report the DET error: XCPR_E_INVALID_TX_PDU_LENGTH.
    04. Set the result as success.
  
Test Input: 
  
Test Output: 
    DET error reported with "XCPR_E_INVALID_TX_PDU_LENGTH"
  </description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.DevelopmentErrors</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>142</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.XcpRTransmit.API.DetOn.ErrorCodeInvalidTxLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>474</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>484</internalId></specobject>
    <specobject>
      <id>TS_XCPR_DetOn_AllAPI_NullPointerData</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_DetOn/source/application/EbTest.c.m4</sourcefile>
      <sourceline>543</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;

    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    XcpRDevErrorDetect is enabled.
  
Test Execution: 
    01. Initialize XcpR Module.
    02. Call XcpR_RxIndication() with NULL pointer for the SDU data.
    03. VP(XcpR.dsn.RxIndication.API.DetOn.ErrorCodeNullPointer): Should report the DET error: XCPR_E_NULL_POINTER.
    04. Call XcpR_Transmit() with NULL pointer for the SDU data.
    05. VP(XcpR.dsn.Transmit.API.DetOn.ErrorCodeNullPointer): Should report the DET error: XCPR_E_NULL_POINTER.
    06. Call XcpR_TriggerTransmit() with NULL pointer for the SDU data.
    07. VP(XcpR.dsn.TriggerTransmit.API.DetOn.ErrorCodeNullPointer): Should report the DET error: XCPR_E_NULL_POINTER.
    08. Set the result as success.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.DevelopmentErrors</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>142</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.RxIndication.API.DetOn.ErrorCodeInvalidPduID</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>442</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.TxConfirmation.API.DetOn.ErrorCodeInvalidPduID</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>465</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.TriggerTransmit.API.DetOn.ErrorCodeInvalidPduID</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>461</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.Transmit.API.DetOn.ErrorCodeInvalidPduID</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>457</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>485</internalId></specobject>
    <specobject>
      <id>TS_XCPR_DetOn_RxIndication_ZeroPduLength</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_DetOn/source/application/EbTest.c.m4</sourcefile>
      <sourceline>620</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      The test should prove that functions XcpR_RxIndication should return XCPR_E_ZERO_RX_PDU_LENGTH
      in case the length of the PDU is greater than the configured length for incoming PDUs.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    XcpRDetRuntimeChecks is enabled.
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Call XcpR_RxIndication with invalid length for the pdu.
    03. VP(XcpR.dsn.RxIndication.API.DetOn.ErrorCodeZeroRxLength): Should report the DET error: XCPR_E_ZERO_RX_PDU_LENGTH.
    04. Set the result as success.
  
Test Input: 
  
Test Output: 
    DET error reported with "XCPR_E_ZERO_RX_PDU_LENGTH"
  </description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.DevelopmentErrors</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>142</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.RxIndication.API.DetOn.ErrorCodeZeroRxLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>447</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>486</internalId></specobject>
    <specobject>
      <id>TS_XCPR_DetOn_Transmit_ZeroPduLength</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_DetOn/source/application/EbTest.c.m4</sourcefile>
      <sourceline>680</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      The test should prove that functions XcpR_Transmit should return XCPR_E_ZERO_TX_PDU_LENGTH
      in case the length of the PDU is greater than the configured length for incoming PDUs.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    XcpRDevErrorDetect is enabled.
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Call XcpR_Transmit with zero length for the pdu.
    03. VP(XcpR.dsn.Transmit.API.DetOn.ErrorCodeZeroTxLength): Should report the DET error: XCPR_E_ZERO_TX_PDU_LENGTH.
    04. Set the result as success.
  
Test Input: 
  
Test Output: 
    DET error reported with "XCPR_E_ZERO_TX_PDU_LENGTH"
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.DevelopmentErrors</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>142</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.Transmit.API.DetOn.ErrorCodeZeroTxLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>460</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>487</internalId></specobject>
    <specobject>
      <id>TS_XCPR_DetOn_Unused_Sources</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_DetOn/source/application/EbTest.c.m4</sourcefile>
      <sourceline>740</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      The test should prove that the XcpR_RxIndication and XcpR_Transmit functions should return XCPR_E_INVALID_ACTIVE_DESTINATION
      when a not linked Pdu id is used.
    &lt;/para&gt;
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    XcpRDetRuntimeChecks is enabled.
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Call XcpR_RxIndication with an UNUSED Master PDU ID.
    03. VP(XcpR.dsn.RxIndication.API.DetOn.ErrorCodeInvalidActiveDestination): Should report the DET error: XCPR_E_INVALID_ACTIVE_DESTINATION
    02. Call XcpR_RxIndication with an UNUSED Remote PDU ID.
    03. VP(XcpR.dsn.RxIndication.API.DetOn.ErrorCodeInvalidActiveDestination): Should report the DET error: XCPR_E_INVALID_ACTIVE_DESTINATION
    04. Call XcpR_RxIndication with an UNUSED Remote PDU ID.
    05. VP(XcpR.dsn.Transmit.API.DetOn.ErrorCodeInvalidActiveDestination): Should report the DET error: XCPR_E_INVALID_ACTIVE_DESTINATION
    06. Set the result as success.
  
Test Input: 
  
Test Output: 
    DET error reported with "XCPR_E_INVALID_ACTIVE_DESTINATION"
  </description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.DevelopmentErrors</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>142</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.RxIndication.API.DetOn.ErrorCodeInvalidActiveDestination</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>440</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.Transmit.API.DetOn.ErrorCodeInvalidActiveDestination</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>456</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>488</internalId></specobject>
    <specobject>
      <id>TS_XCPR_DetOn_InvalidMessageLength_PduHeader</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_DetOn/source/application/EbTest.c.m4</sourcefile>
      <sourceline>820</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      The test should prove that functions XcpR_RxIndication should return XCPR_E_INVALID_MESSAGE_LENGTH
      in case the length of the PDU is less than or equal to PDU header length from configuration.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    XcpRDetRuntimeChecks is enabled.
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Call XcpR_RxIndication with invalid length for the pdu ( is less than or equal to PDU header length from configuration).
        XcpR_RxIndication(TST_XCPR_VALID_PDU, &amp;PduInfo);
    03. VP(XcpR.dsn.RxIndication.API.DetOn.ErrorCodeInvalidMessageHeaderLength): Should report the DET error: XCPR_E_INVALID_MESSAGE_LENGTH.
    04. Set the result as success.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.DevelopmentErrors</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>142</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.RxIndication.API.DetOn.ErrorCodeInvalidMessageHeaderLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>441</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>489</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_XCPR_FlexRay_NoPackedMessage_InvalidPduLength</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_DetOn_NoPackedMessage/source/application/EbTest.c.m4</sourcefile>
      <sourceline>90</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      The test should verify that XcpR should return XCPR_E_INVALID_LENGTH
      in case there is no PDU packed and also not sufficient space for the message.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    XcpRDevErrorDetect is enabled.
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a package consisting in command different than CONNECT command
        on Cdd (XcpR_RxIndication()is called) when no connection is established.
    03. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the Slave is DISCONNECTED.
    04. Simulate reception of a CONNECT command with MODE = 1 on Cdd (XcpR_RxIndication()
        is called and command 0xFF, MODE = 1).
    05. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode): Check that the
        XcpR calls the transmit interface of the lower layer (e.g PM_Tst_Slave_Bus_Type\-::-/Transmit is called and the XCP package
        is the same with the one received from XCP).
    06. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    07. VP(XcpR.Impl.CheckStatusConnection): Verify that the XcpR calls the transmit interface of the lower layer (e.g Cdd_Transmit
        is called and the XCP package is the same with the one received from XCP but header is adapted).
    08. Simulate reception, on Cdd bus, of SET_DAQ_LIST_MODE command.
    09. VP (XcpR.Impl.TransmissionOfConsecutiveMessages) Verify that the package is routed to
        the Xcp instance on the remote ECU in one frame (PM_Tst_Slave_Bus_Type\-::-/Transmit is called ).
    10. Simulate that XCP responses, on FlexRay bus, with a positive response for 
        SET_DAQ_LIST_MODE command (remote Xcp slave calls XcpR_RxIndication).
    11. VP(XcpR.Impl.TransmissionOfConsecutiveMessages): Verify that the XcpR calls the transmit interface
        of the lower layer (e.g Cdd_Transmit is called and the XCP data package is
        the same with the one received from XCP but header is adapted).
    12. Simulate reception, on Cdd bus, of START_DAQ_LIST command.
    13. VP (XcpR.Impl.TransmissionOfConsecutiveMessages) Verify that the package is routed to the Xcp instance on the
        remote ECU in one frame (PM_Tst_Slave_Bus_Type\-::-/Transmit is called ).
    14. Simulate that XCP responses, on FlexRay bus, with a positive response for 
        START_DAQ_LIST command (remote Xcp slave calls XcpR_RxIndication).
    15. VP(XcpR.Impl.TransmissionOfConsecutiveMessages): Verify that the XcpR calls the transmit interface of the
        lower layer (e.g Cdd_Transmit is called and the XCP data package is the same with
        the one received from XCP but header is adapted).
    16. Simulate reception, on Cdd bus, of simulation data package with invalid length.
    17. VP(XcpR.dsn.PackMessage.DetOn.ErrorCodeInvalidLength): Verify that XcpR did NOT send the
        package and reported the runtime error XCPR_E_INVALID_LENGTH because the message does not
        fit in the destination's available length.
    18. Simulate reception, on Cdd bus, of simulation data package with valid length.
    19. VP (XcpR.Impl.TransmissionOfConsecutiveMessages) Verify that the package is routed to the Xcp instance on
        the remote ECU (PM_Tst_Slave_Bus_Type\-::-/Transmit is called ) and no Det error was reported.
    20. Set the result as success.
  
Test Input: 
  
Test Output: 
    DET error reported with "XCPR_E_INVALID_LENGTH"
  </description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.DevelopmentErrors</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>142</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.AdaptBusInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>147</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.PackMessage.DetOn.ErrorCodeInvalidLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>422</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>490</internalId></specobject>
    <specobject>
      <id>TS_XCPR_FlexRay_UnpackedMessage_InvalidPduLength</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_DetOn_NoPackedMessage/source/application/EbTest.c.m4</sourcefile>
      <sourceline>390</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      The test should verify that XcpR should return XCPR_E_INVALID_LENGTH
      in case the unpacked message does not fit in the destination's available length.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    XcpRDevErrorDetect is enabled.
  
Test Execution: 
    01. Call XCPR main processing function before XcpR_Init() function.
    02. VP(XcpR.Impl.MainFunction.InitCheck) Check if the module abort the execution
        without doing anything else.
    03. Initialize stubs and XcpR.
    04. Simulate reception of a package consisting in command different than CONNECT command
        from remote Xcp slave (XcpR_RxIndication() is called) when no connection is established.
    05. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the Slave is DISCONNECTED.
    06. Simulate reception of a CONNECT command with MODE = 1 on Cdd (XcpR_RxIndication()
        is called and command 0xFF, MODE = 1).
    07. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode): Check that the
        XcpR calls the transmit interface of the lower layer (e.g PM_Tst_Slave_Bus_Type\-::-/Transmit is called and the XCP package
        is the same with the one received from XCP).
    08. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    09. VP(XcpR.Impl.CheckStatusConnection, XcpR.Impl.AdaptBusInfo): Verify that the XcpR calls the transmit
        interface of the lower layer (e.g Cdd_Transmit is called and the XCP package is the same with the one
        received from XCP but header is adapted).
    10. Simulate reception, on Cdd bus, of SET_DAQ_LIST_MODE command.
    11. VP (XcpR.Impl.TransmissionOfConsecutiveMessages) Verify that the package is routed to
        the Xcp instance on the remote ECU in one frame (PM_Tst_Slave_Bus_Type\-::-/Transmit is called).
    12. Simulate that XCP responses, on FlexRay bus, with a positive response for 
        SET_DAQ_LIST_MODE command (remote Xcp slave calls XcpR_RxIndication).
    13. VP(XcpR.Impl.TransmissionOfConsecutiveMessages): Verify that the XcpR calls the transmit interface
        of the lower layer (e.g Cdd_Transmit is called and the XCP data package is
        the same with the one received from XCP but header is adapted).
    14. Simulate reception, on Cdd bus, of START_DAQ_LIST command.
    15. VP (XcpR.Impl.TransmissionOfConsecutiveMessages) Verify that the package is routed to the Xcp instance on the
        remote ECU (PM_Tst_Slave_Bus_Type\-::-/Transmit is called ).
    16. Simulate that XCP responses, on FlexRay bus, with a positive response for
        START_DAQ_LIST command (remote Xcp slave calls XcpR_RxIndication).
    17. VP(XcpR.Impl.TransmissionOfConsecutiveMessages): Verify that the XcpR calls the transmit interface of the
        lower layer (e.g Cdd_Transmit is called and the XCP data package is the same with
        the one received from XCP but header is adapted).
    18. Simulate reception, on FlexRay bus, of data acquisition package with invalid length.
    19. VP(XcpR.dsn.PackMessage.DetOn.ErrorCodeInvalidLength): Verify that XcpR did NOT send the
        package and reported the runtime error XCPR_E_INVALID_LENGTH because the message does not fit
        in the destination's available length.
    20. Simulate reception, on FlexRay bus, of data acquisition package with valid length.
    21. VP(XcpR.Impl.TransmissionOfConsecutiveMessages): Verify that the XcpR calls the transmit interface of the
        lower layer (e.g Cdd_Transmit is called and the XCP data package is the same with
        the one received from XCP but header is adapted) and no Det error was reported.
    22. Set the result as success.
  
Test Input: 
  
Test Output: 
    DET error reported with "XCPR_E_INVALID_LENGTH"
  </description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.DevelopmentErrors</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>142</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>491</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_XCPR_SimulateConnectCMD_PosResponse_Mode_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_DifferentBusProtocol/source/application/EbTest.c.m4</sourcefile>
      <sourceline>60</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Check that messages sent from Xcp Master are forwarded to the Xcp Slave
      on the remote ECU only if the connection is established through a CONNECT command.
      * MASTER NETWORK: PM_Tst_Master_Bus_Type
      * REMOTE SLAVE NETWORK: PM_Tst_Slave_Bus_Type
      
m4_ifelse(PM_Permutation,EthTcpToCan,\-:
      Multiple Ethernet master sources are configured. The test verifies that XcpR
      disconnects and then connects using another Ethernet master source, and communication
      is sucessful.
:-/m4_ifelse( :endif: ))
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    01. Call XCPR main processing function before XcpR_Init() function.
    02. VP(XcpR.Impl.MainFunction.InitCheck) Check if the module abort the execution
        without doing anything else.
    03. Initialize stubs and XcpR.
    04. Simulate reception of a package consisting in command different than CONNECT command
        on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called) when no connection is established.
    05. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the slave is DISCONNECTED.
    06. Simulate reception of a CONNECT command with MODE = 1 on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called
        and command 0xFF, MODE = 1).
    07. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode, XcpR.Impl.AdaptBusInfo):
        Check that the XcpR calls the transmit interface of the lower layer (e.g PM_Tst_Slave_Bus_Type\-::-/Transmit is called
        and the XCP package is the same with the one received from  XCP but header is adapted).
    08. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    09. VP(XcpR.Impl.CheckStatusConnection, XcpR.Impl.AdaptBusInfo): Verify that the XcpR calls the transmit
        interface of the lower layer(e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package is the
        same with the one received from XCP).
    10. Simulate confirming the response after PM_Tst_Master_Bus_Type\-::-/Transmit() was processed from step 08.
    11. VP(XcpR.Impl.DoNotForward.TxConfirmation.LowerLayer): Verify that the XcpR does not forward TxConfirmation notifications
        from the master Xcp to the remote slave Xcp.
    12. Simulate reception, on PM_Tst_Master_Bus_Type bus, of a first package consisting in command different than CONNECT command.
    13. Simulate reception, on PM_Tst_Master_Bus_Type bus, of a second package consisting in command different than CONNECT command.
m4_ifelse(PM_Permutation,CanFdToCddDetRuntimeOff,\-:m4_dnl
    14. Check that XcpR does not store a Det runtime error if XcpRDetRuntimeChecks is set to false.
:-/,m4_ifelse( :else: )\-:
    14. VP(XcpR.dsn.ReceptionFromRxIndication.DiscardMessage): Check that XcpR throws the
        runtime error XCPR_E_PDU_BUFFER_FULL because a message was lost because the corresponding Pdu buffer is full.
:-/m4_ifelse( :endif: ))
    15. VP (XcpR.Impl.TransmissionOfConsecutiveMessages, XcpR.Impl.AdaptBusInfo) Verify that only the first command
        is routed to the XCP instance on the remote ECU (PM_Tst_Slave_Bus_Type\-::-/Transmit is called and the XCP package is the
        same with the one received from XCP but header is adapted) and the second package is ignored.
    16. Simulate that XCP responses with a positive response (XcpR_RxIndication is called
        and data equals to GET_STATUS positive response).
    17. VP(XcpR.Impl.TransmissionOfConsecutiveMessages): Verify that the XcpR calls the transmit interface of the lower layer
        (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package is the same with the one received
        from XCP).
    18. Simulate confirming the response after PM_Tst_Master_Bus_Type\-::-/Transmit() was processed from step 16.
    19. VP(XcpR.Impl.DoNotForward.TxConfirmation.LowerLayer): Verify that the XcpR does not forward TxConfirmation notifications
        from the master Xcp to the remote slave Xcp..
    20. Simulate reception, on PM_Tst_Master_Bus_Type bus, of a package consisting in command different than CONNECT command when
        no TxConfirmation is received for previous command to remote Xcp slave.
    21. VP(XcpR.Impl.DestinationProcessing.BusyState): Received package is ignored without any action
        because no TxConfirmation is received from previous command.
    22. Simulate confirming the package after PM_Tst_Slave_Bus_Type\-::-/Transmit() was processed from step 13.
    23. VP (XcpR.Impl.TransmissionOfConsecutiveMessages) Verify that the command is routed to the XCP instance on
        received from XCP but header is adapted).
m4_ifelse(PM_Permutation,EthTcpToCan,\-:
    24. Simulate reception of a package consisting in a DISCONNECT command.
    25. Verify that the command is routed to the XCP instance on the remote ECU
       (CanIf_Transmit is called and the XCP package is the same with the one received from XCP but header is adapted)
    26. Simulate that XCP responses with a positive response (XcpR_RxIndication is called and
         data equals to DISCONNECT positive response)
    27. Verify that the command is routed to the XCP Master
        (SoAdIf_Transmit is called and the XCP package is the same with the one received
        from XCP but header is adapted)
    28. Simulate reception of a CONNECT command with MODE = 1 on SoAd_If (XcpR_RxIndication() is called
        and command 0xFF, MODE = 1)
    29. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode, XcpR.Impl.AdaptBusInfo):
        Check that the XcpR calls the transmit interface of the lower layer (e.g CanIf_Transmit is called
        and the XCP package is the same with the one received from  XCP but header is adapted)
    30. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response)
    31. VP(XcpR.Impl.CheckStatusConnection, XcpR.Impl.AdaptBusInfo): Verify that the XcpR calls the transmit
       interface of the lower layer(e.g SoAd_IfTransmit is called and the XCP package is the
       same with the one received from XCP)
    32. Simulate confirming the response after SoAd_IfTransmit() was processed 
    33. Simulate reception, on Ethernet bus, of a package consisting in command different than CONNECT command
    34. VP (XcpR.Impl.TransmissionOfConsecutiveMessages, XcpR.Impl.AdaptBusInfo) Verify that the command
        is routed to the XCP instance on the remote ECU (Cdd_Transmit is called and the XCP package is the
        same with the one received from XCP but header is adapted)
    35. Simulate that remote XCP responses with a positive response (XcpR_RxIndication is called
        and data equals to GET_STATUS positive response)
    36. VP(XcpR.Impl.TransmissionOfConsecutiveMessages): Verify that the XcpR calls the transmit interface of the lower layer
        (e.g SoAd_IfTransmit is called and the XCP package is the same with the one received
        from XCP)
:-/m4_ifelse( :endif: ))
  Set the result as success.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.BusTypesRemoteConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.MainFunction.InitCheck</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>134</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.AdaptBusInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>147</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DoNotForward.TxConfirmation.LowerLayer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>162</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.ReceptionFromRxIndication.DiscardMessage</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>429</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.ActiveRoutingPath</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>154</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.Transmit.From.Tx.Context.Configuration</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>135</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.SourceProcessing.BusyState</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>132</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.ConfigurableLoweyLayer.CddConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>156</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.Communication.FlexRay.ImmediateAccess</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>137</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.ConnectionGroups.Disabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>166</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>492</internalId></specobject>
    <specobject>
      <id>TS_XCPR_SimulateConnectCMD_NegResponse_Mode_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_DifferentBusProtocol/source/application/EbTest.c.m4</sourcefile>
      <sourceline>541</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Check that messages sent from Xcp Master are NOT forwarded to the Xcp Slave
      on the remote ECU if the connection is not established through a CONNECT command.
      * MASTER NETWORK: PM_Tst_Master_Bus_Type
      * REMOTE SLAVE NETWORK: PM_Tst_Slave_Bus_Type
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a package consisting in command different than CONNECT command
        on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called) when no connection is established.
    03. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because no connection is established.
    04. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    05. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because no connection is established.
    06. Simulate reception of a CONNECT command with MODE = 1 on PM_Tst_Master_Bus_Type (XcpR_RxIndication()
        is called and command 0xFF, MODE = 1).
    07. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode, XcpR.Impl.AdaptBusInfo): Check that the
        XcpR calls the transmit interface of the lower layer (e.g PM_Tst_Slave_Bus_Type\-::-/Transmit is called and
        the XCP package is the same with the one received from XCP but header is adapted).
    08. Simulate a negative response from the XCP on remote ECU (XcpR_RxInidication
        is called with a CONNECT negative response).
m4_ifelse(PM_Permutation,CanFdToCddDetRuntimeOff,\-:m4_dnl
    09. Check that XcpR does not store a Det runtime error if XcpRDetRuntimeChecks is set to false.
:-/,m4_ifelse( :else: )\-:
    09. VP(XcpR.Impl.AdaptBusInfo): Verify that the XcpR calls the transmit interface of the lower layer
         and the runtime error XCPR_E_PDU_LOST is reported.
:-/m4_ifelse( :endif: ))
    10. Simulate reception, on PM_Tst_Master_Bus_Type bus, of a package consisting in command different than CONNECT command.
    11. VP (XcpR.dsn.NegativeResponseConnect.DetOn.ErrorCodePduLost) Received package is ignored without any action.
    12. Set the result as success.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.BusTypesRemoteConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.AdaptBusInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>147</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.NegativeResponseConnect.DetOn.ErrorCodePduLost</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>420</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.Reception.From.Rx.Context.Configuration</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>136</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.ConfigurableLoweyLayer.CddConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>156</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.Communication.FlexRay.ImmediateAccess</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>137</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>493</internalId></specobject>
    <specobject>
      <id>TS_XCPR_SimulateInvalidConnectCMD</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_DifferentBusProtocol/source/application/EbTest.c.m4</sourcefile>
      <sourceline>714</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Check that message sent from Xcp Master are NOT forwarded to the Xcp Slave
      on the remote ECU when XcpR is disconnected and an invalid CONNECT command is used (wrong connection mode is used).
      * MASTER NETWORK: PM_Tst_Master_Bus_Type
      * REMOTE SLAVE NETWORK: PM_Tst_Slave_Bus_Type
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a package consisting in command different than CONNECT command
        on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called) when no connection is established.
    03. Received package is ignored without any action because no connection is established.
    04. Simulate reception of a INVALID CONNECT command with MODE = 5 on PM_Tst_Master_Bus_Type (XcpR_RxIndication()
        is called and command 0xFF, MODE = 5).
m4_ifelse(PM_Permutation,CanFdToCddDetRuntimeOff,\-:m4_dnl
    05. Check that XcpR does not store a Det runtime error if XcpRDetRuntimeChecks is set to false..
:-/,m4_ifelse( :else: )\-:
    05. Check that XcpR throws the runtime error XCPR_E_INVALID_CONNECT_MODE because a CONNECT command with wrong connection mode has been sent.
:-/m4_ifelse( :endif: ))
    06. Simulate reception of a CONNECT command with MODE = 1 on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called
        and command 0xFF, MODE = 1).
    07. Check that the XcpR calls the transmit interface of the lower layer (e.g PM_Tst_Slave_Bus_Type\-::-/Transmit is called
        and the XCP package is the same with the one received from master XCP but header is adapted).
    08. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    09. Verify that the XcpR calls the transmit interface of the lower layer(e.g PM_Tst_Master_Bus_Type\-::-/Transmit
        is called and the XCP package is the same with the one received from remote XCP slave).
    10. Simulate confirming the response after PM_Tst_Master_Bus_Type\-::-/Transmit() was processed.
    11. Simulate reception, on PM_Tst_Master_Bus_Type bus, of a package consisting in command different than CONNECT command.
    12. Verify that the command is routed to the XCP instance on the remote ECU (PM_Tst_Slave_Bus_Type\-::-/Transmit
        is called and the XCP package is the same with the one received from master XCP but header is adapted).
    13. Simulate that remote XCP responses with a positive response (XcpR_RxIndication is called
        and data equals to GET_STATUS positive response).
    14. Verify that the XcpR calls the transmit interface of the lower layer (e.g PM_Tst_Master_Bus_Type\-::-/Transmit
        is called and the XCP package is the same with the one received from remote XCP slave).
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.BusTypesRemoteConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.AdaptBusInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>147</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>494</internalId></specobject>
    <specobject>
      <id>TS_XCPR_SimulateConnectCMD_PosResponse_Mode_0</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_DifferentBusProtocol/source/application/EbTest.c.m4</sourcefile>
      <sourceline>923</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Check that messages sent from Xcp Master are forwarded to the Xcp Slave
      on the local ECU only if the connection is established through a CONNECT command.
      * MASTER NETWORK: PM_Tst_Master_Bus_Type
      * LOCAL SLAVE NETWORK: CDD
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a package consisting in command different than CONNECT command
        on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called) when no connection is established.
    03. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the slave is DISCONNECTED.
    04. Simulate reception of a CONNECT command with MODE = 0 on PM_Tst_Master_Bus_Type ( XcpR_RxIndication() is
        called and command 0xFF, MODE = 0).
    05. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_0, XcpR.Impl.DisconnectedState.ConnectMode): Verify that the XcpR calls
        the indication interface of the upper layer(e.g Xcp_CddRxIndication is called and the XCP package is the same
        with the one received).
    06. Simulate a positive response from the Xcp on local ECU (Xcp calls XcpR_Transmit
        with a CONNECT positive response).
    07. VP(XcpR.Impl.TxConfirmation.UpperLayer): Verify that the XcpR calls the confirmation interface
        of the upper layer (e.g Xcp_CddTxConfirmation is called with the correct Pdu id).
    08. VP(XcpR.Impl.CheckStatusConnection): Verify that the XcpR calls the transmit interface of the lower layer
        (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package is the same with the one received
        from XCP  but header is adapted).
    09. Simulate reception, on PM_Tst_Master_Bus_Type bus, of a package consisting in command different than CONNECT command
        when no TxConfirmation was send after a CONNECT positive response.
    10. VP(XcpR.Impl.SaveConnectedState): Received package is ignored without any action.
    11. Simulate confirming the response after PM_Tst_Master_Bus_Type\-::-/Transmit() was processed from step 06.
    12. Simulate reception, on PM_Tst_Master_Bus_Type bus, of a package consisting in command different than CONNECT command.
    13. VP (XcpR.Impl.TransmissionOfConsecutiveMessages, XcpR.Impl.SaveConnectedState) Verify that the
        command is routed to the Xcp instance on the local ECU (Xcp_CddRxIndication is called and the XCP package
        is the same with the one received from XCP but header is adapted).
    14. Simulate that XCP responses, on CDD bus, with a positive response (Xcp calls XcpR_Transmit
        with GET_STATUS positive response).
    15. VP(XcpR.Impl.TxConfirmation.UpperLayer): Verify that the XcpR calls the confirmation
        interface of the upper layer (e.g Xcp_CddTxConfirmation is called with the correct pdu id).
    16. VP(XcpR.Impl.TransmissionOfConsecutiveMessages): Verify that the XcpR calls the transmit
        interface of the lower layer (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package is
        the same with the one received from XCP).
    17. Simulate confirming the response after PM_Tst_Master_Bus_Type\-::-/Transmit() was processed from step 14.
    18. Set the result as success.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Enabled.TwoDestinationPDUs</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>125</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CddLocalConnectionsOnly</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>149</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_0</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>122</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>153</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.SaveConnectedState</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>158</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TxConfirmation.UpperLayer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>160</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.ActiveRoutingPath</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>154</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.TxConfirmation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>464</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.UpperLayerRxIndicationPduId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>151</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.UpperLayerTxConfirmationPduId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>152</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.PublicHeader</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>141</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>495</internalId></specobject>
    <specobject>
      <id>TS_XCPR_SimulateConnectCMD_NegResponse_Mode_0</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_DifferentBusProtocol/source/application/EbTest.c.m4</sourcefile>
      <sourceline>1141</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Check that messages sent from Xcp Master are NOT forwarded to the Xcp Slave
      on the local ECU if the connection is not established through a CONNECT command.
      * MASTER NETWORK: PM_Tst_Master_Bus_Type
      * LOCAL SLAVE NETWORK: CDD
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a package consisting in command different than CONNECT command
        on PM_Tst_Master_Bus_Type (XcpR_RxIndication()is called) when no connection is established.
    03. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action.
    04. Simulate a positive response from the Xcp on local ECU (Xcp calls XcpR_Transmit
        with a CONNECT positive response).
    05. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action.
    06. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    07. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action.
    08. Simulate reception of a CONNECT command with MODE = 0 on PM_Tst_Master_Bus_Type (XcpR_RxIndication()
        is called and command 0xFF, MODE = 0).
    09. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_0, XcpR.Impl.DisconnectedState.ConnectMode): Check that the XcpR calls
        the indication interface of the upper layer (e.g Xcp_CddRxIndication is called and the XCP package is the same
        with the one received from XCP but header is adapted).
    10. Simulate a negative response from the Xcp local ECU on CDD bus(Xcp calls XcpR_Transmit
        with a CONNECT negative response).
m4_ifelse(PM_Permutation,CanFdToCddDetRuntimeOff,\-:m4_dnl
    11. Check that XcpR does not store a Det runtime error if XcpRDetRuntimeChecks is set to false.
:-/,m4_ifelse( :else: )\-:
    11. VP(XcpR.dsn.NegativeResponseConnect.DetOn.ErrorCodePduLost): Verify that the XcpR calls the transmit
        interface of the lower layer and the runtime error XCPR_E_PDU_LOST is reported.
:-/m4_ifelse( :endif: ))
    12. Simulate reception, on PM_Tst_Master_Bus_Type bus, of a package consisting in command different than CONNECT command.
    13. VP (XcpR.dsn.NegativeResponseConnect.DetOn.ErrorCodePduLost) Received package is ignored without any action.
    14. Set the result as success.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Enabled.TwoDestinationPDUs</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>125</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CddLocalConnectionsOnly</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>149</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_0</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>122</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>153</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.NegativeResponseConnect.DetOn.ErrorCodePduLost</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>420</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.ActiveRoutingPath</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>154</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.TxConfirmation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>464</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.UpperLayerRxIndicationPduId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>151</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.UpperLayerTxConfirmationPduId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>152</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>496</internalId></specobject>
    <specobject>
      <id>TS_XCPR_ChangeMode_SwitchRemoteXcpToLocalXcp</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_DifferentBusProtocol/source/application/EbTest.c.m4</sourcefile>
      <sourceline>1324</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Verify that XcpR can connect with the local Xcp slave after disconnecting from the remote Xcp slave.
      * MASTER NETWORK: PM_Tst_Master_Bus_Type
      * LOCAL SLAVE NETWORK: CDD
      * REMOTE SLAVE NETWORK: PM_Tst_Slave_Bus_Type
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a package consisting in command different than CONNECT command
        on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called) when no connection is established.
    03. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action.
    04. Simulate reception of a CONNECT command with MODE = 1 on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called
        and command 0xFF, MODE = 1).
    05. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode, XcpR.Impl.DisconnectedState.ConnectMode): Check that the XcpR calls
        the transmit interface of the lower layer (e.g PM_Tst_Slave_Bus_Type\-::-/Transmit is called and the XCP package
        is the same with the one received from XCP but header is adapted).
    06. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    07. VP(XcpR.Impl.CheckStatusConnection): Verify that the XcpR calls the transmit interface
        of the lower layer (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package is the same
        with the one received from XCP).
    08. Simulate confirming the response after PM_Tst_Master_Bus_Type\-::-/Transmit() was processed from step 06.
    09. VP(XcpR.Impl.DoNotForward.TxConfirmation.LowerLayer): Verify that the XcpR does not forward TxConfirmation
        notifications from the master Xcp to the remote slave Xcp..
    10. Simulate reception of a package consisting in a DISCONNECT command.
    11. VP (XcpR.Impl.TransmissionOfConsecutiveMessages) Verify that the command
        is routed to the XCP instance on the remote ECU (Cdd_Transmit is called and the XCP package is the same with
        the one received from XCP but header is adapted).
    12. Simulate that XCP responses with a positive response (XcpR_RxIndication is called and
        data equals to DISCONNECT positive response).
    13. VP (XcpR.Impl.ResetRoutingPath) Verify that the command is routed to the XCP Master
        (PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package is the same with the one received
        from XCP but header is adapted).
    14. Simulate reception, on PM_Tst_Master_Bus_Type bus, of a CONNECT command with MODE = 0 (XcpR_RxIndication()
        is called and command 0xFF, MODE = 0).
    15. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_0, XcpR.Impl.DisconnectedState.ConnectMode): Verify that the XcpR
        calls the indication interface of the upper layer (e.g Xcp_CddRxIndication is called and the XCP package is
        the same with the one received).
    16. Simulate a positive response from the XCP on local ECU (XCP calls XcpR_Transmit
        with a CONNECT positive response).
    17. VP(XcpR.Impl.TxConfirmation.UpperLayer): Verify that the XcpR calls the confirmation interface
        of the upper layer (e.g Xcp_CddTxConfirmation is called with the correct pdu id).
    18. VP(XcpR.Impl.CheckStatusConnection, XcpR.Impl.AdaptBusInfo): Verify that the XcpR calls the transmit
        interface of the lower layer (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package is the
        same with the one received from XCP  but header is adapted).
    19. Simulate confirming the response after PM_Tst_Master_Bus_Type\-::-/Transmit() was processed from step 16.
    20. Set the result as success.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Enabled.TwoDestinationPDUs</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>125</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CddLocalConnectionsOnly</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>149</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.BusTypesRemoteConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.ReceiveFromLocalSlave</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>426</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.ReceiveFromMaster</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>427</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.ReceiveFromRemoteSlave</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>428</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>153</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DoNotForward.TxConfirmation.LowerLayer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>162</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.ResetRoutingPath</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>159</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_0</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>122</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TxConfirmation.UpperLayer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>160</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.TxConfirmation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>464</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.Reception.From.Rx.Context.Configuration</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>136</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.UpperLayerRxIndicationPduId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>151</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.UpperLayerTxConfirmationPduId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>152</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.ConfigurableLoweyLayer.CddConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>156</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>497</internalId></specobject>
    <specobject>
      <id>TS_XCPR_SwitchConections</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_DifferentBusProtocol/source/application/EbTest.c.m4</sourcefile>
      <sourceline>1589</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para
      Verify that the connection state is still CONNECTED after receiving a NEGATIVE response
      for a DISCONNECT command.
      Verify that a new connection with remote Xcp slave can be established after receiving a
      POSITIVE response for a DISCONNECT command with the local Xcp slave.
      * MASTER NETWORK: PM_Tst_Master_Bus_Type
      * LOCAL SLAVE NETWORK: CDD
      * REMOTE SLAVE NETWORK: PM_Tst_Slave_Bus_Type
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a package consisting in command different than CONNECT command
        on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called) when no connection is established.
    03. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the slave is DISCONNECTED.
    04. Simulate reception of a CONNECT command with MODE = 0 on PM_Tst_Master_Bus_Type ( XcpR_RxIndication() is
        called and command 0xFF, MODE = 0).
    05. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_0): Verify that the XcpR calls the indication
        interface of the upper layer (e.g Xcp_CddRxIndication is called and the XCP package is the
        same with the one received).
    06. Simulate a positive response from the Xcp on local ECU (Xcp calls XcpR_Transmit
        with a CONNECT positive response).
    07. VP(XcpR.Impl.TxConfirmation.UpperLayer): Verify that the XcpR calls the confirmation
        interface of the upper layer (e.g Xcp_CddTxConfirmation is called with the correct Pdu id).
    08. VP(XcpR.Impl.CheckStatusConnection): Verify that the XcpR calls the transmit interface of the lower layer
        (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package is the same with the one received
        from XCP  but header is adapted).
    09. Simulate confirming the response after PM_Tst_Master_Bus_Type\-::-/Transmit()
        was processed from step 06.
    10. Simulate reception of a package consisting in a DISCONNECT command.
    11. VP (XcpR.Impl.TransmissionOfConsecutiveMessages) Verify
        that the command is routed to the XCP instance on the remote ECU (Cdd_Transmit is called and the
        XCP package is the same with the one received from XCP but header is adapted).
    12. Simulate that XCP responses with a positive response (XcpR_RxIndication is called and
        data equals to DISCONNECT negative response).
    13. VP(XcpR.Impl.TxConfirmation.UpperLayer): Verify that the XcpR calls the confirmation interface
        of the upper layer (e.g Xcp_CddTxConfirmation is called with the correct pdu id).
    14. VP (XcpR.Impl.TransmissionOfConsecutiveMessages) Verify that the XcpR calls the transmit interface
        of the lower layer (PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package is the same with the
        one received from XCP but header is adapted).
    15. Simulate confirming the response after PM_Tst_Master_Bus_Type\-::-/Transmit() was processed from step 12.
    16. Simulate reception, on PM_Tst_Master_Bus_Type bus, of a package consisting in command different than CONNECT command.
    17. VP (XcpR.Impl.TransmissionOfConsecutiveMessages, XcpR.dsn.NegativeResponseDisconnect.DetOn.ErrorCodePduLost) Verify
        that the command is routed to the Xcp instance on the local ECU (Xcp_CddRxIndication is called and the XCP package
        is the same with the one received from XCP but header is adapted).
    18. Simulate that XCP responses, on CDD bus, with a positive response (Xcp calls XcpR_Transmit
        with GET_STATUS positive response).
    19. VP(XcpR.Impl.TxConfirmation.UpperLayer): Verify that the XcpR calls the confirmation interface of the
        upper layer (e.g Xcp_CddTxConfirmation is called with the correct pdu id).
    20. VP(XcpR.Impl.TransmissionOfConsecutiveMessages): Verify that the XcpR calls the transmit interface
        of the lower layer (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package is the same with
        the one received from XCP).
    21. Simulate confirming the response after PM_Tst_Master_Bus_Type\-::-/Transmit() was processed from step 18.
    22. Simulate reception of a package consisting in a DISCONNECT command.
    23. VP (XcpR.Impl.TransmissionOfConsecutiveMessages) Verify that the command is routed to the
        the one received from XCP but header is adapted).
    24. Simulate that XCP responses with a positive response (XcpR_Transmit and
        data equals to DISCONNECT positive response).
    25. VP(XcpR.Impl.TxConfirmation.UpperLayer): Verify that the XcpR calls the confirmation interface
        of the upper layer (e.g Xcp_CddTxConfirmation is called with the correct pdu id).
    26. VP (XcpR.Impl.TransmissionOfConsecutiveMessages) Verify that the XcpR calls the transmit interface
        of the lower layer (PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package is the same with the
        one received from XCP but header is adapted).
    27. Simulate confirming the response after PM_Tst_Master_Bus_Type\-::-/Transmit() was processed from step 24.
    28. Simulate reception of a package consisting in command different than CONNECT command
        on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called) when no connection is established.
    29. VP(XcpR.Impl.DisconnectedState.CommandResponse, XcpR.Impl.ResetRoutingPath): Received package is ignored without any action.
    30. Simulate reception of a CONNECT command with MODE = 1 on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called
        and command 0xFF, MODE = 1).
    31. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode): Check that the XcpR calls
        the transmit interface of the lower layer (e.g PM_Tst_Slave_Bus_Type\-::-/Transmit is called and the XCP package is
        the same with the one received from XCP but header is adapted).
    32. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    33. VP(XcpR.Impl.CheckStatusConnection): Verify that the XcpR calls the
        transmit interface of the lower layer (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and
        the XCP package is the same with the one received from XCP).
    35. Simulate confirming the response after PM_Tst_Master_Bus_Type\-::-/Transmit() was processed from step 32.
    36. VP(XcpR.Impl.DoNotForward.TxConfirmation.LowerLayer): Verify that the XcpR does not forward TxConfirmation notifications
        from the master Xcp to the remote slave Xcp.
    37. Set the result as success.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Enabled.TwoDestinationPDUs</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>125</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CddLocalConnectionsOnly</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>149</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.BusTypesRemoteConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.ReceiveFromLocalSlave</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>426</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.ReceiveFromMaster</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>427</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.ReceiveFromRemoteSlave</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>428</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.ResetRoutingPath</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>159</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_0</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>122</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TxConfirmation.UpperLayer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>160</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DoNotForward.TxConfirmation.LowerLayer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>162</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.TxConfirmation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>464</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>498</internalId></specobject>
    <specobject>
      <id>TS_XCPR_NewCONNECTCmd_RemoteXcpSlave</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_DifferentBusProtocol/source/application/EbTest.c.m4</sourcefile>
      <sourceline>1995</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Check that after the connection is established with remote Xcp slave, a new CONNECT command
      will be forwarded to the remote Xcp slave.(whether the new CONNECT command is the same or different MODE)
      * MASTER NETWORK: PM_Tst_Master_Bus_Type
      * REMOTE SLAVE NETWORK: PM_Tst_Slave_Bus_Type
      * LOCAL SLAVE NETWORK: CDD
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a package consisting in command different than CONNECT command
        on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called) when no connection is established.
    03. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the slave is DISCONNECTED.
    04. Simulate reception of a CONNECT command with MODE = 1 on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called
        and command 0xFF, MODE = 1).
    05. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode, XcpR.Impl.AdaptBusInfo):
        Check that the XcpR calls the transmit interface of the lower layer (e.g PM_Tst_Slave_Bus_Type\-::-/Transmit is called
        and the XCP package is the same with the one received from  XCP but header is adapted).
    06. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    07. VP(XcpR.Impl.CheckStatusConnection, XcpR.Impl.AdaptBusInfo): Verify that the XcpR calls the transmit
        interface of the lower layer(e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package is the
        same with the one received from XCP).
    08. Simulate reception of a new CONNECT command with MODE = 1 on PM_Tst_Master_Bus_Type when
        connection is already established.
    09. VP(XcpR.Impl.AdaptBusInfo): Verify that the XcpR calls the transmit
        interface of the lower layer and the CONNECT command is forwarded to the remote Xcp slave.
    10. Simulate reception of a new CONNECT command with MODE = 0 on PM_Tst_Master_Bus_Type when
      connection is already established.
    11. VP(XcpR.Impl.AdaptBusInfo): Verify that the XcpR calls the transmit
        interface of the lower layer and the CONNECT command is forwarded to the remote Xcp slave.
    12. Set the result as success.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.BusTypesRemoteConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.AdaptBusInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>147</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>499</internalId></specobject>
    <specobject>
      <id>TS_XCPR_NewCONNECTCmd_LocalXcpSlave</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_DifferentBusProtocol/source/application/EbTest.c.m4</sourcefile>
      <sourceline>2176</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Check that after the connection is established with local Xcp slave, a new CONNECT command
      will be forwarded to the local Xcp slave.(whether the new CONNECT command is the same or different MODE)
      * MASTER NETWORK: PM_Tst_Master_Bus_Type
      * REMOTE SLAVE NETWORK: PM_Tst_Slave_Bus_Type
      * LOCAL SLAVE NETWORK: CDD
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a package consisting in command different than CONNECT command
        on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called) when no connection is established.
    03. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the slave is DISCONNECTED.
    04. Simulate reception of a CONNECT command with MODE = 0 on PM_Tst_Master_Bus_Type ( XcpR_RxIndication() is
        called and command 0xFF, MODE = 0).
    05. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_0, XcpR.Impl.DisconnectedState.ConnectMode): Verify that the XcpR calls
        the indication interface of the upper layer(e.g Xcp_CddRxIndication is called and the XCP package is the same
        with the one received).
    06. Simulate a positive response from the Xcp on local ECU (Xcp calls XcpR_Transmit
        with a CONNECT positive response).
    07. VP(XcpR.Impl.CheckStatusConnection): Verify that the XcpR calls the transmit interface of the lower layer
        (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package is the same with the one received
        from XCP  but header is adapted).
    08. Simulate reception of a new CONNECT command with MODE = 1 on PM_Tst_Master_Bus_Type when
        connection is already established.
    09. VP (XcpR.Impl.TransmissionOfConsecutiveMessages, XcpR.Impl.SaveConnectedState) Verify that the
        new CONNECT command is routed to the Xcp instance on the local ECU (Xcp_CddRxIndication is called and the XCP package
        is the same with the one received from XCP but header is adapted).
    10. Simulate reception of a new CONNECT command with MODE = 0 on PM_Tst_Master_Bus_Type when
        connection is already established.
    11. VP (XcpR.Impl.TransmissionOfConsecutiveMessages, XcpR.Impl.SaveConnectedState) Verify that the
        new CONNECT command is routed to the Xcp instance on the local ECU (Xcp_CddRxIndication is called
        and the XCP package is the same with the one received from XCP but header is adapted).
    12. Set the result as success.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.CddLocalConnectionsOnly</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>149</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_0</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>122</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>153</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.SaveConnectedState</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>158</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>500</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_XCPR_InternalQueue_DifferentDestinations</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_DifferentDestinations/source/application/EbTest.c</sourcefile>
      <sourceline>73</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Verify the scenario where the XcpR internal queue contains 2 messages with different
      destinations and are both processed during the same call of XcpR_MainFunction().
      Check that during XcpR_MainFunction(), after the first message is dequeued, considering 
      its Tx buffer is locked (isBufferFullFlag), the second message is not impacted by
      this locked Tx buffer and it is dequeued and processed since it has a different destination.
      * MASTER NETWORK: CanIf;
      * REMOTE SLAVE NETWORK: Cdd;
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    01. Call XCPR main processing function before XcpR_Init() function.
    02. VP(XcpR.Impl.MainFunction.InitCheck) Check if the module aborts the execution
        without doing anything else.
    03. Initialize stubs and XcpR.
    04. Simulate reception of a package consisting in command different than CONNECT command
        on CanIf (XcpR_RxIndication() is called) when no connection is established.
    05. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the slave is DISCONNECTED.
    06. Simulate reception of a CONNECT command with MODE = 1 on CanIf (XcpR_RxIndication() is called
        and command 0xFF, MODE = 1).
    07. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode,
        XcpR.Impl.AdaptBusInfo): Check that the XcpR calls the transmit interface of the lower layer
        (e.g Cdd_Transmit is called and the XCP package is the same with the one received from  XCP
        but header is adapted).
    08. Confirm the transmission after Cdd_Transmit() from step 6.
    09. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    10. VP(XcpR.Impl.CheckStatusConnection, XcpR.Impl.AdaptBusInfo): Verify that the XcpR calls the transmit
        interface of the lower layer(e.g CanIf_Transmit is called and the XCP package is the
        same with the one received from XCP).
    11. Confirm the transmission after CanIf_Transmit() from step 9.
    12. Simulate reception, on CanIf bus, of a first package consisting in a GetStatus command
    13. Check that the XcpR calls the transmit interface of the lower layer (e.g Cdd_Transmit is called
        and the XCP package is the same with the one received from  XCP but header is adapted).
    14. Confirm the transmission after CanIf_Transmit() from step 12.
    15. Simulate reception, on CanIf bus, of a second package consisting in a GetId command (no Tx confirmation
        yet - Tx buffer is full)
    16. The previous GetId command is not sent yet, instead a positive response from the GetStatus command is
        simulated. At this point, the XcpR internal queue contains 2 messages with different destinations.
    17. Process both messages with different destinations. The first sent message is GetId from Xcp Master to Xcp 
        Slave and the second message is the positive response for the GetStatus command, from Xcp Slave to Xcp Master.
    18. Verify that the first message was processed correctly: package length and data for the GetId command
    19. Verify that the second message was processed correctly: package length and data for the positive response of
        the GetStatus command.
    20. Confirm transmission of the first package.
    21. Confirm transmission of the second package.
    22. Set the result as success.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.BusTypesRemoteConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.PrecompileTimeConfig</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>423</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.MainFunction.InitCheck</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>134</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.AdaptBusInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>147</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.ActiveRoutingPath</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>154</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DestinationProcessing.BusyState</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>133</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.ConfigurableLoweyLayer.CddConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>156</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.Communication.FlexRay.ImmediateAccess</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>137</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.PublicHeader</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>141</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.ConnectionGroups.Enabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>167</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>501</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_XCPR_XcpRSoAdSoConModeChg_ONLINE_MasterToRemote</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_EthTcp_Master_SoConModeChg/source/application/EbTest.c.m4</sourcefile>
      <sourceline>98</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Check that the connection remains established when the XcpR_SoAdSoConModeChg function is called with ONLINE
      MODE for master Xcp and the subsequent messages are forwarded between master and remote Xcp.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    01. Call XcpR_SoAdSoConModeChg with mode ONLINE for Xcp master without initializing XcpR.
m4_ifelse(PM_Permutation,EthTcpToEthUdpRuntimeOff,\-:m4_dnl
    02. Check that XcpR does not store a Det runtime error if XcpRDetRuntimeChecks is set to false.
:-/,m4_ifelse( :else: )\-:
    02. VP(XcpR.dsn.SoAdSoConModeChg.API.DetOn.ErrorCodeNotInitialized): Check that XcpR_SoAdSoConModeChg() throws
        the runtime error XCPR_E_NOT_INITIALIZED.
:-/m4_ifelse( :endif: ))
    03. Simulate reception of a package consisting in command different than CONNECT command
        on Ethernet (XcpR_RxIndication() is called) when no connection is established.
    04. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the slave is DISCONNECTED.
    05. Initialize stubs and XcpR.
    06. Simulate reception of a CONNECT command with MODE = 1 on Ethernet (XcpR_RxIndication() is called
        and command 0xFF, MODE = 1).
    07. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode, XcpR.Impl.AdaptBusInfo):
        Check that the XcpR calls the transmit interface of the lower layer (e.g PM_Tst_Slave_Bus_Type\-::-/Transmit is called
        and the XCP package is the same with the one received from  XCP but header is adapted).
    08. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    09. VP(XcpR.Impl.CheckStatusConnection, XcpR.Impl.AdaptBusInfo): Verify that the XcpR calls the transmit
        interface of the lower layer(e.g SoAd_IfTransmit is called and the XCP package is the
        same with the one received from XCP).
    10. Call XcpR_SoAdSoConModeChg with mode ONLINE for Xcp master.
    11. VP: No Det errors were reported.
    12. Simulate reception, on Ethernet bus, of a package consisting in command different than CONNECT command.
    13. VP (XcpR.Impl.TransmissionOfConsecutiveMessages, XcpR.Impl.AdaptBusInfo) Verify that the command
        is routed to the XCP instance on the remote ECU (PM_Tst_Slave_Bus_Type\-::-/Transmit is called and the XCP package is the
        same with the one received from XCP but header is adapted).
    14. Simulate that remote XCP responses with a positive response (XcpR_RxIndication is called
        and data equals to GET_STATUS positive response).
    15. VP(XcpR.Impl.TransmissionOfConsecutiveMessages): Verify that the XcpR calls the transmit interface of the lower layer
        (e.g SoAd_IfTransmit is called and the XCP package is the same with the one received
        from XCP).
    16. Set the result as success.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.BusTypesRemoteConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.SoAdSoConModeChg.API.DetOn.ErrorCodeNotInitialized</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>450</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.AdaptBusInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>147</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>XcpR.Ethernet.Header.DataLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>174</internalId></provcov>
        <provcov>
          <linksto>XcpR.Ethernet.Header.Ctr</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>175</internalId></provcov>
        <provcov>
          <linksto>XcpR.Ethernet.SoAdAPIs</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>173</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>502</internalId></specobject>
    <specobject>
      <id>TS_XCPR_XcpRSoAdSoConModeChg_OFFLINE_MasterToRemote</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_EthTcp_Master_SoConModeChg/source/application/EbTest.c.m4</sourcefile>
      <sourceline>309</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Test the closing of the master Xcp ethernet socket while the connection is established.
      Verifies that the connection is closed after the XcpR_SoAdSoConModeChg function is called with OFFLINE mode
      and the subsequent messages are not forwarded between master and remote Xcp.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a CONNECT command with MODE = 1 on Ethernet (XcpR_RxIndication() is called
        and command 0xFF, MODE = 1).
    03. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode, XcpR.Impl.AdaptBusInfo):
        Check that the XcpR calls the transmit interface of the lower layer (e.g SoAd_IfTransmit is called
        and the XCP package is the same with the one received from  XCP but header is adapted).
    04. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    05. VP(XcpR.Impl.CheckStatusConnection, XcpR.Impl.AdaptBusInfo): Verify that the XcpR calls the transmit
        interface of the lower layer(e.g SoAd_IfTransmit is called and the XCP package is the
        same with the one received from XCP remote).
    06. Call XcpR_SoAdSoConModeChg with mode OFFLINE for Xcp master.
    07. VP(XcpR.dsn.BusMonitor.SendSessionTerminatedEvent): Verify the session terminated
        event was sent (XcpR calls the transmit interface of the lower layer, e.g SoAd_IfTransmit is called).
    08. VP (XcpR.Ethernet.Tcp.SoConModeChg.Disconnect) Verify that the DISCONNECT command is routed to
        the XCP instance on the remote ECU (PM_Tst_Slave_Bus_Type\-::-/Transmit is called).
    09. Simulate that XCP responses with a positive response (XcpR_RxIndication is called and
        data equals to DISCONNECT positive response).
    10. Verify that the DISCONNECT response is not forwarded to Xcp master.
    11. Simulate reception of a package consisting in command different than CONNECT command
        on master bus (XcpR_RxIndication() is called) when no connection is established.
    12. VP(XcpR.Impl.DisconnectedState.CommandResponse, XcpR.Ethernet.Tcp.SoConModeChg.Disconnect): Received package
        is ignored without any action because the slave is DISCONNECTED.
    13. Set the result as success.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.BusTypesRemoteConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.AdaptBusInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>147</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.BusMonitor.SendSessionTerminatedEvent</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>405</internalId></provcov>
        <provcov>
          <linksto>XcpR.Ethernet.Tcp.SoConModeChg.Disconnect</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>176</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Ethernet.Header.DataLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>174</internalId></provcov>
        <provcov>
          <linksto>XcpR.Ethernet.Header.Ctr</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>175</internalId></provcov>
        <provcov>
          <linksto>XcpR.Ethernet.SoAdAPIs</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>173</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>503</internalId></specobject>
    <specobject>
      <id>TS_XCPR_XcpRSoAdSoConModeChg_WrongId_MasterToRemote</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_EthTcp_Master_SoConModeChg/source/application/EbTest.c.m4</sourcefile>
      <sourceline>499</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Test the closing of the master Xcp ethernet socket while the connection is established.
      Check that if the XcpR_SoAdSoConModeChg function is called with OFFLINE mode having a wrong socket connection id,
      the connection remains established. The subsequent messages are forwarded between master and remote Xcp.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a CONNECT command with MODE = 1 on Ethernet (XcpR_RxIndication() is called
        and command 0xFF, MODE = 1).
    03. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode, XcpR.Impl.AdaptBusInfo):
        Check that the XcpR calls the transmit interface of the lower layer (e.g SoAd_IfTransmit is called
        and the XCP package is the same with the one received from  XCP but header is adapted).
    04. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    05. VP(XcpR.Impl.CheckStatusConnection, XcpR.Impl.AdaptBusInfo): Verify that the XcpR calls the transmit
        interface of the lower layer(e.g PM_Tst_Slave_Bus_Type\-::-/Transmit is called and the XCP package is the
        same with the one received from XCP).
    06. Call XcpR_SoAdSoConModeChg with mode SOAD_SOCON_OFFLINE but with wrong SoConId.
    07. Simulate reception, on Ethernet bus, of a package consisting in command different than CONNECT command.
    08. VP (XcpR.Impl.TransmissionOfConsecutiveMessages, XcpR.Impl.AdaptBusInfo) Verify that the command
        is routed to the XCP instance on the remote ECU. The connection is still established because XcpR_SoAdSoConModeChg
        was called with wrong SoConId.
    09. Call XcpR_SoAdSoConModeChg with mode SOAD_SOCON_OFFLINE for Xcp master.
    10. VP(XcpR.dsn.BusMonitor.SendSessionTerminatedEvent): Verify the session terminated
        event was sent (XcpR calls the transmit interface of the lower layer, e.g SoAd_IfTransmit is called).
    11. VP (XcpR.Ethernet.Tcp.SoConModeChg.Disconnect) Verify that the DISCONNECT command is routed to
        the XCP instance on the remote ECU (PM_Tst_Slave_Bus_Type\-::-/Transmit is called).
    12. Simulate that XCP responses with a positive response (XcpR_RxIndication is called and
        data equals to DISCONNECT positive response).
    13. Verify that the DISCONNECT response is not forwarded to Xcp master.
    14. Simulate reception of a package consisting in command different than CONNECT command
        on master bus (XcpR_RxIndication() is called) when no connection is established.
    15. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the slave is DISCONNECTED.
    16. Set the result as success.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.BusTypesRemoteConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.AdaptBusInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>147</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.BusMonitor.SendSessionTerminatedEvent</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>405</internalId></provcov>
        <provcov>
          <linksto>XcpR.Ethernet.Tcp.SoConModeChg.Disconnect</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>176</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Ethernet.Header.DataLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>174</internalId></provcov>
        <provcov>
          <linksto>XcpR.Ethernet.Header.Ctr</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>175</internalId></provcov>
        <provcov>
          <linksto>XcpR.Ethernet.SoAdAPIs</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>173</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>504</internalId></specobject>
    <specobject>
      <id>TS_XCPR_XcpRSoAdSoConModeChg_NoConnectionEstablished</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_EthTcp_Master_SoConModeChg/source/application/EbTest.c.m4</sourcefile>
      <sourceline>722</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Check that when the XcpR_SoAdSoConModeChg function is called with ONLINE/OFFLINE mode, no Det errors are reported
      or any messages are transmitted if XcpR is initialized and there is no connection established.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a package consisting in command different than CONNECT command
        on master bus (XcpR_RxIndication() is called) when no connection is established.
    03. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the slave is DISCONNECTED.
    04. Call XcpR_SoAdSoConModeChg with mode SOAD_SOCON_OFFLINE for Xcp master.
    05. Call XcpR_SoAdSoConModeChg with mode SOAD_SOCON_ONLINE for Xcp master.
    06. Call XcpR_SoAdSoConModeChg with mode SOAD_SOCON_RECONNECT for Xcp master.
    07. VP: No Det errors are reported or any messages are transmitted.
    08. Set the result as success.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.BusTypesRemoteConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>505</internalId></specobject>
    <specobject>
      <id>TS_XCPR_OpenSocketConnection_FAILED</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_EthTcp_Master_SoConModeChg/source/application/EbTest.c.m4</sourcefile>
      <sourceline>816</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Verify that the XcpR does NOT forward any message when SoAd_OpenSoCon returns
      value being E_NOT_OK, in turn XcpR_InitSoAdConnections.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    01. Set SoAd_OpenSoCon return value to E_NOT_OK.
    02. Initialize stubs and XcpR.
    03. Simulate reception of a CONNECT command with MODE = 1 on Ethernet (XcpR_RxIndication() is called
        and command 0xFF, MODE = 1).
    05. VP: Received package is ignored without any action because the SoAd could not open the socket connections.
    04. Simulate reception of a package consisting in command different than CONNECT command
        on Ethernet (XcpR_RxIndication() is called) when no connection is established.
    05. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the slave is DISCONNECTED.
    06. Set SoAd_OpenSoCon return value to E_OK.
    07. Initialize stubs and XcpR.
    08. Simulate reception of a CONNECT command with MODE = 1 on Ethernet (XcpR_RxIndication() is called
        and command 0xFF, MODE = 1).
    09. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode, XcpR.Impl.AdaptBusInfo):
        Check that the XcpR calls the transmit interface of the lower layer (e.g SoAd_IfTransmit is called
        and the XCP package is the same with the one received from  XCP but header is adapted).
    10. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    11. VP(XcpR.Impl.CheckStatusConnection, XcpR.Impl.AdaptBusInfo): Verify that the XcpR calls the transmit
        interface of the lower layer(e.g PM_Tst_Slave_Bus_Type\-::-/Transmit is called and the XCP package is the
        same with the one received from XCP).
    12. Simulate reception, on Ethernet bus, of a package consisting in command different than CONNECT command.
    13. VP (XcpR.Impl.TransmissionOfConsecutiveMessages, XcpR.Impl.AdaptBusInfo) Verify that the command
        is routed to the XCP instance on the remote ECU. The connection is still established because XcpR_SoAdSoConModeChg
        was called with wrong SoConId.
    14. Simulate that remote XCP responses with a positive response (XcpR_RxIndication is called
        and data equals to GET_STATUS positive response).
    15. VP(XcpR.Impl.TransmissionOfConsecutiveMessages): Verify that the XcpR calls the transmit interface of the lower layer
        (e.g SoAd_IfTransmit is called and the XCP package is the same with the one received
        from XCP).
    16. Set the result as success.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.BusTypesRemoteConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.AdaptBusInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>147</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>506</internalId></specobject>
    <specobject>
      <id>TS_XCPR_TcpIp_CannotGetRemoteAddress</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_EthTcp_Master_SoConModeChg/source/application/EbTest.c.m4</sourcefile>
      <sourceline>1044</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      XcpR is connected to the master Xcp via TcpIp.
      Verify that XcpR will perform an autonomous disconnect if it can't get the remote address of a socket connection.
      (The communication will be stopped)
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Set SoAd_GetRemoteAddr return value to E_NOT_OK.
    03. Simulate reception of a CONNECT command with MODE = 1 on Ethernet (XcpR_RxIndication() is called
        and command 0xFF, MODE = 1).
    04. VP: Verify that no message is sent neither to master or remote slave.
    05. Simulate reception of a package consisting in command different than CONNECT command
        on master bus (XcpR_RxIndication() is called) when no connection is established  and
        SoAd_SetRemoteAddr return value to E_NOT_OK
    06. VP: Verify that no message is sent neither to master or remote slave.
    07. Set SoAd_GetRemoteAddr return value to E_OK.
    08. Simulate reception of a CONNECT command with MODE = 1 on Ethernet (XcpR_RxIndication() is called
        and command 0xFF, MODE = 1).
    09. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode, XcpR.Impl.AdaptBusInfo):
        Check that the XcpR calls the transmit interface of the lower layer (e.g PM_Tst_Slave_Bus_Type\-::-/Transmit is called
        and the XCP package is the same with the one received from  XCP but header is adapted).
    10. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    11. VP(XcpR.Impl.CheckStatusConnection, XcpR.Impl.AdaptBusInfo): Verify that the XcpR calls the transmit
        interface of the lower layer(e.g SoAd_IfTransmit is called and the XCP package is the
        same with the one received from XCP).
    12. Change address after XcpR is CONNECTED and try to send another message.
    13. Simulate reception, on Ethernet bus, of a package consisting in command different than CONNECT command
    14. VP: Verify that no message is sent neither to master or remote slave
    15. Change address back to the one used by XcpR after it is CONNECTED, but use another port
    16. Simulate reception, on Ethernet bus, of a package consisting in command different than CONNECT command
    17. VP: Verify that no message is sent neither to master or remote slave
    18. Change address and port back to initial values
    19. Simulate reception, on Ethernet bus, of a package consisting in command different than CONNECT command.
    20. VP (XcpR.Impl.TransmissionOfConsecutiveMessages, XcpR.Impl.AdaptBusInfo) Verify that the command
        is routed to the XCP instance on the remote ECU (PM_Tst_Slave_Bus_Type\-::-/Transmit is called and the XCP package is the
        same with the one received from XCP but header is adapted).
    21. Simulate that XCP responses with a positive response (XcpR_RxIndication is called
        and data equals to GET_STATUS positive response).
    22. VP(XcpR.Impl.TransmissionOfConsecutiveMessages): Verify that the XcpR calls the transmit interface of the lower layer
        (e.g SoAd_IfTransmit is called and the XCP package is the same with the one received from XCP).
    23. Set SoAd_GetRemoteAddr return value to E_NOT_OK.
    24. Simulate reception, on Ethernet bus, of a package consisting in command different than CONNECT command.
    25. VP(XcpR.dsn.BusMonitor.SendSessionTerminatedEvent, XcpR.Ethernet.Udp.Disconnect): Verify the session terminated
        event was sent (XcpR calls the transmit interface of the lower layer, e.g SoAd_IfTransmit is called).
    26. VP (XcpR.Ethernet.Udp.Disconnect) Verify that the DISCONNECT command is routed to
        the XCP instance on the remote ECU (PM_Tst_Slave_Bus_Type\-::-/Transmit is called).
    27. Configure stub function SoAd_GetRemoteAddr_Stub to return E_OK.
    28. Simulate that XCP responses with a positive response (XcpR_RxIndication is called and
        data equals to DISCONNECT positive response).
    29. Verify that the DISCONNECT response is not forwarded to Xcp master.
    30. Simulate reception of a package consisting in command different than CONNECT command
        on master bus (XcpR_RxIndication() is called) when no connection is established.
    31. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the slave is DISCONNECTED.
    32. Set the result as success.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.BusTypesRemoteConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.BusMonitor.SendSessionTerminatedEvent</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>405</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.AdaptBusInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>147</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>XcpR.Ethernet.Tcp.DifferentIp</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>183</internalId></provcov>
        <provcov>
          <linksto>XcpR.Ethernet.Tcp.DifferentPort</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>182</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.TcpConnected.DiffAddr.DetOn.ErrorCodePduLost</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>451</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.TcpConnected.DiffPort.DetOn.ErrorCodePduLost</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>452</internalId></provcov>
        <provcov>
          <linksto>XcpR.Ethernet.Tcp.Disconnect</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>177</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>507</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_XCPR_XcpRSoAdSoConModeChg_ONLINE_Remote</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_EthTcp_Remote_SoConModeChg/source/application/EbTest.c.m4</sourcefile>
      <sourceline>83</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Check that the connection remains established when the XcpR_SoAdSoConModeChg function is called with ONLINE
      MODE for remote Xcp and the subsequent messages are forwarded between master and remote Xcp.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    01. Call XcpR_SoAdSoConModeChg with mode ONLINE for remote Xcp slave without initializing XcpR.
    02. VP(XcpR.dsn.SoAdSoConModeChg.API.DetOn.ErrorCodeNotInitialized): Check that XcpR_SoAdSoConModeChg() throws
        the runtime error XCPR_E_NOT_INITIALIZED.
    03. Simulate reception of a package consisting in command different than CONNECT command
        on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called) when no connection is established.
    04. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the slave is DISCONNECTED.
    05. Initialize stubs and XcpR.
    06. Simulate reception of a CONNECT command with MODE = 1 on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called
        and command 0xFF, MODE = 1).
    07. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode, XcpR.Impl.AdaptBusInfo):
        Check that the XcpR calls the transmit interface of the lower layer (e.g SoAd_IfTransmit is called
        and the XCP package is the same with the one received from XCP but header is adapted).
    08. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    09. VP(XcpR.Impl.CheckStatusConnection, XcpR.Impl.AdaptBusInfo): Verify that the XcpR calls the transmit
        interface of the lower layer(e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package is the
        same with the one received from XCP).
    10. Call XcpR_SoAdSoConModeChg with mode ONLINE for remote Xcp slave.
    11. VP: No Det errors were reported.
    12. Simulate reception, on PM_Tst_Master_Bus_Type bus, of a package consisting in command different than
        CONNECT command.
    13. VP (XcpR.Impl.TransmissionOfConsecutiveMessages, XcpR.Impl.AdaptBusInfo) Verify that the command
        is routed to the XCP instance on the remote ECU (SoAd_IfTransmit is called and the XCP package is the
        same with the one received from XCP but header is adapted).
    14. Simulate that XCP responses with a positive response (XcpR_RxIndication is called
        and data equals to GET_STATUS positive response).
    15. VP(XcpR.Impl.TransmissionOfConsecutiveMessages): Verify that the XcpR calls the transmit interface of
        the lower layer (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package is the same with the one
        received from XCP).
    16. Set the result as success.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.BusTypesRemoteConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.SoAdSoConModeChg.API.DetOn.ErrorCodeNotInitialized</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>450</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.AdaptBusInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>147</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>XcpR.Ethernet.Header.DataLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>174</internalId></provcov>
        <provcov>
          <linksto>XcpR.Ethernet.Header.Ctr</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>175</internalId></provcov>
        <provcov>
          <linksto>XcpR.Ethernet.SoAdAPIs</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>173</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>508</internalId></specobject>
    <specobject>
      <id>TS_XCPR_XcpRSoAdSoConModeChg_OFFLINE_Remote</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_EthTcp_Remote_SoConModeChg/source/application/EbTest.c.m4</sourcefile>
      <sourceline>289</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Test the closing of the remote Xcp ethernet socket while the connection is established.
      Verifies that the connection is closed after the XcpR_SoAdSoConModeChg function is called with OFFLINE mode
      and the subsequent messages are not forwarded between master and remote Xcp.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a CONNECT command with MODE = 1 on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called
        and command 0xFF, MODE = 1).
    03. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode, XcpR.Impl.AdaptBusInfo):
        Check that the XcpR calls the transmit interface of the lower layer (e.g SoAd_IfTransmit is called
        and the XCP package is the same with the one received from  XCP but header is adapted).
    04. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    05. VP(XcpR.Impl.CheckStatusConnection, XcpR.Impl.AdaptBusInfo): Verify that the XcpR calls the transmit
        interface of the lower layer(e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package is the
        same with the one received from XCP).
    06. Call XcpR_SoAdSoConModeChg with mode OFFLINE for remote Xcp slave.
    07. VP(XcpR.dsn.BusMonitor.SendSessionTerminatedEvent): Verify the session terminated
        event was sent (XcpR calls the transmit interface of the lower layer, e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called).
    08. VP (XcpR.Ethernet.Tcp.SoConModeChg.Disconnect) Verify that the DISCONNECT command is routed to
        the XCP instance on the remote ECU (SoAd_IfTransmit is called).
    09. Simulate that XCP responses with a positive response (XcpR_RxIndication is called and
        data equals to DISCONNECT positive response).
    10. Verify that the DISCONNECT response is not forwarded to Xcp master.
    11. Simulate reception of a package consisting in command different than CONNECT command
        on master bus (XcpR_RxIndication() is called) when no connection is established.
    12. VP(XcpR.Impl.DisconnectedState.CommandResponse, XcpR.Ethernet.Tcp.SoConModeChg.Disconnect): Received package is
        ignored without any action because the slave is DISCONNECTED.
    13. Set the result as success.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.BusTypesRemoteConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.PrecompileTimeConfig</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>423</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.AdaptBusInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>147</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.BusMonitor.SendSessionTerminatedEvent</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>405</internalId></provcov>
        <provcov>
          <linksto>XcpR.Ethernet.Tcp.SoConModeChg.Disconnect</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>176</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Ethernet.Header.DataLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>174</internalId></provcov>
        <provcov>
          <linksto>XcpR.Ethernet.Header.Ctr</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>175</internalId></provcov>
        <provcov>
          <linksto>XcpR.Ethernet.SoAdAPIs</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>173</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>509</internalId></specobject>
    <specobject>
      <id>TS_XCPR_XcpRSoAdSoConModeChg_WrongId_Remote</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_EthTcp_Remote_SoConModeChg/source/application/EbTest.c.m4</sourcefile>
      <sourceline>480</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Test the closing of the remote Xcp ethernet socket while the connection is established.
      Check that if the XcpR_SoAdSoConModeChg function is called with OFFLINE mode having a wrong socket id,
      the connection remains established. The subsequent messages are forwarded between master and remote Xcp.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a CONNECT command with MODE = 1 on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called
        and command 0xFF, MODE = 1).
    03. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode, XcpR.Impl.AdaptBusInfo):
        Check that the XcpR calls the transmit interface of the lower layer (e.g SoAd_IfTransmit is called
        and the XCP package is the same with the one received from  XCP but header is adapted).
    04. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    05. VP(XcpR.Impl.CheckStatusConnection, XcpR.Impl.AdaptBusInfo): Verify that the XcpR calls the transmit
        interface of the lower layer(e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package is the
        same with the one received from XCP).
    06. Call XcpR_SoAdSoConModeChg with mode SOAD_SOCON_OFFLINE but with wrong SoConId.
    07. Simulate reception, on PM_Tst_Master_Bus_Type bus, of a package consisting in command different than CONNECT command.
    08. VP (XcpR.Impl.TransmissionOfConsecutiveMessages, XcpR.Impl.AdaptBusInfo) Verify that the command
        is routed to the XCP instance on the remote ECU. The connection is still established because XcpR_SoAdSoConModeChg
        was called with wrong SoConId.
    09. Call XcpR_SoAdSoConModeChg with mode SOAD_SOCON_OFFLINE for remote Xcp slave.
    10. VP(XcpR.dsn.BusMonitor.SendSessionTerminatedEvent): Verify the session terminated
        event was sent (XcpR calls the transmit interface of the lower layer, e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called).
    11. VP (XcpR.Ethernet.Tcp.SoConModeChg.Disconnect) Verify that the DISCONNECT command is routed to
        the XCP instance on the remote ECU (SoAd_IfTransmit is called).
    12. Simulate that XCP responses with a positive response (XcpR_RxIndication is called and
        data equals to DISCONNECT positive response).
    13. Verify that the DISCONNECT response is not forwarded to Xcp master.
    14. Simulate reception of a package consisting in command different than CONNECT command
        on master bus (XcpR_RxIndication() is called) when no connection is established.
    15. VP(XcpR.Impl.DisconnectedState.CommandResponse, XcpR.Ethernet.Tcp.SoConModeChg.Disconnect): Received package is ignored without any action
        because the slave is DISCONNECTED.
    16. Set the result as success.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.BusTypesRemoteConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.PrecompileTimeConfig</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>423</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.AdaptBusInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>147</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.BusMonitor.SendSessionTerminatedEvent</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>405</internalId></provcov>
        <provcov>
          <linksto>XcpR.Ethernet.Tcp.SoConModeChg.Disconnect</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>176</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Ethernet.Header.DataLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>174</internalId></provcov>
        <provcov>
          <linksto>XcpR.Ethernet.Header.Ctr</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>175</internalId></provcov>
        <provcov>
          <linksto>XcpR.Ethernet.SoAdAPIs</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>173</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>510</internalId></specobject>
    <specobject>
      <id>TS_XCPR_Ethernet_SimulateInvalidConnectCMD</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_EthTcp_Remote_SoConModeChg/source/application/EbTest.c.m4</sourcefile>
      <sourceline>708</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Simulate reception of an invalid CONNECT command sequence and verify that XcpR throws the runtime error XCPR_E_INVALID_CONNECT_MODE.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of an invalid CONNECT command sequence.
    03. Check that XcpR throws the runtime error XCPR_E_INVALID_CONNECT_MODE because a invalid CONNECT command sequence has been sent.
    04. Received package is ignored without any action.
    05. Check that there are no unprocessed data left.
    06. Set the result as success.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.dsn.InvalidConnectMode.DetOn.ErrorCodeInvalidConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>418</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>511</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_XCPR_EthUdp_ReconfiguredSocket</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_EthUdp_Master/source/application/EbTest.c.m4</sourcefile>
      <sourceline>103</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      To test whether the sockets are correctly being reconfigured upon a message reception.
      Test also verifies that XcpR disconnects from the first Ethernet UDP connection and then
      connects using another Ethernet UDP master source, and communication is succesful.
      The test verifies that the SoAd Rx and Tx sockets are correctly updated.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Set the remote address of the master to default values.
    03. Simulate reception of a package consisting in command different than CONNECT command
        on Ethernet (XcpR_RxIndication() is called) when no connection is established.
    04. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the slave is DISCONNECTED.
    05. Simulate reception of a CONNECT command with MODE = 1 on Ethernet (XcpR_RxIndication() is called
        and command 0xFF, MODE = 1).
    06. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode, XcpR.Impl.AdaptBusInfo):
        Check that the XcpR calls the transmit interface of the lower layer (e.g PM_Tst_Slave_Bus_Type\-::-/Transmit is called
        and the XCP package is the same with the one received from  XCP but header is adapted).
    07. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    08. VP(XcpR.Impl.CheckStatusConnection, XcpR.Impl.AdaptBusInfo): Verify that the XcpR calls the transmit
        interface of the lower layer(e.g SoAd_IfTransmit is called and the XCP package is the
        same with the one received from XCP).
    09a. VP(XcpR.Ethernet.AddressMethod): Check that the port of the RX socket has been changed to
         0 (wildcard)
    09b. VP(XcpR.Ethernet.AddressMethod): Check that the remote address for both TX sockets has been changed to
         the one which contacted the RX socket with the CONNECT command
    09c. VP: Check that SoAd_SetRemoteAddress() is called for both Tx sockets
    09d. VP: Check that the address and port for the RX socket of the second connection have not been changed
    09e. VP: Check that SoAd_SetRemoteAddress() is not called for this Rx socket
    09f. VP: Check that SoAd_SetRemoteAddress() is invoked 3 times: 2 times for setting the 2 Tx sockets, and once
         for setting the Rx socket for connection 1
    10. VP Check that SoAd_GetRemoteAddr() was called with the correct domain.
    11. VP(XcpR.Ethernet.AddressMethod): Check that the remote port of the RX socket has been changed to 0.
    12. Now, we change the remote port number for the next request. IP is unchanged..
    13. Simulate reception, on Ethernet bus, of a package consisting in command different than CONNECT command.
    14. VP (XcpR.Impl.TransmissionOfConsecutiveMessages, XcpR.Impl.AdaptBusInfo) Verify that the command
        is routed to the XCP instance on the remote ECU (PM_Tst_Slave_Bus_Type\-::-/Transmit is called and the XCP package is the
        same with the one received from XCP but header is adapted).
    15. VP(XcpR.Ethernet.AddressMethod): Check that the remote address of the TX socket has not been changed to the one which contacted
        the RX socket.
    16. VP(XcpR.Ethernet.AddressMethod): Check that the remote port of the RX socket has been changed to 0.
    17. Simulate reception of a package consisting in a DISCONNECT command.
    18. Verify that the command is routed to the XCP instance on the remote ECU
       (PM_Tst_Slave_Bus_Type\-::-/Transmit is called and the XCP package is the same with the one received from XCP but header is adapted)
    19. Simulate that XCP responses with a positive response (XcpR_RxIndication is called and
         data equals to DISCONNECT positive response)
    20. Verify that the command is routed to the XCP Master
       (SoAd_IfTransmit is called and the XCP package is the same with the one received
       from XCP but header is adapted)
    21. Simulate reception of a CONNECT command with MODE = 1 on SoAd_If (XcpR_RxIndication() is called
        and command 0xFF, MODE = 1)
    22. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode, XcpR.Impl.AdaptBusInfo):
        Check that the XcpR calls the transmit interface of the lower layer (e.g PM_Tst_Slave_Bus_Type\-::-/Transmit is called
        and the XCP package is the same with the one received from  XCP but header is adapted)
    23. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response)
    24. VP(XcpR.Impl.CheckStatusConnection, XcpR.Impl.AdaptBusInfo): Verify that the XcpR calls the transmit
        interface of the lower layer(e.g SoAd_IfTransmit is called and the XCP package is the
        same with the one received from XCP)
    25a. VP(XcpR.Ethernet.AddressMethod): Check that the port of the RX socket has been changed to
         0 (wildcard).
    25b. VP(XcpR.Ethernet.AddressMethod): Check that the remote address for both TX sockets has been changed to
         the one which contacted the RX socket with the CONNECT command
    25c. VP: Check that SoAd_SetRemoteAddress() is called for both Tx sockets
    25d. VP: Check that the address and port for the RX socket of the first connection have not been changed
    25e. VP: Check that SoAd_SetRemoteAddress() is not called for this Rx socket
    25f. VP: Check that SoAd_SetRemoteAddress() is invoked 3 times: 2 times for setting the 2 Tx sockets, and once
         for setting the Rx socket for connection 2.
    26. Simulate confirming the response after SoAd_IfTransmit() was processed from step 08
    27. Change the remote port number for the next request. IP is unchanged.
    28. Simulate reception, on Ethernet bus, of a package consisting in command different than CONNECT command
    29. VP (XcpR.Impl.TransmissionOfConsecutiveMessages, XcpR.Impl.AdaptBusInfo) Verify that the command
        is routed to the XCP instance on the remote ECU (Cdd_Transmit is called and the XCP package is the
        same with the one received from XCP but header is adapted)
    30. Simulate that remote XCP responses with a positive response (XcpR_RxIndication is called
        and data equals to GET_STATUS positive response)
    31. VP(XcpR.Impl.TransmissionOfConsecutiveMessages): Verify that the XcpR calls the transmit interface of the lower layer
        (e.g SoAd_IfTransmit is called and the XCP package is the same with the one received
        from XCP)
    32. Set the result as success.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.BusTypesRemoteConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.AdaptBusInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>147</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Ethernet.AddressMethod</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>172</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>512</internalId></specobject>
    <specobject>
      <id>TS_XCPR_EthUdp_CannotSetRemoteAddress</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_EthUdp_Master/source/application/EbTest.c.m4</sourcefile>
      <sourceline>573</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Check if the Udp socket adapter remote address cannot be set, the XcpR will perform an autonomous disconnect,
      which means that communication will be stopped.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Set the remote address of the master to default values.
    03. Set SoAd address.
    04. Simulate reception of a package consisting in command different than CONNECT command
        on Ethernet (XcpR_RxIndication() is called) when no connection is established.
    05. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the slave is DISCONNECTED.
    06. Simulate reception of a CONNECT command with MODE = 1 on Ethernet (XcpR_RxIndication() is called
        and command 0xFF, MODE = 1).
    07. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode, XcpR.Impl.AdaptBusInfo):
        Check that the XcpR calls the transmit interface of the lower layer (e.g PM_Tst_Slave_Bus_Type\-::-/Transmit is called
        and the XCP package is the same with the one received from  XCP but header is adapted).
    08. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    09. VP(XcpR.Impl.CheckStatusConnection, XcpR.Impl.AdaptBusInfo): Verify that the XcpR calls the transmit
        interface of the lower layer(e.g SoAd_IfTransmit is called and the XCP package is the
        same with the one received from XCP).
    08. VP(XcpR.Ethernet.AddressMethod): Check that the remote address of the TX socket has been changed to
        the one which contacted the RX socket with the CONNECT command.
    09. VP Check that SoAd_GetRemoteAddr() was called with the correct domain.
    10. VP(XcpR.Ethernet.AddressMethod): Check that the remote port of the RX socket has been changed to 0.
    11. Set the remote address of the master to default values.
    12. Simulate reception, on Ethernet bus, of a package consisting in command different than CONNECT command.
    13. VP (XcpR.Impl.TransmissionOfConsecutiveMessages, XcpR.Impl.AdaptBusInfo) Verify that the command
        is routed to the XCP instance on the remote ECU (PM_Tst_Slave_Bus_Type\-::-/Transmit is called and the XCP package is the
        same with the one received from XCP but header is adapted).
    14. VP(XcpR.Ethernet.AddressMethod): Check that the remote address of the TX socket has not been changed to the one which contacted
        the RX socket.
    15. VP(XcpR.Ethernet.AddressMethod): Check that the remote port of the RX socket has been changed to 0.
    16. Simulate that remote XCP responses with a positive response (XcpR_RxIndication is called
        and data equals to GET_STATUS positive response).
    17. VP(XcpR.Impl.TransmissionOfConsecutiveMessages): Verify that the XcpR calls the transmit interface of the lower layer
        (e.g SoAd_IfTransmit is called and the XCP package is the same with the one received
        from XCP).
    18. Configure stub function SoAd_SetRemoteAddr_Stub to return E_NOT_OK.
    17. Set the remote address of the master to default values.
    18. Simulate reception, on Ethernet bus, of a package consisting in command different than CONNECT command.
    19. VP(XcpR.dsn.BusMonitor.SendSessionTerminatedEvent, XcpR.Ethernet.Udp.Disconnect): Verify the session terminated
        event was sent (XcpR calls the transmit interface of the lower layer, e.g SoAd_IfTransmit is called).
    20. VP (XcpR.Ethernet.Udp.Disconnect) Verify that the DISCONNECT command is routed to
        the XCP instance on the remote ECU (PM_Tst_Slave_Bus_Type\-::-/Transmit is called).
    21. Configure stub function SoAd_SetRemoteAddr_Stub to return E_OK.
    22. Simulate that XCP responses with a positive response (XcpR_RxIndication is called and
        data equals to DISCONNECT positive response).
    23. Verify that the DISCONNECT response is not forwarded to Xcp master.
    24. Simulate reception of a package consisting in command different than CONNECT command
        on master bus (XcpR_RxIndication() is called) when no connection is established.
    25. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the slave is DISCONNECTED.
    26. Set the result as success.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.BusTypesRemoteConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.AdaptBusInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>147</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Ethernet.AddressMethod</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>172</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.BusMonitor.SendSessionTerminatedEvent</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>405</internalId></provcov>
        <provcov>
          <linksto>XcpR.Ethernet.Udp.Disconnect</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>178</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>513</internalId></specobject>
    <specobject>
      <id>TS_XCPR_EthUdp_CommandDifferentIp</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_EthUdp_Master/source/application/EbTest.c.m4</sourcefile>
      <sourceline>898</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Verify that XcpR does not forward messages received from the master Xcp coming from an
      IP different than the one which originated the connection(via command CONNECT).
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Set the remote address of the master to default values.
    03. Set SoAd address.
    04. Simulate reception of a package consisting in command different than CONNECT command
        on Ethernet (XcpR_RxIndication() is called) when no connection is established.
    05. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the slave is DISCONNECTED.
    06. Simulate reception of a CONNECT command with MODE = 1 on Ethernet (XcpR_RxIndication() is called
        and command 0xFF, MODE = 1).
    07. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode, XcpR.Impl.AdaptBusInfo):
        Check that the XcpR calls the transmit interface of the lower layer (e.g PM_Tst_Slave_Bus_Type\-::-/Transmit is called
        and the XCP package is the same with the one received from  XCP but header is adapted).
    08. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    09. VP(XcpR.Impl.CheckStatusConnection, XcpR.Impl.AdaptBusInfo): Verify that the XcpR calls the transmit
        interface of the lower layer(e.g SoAd_IfTransmit is called and the XCP package is the
        same with the one received from XCP).
    10. VP(XcpR.Ethernet.AddressMethod): Check that the remote address of the TX socket has been changed to
        the one which contacted the RX socket with the CONNECT command.
    11. VP Check that SoAd_GetRemoteAddr() was called with the correct domain.
    12. VP(XcpR.Ethernet.AddressMethod): Check that the remote port of the RX socket has been changed to 0.
    13. Now, we change the remote ip number for the next request. Port is unchanged..
    14. Simulate reception, on Ethernet bus, of a package consisting in command different than CONNECT command.
    15. VP(XcpR.Ethernet.Udp.DifferentIp): Received package is ignored because it comes from
        an IP different than the one which originated the connection.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.BusTypesRemoteConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.AdaptBusInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>147</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Ethernet.AddressMethod</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>172</internalId></provcov>
        <provcov>
          <linksto>XcpR.Ethernet.Udp.DifferentIp</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>181</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.UdpConnected.DiffAddr.DetOn.ErrorCodePduLost</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>473</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>514</internalId></specobject>
    <specobject>
      <id>TS_XCPR_EthUdp_RespondOnlyToConnectIpAddress</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_EthUdp_Master/source/application/EbTest.c.m4</sourcefile>
      <sourceline>1082</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Verify that XcpR forwards the messages from Xcp slave to Xcp master only to
      the address and port corresponding with the established connection.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Set the remote address of the master to default values.
    03. Set SoAd address.
    04. Simulate reception of a CONNECT command with MODE = 1 on Ethernet (XcpR_RxIndication() is called
        and command 0xFF, MODE = 1).
    05. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode, XcpR.Impl.AdaptBusInfo):
        Check that the XcpR calls the transmit interface of the lower layer (e.g PM_Tst_Slave_Bus_Type\-::-/Transmit is called
        and the XCP package is the same with the one received from  XCP but header is adapted).
    06. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    07. VP(XcpR.Impl.CheckStatusConnection, XcpR.Impl.AdaptBusInfo): Verify that the XcpR calls the transmit
        interface of the lower layer(e.g SoAd_IfTransmit is called and the XCP package is the
        same with the one received from XCP).
    08. VP(XcpR.Ethernet.AddressMethod): Check that the remote address of the TX socket has been changed to
        the one which contacted the RX socket with the CONNECT command.
    09. VP Check that SoAd_GetRemoteAddr() was called with the correct domain.
    10. VP(XcpR.Ethernet.AddressMethod): Check that the remote port of the RX socket has been changed to 0.
    11. Now, we change the remote port number for the next request. IP is unchanged..
    12. Simulate reception, on Ethernet bus, of a package consisting in command different than CONNECT command.
    13. VP (XcpR.Impl.TransmissionOfConsecutiveMessages, XcpR.Impl.AdaptBusInfo) Verify that the command
        is routed to the XCP instance on the remote ECU (PM_Tst_Slave_Bus_Type\-::-/Transmit is called and the XCP package is the
        same with the one received from XCP but header is adapted).
    14. Simulate that XCP responses with a positive response (XcpR_RxIndication is called
        and data equals to GET_STATUS positive response).
    15. VP(XcpR.Impl.TransmissionOfConsecutiveMessages): Verify that the XcpR calls the transmit interface of the lower layer
        (e.g SoAd_IfTransmit is called and the XCP package is the same with the one received
        from XCP).
    16. VP(XcpR.Ethernet.Udp.DifferentPort): Check that the remote address of the TX socket has been changed to
        the one which contacted the RX socket with the CONNECT command.
    17. Set the result as success.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.BusTypesRemoteConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.AdaptBusInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>147</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Ethernet.AddressMethod</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>172</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>XcpR.Ethernet.Udp.DifferentPort</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>180</internalId></provcov>
        <provcov>
          <linksto>XcpR.Ethernet.Udp.Communication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>179</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>515</internalId></specobject>
    <specobject>
      <id>TS_XCPR_CannotGetRemoteAddress</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_EthUdp_Master/source/application/EbTest.c.m4</sourcefile>
      <sourceline>1284</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Verify that XcpR will perform an autonomous disconnect if it can't get the remote address of a socket connection.
      (The communication will be stopped)
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Set SoAd_GetRemoteAddr return value to E_NOT_OK.
    03. Simulate reception of a CONNECT command with MODE = 1 on Ethernet (XcpR_RxIndication() is called
        and command 0xFF, MODE = 1).
    04. VP: Verify that no message is sent neither to master or remote slave.
    05. Simulate reception of a package consisting in command different than CONNECT command
        on master bus (XcpR_RxIndication() is called) when no connection is established  and
        SoAd_SetRemoteAddr return value to E_NOT_OK
    06. VP: Verify that no message is sent neither to master or remote slave.
    07. Set SoAd_GetRemoteAddr return value to E_OK.
    08. Simulate reception of a CONNECT command with MODE = 1 on Ethernet (XcpR_RxIndication() is called
        and command 0xFF, MODE = 1).
    09. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode, XcpR.Impl.AdaptBusInfo):
        Check that the XcpR calls the transmit interface of the lower layer (e.g PM_Tst_Slave_Bus_Type\-::-/Transmit is called
        and the XCP package is the same with the one received from  XCP but header is adapted).
    10. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    11. VP(XcpR.Impl.CheckStatusConnection, XcpR.Impl.AdaptBusInfo): Verify that the XcpR calls the transmit
        interface of the lower layer(e.g SoAd_IfTransmit is called and the XCP package is the
        same with the one received from XCP).
    12. Simulate reception, on Ethernet bus, of a package consisting in command different than CONNECT command.
    13. VP (XcpR.Impl.TransmissionOfConsecutiveMessages, XcpR.Impl.AdaptBusInfo) Verify that the command
        is routed to the XCP instance on the remote ECU (PM_Tst_Slave_Bus_Type\-::-/Transmit is called and the XCP package is the
        same with the one received from XCP but header is adapted).
    14. Simulate that XCP responses with a positive response (XcpR_RxIndication is called
        and data equals to GET_STATUS positive response).
    15. VP(XcpR.Impl.TransmissionOfConsecutiveMessages): Verify that the XcpR calls the transmit interface of the lower layer
        (e.g SoAd_IfTransmit is called and the XCP package is the same with the one received from XCP).
    16. Set SoAd_GetRemoteAddr return value to E_NOT_OK.
    17. Simulate reception, on Ethernet bus, of a package consisting in command different than CONNECT command.
    18. VP(XcpR.dsn.BusMonitor.SendSessionTerminatedEvent, XcpR.Ethernet.Udp.Disconnect): Verify the session terminated
        event was sent (XcpR calls the transmit interface of the lower layer, e.g SoAd_IfTransmit is called).
    19. VP (XcpR.Ethernet.Udp.Disconnect) Verify that the DISCONNECT command is routed to
        the XCP instance on the remote ECU (PM_Tst_Slave_Bus_Type\-::-/Transmit is called).
    20. Configure stub function SoAd_GetRemoteAddr_Stub to return E_OK.
    21. Simulate that XCP responses with a positive response (XcpR_RxIndication is called and
        data equals to DISCONNECT positive response).
    22. Verify that the DISCONNECT response is not forwarded to Xcp master.
    23. Simulate reception of a package consisting in command different than CONNECT command
        on master bus (XcpR_RxIndication() is called) when no connection is established.
    24. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the slave is DISCONNECTED.
    25. Set the result as success.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.BusTypesRemoteConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.BusMonitor.SendSessionTerminatedEvent</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>405</internalId></provcov>
        <provcov>
          <linksto>XcpR.Ethernet.Udp.Disconnect</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>178</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.AdaptBusInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>147</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>516</internalId></specobject>
    <specobject>
      <id>TS_XCPR_CONNECTcmd_CannotSetRemoteAddress</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_EthUdp_Master/source/application/EbTest.c.m4</sourcefile>
      <sourceline>1572</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Check if the Udp socket adapter remote address cannot be set, the XcpR will perform an autonomous disconnect,
      which means that communication will be stopped.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Set SoAd_SetRemoteAddr return value to E_NOT_OK.
    03. Simulate reception of a CONNECT command with MODE = 1 on Ethernet (XcpR_RxIndication() is called
        and command 0xFF, MODE = 1).
    04. VP: Verify that no message is sent neither to master or remote slave.
    05. Simulate reception of a package consisting in command different than CONNECT command
        on master bus (XcpR_RxIndication() is called) when no connection is established  and
        SoAd_SetRemoteAddr return value to E_NOT_OK
    06. VP: Verify that no message is sent neither to master or remote slave.
    07. Set SoAd_SetRemoteAddr return value to E_OK.
    08. Simulate reception of a CONNECT command with MODE = 1 on Ethernet (XcpR_RxIndication() is called
        and command 0xFF, MODE = 1).
    09. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode, XcpR.Impl.AdaptBusInfo):
        Check that the XcpR calls the transmit interface of the lower layer (e.g PM_Tst_Slave_Bus_Type\-::-/Transmit is called
        and the XCP package is the same with the one received from  XCP but header is adapted).
    10. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    11. VP(XcpR.Impl.CheckStatusConnection, XcpR.Impl.AdaptBusInfo): Verify that the XcpR calls the transmit
        interface of the lower layer(e.g SoAd_IfTransmit is called and the XCP package is the
        same with the one received from XCP).
    12. Simulate reception, on Ethernet bus, of a package consisting in command different than CONNECT command.
    13. VP (XcpR.Impl.TransmissionOfConsecutiveMessages, XcpR.Impl.AdaptBusInfo) Verify that the command
        is routed to the XCP instance on the remote ECU (PM_Tst_Slave_Bus_Type\-::-/Transmit is called and the XCP package is the
        same with the one received from XCP but header is adapted).
    14. Simulate that XCP responses with a positive response (XcpR_RxIndication is called
        and data equals to GET_STATUS positive response).
    15. VP(XcpR.Impl.TransmissionOfConsecutiveMessages): Verify that the XcpR calls the transmit interface of the lower layer
        (e.g SoAd_IfTransmit is called and the XCP package is the same with the one received from XCP).
    16. Set SoAd_SetRemoteAddr return value to E_NOT_OK.
    17. Simulate reception, on Ethernet bus, of a package consisting in command different than CONNECT command.
    18. VP(XcpR.dsn.BusMonitor.SendSessionTerminatedEvent, XcpR.Ethernet.Udp.Disconnect): Verify the session terminated
        event was sent (XcpR calls the transmit interface of the lower layer, e.g SoAd_IfTransmit is called).
    19. VP (XcpR.Ethernet.Udp.Disconnect) Verify that the DISCONNECT command is routed to
        the XCP instance on the remote ECU (PM_Tst_Slave_Bus_Type\-::-/Transmit is called).
    20. Configure stub function SoAd_SetRemoteAddr_Stub to return E_OK.
    21. Simulate that XCP responses with a positive response (XcpR_RxIndication is called and
        data equals to DISCONNECT positive response).
    22. Verify that the DISCONNECT response is not forwarded to Xcp master.
    23. Simulate reception of a package consisting in command different than CONNECT command
        on master bus (XcpR_RxIndication() is called) when no connection is established.
    24. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the slave is DISCONNECTED.
    25. Set the result as success.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.BusTypesRemoteConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.BusMonitor.SendSessionTerminatedEvent</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>405</internalId></provcov>
        <provcov>
          <linksto>XcpR.Ethernet.Udp.Disconnect</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>178</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.AdaptBusInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>147</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>517</internalId></specobject>
    <specobject>
      <id>TS_XCPR_EthUdp_PortAlready_0_SetRemoteAddrNotCalled</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_EthUdp_Master/source/application/EbTest.c.m4</sourcefile>
      <sourceline>1862</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Verify that SoAd_SetRemoteAddr() is not called if the Rx port is already configured with 0.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a CONNECT command with MODE = 1 on Ethernet (XcpR_RxIndication() is called
        and command 0xFF, MODE = 1).
    03. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode, XcpR.Impl.AdaptBusInfo):
        Check that the XcpR calls the transmit interface of the lower layer (e.g PM_Tst_Slave_Bus_Type\-::-/Transmit is called
        and the XCP package is the same with the one received from  XCP but header is adapted).
    04. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    05. VP(XcpR.Impl.CheckStatusConnection, XcpR.Impl.AdaptBusInfo): Verify that the XcpR calls the transmit
        interface of the lower layer(e.g SoAd_IfTransmit is called and the XCP package is the
        same with the one received from XCP).
    06. Reset SoAd_SetRemoteAddr count.
    07. Set the remote port to TST_MASTER_PORT (something different from 0).
    08. Simulate reception, on Ethernet bus, of a package consisting in command different than CONNECT command.
    09. VP (XcpR.Impl.TransmissionOfConsecutiveMessages, XcpR.Impl.AdaptBusInfo) Verify that the command
        is routed to the XCP instance on the remote ECU (PM_Tst_Slave_Bus_Type\-::-/Transmit is called and the XCP package is the
        same with the one received from XCP but header is adapted).
    10. VP: Check that SoAd_SetRemoteAddr was called to reconfigured Rx socket (wild card, i.e. accept all ports).
    11. Simulate that XCP responses with a positive response (XcpR_RxIndication is called
        and data equals to GET_STATUS positive response).
    12. VP(XcpR.Impl.TransmissionOfConsecutiveMessages): Verify that the XcpR calls the transmit interface of the lower layer
        (e.g SoAd_IfTransmit is called and the XCP package is the same with the one received from XCP).
    13. Set the remote port to 0 (wild card)
    14. Reset SoAd_SetRemoteAddr count.
    15. Simulate reception, on Ethernet bus, of a package consisting in command different than CONNECT command.
    16. VP (XcpR.Impl.TransmissionOfConsecutiveMessages, XcpR.Impl.AdaptBusInfo) Verify that the command
        same with the one received from XCP but header is adapted).
    17. VP Check that SoAd_SetRemoteAddr was not called.
    18. Simulate that XCP responses with a positive response (XcpR_RxIndication is called
        and data equals to GET_STATUS positive response).
    19. VP(XcpR.Impl.TransmissionOfConsecutiveMessages): Verify that the XcpR calls the transmit interface of the lower layer
        (e.g SoAd_IfTransmit is called and the XCP package is the same with the one received from XCP).
    20. Set the result as success.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.BusTypesRemoteConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.AdaptBusInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>147</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>518</internalId></specobject>
    <specobject>
      <id>TS_XCPR_SoAd_OpenSoCon</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_EthUdp_Master/source/application/EbTest.c.m4</sourcefile>
      <sourceline>2078</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Verify that no connection is established when the second SoAd socket cannot be successfully opened.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    01. Set SoAd_OpenSoCon return value to E_NOT_OK.
    02. Initialize stubs and XcpR.
    03. Simulate reception of a CONNECT command with MODE = 1 on Ethernet (XcpR_RxIndication() is called
        and command 0xFF, MODE = 1).
    05. VP: Received package is ignored without any action because the SoAd could not open the socket connections.
    06. Simulate reception of a package consisting in command different than CONNECT command
        on Ethernet (XcpR_RxIndication() is called) when no connection is established.
    07. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
    08. Set the result as success.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.BusTypesRemoteConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>519</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_XCPR_XcpRInternalQueue</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_InternalQueue/source/application/EbTest.c</sourcefile>
      <sourceline>83</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Check the functionality of the XcpR internal queue (which is a circular buffer).
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a package consisting in command different than CONNECT command
        on CAN (XcpR_RxIndication() is called) when no connection is established.
    03. VP(XcpR.dsn.DisconnectedState.DetOn.ErrorCodePduLost): Check that XcpR throws the
        runtime error XCPR_E_PDU_LOST.
    04. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the slave is DISCONNECTED.
    05. Simulate reception of a CONNECT command with MODE = 1 on CAN (XcpR_RxIndication() is
        called and command 0xFF, MODE = 1).
    06. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode): Check that the
        package is the same with the one received from XCP).
    07. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals  to CONNECT positive response).
    08. VP(XcpR.Impl.CheckStatusConnection): Verify that the XcpR calls the transmit interface of the lower layer
        (e.g CanIf_Transmit is called and the XCP package is the same with the one received from XCP).
        Loop up to 1000 calls.
          09. Simulate reception of a 8 byte message CAN (XcpR_RxIndication() is called ).
          10. VP (XcpR.Impl.TransmissionOfConsecutiveMessages) Verify that the 8 byte message is routed to the
              the one received from XCP).
    11. Set the result as success.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.BusTypesRemoteConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.GeneralDescription</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>411</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.DisconnectedState.DetOn.ErrorCodePduLost</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>408</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.ConfigurableInternalQueue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>148</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.PublicHeader</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>141</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>520</internalId></specobject>
    <specobject>
      <id>TS_XCPR_XcpRInternalQueue_LastIndexes</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_InternalQueue/source/application/EbTest.c</sourcefile>
      <sourceline>252</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Check the functionality of the XcpR internal queue (which is a circular buffer).
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a package consisting in command different than CONNECT command
        on CAN (XcpR_RxIndication()is called) when no connection is established.
    03. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the slave is DISCONNECTED.
    04. Simulate reception of a CONNECT command with MODE = 1 on CAN (XcpR_RxIndication() is called and command 0xFF, MODE = 1).
    05. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode): Check that the
        XcpR calls the transmit interface of the lower layer (e.g CanIf_Transmit is called and the XCP
        package is the same with the one received from XCP).
    06. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    07. VP(XcpR.Impl.CheckStatusConnection): Verify that the XcpR calls the transmit interface of the lower layer
        (e.g CanIf_Transmit is called and the XCP package is the same
        with the one received from XCP).
    08. Simulate reception of a 1 byte message on CAN (XcpR_RxIndication() is called ).
    09. VP (XcpR.Impl.TransmissionOfConsecutiveMessages) Verify that the 1 byte message is routed to
        the XCP instance on the remote ECU (CanIf_Transmit is called and the XCP package are the same with
        the one received from XCP).
    10. Simulate reception of a 7 byte message on CAN (XcpR_RxIndication() is called ).
    11. VP (XcpR.Impl.TransmissionOfConsecutiveMessages) Verify that the 7 byte message is routed to
        the XCP instance on the remote ECU (CanIf_Transmit is called and the XCP package are the same with
        the one received from XCP).
        Loop up to 1000 calls.
          12. Simulate reception of a 8 byte message CAN (XcpR_RxIndication() is called ).
          13. VP (XcpR.Impl.TransmissionOfConsecutiveMessages) Verify that the 8 byte message is routed
              to the XCP instance on the remote ECU (CanIf_Transmit is called and the XCP package are the same with
              the one received from XCP).
    14. Set the result as success.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.BusTypesRemoteConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.ConfigurableInternalQueue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>148</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>521</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_XCPR_LocalXcpSlave_InvalidConnectMode_TransmissionRx</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_LocalXcpSlave/source/application/EbTest.c.m4</sourcefile>
      <sourceline>46</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Check that XcpR module reports DET error: XCPR_E_INVALID_CONNECT_REMOTE_XCP if receives a CONNECT
      command with Mode 1, but there is no Tx destination linked to this source.
      Check that XcpR module reports DET error: XCPR_E_INVALID_LENGTH when attempts to send a
      message  but the message does not fit in the configured  destination's length
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    MASTER NETWORK:
      XcpRSrcPduSupportRxFromRxIndication is enabled.
      XcpRRxSrcPduSupportTxFromRxIndication is enabled.
    LOCAL SLAVE NETWORK:
      XcpRSrcPduSupportRxFromXcpRTransmit is enabled.
      XcpRTxSrcPduSupportTxFromXcpRTransmit is enabled.
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a package consisting in command different than CONNECT command
        on CanIf (XcpR_RxIndication()is called) when no connection is established.
m4_ifelse(PM_Permutation,FrToCddDetRuntimeOff,\-:m4_dnl
    03. Check that XcpR does not store a Det runtime error if XcpRDetRuntimeChecks is set to false.
:-/,m4_ifelse( :else: )\-:
    03. VP(XcpR.dsn.DisconnectedState.DetOn.ErrorCodePduLost): Check that XcpR throws the
        runtime error XCPR_E_PDU_LOST.
:-/m4_ifelse( :endif: ))
    04. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action.
    05. Simulate reception of a CONNECT command with MODE = 1 on FlexRay when no remote Xcp slave is configured.
    06. VP(XcpR.dsn.RemoteConnectMode.DetOn.ErrorCodeInvalidConnectMode): Check that XcpR throws the
        runtime error XCPR_E_INVALID_CONNECT_REMOTE_XCP.
    07. Simulate reception of a CONNECT command with MODE = 0 on FlexRay ( XcpR_RxIndication() is
        called and command 0xFF, MODE = 0).
    08. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_0): Verify that the XcpR calls the indication interface of the upper layer
        (e.g Xcp_CddRxIndication is called and the XCP package is the same with the one received).
    09. Simulate a positive response from the local Xcp slave (Xcp calls XcpR_Transmit
        with CONNECT positive response).
    10. VP(XcpR.Impl.TxConfirmation.UpperLayer): Verify that the XcpR calls the confirmation
        interface of the upper layer (e.g Xcp_CddTxConfirmation is called with the correct Pdu id).
    11. VP(XcpR.Impl.CheckStatusConnection): Verify that the XcpR calls the transmit interface
        of the lower layer (e.g FrIf_Transmit is called and the XCP package is the same with the one
        received from XCP  but header is adapted).
    12. Simulate confirming the response after FrIf_Transmit() was processed from step 09.
    13. Simulate reception, on FlexRay bus, of the WRITE_DAQ_MULTIPLE command (the command
        does not fit in the configured destination's length).
    14. VP(XcpR.dsn.PackMessage.DetOn.ErrorCodeInvalidLength): Received package is ignored without any action
        because the message does not fit in the configured destination's length.
    15. Set the result as success.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Disabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>124</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CddLocalConnectionsOnly</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>149</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.DisconnectedState.DetOn.ErrorCodePduLost</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>408</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.RemoteConnectMode.DetOn.ErrorCodeInvalidConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>439</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_0</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>122</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TxConfirmation.UpperLayer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>160</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.PackMessage.DetOn.ErrorCodeInvalidLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>422</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.Communication.CDD.ImmediateAccess</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>139</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.PublicHeader</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>141</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>522</internalId></specobject>
    <specobject>
      <id>TS_XCPR_LocalXcpSlave_InvalidConnectMode</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_LocalXcpSlave/source/application/EbTest.c.m4</sourcefile>
      <sourceline>261</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Check that XcpR module reports DET error: XCPR_E_INVALID_CONNECT_REMOTE_XCP if receives a CONNECT
      command with Mode 1, but there is no Tx destination linked to this source.
      Check that XcpR module reports DET error: XCPR_E_INVALID_LENGTH when attempts to send a
      message  but the message does not fit in the configured  destination's length.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    None
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a package consisting in command different than CONNECT command
        on CanIf (XcpR_RxIndication()is called) when no connection is established.
    03. VP(XcpR.dsn.DisconnectedState.DetOn.ErrorCodePduLost): Check that XcpR throws the
        runtime error XCPR_E_PDU_LOST.
    04. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action.
    05. Simulate reception of a CONNECT command with MODE = 1 on Cdd when no remote Xcp slave is configured.
    06. VP(XcpR.dsn.RemoteConnectMode.DetOn.ErrorCodeInvalidConnectMode): Check that XcpR throws the
        runtime error XCPR_E_INVALID_CONNECT_REMOTE_XCP.
    07. Simulate reception of a CONNECT command with MODE = 0 on Cdd ( XcpR_RxIndication() is
        called and command 0xFF, MODE = 0).
    08. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_0): Verify that the XcpR calls the indication interface of the upper layer
        (e.g Xcp_CddRxIndication is called and the XCP package is the same with the one received).
    09. Simulate a positive response from the local Xcp slave (Xcp calls XcpR_Transmit
        with CONNECT positive response).
    10. VP(XcpR.Impl.TxConfirmation.UpperLayer): Verify that the XcpR calls the confirmation
        interface of the upper layer (e.g Xcp_CddTxConfirmation is called with the correct Pdu id).
    11. VP(XcpR.Impl.CheckStatusConnection): Verify that the XcpR calls the transmit interface
        of the lower layer (e.g Cdd_Transmit is called and the XCP package is the same with the one
        received from XCP  but header is adapted).
    12. Simulate confirming the response after Cdd_Transmit() was processed from step 09.
    13. Simulate reception, on Cdd bus, of the WRITE_DAQ_MULTIPLE command (the command
        does not fit in the configured destination's length).
    14. VP(XcpR.dsn.PackMessage.DetOn.ErrorCodeInvalidLength): Received package is ignored without any action
        because the message does not fit in the configured destination's length.
    15. Set the result as success.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Disabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>124</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CddLocalConnectionsOnly</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>149</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.RemoteConnectMode.DetOn.ErrorCodeInvalidConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>439</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_0</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>122</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TxConfirmation.UpperLayer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>160</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.PackMessage.DetOn.ErrorCodeInvalidLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>422</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.Communication.CDD.ImmediateAccess</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>139</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>523</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_XCPR_MainFunctionPeriod</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_MainFunctionPeriod/source/application/EbTest.c</sourcefile>
      <sourceline>32</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Check that the TimingEvent_MainFunction PERIOD value from XcpR_Bswmd.arxml file based on the XcpRMainFunctionPeriod configuration parameter.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    XcpRMainFunctionPeriod = 0.005
  
Test Execution: 
    01. Generate all files
    02. Compare XcpR_Bswmd.arxml generated System Description file with reference file
    03. Include comparison difference of 02 in this test
    04. VP: If no difference in 03 exists, then nothing will be included and the test compiles

    If a difference exists in 03, then the gnu diff tool generates some characters which cannot be
    compiled which will be indicated by the ts5 environment.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.dsn.GeneralDescription</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>411</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>524</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_XCPR_MultiplePdusInOneFrame</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_MultiplePdusInOneFrame/source/application/EbTest.c.m4</sourcefile>
      <sourceline>75</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Verifies that if XcpR receives a multi-packet frame from a source, then it also sends a multi-packet
      frame to the destination, when both master and remote networks support multiple XcpR
      messanges in one FlexRay frame functionality.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    MASTER NETWORK:
      Bus type: FlexRay
      XcpRSourcePackMultiMsgInOneFlexRayFrame is enabled.
      XcpRDestinationPackMultiMsgInOneFlexRayFrame is enabled.
    REMOTE SLAVE NETWORK:
      Bus type: FlexRay
      XcpRSourcePackMultiMsgInOneFlexRayFrame is enabled.
      XcpRDestinationPackMultiMsgInOneFlexRayFrame is enabled.
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a CONNECT command with MODE = 0 on FlexRay (XcpR_RxIndication()
        is called and command 0xFF, MODE = 0) when no local Xcp slave is configured.
    03. VP(XcpR.dsn.LocalConnectMode.DetOn.ErrorCodeInvalidConnectMode): Check that XcpR module
        throws the runtime error XCPR_E_INVALID_CONNECT_LOCAL_XCP.
    04. Simulate reception of a package consisting in command different than CONNECT command
        on FlexRay (XcpR_RxIndication() is called) when no connection is established.
    05. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the Slave is DISCONNECTED.
    06. Simulate reception of a CONNECT command with MODE = 1 on FlexRay (XcpR_RxIndication()
        is called and command 0xFF, MODE = 1).
    07. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.dsn.ReceptionPackedFrame.TransmissionPackedFrame.AddHeaderInfo,
        XcpR.Impl.RemoteConnections.ConnectMode): Check that the XcpR calls the transmit interface of the lower layer
        (e.g PM_Tst_Slave_Bus_Type\-::-/Transmit is called and the XCP package is the same with the one received from XCP).
    08. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    09. VP(XcpR.Impl.CheckStatusConnection, XcpR.dsn.ReceptionPackedFrame.TransmissionPackedFrame.AddHeaderInfo): Verify that
        the XcpR calls the transmit interface of the lower layer (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package is the same
        with the one received from XCP but header is adapted).
    10. Simulate reception, on master FlexRay bus, of one frame with SET_DAQ_LIST_MODE
        (Data Stimulation Mode) commands to be sent from Xcp master to Xcp slave.
    11. VP(XcpR.dsn.ReceptionPackedFrame.TransmissionPackedFrame.AddHeaderInfo, XcpR.Impl.TransmissionOfConsecutiveMessages)
        Verify that the package is routed to the Xcp instance on the remote ECU in one frame (PM_Tst_Slave_Bus_Type\-::-/Transmit is called ).
    12. Simulate that XCP responses, on remote FlexRay bus, with a positive response to the
        SET_DAQ_LIST_MODE commands (remote Xcp slave calls XcpR_RxIndication).
    13. VP(XcpR.dsn.ReceptionPackedFrame.TransmissionPackedFrame.AddHeaderInfo): Verify that the
        XcpR calls the transmit interface of the lower layer (e.g master PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP
        package is the same with the one received from XCP but header is adapted).
    14. Simulate reception, on FlexRay bus, of one frame with StartDaqList commands
        to be sent from Xcp master to Xcp slave.
    15. VP(XcpR.dsn.ReceptionPackedFrame.TransmissionPackedFrame.AddHeaderInfo) Verify that the packages
        are routed to the Xcp instance on the remote ECU in one frame( remote slave PM_Tst_Master_Bus_Type\-::-/Transmit is called ).
    16. Simulate that XCP responses, on FlexRay bus, with a positive response for 
        START_DAQ_LIST commands (remote Xcp slave calls XcpR_RxIndication).
    17. VP(XcpR.dsn.ReceptionPackedFrame.TransmissionPackedFrame.AddHeaderInfo): Verify that the XcpR calls
        the transmit interface of the lower layer (e.g master PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package is the
        same with the one received from XCP but header is adapted).
    18. Simulate reception, on FlexRay bus, of one frame with simulation data
        to be sent from Xcp master to Xcp slave.
    19. VP(XcpR.dsn.ReceptionPackedFrame.TransmissionPackedFrame.AddHeaderInfo) Verify that the packages
        are routed to the Xcp instance on the remote ECU in one frame( remote slave PM_Tst_Slave_Bus_Type\-::-/Transmit is called ).
    20. Simulate reception, on master FlexRay bus, of one frame with SET_DAQ_LIST_MODE
        (Data Stimulation Mode) commands to be sent from Xcp master to Xcp slave.
    21. VP(XcpR.dsn.ReceptionPackedFrame.TransmissionPackedFrame.AddHeaderInfo) Verify that the package
        is routed to the Xcp instance on the remote ECU in one frame (PM_Tst_Slave_Bus_Type\-::-/Transmit is called).
    22. Simulate reception, on FlexRay bus, of simulation data frame with invalid message
        length to be sent from Xcp master to Xcp slave.
    23. VP(XcpR.dsn.ProcessSource.API.DetOn.ErrorCodeInvalidMessageLength): Verify that XcpR did
        NOT send the package and reported the the runtime error XCPR_E_INVALID_MESSAGE_LENGTH because
        data length of the unpacked message is bigger than the maximum between MaxCto/MaxDto/MaxCtoPgm
        of all configured XcpR sources.
    24. Set the result as success.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Disabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>124</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.BusTypesRemoteConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.LocalConnectMode.DetOn.ErrorCodeInvalidConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>419</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.ReceptionPackedFrame.TransmissionPackedFrame.AddHeaderInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>437</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.ReceptionPackedFrame.AbortUnpacking</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>433</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.ReceptionPackedFrame.TransmissionPackedFrame.PackAtLeastOneMsg</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>438</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.Communication.FlexRay.ImmediateAccess</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>137</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.ProcessSource.API.DetOn.ErrorCodeInvalidMessageLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>424</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>525</internalId></specobject>
    <specobject>
      <id>TS_XCPR_MultiplePdusInOneFrame_RxIndication</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_MultiplePdusInOneFrame/source/application/EbTest.c.m4</sourcefile>
      <sourceline>461</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Test the multiple XcpR messanges in one FlexRay frame and reception
      from RxIndication functionality.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    MASTER NETWORK:
      Bus type: FlexRay
      XcpRSourcePackMultiMsgInOneFlexRayFrame is enabled.
      XcpRDestinationPackMultiMsgInOneFlexRayFrame is enabled.
      XcpRSrcPduSupportRxFromRxIndication is enabled.
    REMOTE SLAVE NETWORK:
      Bus type: FlexRay
      XcpRSourcePackMultiMsgInOneFlexRayFrame is enabled.
      XcpRDestinationPackMultiMsgInOneFlexRayFrame is enabled.
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a CONNECT command with MODE = 0 on FlexRay (XcpR_RxIndication()
        is called and command 0xFF, MODE = 0) when no local Xcp slave is configured.
    03. VP(XcpR.dsn.LocalConnectMode.DetOn.ErrorCodeInvalidConnectMode): Check that XcpR module
        throws the runtime error XCPR_E_INVALID_CONNECT_LOCAL_XCP.
    04. Simulate reception of a package consisting in command different than CONNECT command
        on FlexRay (XcpR_RxIndication() is called) when no connection is established.
    05. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the Slave is DISCONNECTED.
    06. Simulate reception of a CONNECT command with MODE = 1 on FlexRay (XcpR_RxIndication()
        is called and command 0xFF, MODE = 1).
    07. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.dsn.ReceptionPackedFrame.TransmissionPackedFrame.AddHeaderInfo,
        XcpR.Impl.RemoteConnections.ConnectMode): Check that the XcpR calls the transmit interface of the lower layer
        (e.g PM_Tst_Slave_Bus_Type\-::-/Transmit is called and the XCP package is the same with the one received from XCP).
    08. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    09. VP(XcpR.Impl.CheckStatusConnection, XcpR.dsn.ReceptionPackedFrame.TransmissionPackedFrame.AddHeaderInfo): Verify that
        the XcpR calls the transmit interface of the lower layer (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package is the same
        with the one received from XCP but header is adapted).
    10. Simulate reception, on master FlexRay bus, of the first frame with SET_DAQ_LIST_MODE
        (Data Stimulation Mode) commands to be sent from Xcp master to Xcp slave.
    11. Simulate reception, on master FlexRay bus, of the second frame with SET_DAQ_LIST_MODE
        (Data Stimulation Mode) commands to be sent from Xcp master to Xcp slave.
    12. VP(XcpR.dsn.ReceptionPackedFrame.TransmissionPackedFrame.AddHeaderInfo, XcpR.Impl.TransmissionOfConsecutiveMessages)
        Verify that the first package is routed to the Xcp instance on the remote ECU in one frame (PM_Tst_Slave_Bus_Type\-::-/Transmit is called).
    13. Call XCPR main processing function to process the second package.
    14. VP(XcpR.dsn.ReceptionPackedFrame.TransmissionPackedFrame.AddHeaderInfo, XcpR.Impl.TransmissionOfConsecutiveMessages)
        Verify that the package is routed to the Xcp instance on the remote ECU in one frame (PM_Tst_Slave_Bus_Type\-::-/Transmit is called ).
    15. Simulate that XCP responses, on remote FlexRay bus, with a positive response to the
        SET_DAQ_LIST_MODE commands (remote Xcp slave calls XcpR_RxIndication).
    16. Simulate that XCP responses, on remote FlexRay bus, with a second positive response to the
        SET_DAQ_LIST_MODE commands (remote Xcp slave calls XcpR_RxIndication).
    17. VP(XcpR.dsn.ReceptionPackedFrame.TransmissionPackedFrame.AddHeaderInfo): Verify that the
        XcpR calls the transmit interface of the lower layer (e.g master PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP
        package is the same with the one received from XCP but header is adapted).
    18. Call XCPR main processing function to check that no other data should be available for transmission.
    19. No other messages are sent.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Disabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>124</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.BusTypesRemoteConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.LocalConnectMode.DetOn.ErrorCodeInvalidConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>419</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.ReceptionPackedFrame.TransmissionPackedFrame.AddHeaderInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>437</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>526</internalId></specobject>
    <specobject>
      <id>TS_XCPR_MultiplePdusInOneFrame_DifferentSources</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_MultiplePdusInOneFrame/source/application/EbTest.c.m4</sourcefile>
      <sourceline>813</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Test the multiple XcpR messanges in one FlexRay frame functionality when simulate reception
      of two packages frame from two different sources.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    MASTER NETWORK:
      Bus type: FlexRay
      XcpRSourcePackMultiMsgInOneFlexRayFrame is enabled.
      XcpRDestinationPackMultiMsgInOneFlexRayFrame is enabled.
      XcpRSrcPduSupportRxFromRxIndication is enabled.
    REMOTE SLAVE NETWORK:
      Bus type: FlexRay
      XcpRSourcePackMultiMsgInOneFlexRayFrame is enabled.
      XcpRDestinationPackMultiMsgInOneFlexRayFrame is enabled.
      XcpRSrcPduSupportRxFromRxIndication is enabled.
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a CONNECT command with MODE = 0 on FlexRay (XcpR_RxIndication()
        is called and command 0xFF, MODE = 0) when no local Xcp slave is configured.
    03. VP(XcpR.dsn.LocalConnectMode.DetOn.ErrorCodeInvalidConnectMode): Check that XcpR module
        throws the runtime error XCPR_E_INVALID_CONNECT_LOCAL_XCP.
    04. Simulate reception of a package consisting in command different than CONNECT command
        on FlexRay (XcpR_RxIndication() is called) when no connection is established.
    05. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the Slave is DISCONNECTED.
    06. Simulate reception of a CONNECT command with MODE = 1 on FlexRay (XcpR_RxIndication()
        is called and command 0xFF, MODE = 1).
    07. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.dsn.ReceptionPackedFrame.TransmissionPackedFrame.AddHeaderInfo,
        XcpR.Impl.RemoteConnections.ConnectMode): Check that the XcpR calls the transmit interface of the lower layer
        (e.g PM_Tst_Slave_Bus_Type\-::-/Transmit is called and the XCP package is the same with the one received from XCP).
    08. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    09. VP(XcpR.Impl.CheckStatusConnection, XcpR.dsn.ReceptionPackedFrame.TransmissionPackedFrame.AddHeaderInfo): Verify that
        the XcpR calls the transmit interface of the lower layer (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package is the same
        with the one received from XCP but header is adapted).
    10. Simulate reception of a packet frame to be sent from Xcp master to remote Xcp slave.
    11. Simulate the response from Xcp slave, on FlexRay bus, with a frame package to be
        sent from remote Xcp slave to Xcp master.
    12. VP(XcpR.dsn.ReceptionPackedFrame.TransmissionPackedFrame.AddHeaderInfo): Verify that
        remote XCP slave received the expected data. (the XCP package is the same with the received package
        from master XCP but header is adapted).
    13. VP(XcpR.dsn.ReceptionPackedFrame.TransmissionPackedFrame.AddHeaderInfo): Verify that
        XCP master received the expected data. (the XCP package is the same with the received package
        from remote XCP slave but header is adapted).
    14. Set the result as success.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Disabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>124</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.BusTypesRemoteConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.LocalConnectMode.DetOn.ErrorCodeInvalidConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>419</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.ReceptionPackedFrame.TransmissionPackedFrame.AddHeaderInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>437</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>527</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_XCPR_MultiplePdusInOneFrame_Master</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_MultiplePdusInOneFrame_Master/source/application/EbTest.c.m4</sourcefile>
      <sourceline>41</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Test the multiple XcpR messanges in one FlexRay frame functionality (Master bus)
      and packing/unpacking from/to the remote network.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    MASTER NETWORK:
      Bus type: FlexRay
      XcpRSourcePackMultiMsgInOneFlexRayFrame is enabled.
      XcpRDestinationPackMultiMsgInOneFlexRayFrame is enabled.
    REMOTE SLAVE NETWORK:
      Bus type: PM_Tst_Slave_Bus_Type
      Tansmission from TxConfirmation : PM_Tst_Slave_XcpRDestPduSupportTxFromTxConfirmation
  
Test Execution: 
    01. Call XCPR main processing function before XcpR_Init() function.
    02. VP(XcpR.Impl.MainFunction.InitCheck) Check if the module abort the execution
        without doing anything else.
    03. Initialize stubs and XcpR.
    04. Simulate reception of a package consisting in command different than CONNECT command
        on FlexRay (XcpR_RxIndication() is called) when no connection is established (simulate GET_STATUS
        command.
    05. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without
        any action because the Slave is DISCONNECTED.
    06. Simulate reception of a CONNECT command with MODE = 1 on FlexRay (XcpR_RxIndication()
        is called and command 0xFF, MODE = 1).
    07. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode): Check that the XcpR
        calls the transmit interface of the lower layer (e.g PM_Tst_Slave_Bus_Type\-::-/Transmit is called and the XCP
        package is the same with the one received from XCP).
    08. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals  to CONNECT positive response).
    09. VP(XcpR.Impl.CheckStatusConnection): Verify that the XcpR calls the transmit interface
        of the lower layer (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package is the same with the
        one received from XCP but header is adapted).
    10. Simulate reception, on FlexRay bus, of one frame with SET_DAQ_LIST_MODE
        (Data Stimulation Mode) commands to be sent from Xcp master to Xcp slave.
    11. VP (XcpR.Impl.TransmissionOfConsecutiveMessages, XcpR.dsn.ReceptionPackedFrame.SendMessageIndependently)
        Verify that the packages are routed to the Xcp instance on the remote ECU (PM_Tst_Slave_Bus_Type\-::-/Transmit is called three times).
    12. Simulate that slave XCP responses, on PM_Tst_Slave_Bus_Type bus, with positive responses for 
        SET_DAQ_LIST_MODE commands (remote Xcp slave calls XcpR_RxIndication).
    13. VP(XcpR.dsn.ReceptionFromRxIndication.TransmissionPackedFrame.PackMsgIntoFrame): Verify that the XcpR
        calls the transmit interface of the lower layer (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package is the same with
        the one received from XCP but header is adapted).
    14. Simulate reception, on FlexRay bus, of one frame with START_DAQ_LIST commands
        to be sent from Xcp master to Xcp slave.
    15. VP (XcpR.dsn.ReceptionPackedFrame.SendMessageIndependently) Verify that the packages are routed
        to the Xcp instance on the remote ECU (PM_Tst_Slave_Bus_Type\-::-/Transmit is called three times).
    16. Simulate that XCP responses, on PM_Tst_Slave_Bus_Type bus, with a positive responses for 
        START_STOP_DAQ_LIST commands (remote Xcp slave calls XcpR_RxIndication).
    17. VP(XcpR.dsn.ReceptionFromRxIndication.TransmissionPackedFrame.PackMsgIntoFrame): Verify that the
        XcpR calls the transmit interface of the lower layer (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package
        is the same with the one received from XCP but header is adapted).
    18. Simulate reception, on FlexRay bus, of one frame with simulation data
        to be sent from Xcp master to Xcp slave.
    19. VP (XcpR.dsn.ReceptionPackedFrame.SendMessageIndependently) Verify that the packages are routed to the Xcp
        instance on the remote ECU (PM_Tst_Slave_Bus_Type\-::-/Transmit is called three times).
    20. Simulate reception, on FlexRay bus, of one frame with SET_DAQ_LIST_MODE
        (Data Acquisition Mode) commands to be sent from Xcp master to Xcp slave.
    21. VP (XcpR.dsn.ReceptionPackedFrame.SendMessageIndependently) Verify that the packages
        are routed to the Xcp instance on the remote ECU (PM_Tst_Slave_Bus_Type\-::-/Transmit is called three times).
    22. Simulate that slave XCP responses, on PM_Tst_Slave_Bus_Type bus, with 3 individual positive response
        packets for Tst_SetDaqListModeDAQ_Cmd commands (remote Xcp slave calls XcpR_RxIndication).
    23. VP(XcpR.dsn.ReceptionFromRxIndication.TransmissionPackedFrame.PackMsgIntoFrame): Verify that
        the XcpR calls the transmit interface of the lower layer only once (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP
        frame package contains the 3 response messages from remote Slave but header is adapted)
    24. Set the result as success.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.BusTypesRemoteConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.MainFunction.InitCheck</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>134</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.ReceptionPackedFrame.SendMessageIndependently</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>435</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.ReceptionFromRxIndication.TransmissionPackedFrame.PackMsgIntoFrame</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>432</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.ReceptionPackedFrame.AbortUnpacking</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>433</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.ReceptionPackedFrame.CheckTxConfirmation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>434</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.Communication.FlexRay.ImmediateAccess</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>137</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>528</internalId></specobject>
    <specobject>
      <id>TS_XCPR_MultiplePdusInOneFrame_ToLocalXcp</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_MultiplePdusInOneFrame_Master/source/application/EbTest.c.m4</sourcefile>
      <sourceline>401</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Test the multiple XcpR messanges in one FlexRay frame functionality (Master bus)
      and packing/unpacking from/to the local network.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    MASTER NETWORK:
      Bus type: FlexRay
      XcpRSourcePackMultiMsgInOneFlexRayFrame is enabled.
      XcpRDestinationPackMultiMsgInOneFlexRayFrame is enabled.
    LOCAL SLAVE NETWORK:
      Bus type: CDD
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a package consisting in command different than CONNECT command
        on FlexRay (XcpR_RxIndication() is called) when no connection is established (simulate GET_STATUS
        command.
    03. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the Slave is DISCONNECTED.
    04. Simulate reception of a CONNECT command with MODE = 0 on FlexRay (XcpR_RxIndication()
        is called and command 0xFF, MODE = 0).
    05. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_0, XcpR.Impl.AdaptBusInfo): Verify that the XcpR calls
        the indication interface of the upper layer (e.g Xcp_CddRxIndication is called and the XCP package
        is the same with the one received from XCP but header is adapted).
    06. Simulate a positive response from the local XCP slave (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    07. VP(XcpR.Impl.CheckStatusConnection, XcpR.Impl.AdaptBusInfo): Verify that the XcpR calls
        the transmit interface of the lower layer (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package is
        the same with the one received from XCP but header is adapted).
    08. Simulate reception, on FlexRay bus, of one frame with SET_DAQ_LIST_MODE
        (Data Stimulation Mode) commands to be sent from Xcp master to Xcp slave.
    09. VP (XcpR.dsn.ReceptionPackedFrame.SendMessageIndependently, XcpR.Impl.TransmissionOfConsecutiveMessages,
        XcpR.Impl.AdaptBusInfo) Verify that the packages are routed to the Xcp instance on the local ECU
        (Xcp_CddRxIndication is called three times).
    10. Simulate that slave XCP responses, on Cdd bus, with positive responses for 
        SET_DAQ_LIST_MODE commands (Xcp calls XcpR_Transmit).
    11. VP(XcpR.Impl.AdaptBusInfo, XcpR.dsn.ReceptionFromRxIndication.TransmissionPackedFrame.PackMsgIntoFrame):
        Verify that the XcpR calls the transmit interface of the lower layer only once (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called
        and the XCP frame package contains the 3 response messages from local Slave but header is adapted).
    12. Simulate reception, on FlexRay bus, of one frame with StartDaqList commands
        to be sent from Xcp master to Xcp slave.
    13. VP (XcpR.Impl.AdaptBusInfo, XcpR.dsn.ReceptionPackedFrame.SendMessageIndependently) Verify
        that the packages are routed to the Xcp instance on the local ECU (Xcp_CddRxIndication is called three times).
    14. Simulate that XCP responses, on CDD bus, with a positive responses for START_STOP_DAQ_LIST
        commands (Xcp calls XcpR_Transmit).
    15. VP(XcpR.dsn.ReceptionFromRxIndication.TransmissionPackedFrame.PackMsgIntoFrame): Verify that the
        XcpR calls the transmit interface of the lower layer (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package
        is the same with the one received from XCP but header is adapted).
    16. Simulate reception, on FlexRay bus, of one frame with simulation data
        to be sent from Xcp master to Xcp slave.
    17. VP (XcpR.dsn.ReceptionPackedFrame.SendMessageIndependently) Verify that the packages are routed
        to the Xcp instance on the local ECU (Xcp_CddRxIndication is called three times).
    18. Simulate reception, on FlexRay bus, of one frame with SET_DAQ_LIST_MODE
        (Data Acquisition Mode) commands to be sent from Xcp master to Xcp slave.
    19. VP (XcpR.dsn.ReceptionPackedFrame.SendMessageIndependently) Verify that the packages are routed to
        the Xcp instance on the local ECU (Xcp_CddRxIndication is called three times).
    20. Simulate that slave XCP responses, on Cdd bus, with positive responses for 
        Tst_SetDaqListModeDAQ_Cmd commands (Xcp calls XcpR_Transmit).
    21. VP(XcpR.dsn.ReceptionFromRxIndication.TransmissionPackedFrame.PackMsgIntoFrame): Verify that the XcpR
        calls the transmit interface of the lower layer only once (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP frame
        package contains the 3 response messages from local Slave but header is adapted).
    22. Set the result as success.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.CddLocalConnectionsOnly</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>149</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_0</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>122</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.AdaptBusInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>147</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.ReceptionPackedFrame.SendMessageIndependently</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>435</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.ReceptionFromRxIndication.TransmissionPackedFrame.PackMsgIntoFrame</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>432</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.ReceptionPackedFrame.AbortUnpacking</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>433</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.ReceptionPackedFrame.CheckTxConfirmation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>434</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.UpperLayerRxIndicationPduId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>151</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.UpperLayerTxConfirmationPduId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>152</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.Communication.FlexRay.ImmediateAccess</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>137</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>529</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_XCPR_MultiplePdusInOneFrame_RemoteXcpSlave</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_MultiplePdusInOneFrame_Slave/source/application/EbTest.c.m4</sourcefile>
      <sourceline>159</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Test the multiple XcpR messages in one frame functionality (Remote bus)
      and packing/unpacking from/to the master network.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    MASTER NETWORK:
      Bus type: PM_Tst_Master_Bus_Type
      Transmission from TxConfirmation: PM_Tst_Master_XcpRDestPduSupportTxFromTxConfirmation
    REMOTE SLAVE NETWORK:
      Bus type: PM_Tst_Slave_Bus_Type
      XcpRSourcePackMultiMsgInOneFlexRayFrame is enabled.
      XcpRDestinationPackMultiMsgInOneFlexRayFrame is enabled.
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a package consisting in command different than CONNECT command
        on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called) when no connection is established.
    03. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the Slave is DISCONNECTED.
    04. Simulate reception of a CONNECT command with MODE = 1 on PM_Tst_Master_Bus_Type (XcpR_RxIndication()
        is called and command 0xFF, MODE = 1).
    05. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode): Check that the
        XcpR calls the transmit interface of the lower layer (e.g PM_Tst_Slave_Bus_Type\-::-/Transmit is called and the XCP package
        is the same with the one received from XCP).
    06. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    07. VP(XcpR.Impl.CheckStatusConnection): Verify that the XcpR calls the transmit interface of the lower
        layer (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package is the same with the one
        received from XCP but header is adapted).
    08. Simulate reception, on PM_Tst_Master_Bus_Type bus, of SET_DAQ_LIST_MODE commands.
    09. VP (XcpR.Impl.TransmissionOfConsecutiveMessages
        XcpR.dsn.ReceptionFromRxIndication.TransmissionPackedFrame.PackMsgIntoFrame) Verify that the packages
        are routed to the Xcp instance on the remote ECU in one frame (PM_Tst_Slave_Bus_Type\-::-/Transmit is called once).
    10. Call XCPR main processing function to process the fourth SET_DAQ_LIST_MODE command.
    11. VP (XcpR.Impl.TransmissionOfConsecutiveMessages
        XcpR.dsn.ReceptionFromRxIndication.TransmissionPackedFrame.PackMsgIntoFrame) Verify that the fourth package
        is routed to the Xcp instance on the remote ECU in one frame (PM_Tst_Slave_Bus_Type\-::-/Transmit is called once).
    12. Simulate that XCP responses, on FlexRay bus, with a positive response for 
        SET_DAQ_LIST_MODE commands (remote Xcp slave calls XcpR_RxIndication).
    13. VP(XcpR.dsn.ReceptionPackedFrame.SendMessageIndependently): Verify that the XcpR calls the transmit interface
        of the lower layer (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called four times and the XCP data packages are
        the same with the one received from XCP but header is adapted).
    14. Simulate reception, on PM_Tst_Master_Bus_Type bus, of four START_DAQ_LIST commands.
    15. VP (XcpR.dsn.ReceptionFromRxIndication.TransmissionPackedFrame.PackMsgIntoFrame) Verify that the package
        are routed to the Xcp instance on the remote ECU in one frame (PM_Tst_Slave_Bus_Type\-::-/Transmit is called once).
    16. Simulate that XCP responses, on FlexRay bus, with frame containing 4 positive responses for
        START_DAQ_LIST commands (remote Xcp slave calls XcpR_RxIndication).
    17. VP(XcpR.dsn.ReceptionPackedFrame.SendMessageIndependently): Verify that the XcpR calls the transmit interface of the
        lower layer only once (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called four times and the XCP data packages are the same with
        the one received from XCP but header is adapted).
    18. Simulate reception, on PM_Tst_Master_Bus_Type bus, of four simulation data packages
        to be sent from Xcp master to Xcp slave.
    19. VP (XcpR.dsn.ReceptionFromRxIndication.TransmissionPackedFrame.PackMsgIntoFrame) Verify that
        the packages are routed to the Xcp instance on the remote ECU in one frame (PM_Tst_Slave_Bus_Type\-::-/Transmit is called once).
    20. Set the result as success.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.ConcatMessagesFlexRayPackMultipleMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>128</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.ConcatMessagesEthernetPackMultipleMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>129</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.ConcatMessagesFlexRayUnpackMultipleMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>126</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.ConcatMessagesEthernetUnpackMultipleMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>127</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Disabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>124</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.BusTypesRemoteConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.GeneralDescription</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>411</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.PrecompileTimeConfig</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>423</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.ReceptionFromRxIndication.TransmissionPackedFrame.PackMsgIntoFrame</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>432</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.ReceptionPackedFrame.SendMessageIndependently</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>435</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.ReceptionPackedFrame.AbortUnpacking</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>433</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.ReceptionPackedFrame.CheckTxConfirmation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>434</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>530</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_XCPR_MultiplePdus_TxConf</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_MultiplePdus_TxConf/source/application/EbTest.c.m4</sourcefile>
      <sourceline>187</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Test the multiple XcpR messages in one frame functionality (master bus)
      and packing/unpacking from/to the master network and transmission from TxConfirmation.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    MASTER NETWORK:
      Bus type: FlexRay
      XcpRSourcePackMultiMsgInOneFlexRayFrame enabled.
      XcpRDestinationPackMultiMsgInOneFlexRayFrame enabled.
      XcpRSrcPduSupportRxFromRxIndication enabled.
      XcpRDestPduSupportTxFromTxConfirmation enabled.
    REMOTE SLAVE NETWORK:
      Bus type: PM_Tst_Slave_Bus_Type
      XcpRSrcPduSupportRxFromRxIndication enabled.
      XcpRDestPduSupportTxFromTxConfirmation enabled.
  
Test Execution: 
    01. Initialize stubs and XcpR,
    02. Simulate reception of a package consisting in command different than CONNECT command on FlexRay
        (XcpR_RxIndication() is called) when no connection is established (simulate GET_STATUS command,
    03. VP(XcpR.dsn.DisconnectedState.DetOn.ErrorCodePduLost): Check that XcpR throws the
        runtime error XCPR_E_PDU_LOST,
    04. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the Slave is DISCONNECTED,
    05. Simulate reception of a CONNECT command with MODE = 1 on FlexRay (XcpR_RxIndication()
        is called and command 0xFF, MODE = 1),
    06. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode): Check that the XcpR
        calls the transmit interface of the lower layer (e.g PM_Tst_Slave_Bus_Type\-::-/Transmit is called and the
        XCP package is the same with the one received from XCP),
    07. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
          and data equals to CONNECT positive response),
    08. VP(XcpR.Impl.CheckStatusConnection): Verify that the XcpR calls the transmit interface
        of the lower layer (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package is the same with the
        one received from XCP but header is adapted),
    09. Simulate reception, on FlexRay bus, of one frame with SET_DAQ_LIST_MODE
        (Data Stimulation Mode) commands to be sent from Xcp master to Xcp slave,
    10. VP (XcpR.Impl.TransmitFromTxConfirmation, XcpR.Impl.TransmissionOfConsecutiveMessages) Verify that
        the packages are routed to the Xcp instance on the remote ECU (PM_Tst_Slave_Bus_Type\-::-/Transmit is called),
    11. Simulate reception, on FlexRay bus, of one frame with SET_DAQ_LIST_MODE
        (Data Stimulation Mode) commands to be sent from Xcp master to Xcp slave,
    12. Simulate confirming the packet after\-::-/PM_Tst_Slave_Bus_Type\-::-/Transmit() was processed from step 09
        and process the Tst_SetDaqListModeSTIM2_Cmd packet,
    13. VP (XcpR.Impl.TransmitFromTxConfirmation, XcpR.Impl.TransmissionOfConsecutiveMessages) Verify that
        the packages are routed to the Xcp instance on the remote ECU (PM_Tst_Slave_Bus_Type\-::-/Transmit is called two times),
    14. Call XCPR main processing function to check that no other data should be available for transmission,
    15. No other messages are sent,
    16. Simulate that slave XCP responses, on PM_Tst_Slave_Bus_Type bus, with positive responses for 
        Tst_SetDaqListModeSTIM1_Cmd command (remote Xcp slave calls XcpR_RxIndication),
    17. VP(XcpR.Impl.TransmitFromTxConfirmation): Verify that the XcpR calls the transmit
        interface of the lower layer (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package is the same with
        the one received from XCP but header is adapted),
    18. Simulate that slave XCP responses, on PM_Tst_Slave_Bus_Type bus, with positive responses for 
        Tst_SetDaqListModeSTIM2_Cmd command,
    19. VP(XcpR.Impl.TransmitFromTxConfirmation): Verify that the XcpR calls the transmit
        interface of the lower layer (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package is the same with
        the one received from XCP but header is adapted),
    20. Simulate reception, on FlexRay bus, of  START_STOP_DAQ_LIST frame command to be sent
        from Xcp master to remote Xcp slave,
    21. VP (XcpR.Impl.TransmitFromTxConfirmation) Verify that the packages are routed
        to the Xcp instance on the remote ECU (PM_Tst_Slave_Bus_Type\-::-/Transmit is called ),
    22. Simulate reception, on FlexRay bus, of START_STOP_DAQ_LIST frame commands to be sent
        from Xcp master to remote Xcp slave,
    23. Simulate confirming the packet after\-::-/PM_Tst_Slave_Bus_Type\-::-/Transmit() was processed from step 20
        and process the packet from step 21,
    24. VP (XcpR.Impl.TransmitFromTxConfirmation) Verify that the packages are routed
        to the Xcp instance on the remote ECU (PM_Tst_Slave_Bus_Type\-::-/Transmit is called two times),
    25. Simulate that slave XCP responses, on PM_Tst_Slave_Bus_Type bus, with positive responses to
        START_STOP_DAQ_LIST commands (remote Xcp slave calls XcpR_RxIndication),
    26. VP(XcpR.Impl.TransmitFromTxConfirmation): Verify that the XcpR calls the transmit
        interface of the lower layer (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package is the same with
        the one received from XCP but header is adapted),
    27. Simulate that slave XCP responses, on PM_Tst_Slave_Bus_Type bus, with positive responses to
        START_STOP_DAQ_LIST command,
    28. Simulate confirming the response after PM_Tst_Master_Bus_Type\-::-/Transmit() was processed from step 25
        and process the responses from step 27.
    29. VP(XcpR.Impl.TransmitFromTxConfirmation): Verify that the XcpR calls the transmit
        interface of the lower layer (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package is the same with
        the one received from XCP but header is adapted),
    30. Simulate reception, on FlexRay bus, of one frame with simulation data
        to be sent from Xcp master to Xcp slave,
    31. VP (XcpR.Impl.TransmissionOfConsecutiveMessages, XcpR.dsn.ReceptionPackedFrame.SendMessageIndependently)
        Verify that the packages are routed to the Xcp instance on the remote ECU (PM_Tst_Slave_Bus_Type\-::-/Transmit
        is called three times).
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.BusTypesRemoteConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.ConcatMessagesFlexRayUnpackMultipleMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>126</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.ConcatMessagesEthernetUnpackMultipleMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>127</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.DisconnectedState.DetOn.ErrorCodePduLost</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>408</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmitFromTxConfirmation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>165</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.Transmit.From.Tx.Context.Configuration</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>135</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.Reception.From.Rx.Context.Configuration</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>136</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>531</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_XCPR_InternalQueueStress</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_Queue_Stress/source/application/EbTest.c.m4</sourcefile>
      <sourceline>66</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Check the consistency of the XcpR internal queue when multiple massages are simulated
      to be sent and all messages are forwarded to the Xcp Slave on the remote ECU.
      * MASTER NETWORK: CAN-FD
        Enabled reception from RxIndication
      * REMOTE SLAVE NETWORK: CDD
        Enabled transmission from TxConfirmation
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    XcpRSrcPduSupportRxFromRxIndication is enabled.
    XcpRDestPduSupportTxFromTxConfirmation is enabled.
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a CONNECT command with MODE = 1 on CANFD (XcpR_RxIndication() is called
        and command 0xFF, MODE = 1).
    03. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode):
        Check that the XcpR calls the transmit interface of the lower layer (e.g CanIf_Transmit is called
        and the XCP package is the same with the one received from  XCP but header is adapted).
    04. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    05. VP(XcpR.Impl.CheckStatusConnection): Verify that the XcpR calls the transmit
        interface of the lower layer(e.g CanIf_Transmit is called and the XCP package is the
        same with the one received from XCP).
    06. Loop to simulated several packages with different sizes 
      07. Loop to simulate a different number of packets before XcpR_MainFunction is called.
        08. Loop to simulate sending the data packet index_2 times if the packet fits in the unused XcpR internal queue size.
          09. Simulate reception of a packet on CAN-FD (XcpR_RxIndication() is called) to be sent
              from Xcp master to remote Xcp slave.
        10. Call XCPR main processing function to process the packages.
m4_ifelse(PM_Permutation,p1DetRuntimeOff,\-:m4_dnl
        11. Check that XcpR does not store a Det runtime error if XcpRDetRuntimeChecks is set to false.
:-/,m4_ifelse( :else: )\-:
        11. VP(XcpR.dsn.InternalQueue.DetOn.ErrorCodeOverflow): Check that XcpR throws the runtime
            error XCPR_E_INTERNAL_BUFFER_OVERFLOW.
:-/m4_ifelse( :endif: ))
        12. VP Verify that the packages are routed to the Xcp instance on the remote ECU.
    13. Loop to simulated several packages with different sizes 
      14. Loop to simulate a different number of packets before XcpR_MainFunction is called.
        15. Loop to simulate sending the data packet index_2 times if the packet fits in the unused XcpR internal queue size.
          16. Simulate reception of a packet on CAN-FD (XcpR_RxIndication() is called) to be sent
              from Xcp master to remote Xcp slave.
        17. Call XCPR main processing function to process the packages.
m4_ifelse(PM_Permutation,p1DetRuntimeOff,\-:m4_dnl
        18. Check that XcpR does not store a Det runtime error if XcpRDetRuntimeChecks is set to false.
:-/,m4_ifelse( :else: )\-:
        18. VP(XcpR.dsn.InternalQueue.DetOn.ErrorCodeOverflow): Check that XcpR throws the runtime
            error XCPR_E_INTERNAL_BUFFER_OVERFLOW.
:-/m4_ifelse( :endif: ))
        19. VP Verify that the packages are routed to the Xcp instance on the remote ECU.
    20. Loop to simulated several packages with different sizes 
      21. Loop to simulate a different number of packets before XcpR_MainFunction is called.
        22. Loop to simulate sending the data packet index_2 times if the packet fits in the unused XcpR internal queue size.
          23. Simulate reception of a packet on CAN-FD (XcpR_RxIndication() is called) to be sent
              from Xcp master to remote Xcp slave.
        24. Call XCPR main processing function to process the packages.
m4_ifelse(PM_Permutation,p1DetRuntimeOff,\-:m4_dnl
        25. Check that XcpR does not store a Det runtime error if XcpRDetRuntimeChecks is set to false.
:-/,m4_ifelse( :else: )\-:
        25. VP(XcpR.dsn.InternalQueue.DetOn.ErrorCodeOverflow): Check that XcpR throws the runtime
            error XCPR_E_INTERNAL_BUFFER_OVERFLOW.
:-/m4_ifelse( :endif: ))
        26. VP Verify that the packages are routed to the Xcp instance on the remote ECU.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.BusTypesRemoteConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.GeneralDescription</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>411</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.ConfigurableInternalQueue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>148</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.InternalQueue.DetOn.ErrorCodeOverflow</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>413</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>532</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_XCPR_ReceptionFromRx_RemoteXcpSlave</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_ReceptionRx/source/application/EbTest.c.m4</sourcefile>
      <sourceline>107</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Test the reception from RxIndication functionality on remote Xcp slave.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    MASTER NETWORK:
      Bus type: PM_Tst_Master_Bus_Type
      XcpRSrcPduSupportRxFromRxIndication enabled.
    REMOTE SLAVE NETWORK:
      Bus type: PM_Tst_Slave_Bus_Type
      XcpRSrcPduSupportRxFromRxIndication enabled.
    Timestamp is PM_Tst_XcpRTimestampEnabled.
  
Test Execution: 
    01. Call XCPR main processing function before XcpR_Init() function.
    02. VP(XcpR.Impl.MainFunction.InitCheck) Check if the module abort the execution
        without doing anything else.
    03. Initialize stubs and XcpR.
    04. Simulate reception of a package consisting in command different than CONNECT command on PM_Tst_Master_Bus_Type
        (XcpR_RxIndication() is called) when no connection is established (simulate GET_STATUS command.
        VP(XcpR.dsn.DisconnectedState.DetOn.ErrorCodePduLost): Check that XcpR throws the
        runtime error XCPR_E_PDU_LOST.
    05. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the Slave is DISCONNECTED.
    06. Simulate reception of a CONNECT command with MODE = 1 on PM_Tst_Master_Bus_Type (XcpR_RxIndication()
        is called and command 0xFF, MODE = 1).
    07. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode): Check that the
        XcpR calls the transmit interface of the lower layer (e.g PM_Tst_Slave_Bus_Type\-::-/Transmit is called
        and the XCP package is the same with the one received from XCP master).
    08. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
          and data equals to CONNECT positive response).
    09. VP(XcpR.Impl.CheckStatusConnection): Verify that the XcpR calls the transmit interface
        of the lower layer (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package is the same
        with the one received from XCP but header is adapted).
    10. Simulate reception, on PM_Tst_Master_Bus_Type bus, of SET_DAQ_LIST_MODE commands.
    11. VP (XcpR.Impl.TransmissionOfConsecutiveMessages, XcpR.dsn.ReceptionFromRxIndication.SendIndependentMessage)
        Verify that the packages are routed to the Xcp instance on the remote ECU (PM_Tst_Slave_Bus_Type\-::-/Transmit is called twice).
    12. Simulate that remote XCP slave responses, on PM_Tst_Slave_Bus_Type bus, with positive response for
        SET_DAQ_LIST_MODE commands (remote Xcp slave calls XcpR_RxIndication).
    13. VP (XcpR.dsn.ReceptionFromRxIndication.SendIndependentMessage) Verify that the response packages are routed to
        the master Xcp (PM_Tst_Master_Bus_Type\-::-/Transmit() is called twice).
    14. Simulate reception, on PM_Tst_Master_Bus_Type bus, of START_STOP_DAQ_LIST commands.
    15. VP (XcpR.dsn.ReceptionFromRxIndication.SendIndependentMessage) Verify that the packages are
        routed to the Xcp instance on the remote ECU (PM_Tst_Slave_Bus_Type\-::-/Transmit is called twice).
    16. Simulate that remote XCP slave responses, on PM_Tst_Slave_Bus_Type bus, with positive response for 
        START_STOP_DAQ_LIST commands (remote Xcp slave calls XcpR_RxIndication]).
    17. VP (XcpR.dsn.ReceptionFromRxIndication.SendIndependentMessage) Verify that the response packages are routed to
        the master Xcp (PM_Tst_Master_Bus_Type\-::-/Transmit() is called twice).
    m4_ifelse(PM_Permutation,FrToCan,\-:
    18. Simulate reception, on PM_Tst_Master_Bus_Type bus, of the WRITE_DAQ_MULTIPLE command .
    19. VP(XcpR.dsn.ProcessSource.API.DetOn.ErrorCodeInvalidMessageLength): XcpR should report the DET error:
        XCPR_E_INVALID_MESSAGE_LENGTH because the message does not fit in the destination's available length
:-/m4_ifelse( :endif: ))\-::-/m4_dnl
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.BusTypesRemoteConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.MainFunction.InitCheck</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>134</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.DisconnectedState.DetOn.ErrorCodePduLost</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>408</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.ReceptionFromRxIndication.SendIndependentMessage</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>430</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.ReceptionFromRxIndication.StoreMessageInternally</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>431</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.Reception.From.Rx.Context.Configuration</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>136</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.PublicHeader</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>141</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.ProcessSource.API.DetOn.ErrorCodeInvalidMessageLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>424</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>533</internalId></specobject>
    <specobject>
      <id>TS_XCPR_ReceptionFromRx_LocalXcpSlave</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_ReceptionRx/source/application/EbTest.c.m4</sourcefile>
      <sourceline>461</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Test the reception from RxIndication functionality on local Xcp slave.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    MASTER NETWORK:
      Bus type: PM_Tst_Master_Bus_Type
      XcpRSrcPduSupportRxFromRxIndication enabled.
    LOCAL SLAVE NETWORK:
      Bus type: Cdd
      XcpRSrcPduSupportRxFromXcpRTransmit enabled.
    Timestamp is PM_Tst_XcpRTimestampEnabled.
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a package consisting in command different than CONNECT command
        on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called) when no connection is
        established (simulate GET_STATUS command.
    03. VP(XcpR.dsn.DisconnectedState.DetOn.ErrorCodePduLost): Check that XcpR throws the
        runtime error XCPR_E_PDU_LOST.
    04. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the Slave is DISCONNECTED.
    05. Simulate a positive response from the XCP on local ECU when no CONNECT command was received.
    06. VP(XcpR.dsn.DisconnectedState.DetOn.ErrorCodeUnexpectedMessage): Check that XcpR throws the
        runtime error XCPR_E_UNEXPECTED_MSG.
    07. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action.
    08. Simulate reception of a CONNECT command with MODE = 0 on PM_Tst_Master_Bus_Type (XcpR_RxIndication()
        is called and command 0xFF, MODE = 0).
    09. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_0, XcpR.Impl.DisconnectedState.ConnectMode): Verify that
        the XcpR calls the indication interface of the upper layer (e.g Xcp_CddRxIndication is called and
        the XCP package is the same with the one received from XCP but header is adapted).
    10. Simulate a positive response from the Xcp on local ECU (Xcp calls XcpR_Transmit with
        CONNECT positive response).
    11. VP(XcpR.Impl.TxConfirmation.UpperLayer): Verify that the XcpR calls the confirmation interface
        of the upper layer (e.g Xcp_CddTxConfirmation is called with the correct pdu id).
    12. VP(XcpR.Impl.CheckStatusConnection): Verify that the XcpR calls the transmit interface of
        the lower layer (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the master Xcp package is the same
        with the one received from the local slave Xcp but header is adapted).
    13. Simulate reception, on PM_Tst_Master_Bus_Type bus, of two SET_DAQ_LIST_MODE commands.
    14. Call XCPR main processing function to process the packages.
    15. VP (XcpR.Impl.TransmissionOfConsecutiveMessages, XcpR.dsn.ReceptionFromRxIndication.SendIndependentMessage):
        Verify that the packages are routed to the Xcp instance on the local ECU (Xcp_CddIfRxIndication is called twice).
    16. Simulate that local XCP slave responses, on CDD bus, with positive response for the
        two SET_DAQ_LIST_MODE commands (local Xcp slave calls XcpR_Transmit).
    17. VP(XcpR.Impl.TxConfirmation.UpperLayer): Verify that the XcpR calls the confirmation
        interface of the upper layer (e.g Xcp_CddTxConfirmation is called with the correct pdu id).
    18. VP(XcpR.dsn.ReceptionFromRxIndication.SendIndependentMessage): Verify that the XcpR calls the transmit
        interface of the lower layer (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the master XCP package is
        the same with the one received from the local slave XCP but header is adapted).
    19. Simulate reception, on PM_Tst_Master_Bus_Type bus, of START_STOP_DAQ_LIST commands.
    20. VP (XcpR.dsn.ReceptionFromRxIndication.SendIndependentMessage) Verify that the packages are
        routed to the Xcp instance on the local ECU (Xcp_CddIfRxIndication is called twice).
    21. Simulate that local XCP slave responses, on CDD bus, with positive response for
        START_STOP_DAQ_LIST commands (local Xcp slave calls XcpR_Transmit).
    22. VP(XcpR.Impl.TxConfirmation.UpperLayer): Verify that the XcpR calls the confirmation interface
        of the upper layer (e.g Xcp_CddTxConfirmation is called with the correct pdu id).
    23. VP(XcpR.dsn.ReceptionFromRxIndication.SendIndependentMessage): Verify that the XcpR calls
        the transmit interface of the lower layer (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the master
        XCP packages are the same with the one received from the local slave XCP but header is adapted).
    24. Set the result as success.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.CddLocalConnectionsOnly</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>149</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.DisconnectedState.DetOn.ErrorCodePduLost</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>408</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.DisconnectedState.DetOn.ErrorCodeUnexpectedMessage</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>409</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_0</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>122</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>153</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TxConfirmation.UpperLayer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>160</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.ReceptionFromRxIndication.SendIndependentMessage</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>430</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.ReceptionFromRxIndication.StoreMessageInternally</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>431</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.UpperLayerRxIndicationPduId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>151</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.UpperLayerTxConfirmationPduId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>152</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>534</internalId></specobject>
    <specobject>
      <id>TS_XCPR_RxIndicationFromRx_TwoMessages_FirstDisconnectCmd</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_ReceptionRx/source/application/EbTest.c.m4</sourcefile>
      <sourceline>763</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Test the XcpR functionality when simulate two messages and the first
      packet is a DISCONNECT command
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    MASTER NETWORK:
      Bus type: PM_Tst_Master_Bus_Type
      XcpRSrcPduSupportRxFromRxIndication enabled.
    REMOTE SLAVE NETWORK:
      Bus type: PM_Tst_Slave_Bus_Type
      XcpRSrcPduSupportRxFromRxIndication enabled.
    Timestamp on XcpR is PM_Tst_XcpRTimestampEnabled.
  
Test Execution: 
    01. Call XCPR main processing function before XcpR_Init() function.
    02. VP(XcpR.Impl.MainFunction.InitCheck) Check if the module abort the execution
        without doing anything else.
    03. Initialize stubs and XcpR.
    04. Simulate reception of a package consisting in command different than CONNECT command on PM_Tst_Master_Bus_Type
        (XcpR_RxIndication() is called) when no connection is established (simulate GET_STATUS command.
    05. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the Slave is DISCONNECTED.
    06. Simulate reception of a CONNECT command with MODE = 1 on PM_Tst_Master_Bus_Type (XcpR_RxIndication()
        is called and command 0xFF, MODE = 1).
    07. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode): Check that the
        XcpR calls the transmit interface of the lower layer (e.g PM_Tst_Slave_Bus_Type\-::-/Transmit is called
        and the XCP package is the same with the one received from XCP master).
    08. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
          and data equals to CONNECT positive response).
    09. VP(XcpR.Impl.CheckStatusConnection): Verify that the XcpR calls the transmit interface
        of the lower layer (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package is the same
        with the one received from XCP but header is adapted).
    10. Simulate reception of a package consisting in a DISCONNECT command when no TX confirmation is made.
    11. Simulate  a second reception of a package consisting in command different than CONNECT command
        on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called).
    12. VP (XcpR.Impl.TransmissionOfConsecutiveMessages) Verify that the commands are routed to the
        XCP instance on the remote ECU (PM_Tst_Slave_Bus_Type\-::-/Transmit is called and the XCP package
        are the same with the one received from XCP but header is adapted).
    13. Simulate that XCP responses with a positive response (XcpR_RxIndication is called and
        data equals to DISCONNECT positive response).
    14. VP (XcpR.Impl.ResetRoutingPath) Verify that the command is routed to the XCP Master
        (PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package is the same with the one received
        from XCP but header is adapted).
    15. Set the result as success.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.MainFunction.InitCheck</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>134</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.ResetRoutingPath</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>159</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>535</internalId></specobject>
    <specobject>
      <id>TS_XCPR_RemoteXcpSlave_InvalidConnectMode</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_ReceptionRx/source/application/EbTest.c.m4</sourcefile>
      <sourceline>968</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Check that XcpR module reports DET error: XCPR_E_INVALID_CONNECT_LOCAL_XCP if receives a CONNECT
      command with Mode 0, but there is no Rx destination linked to this source.
      MASTER NETWORK:
        Bus type: PM_Tst_Master_Bus_Type
      REMOTE SLAVE NETWORK:
        Bus type: PM_Tst_Slave_Bus_Type
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a package consisting in command different than CONNECT command on PM_Tst_Master_Bus_Type
        (XcpR_RxIndication() is called) when no connection is established (simulate GET_STATUS command.
        VP(XcpR.dsn.DisconnectedState.DetOn.ErrorCodePduLost): Check that XcpR throws the
        runtime error XCPR_E_PDU_LOST.
    03. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the Slave is DISCONNECTED.
    04. Simulate reception of a CONNECT command with MODE = 0 on PM_Tst_Master_Bus_Type when no local Xcp slave is configured. 
    05. VP(XcpR.dsn.LocalConnectMode.DetOn.ErrorCodeInvalidConnectMode): Check that XcpR throws the
        runtime error XCPR_E_INVALID_CONNECT_LOCAL_XCP.
    06. Simulate reception of a CONNECT command with MODE = 1 on PM_Tst_Master_Bus_Type (XcpR_RxIndication()
        is called and command 0xFF, MODE = 1).
    07. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode): Check that the
        XcpR calls the transmit interface of the lower layer (e.g PM_Tst_Slave_Bus_Type\-::-/Transmit is called
        and the XCP package is the same with the one received from XCP master).
    08. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
          and data equals to CONNECT positive response).
    09. VP(XcpR.Impl.CheckStatusConnection): Verify that the XcpR calls the transmit interface
        of the lower layer (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package is the same
        with the one received from XCP but header is adapted).
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.BusTypesRemoteConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.DisconnectedState.DetOn.ErrorCodePduLost</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>408</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.LocalConnectMode.DetOn.ErrorCodeInvalidConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>419</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>536</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_XCPR_RxIndication_TxConfirmation_LocalXcp</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_ReceptionRx_TransmissionTx/source/application/EbTest.c.m4</sourcefile>
      <sourceline>104</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Check the reception from RxIndication and transmission from TxConfirmation functionalities.
      Verify that packages can be sent successfully from Tx Confirmation context and all TxConfirmation
      notifications are forwarded from the master Xcp to the local slave Xcp when XcpR is connected
      to a slave Xcp located on the same ECU.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  MASTER NETWORK:
    Bus type: PM_Tst_Master_Bus_Type
    XcpRSrcPduSupportRxFromRxIndication enabled.
    XcpRDestPduSupportTxFromTxConfirmation is enabled.
  LOCAL SLAVE NETWORK:
    Bus type: CDD
    XcpRTxSrcPduSupportTxFromXcpRTransmit is enabled.
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a package consisting in command different than CONNECT command on PM_Tst_Master_Bus_Type
        (XcpR_RxIndication() is called) when no connection is established (simulate GET_STATUS command.
    03. VP(XcpR.dsn.DisconnectedState.DetOn.ErrorCodePduLost): Check that XcpR throws the
        runtime error XCPR_E_PDU_LOST.
    04. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the Slave is DISCONNECTED.
    05. Simulate reception of a CONNECT command with MODE = 0 on PM_Tst_Master_Bus_Type (XcpR_RxIndication()
        is called and command 0xFF, MODE = 0).
    06. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_0, XcpR.Impl.DisconnectedState.ConnectMode): Verify that
        the XcpR calls the indication interface of the upper layer (e.g Xcp_CddRxIndication is called and the
        XCP package is the same with the one received from XCP but header is adapted).
    07. Simulate a positive response from the Xcp on local ECU (Xcp calls XcpR_Transmit
           with CONNECT positive response).
    08. VP(XcpR.Impl.CheckStatusConnection): Verify that the XcpR calls the transmit interface
        of the lower layer (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the master Xcp package
        is the same with the one received from the local slave Xcp but header is adapted).
    09. Simulate confirming the package after PM_Tst_Master_Bus_Type\-::-/Transmit() was processed from step 07.
    10. VP(XcpR.Impl.TxConfirmation.UpperLayer): Verify that the XcpR calls the confirmation interface
        of the upper layer (e.g Xcp_CddTxConfirmation is called with the correct Pdu id).
    11. Simulate reception, on PM_Tst_Master_Bus_Type bus, of SET_DAQ_LIST_MODE commands.
    12. Call XCPR main processing function to process the packages.
    13. VP (XcpR.dsn.ReceptionFromRxIndication.SendIndependentMessage) Verify that the packages
        are routed to the Xcp instance on the local ECU (Xcp_CddIfRxIndication is called twice).
    14. Simulate that local XCP slave responses, on CDD bus, with positive response for 
        DAQ1 SET_DAQ_LIST_MODE command (local Xcp slave calls XcpR_Transmit).
    15. Simulate that local XCP slave responses, on CDD bus, with positive response for 
        DAQ2 SET_DAQ_LIST_MODE command (local Xcp slave calls XcpR_Transmit).
    16. Triggered new transmission request from TxConfirmation with wrong pdu id.
    17. VP(XcpR.Impl.TransmitFromTxConfirmation): Verify that the the second packet is ignored
        because is sent via wrong PDU.
    18. Simulate confirming the package after PM_Tst_Master_Bus_Type\-::-/Transmit() was processed
         from step 14 and trigger a new transmission.
    19. VP(XcpR.Impl.TransmitFromTxConfirmation, XcpR.Impl.TransmissionOfConsecutiveMessages): Verify that the XcpR
        calls the transmit interface of the lower layer (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the master XCP package
        is the same with the one received from the local slave XCP but header is adapted).
    20. Simulate confirming the package after PM_Tst_Master_Bus_Type\-::-/Transmit() was processed from step 15.
    21. VP(XcpR.Impl.TxConfirmation.UpperLayer): Verify that the XcpR calls the confirmation interface
        of the upper layer (e.g Xcp_CddTxConfirmation is called with the correct Pdu id).
    22. Simulate reception, on PM_Tst_Master_Bus_Type bus, of START_STOP_DAQ_LIST commands.
    23. VP (XcpR.Impl.TransmissionOfConsecutiveMessages, XcpR.dsn.ReceptionFromRxIndication.SendIndependentMessage):
        Verify that the packages are routed to the Xcp instance on the local ECU (Xcp_CddIfRxIndication is called twice).
    24. Simulate that local XCP slave responses, on CDD bus, with positive response for 
        DAQ1 START_STOP_DAQ_LIST command (local Xcp slave calls XcpR_Transmit).
    25. Simulate that local XCP slave responses, on CDD bus, with positive response for 
        DAQ2 START_STOP_DAQ_LIST command (local Xcp slave calls XcpR_Transmit).
    26. Triggered new transmission request from TxConfirmation with wrong pdu id.
    27. VP(XcpR.Impl.TransmitFromTxConfirmation): Verify that the the second packet is not sent because wrong PDU.
    28. Simulate confirming the package after PM_Tst_Master_Bus_Type\-::-/Transmit() was processed
         from step 24 and trigger a new transmission.
    29. VP(XcpR.Impl.TransmitFromTxConfirmation, XcpR.dsn.ReceptionFromRxIndication.SendIndependentMessage): Verify that
        the XcpR calls the transmit interface of the lower layer (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the master XCP packages
        are the same with the one received from the local slave XCP but header is adapted).
    30. Simulate confirming the package after PM_Tst_Master_Bus_Type\-::-/Transmit() was processed from step 25.
    31. VP(XcpR.Impl.TxConfirmation.UpperLayer): Verify that the XcpR calls the confirmation interface
        of the upper layer (e.g Xcp_CddTxConfirmation is called with the correct pdu id).
    32. Set the result as success.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.CddLocalConnectionsOnly</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>149</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.ReceiveFromLocalSlave</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>426</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.ReceiveFromMaster</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>427</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.DisconnectedState.DetOn.ErrorCodePduLost</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>408</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_0</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>122</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>153</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TxConfirmation.UpperLayer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>160</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.ReceptionFromRxIndication.SendIndependentMessage</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>430</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmitFromTxConfirmation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>165</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.Transmit.From.Tx.Context.Configuration</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>135</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.UpperLayerRxIndicationPduId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>151</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.UpperLayerTxConfirmationPduId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>152</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>537</internalId></specobject>
    <specobject>
      <id>TS_XCPR_RxIndication_TxConfirmation_RemoteXcp</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_ReceptionRx_TransmissionTx/source/application/EbTest.c.m4</sourcefile>
      <sourceline>443</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Test the reception from RxIndication and transmission from TxConfirmation functionality on remote Xcp slave.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    MASTER NETWORK:
      Bus type: PM_Tst_Master_Bus_Type
      XcpRSrcPduSupportRxFromRxIndication is enabled.
      XcpRDestPduSupportTxFromTxConfirmation is enabled.
    REMOTE SLAVE NETWORK:
      Bus type: PM_Tst_Slave_Bus_Type
      XcpRSrcPduSupportRxFromRxIndication is enabled.
      XcpRDestPduSupportTxFromTxConfirmation is enabled.
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a package consisting in command different than CONNECT command on PM_Tst_Master_Bus_Type
        (XcpR_RxIndication() is called) when no connection is established (simulate GET_STATUS command.
    03. VP(XcpR.dsn.DisconnectedState.DetOn.ErrorCodePduLost): Check that XcpR throws the
        runtime error XCPR_E_PDU_LOST.
    04. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the Slave is DISCONNECTED.
    05. Simulate reception of a CONNECT command with MODE = 1 on PM_Tst_Master_Bus_Type (XcpR_RxIndication()
        is called and command 0xFF, MODE = 1).
    06. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode): Check that the
        XcpR calls the transmit interface of the lower layer (e.g PM_Tst_Slave_Bus_Type\-::-/Transmit is called
        and the XCP package is the same with the one received from XCP).
    07. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    08. VP(XcpR.Impl.CheckStatusConnection): Verify that the XcpR calls the transmit interface of the lower
        layer (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package is the same with the one received
        from XCP but header is adapted).
    09. Simulate reception, on PM_Tst_Master_Bus_Type bus, of first SET_DAQ_LIST_MODE command.
    10. Simulate reception, on PM_Tst_Master_Bus_Type bus, of second SET_DAQ_LIST_MODE command.
    11. VP(XcpR.Impl.DestinationProcessing.BusyState) The second message is not sent, because the 
        the destination processor is in BUSY state.
    12. Simulate confirming the package after PM_Tst_Slave_Bus_Type\-::-/Transmit() was processed
        from step 09 and trigger a new transmission.
    13. VP (XcpR.Impl.TransmitFromTxConfirmation) Verify that the packages are routed to the Xcp
        instance on the remote ECU (PM_Tst_Slave_Bus_Type\-::-/Transmit is called twice).
    14. Simulate that remote XCP slave responses, on PM_Tst_Slave_Bus_Type bus, with positive response for 
        DAQ1 SET_DAQ_LIST_MODE command (remote Xcp slave calls XcpR_RxIndication]).
    15. Simulate that remote XCP slave responses, on PM_Tst_Slave_Bus_Type bus, with positive response for 
        DAQ2 SET_DAQ_LIST_MODE command (remote Xcp slave calls XcpR_RxIndication]).
    16. Simulate confirming the package after PM_Tst_Master_Bus_Type\-::-/Transmit() was processed
        from step 15 and trigger a new transmission.
    17. VP (XcpR.Impl.TransmitFromTxConfirmation) Verify that the response packages are routed to
        the master Xcp (PM_Tst_Master_Bus_Type\-::-/Transmit() is called twice).
    18. Simulate reception, on PM_Tst_Master_Bus_Type bus, of START_STOP_DAQ_LIST command.
    19. Simulate reception, on PM_Tst_Master_Bus_Type bus, of START_STOP_DAQ_LIST command.
    20. Simulate confirming the package after PM_Tst_Slave_Bus_Type\-::-/Transmit() was processed
        from step 16 and trigger a new transmission.
    21. VP (XcpR.Impl.TransmitFromTxConfirmation) Verify that the packages are routed to the Xcp instance
        on the remote ECU (PM_Tst_Slave_Bus_Type\-::-/Transmit is called twice).
    22. Simulate that remote XCP slave responses, on PM_Tst_Slave_Bus_Type bus, with positive response for 
        DAQ1 START_STOP_DAQ_LIST command (remote Xcp slave calls XcpR_RxIndication]).
    23. Simulate that remote XCP slave responses, on CDD bus, with positive response for 
        DAQ2 START_STOP_DAQ_LIST command (remote Xcp slave calls XcpR_RxIndication]).
    24. Simulate confirming the package after PM_Tst_Master_Bus_Type\-::-/Transmit() was processed
         from step 23 and trigger a new transmission.
    25. VP (XcpR.Impl.TransmitFromTxConfirmation) Verify that the response packages are routed to
        the master Xcp (PM_Tst_Master_Bus_Type\-::-/Transmit() is called twice).
    26. Set the result as success.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.BusTypesRemoteConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.ReceiveFromMaster</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>427</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.ReceiveFromRemoteSlave</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>428</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.DisconnectedState.DetOn.ErrorCodePduLost</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>408</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DestinationProcessing.BusyState</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>133</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmitFromTxConfirmation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>165</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.Transmit.From.Tx.Context.Configuration</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>135</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>538</internalId></specobject>
    <specobject>
      <id>TS_XCPR_RxIndication_TxConfirmation_LinkedPduId</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_ReceptionRx_TransmissionTx/source/application/EbTest.c.m4</sourcefile>
      <sourceline>754</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Test the reception from RxIndication and transmission from TxConfirmation functionality on remote Xcp slave.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    MASTER NETWORK:
      Bus type: PM_Tst_Master_Bus_Type
      XcpRSrcPduSupportRxFromRxIndication is enabled.
      XcpRDestPduSupportTxFromTxConfirmation is enabled.
    REMOTE SLAVE NETWORK:
      Bus type: PM_Tst_Slave_Bus_Type
      XcpRSrcPduSupportRxFromRxIndication is enabled.
      XcpRDestPduSupportTxFromTxConfirmation is enabled.
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a package consisting in command different than CONNECT command on PM_Tst_Master_Bus_Type
        (XcpR_RxIndication() is called) when no connection is established (simulate GET_STATUS command.
    03. VP(XcpR.dsn.DisconnectedState.DetOn.ErrorCodePduLost): Check that XcpR throws the
        runtime error XCPR_E_PDU_LOST.
    04. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the Slave is DISCONNECTED.
    05. Simulate reception of a CONNECT command with MODE = 1 on PM_Tst_Master_Bus_Type (XcpR_RxIndication()
        is called and command 0xFF, MODE = 1).
    06. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode): Check that the
        XcpR calls the transmit interface of the lower layer (e.g PM_Tst_Slave_Bus_Type\-::-/Transmit is called
        and the XCP package is the same with the one received from XCP).
    07. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    08. VP(XcpR.Impl.CheckStatusConnection): Verify that the XcpR calls the transmit interface of the lower
        layer (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package is the same with the one received
        from XCP but header is adapted).
    09. Simulate reception, on PM_Tst_Master_Bus_Type bus, of SET_DAQ_LIST_MODE command.
    10. Simulate reception, on PM_Tst_Master_Bus_Type bus, of SET_DAQ_LIST_MODE command.
    11. Simulate confirming the package after PM_Tst_Slave_Bus_Type\-::-/Transmit() was processed
         from step 09 and trigger a new transmission.
    12. VP (XcpR.Impl.TransmitFromTxConfirmation) Verify that the packages are routed to the Xcp
        instance on the remote ECU (PM_Tst_Slave_Bus_Type\-::-/Transmit is called twice).
    13. Simulate that remote XCP slave responses, on PM_Tst_Slave_Bus_Type bus, with positive response for 
        DAQ1 SET_DAQ_LIST_MODE command (remote Xcp slave calls XcpR_RxIndication]).
    14. Simulate that remote XCP slave responses, on PM_Tst_Slave_Bus_Type bus, with positive response for 
        DAQ2 SET_DAQ_LIST_MODE command (remote Xcp slave calls XcpR_RxIndication]).
    15. Simulate confirming the package after PM_Tst_Slave_Bus_Type\-::-/Transmit() was processed
        from step 10 and try to trigger a new transmission from TxConfirmation with a pdu id different
        than linked destination pdu id.
    16. VP (XcpR.Impl.TransmitFromTxConfirmation) Verify that the response packages are routed to
        the master Xcp (PM_Tst_Master_Bus_Type\-::-/Transmit() is called twice).
    17. Simulate reception, on PM_Tst_Master_Bus_Type bus, of START_STOP_DAQ_LIST command.
    18. Simulate reception, on PM_Tst_Master_Bus_Type bus, of START_STOP_DAQ_LIST command.
    19. Simulate confirming the package after PM_Tst_Slave_Bus_Type\-::-/Transmit() was processed
        from step 17 and trigger a new transmission.
    20. VP (XcpR.Impl.TransmitFromTxConfirmation) Verify that the packages are routed to the Xcp instance
        on the remote ECU (PM_Tst_Slave_Bus_Type\-::-/Transmit is called twice).
    21. Simulate that remote XCP slave responses, on CDD bus, with positive response for 
        DAQ1 START_STOP_DAQ_LIST command (remote Xcp slave calls XcpR_RxIndication]).
    22. Simulate that remote XCP slave responses, on CDD bus, with positive response for 
        DAQ2 START_STOP_DAQ_LIST command (remote Xcp slave calls XcpR_RxIndication]).
    23. Simulate confirming the package after PM_Tst_Master_Bus_Type\-::-/Transmit() was processed
        from step 21 and trigger a new transmission.
    24. VP (XcpR.Impl.TransmitFromTxConfirmation) Verify that the response packages are routed to
        the master Xcp (PM_Tst_Master_Bus_Type\-::-/Transmit() is called twice).
    25. Set the result as success.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.BusTypesRemoteConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.DisconnectedState.DetOn.ErrorCodePduLost</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>408</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmitFromTxConfirmation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>165</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>539</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_XCPR_SameBusType_SimulateConnectCMD_PosResponse_Mode_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_SameBusProtocol/source/application/EbTest.c.m4</sourcefile>
      <sourceline>44</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Check that messages sent from Xcp Master are forwarded to the Xcp Slave
      on the remote ECU only if the connection is established through a CONNECT command.
      * MASTER NETWORK: PM_Tst_Master_Bus_Type
      * REMOTE SLAVE NETWORK: PM_Tst_Slave_Bus_Type
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a package consisting in command different than CONNECT command
        on PM_Tst_Master_Bus_Type (XcpR_RxIndication()is called) when no connection is established.
    03. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the slave is DISCONNECTED.
    04. Simulate reception of a CONNECT command with MODE = 1 on PM_Tst_Master_Bus_Type
        (XcpR_RxIndication() is called and command 0xFF, MODE = 1).
    05. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode,
        XcpR.Impl.DisconnectedState.ConnectMode): Check that the XcpR calls the transmit interface of the lower layer
        (e.g PM_Tst_Slave_Bus_Type\-::-/Transmit is called and the XCP package is the same with the one received from XCP).
    06. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals Tst_CONNECTPositiveResponse).
    07. VP(XcpR.Impl.CheckStatusConnection): Verify that the XcpR calls the transmit interface
        of the lower layer (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package is the same
        with the one received from XCP).
    08. Simulate reception, on PM_Tst_Master_Bus_Type bus, of a package consisting in command different than CONNECT command.
    09. VP (XcpR.Impl.TransmissionOfConsecutiveMessages) Verify that the command is routed
        to the XCP instance on the remote ECU (PM_Tst_Slave_Bus_Type\-::-/Transmit is called and the XCP
        package is the same with the one received from XCP).
    10. Simulate that XCP responses with a positive response (XcpR_RxIndication is called
        and data equals to GET_STATUS positive response).
    11. VP(XcpR.Impl.TransmissionOfConsecutiveMessages): Verify that the XcpR
        calls the transmit interface of the lower layer (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called
        and the XCP package is the same with the one received from XCP).
m4_ifelse(PM_Permutation,FrToFr,\-:m4_dnl
    12. Simulate reception, on FlexRay bus, of a package consisting in command different than
        CONNECT command with a different Nax than the one configured.
    13. VP: Received package is ignored without any action
        because the received Nax is different than the one configured.
:-/m4_ifelse( :endif: ))\-::-/m4_dnl
    Set the result as success.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.BusTypesRemoteConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>153</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.ActiveRoutingPath</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>154</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.ConfigurableLoweyLayer.CddConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>156</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>540</internalId></specobject>
    <specobject>
      <id>TS_XCPR_SameBusType_SimulateConnectCMD_NegResponse_Mode_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_SameBusProtocol/source/application/EbTest.c.m4</sourcefile>
      <sourceline>267</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Check that messages sent from Xcp Master are NOT forwarded to the Xcp Slave
      on the remote ECU if the connection is not established through a CONNECT command.
      * MASTER NETWORK: PM_Tst_Master_Bus_Type
      * REMOTE SLAVE NETWORK: PM_Tst_Slave_Bus_Type
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a package consisting in command different than CONNECT command
        on PM_Tst_Master_Bus_Type (XcpR_RxIndication()is called) when no connection is established.
    03. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action.
    04. Simulate reception of a CONNECT command with MODE = 1 on PM_Tst_Master_Bus_Type (XcpR_RxIndication()
        is called and command 0xFF, MODE = 1).
    05. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode): Check that the
        XcpR calls the transmit interface of the lower layer (e.g PM_Tst_Slave_Bus_Type\-::-/Transmit is called
        and the XCP package is the same with the one received from XCP).
    06. Simulate confirming the package after PM_Tst_Slave_Bus_Type\-::-/Transmit() was processed from step 04.
    07. Simulate a negative response from the XCP on remote ECU (XcpR_RxInidication
        is called with CONNECT negative response).
    08. VP(XcpR.dsn.NegativeResponseConnect.DetOn.ErrorCodePduLost): Verify that the XcpR calls the
        transmit interface of the lower layer and the runtime error XCPR_E_PDU_LOST is reported.
    09. Simulate reception, on PM_Tst_Master_Bus_Type bus, of a package consisting in command different than CONNECT command.
    10. VP (XcpR.dsn.NegativeResponseConnect.DetOn.ErrorCodePduLost) Received package is ignored without any action.
    11. Set the result as success.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.BusTypesRemoteConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.NegativeResponseConnect.DetOn.ErrorCodePduLost</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>420</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>541</internalId></specobject>
    <specobject>
      <id>TS_XCPR_CddBusType_SimulateConnectCMD_PosResponse_Mode_0</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_SameBusProtocol/source/application/EbTest.c.m4</sourcefile>
      <sourceline>418</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Check that messages sent from Xcp Master are forwarded to the Xcp Slave
      on the local ECU only if the connection is established through a CONNECT command.
      * MASTER NETWORK: PM_Tst_Master_Bus_Type
      * LOCAL SLAVE NETWORK: CDD
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a package consisting in command different than CONNECT command on CDD (XcpR_RxIndication()
        is called) when no connection is established (simulate GET_STATUS command.
    03. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action 
        because the Slave is DISCONNECTED.
    04. Simulate a positive response from the Xcp on local ECU (Xcp calls XcpR_Transmit
        with a CONNECT positive response).
    05. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action.
    06. Simulate reception of a CONNECT command with MODE = 0 on CDD (XcpR_RxIndication()
        is called and command 0xFF, MODE = 0).
    07. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_0): Verify that the XcpR calls the indication
        interface of the upper layer (e.g Xcp_CddRxIndication is called and the XCP package is
        the same with the one received from XCP).
    08. Simulate a positive response from the Xcp on local ECU (Xcp calls XcpR_Transmit
        with a CONNECT positive response).
    09. VP(XcpR.Impl.CheckStatusConnection): Verify that the XcpR calls the transmit interface of the
        lower layer (e.g Cdd_Transmit is called and the Xcp package is the same with the one received from Xcp).
    10. Simulate reception, on PM_Tst_Master_Bus_Type bus, of a package consisting in command different
        than CONNECT command when no TxConfirmation was send after a CONNECT positive response.
    11. VP(XcpR.Impl.TxConfirmation.UpperLayer): Verify that the XcpR calls the confirmation
        interface of the upper layer (e.g Xcp_CddTxConfirmation is called with the correct pdu id).
    12. VP(XcpR.Impl.SaveConnectedState): Received package is ignored without any action because no TxConfirmation after
        sending a CONNECT positive response to the master Xcp.
    13. Simulate CDD confirming the response after Cdd_Transmit() was processed from step 08.
    14. Simulate reception, on CDD bus, of a package consisting in command different than CONNECT command.
    15. VP (XcpR.Impl.TransmissionOfConsecutiveMessages, XcpR.Impl.SaveConnectedState, XcpR.Impl.TransmissionOfConsecutiveMessages)"
        Verify that the command is routed to the Xcp instance on the local ECU (Xcp_CddRxIndication is called and the XCP package
        is the same with the one received from XCP).
    16. Simulate that XCP responses, on CDD bus, with a configured but WRONG pdu id.
    17. Received package is ignored without any action.
    18. Simulate that XCP responses, on CDD bus, with a positive response (Xcp calls XcpR_Transmit
          with a GET_STATUS positive response).
    19. VP(XcpR.Impl.TxConfirmation.UpperLayer): Verify that the XcpR calls the confirmation interface
        of the upper layer (e.g Xcp_CddTxConfirmation is called with the correct pdu id).
    20. VP(XcpR.Impl.TransmissionOfConsecutiveMessages): Verify that the XcpR calls the transmit interface
        of the lower layer (e.g Cdd_Transmit is called and the XCP package is the same with the one received from XCP).
    21 Simulate CDD confirming the response after Cdd_Transmit() was processed from step 16.
    22. Set the result as success.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.CddLocalConnectionsOnly</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>149</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_0</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>122</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.SaveConnectedState</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>158</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TxConfirmation.UpperLayer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>160</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.ActiveRoutingPath</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>154</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.TxConfirmation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>464</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.UpperLayerRxIndicationPduId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>151</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.UpperLayerTxConfirmationPduId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>152</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.Communication.CDD.ImmediateAccess</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>139</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.ConfigurableUpperLayer.CddConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>157</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>542</internalId></specobject>
    <specobject>
      <id>TS_XCPR_CddBusType_SimulateConnectCMD_NegResponse_Mode_0</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_SameBusProtocol/source/application/EbTest.c.m4</sourcefile>
      <sourceline>663</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Check that messages sent from Xcp Master are NOT forwarded to the Xcp Slave
      on the local ECU if the connection is not established through a CONNECT command.
      * MASTER NETWORK: PM_Tst_Master_Bus_Type
      * LOCAL SLAVE NETWORK: CDD
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a package consisting in command different than CONNECT command
        on CDD (XcpR_RxIndication()is called) when no connection is established.
    03. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action 
        because the slave is DISCONNECTED.
    04. Simulate reception of a CONNECT command with MODE = 0 on CDD (XcpR_RxIndication() is
        called and command 0xFF, MODE = 0).
    05. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_0): Check that the XcpR calls the indication
        interface of the upper layer (e.g Xcp_CddRxIndication is called and the XCP package is
        the same with the one received from XCP).
    06. Simulate a negative response from the Xcp local ECU on CDD bus(Xcp calls XcpR_Transmit
        with CONNECT negative response).
    07. VP(XcpR.dsn.NegativeResponseConnect.DetOn.ErrorCodePduLost): Verify that the
        XcpR calls the transmit interface of the lower layer and the runtime error
        XCPR_E_PDU_LOST is reported.
    08. Simulate reception, on CDD bus, of a package consisting in command different than CONNECT command.
    09. VP (XcpR.dsn.NegativeResponseConnect.DetOn.ErrorCodePduLost) Received package is ignored without any action.
    10. Set the result as success.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.CddLocalConnectionsOnly</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>149</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.NegativeResponseConnect.DetOn.ErrorCodePduLost</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>420</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_0</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>122</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.Communication.CDD.ImmediateAccess</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>139</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.ConfigurableUpperLayer.CddConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>157</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>543</internalId></specobject>
    <specobject>
      <id>TS_XCPR_CddBusType_ChangeMode_SwitchRemoteXcpToLocalXcp</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_SameBusProtocol/source/application/EbTest.c.m4</sourcefile>
      <sourceline>805</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Check the reaction when simulate the Xcp CONNECT command with the parameter Mode = 1 (remote XCP slave)
      then switch the Xcp CONNECT command with the parameter Mode = 0 (local Xcp slave).
      * MASTER NETWORK: PM_Tst_Master_Bus_Type
      * LOCAL SLAVE NETWORK: CDD
      * REMOTE SLAVE NETWORK: PM_Tst_Slave_Bus_Type
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a package consisting in command different than CONNECT command
        on CDD (XcpR_RxIndication()is called) when no connection is established.
    03. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action.
    04. Simulate reception of a CONNECT command with MODE = 1 on CDD (XcpR_RxIndication()
        is called and command 0xFF, MODE = 1).
    05. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode, XcpR.Impl.DisconnectedState.ConnectMode):
        and the XCP package is the same with the one received from XCP).
    06. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    07. VP(XcpR.Impl.CheckStatusConnection): Verify that the XcpR calls the transmit interface of the lower layer
        (e.g Cdd_Transmit is called and the XCP package is the same with the one received from XCP).
    08. Simulate reception of a package consisting in a DISCONNECT command.
    09. VP (XcpR.Impl.TransmissionOfConsecutiveMessages) Verify that the command is routed to the
        XCP instance on the remote ECU (Cdd_Transmit is called and the XCP package is the same with
        the one received from XCP master).
    10. Simulate that XCP responses with a positive response (XcpR_RxIndication is called and
        data equals DISCONNECT positive response).
    11. VP(XcpR.Impl.TransmissionOfConsecutiveMessages): Verify that the XcpR calls the transmit
        interface of the lower layer (e.g Cdd_Transmit is called and the XCP package is the same with
        the one received from XCP).
    12. Simulate reception, on CDD bus, of a CONNECT command with MODE = 0 (XcpR_RxIndication()
          is called and command 0xFF, MODE = 0).
    13. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_0, XcpR.Impl.DisconnectedState.ConnectMode): Verify that the
        XcpR calls the indication interface of the upper layer (e.g Xcp_CddRxIndication is called and the XCP
        package is the same with the one received).
    14. Simulate a positive response from the XCP on local ECU (XCP calls XcpR_Transmit
        with CONNECT positive response).
    15. VP(XcpR.Impl.TxConfirmation.UpperLayer): Verify that the XcpR calls the confirmation interface
        of the upper layer (e.g Xcp_CddTxConfirmation is called with the correct pdu id).
    16. VP(XcpR.Impl.CheckStatusConnection): Verify that the XcpR calls the transmit interface of the lower layer
        (e.g Cdd_Transmit is called and the XCP package is the same with the one received
        from XCP).
    17. Simulate CDD confirming the response after Cdd_Transmit() was processed from step 14.
    18. Set the result as success.
      
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Enabled.TwoDestinationPDUs</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>125</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CddLocalConnectionsOnly</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>149</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.BusTypesRemoteConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.ReceiveFromLocalSlave</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>426</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.ReceiveFromMaster</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>427</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.ReceiveFromRemoteSlave</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>428</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>153</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_0</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>122</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TxConfirmation.UpperLayer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>160</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.TxConfirmation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>464</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.Transmit.From.Tx.Context.Configuration</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>135</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.Reception.From.Rx.Context.Configuration</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>136</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.UpperLayerRxIndicationPduId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>151</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.UpperLayerTxConfirmationPduId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>152</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.ConfigurableLoweyLayer.CddConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>156</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.Communication.CDD.ImmediateAccess</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>139</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>544</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_XCPR_SeqCorr_MultiplePdusInOneFrame</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_SeqCorrection/source/application/EbTest.c.m4</sourcefile>
      <sourceline>43</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Check the sequence correction functionality, verify that all messages are forwarded with the correct frame counter.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    MASTER NETWORK:
      Bus type: FlexRay
      XcpRSourcePackMultiMsgInOneFlexRayFrame = true
      XcpRDestinationPackMultiMsgInOneFlexRayFrame = true
      XcpRSourceSequenceCorrectionEnabled = true
      XcpRDestinationSequenceCorrectionEnabled = true
    REMOTE SLAVE NETWORK:
      Bus type: FlexRay
      XcpRSourcePackMultiMsgInOneFlexRayFrame = true
      XcpRDestinationPackMultiMsgInOneFlexRayFrame = true
      XcpRSourceSequenceCorrectionEnabled = true
      XcpRDestinationSequenceCorrectionEnabled = true
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a package consisting in command different than CONNECT command
        on FlexRay (XcpR_RxIndication() is called) when no connection is established.
    03. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
          because the Slave is DISCONNECTED.
    04. Simulate reception of a CONNECT command with MODE = 1 on FlexRay (XcpR_RxIndication()
        is called and command 0xFF, MODE = 1).
    05. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.dsn.ReceptionPackedFrame.TransmissionPackedFrame.AddHeaderInfo,
        XcpR.Impl.RemoteConnections.ConnectMode): Check that the XcpR calls the transmit interface of the lower layer
        and FlexRay sequence correction header counter has the correct value (0x00).
    06. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    07. VP(XcpR.Impl.CheckStatusConnection, XcpR.Impl.AdaptBusInfo, XcpR.dsn.ReceptionPackedFrame.TransmissionPackedFrame.AddHeaderInfo):
        Verify that the XcpR calls the transmit interface of the lower layer and FlexRay sequence
        correction header counter has the  correct value (0x00).
    08. Simulate reception, on master FlexRay bus, of one frame with SET_DAQ_LIST_MODE
        (Data Stimulation Mode) commands to be sent from Xcp master to Xcp slave.
    09. VP (XcpR.dsn.ReceptionPackedFrame.TransmissionPackedFrame.AddHeaderInfo, XcpR.Impl.TransmissionOfConsecutiveMessages):
        Verify that the package is routed to the Xcp instance on the remote ECU in one frame and FlexRay sequence
        correction header counter has the correct value (0x01).
    10. Simulate that XCP responses, on the internal bus, with a positive response for 
        SET_DAQ_LIST_MODE commands (Xcp calls XcpR_RxIndication).
    11. VP(XcpR.Impl.AdaptBusInfo, XcpR.dsn.ReceptionPackedFrame.TransmissionPackedFrame.AddHeaderInfo):
        Verify that the XcpR calls the transmit interface of the lower layer and FlexRay sequence correction
        header counter has the correct value (0x01).
    12. Simulate reception, on FlexRay bus, of START_DAQ_LIST frame command
        to be sent from Xcp master to Xcp slave.
    13. VP (XcpR.dsn.ReceptionPackedFrame.TransmissionPackedFrame.AddHeaderInfo) Verify that the
        packages are routed to the Xcp instance on the remote ECU in one frame and FlexRay sequence correction
        header counter has the correct value (0x02).
    14. Simulate that XCP responses, on FlexRay bus, with a positive response for
        START_DAQ_LIST commands (Xcp calls XcpR_RxIndication).
    15. VP(XcpR.dsn.ReceptionPackedFrame.TransmissionPackedFrame.AddHeaderInfo): Verify that the XcpR calls
        the transmit interface of the lower layer and FlexRay sequence correction header counter has the
        correct value (0x02).
    16. Simulate reception, on FlexRay bus, of simulation data frame packet
        to be sent from Xcp master to remote Xcp slave.
    17. VP (XcpR.Impl.AdaptBusInfo, XcpR.dsn.ReceptionPackedFrame.TransmissionPackedFrame.AddHeaderInfo):
        Verify that the packages are routed to the Xcp instance on the remote ECU in one frame and FlexRay
        sequence correction header counter has the correct value (0x03).
    18. Set the result as success.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Disabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>124</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.BusTypesRemoteConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.ReceptionPackedFrame.TransmissionPackedFrame.AddHeaderInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>437</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.AdaptBusInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>147</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.ReceptionPackedFrame.AbortUnpacking</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>433</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.ReceptionPackedFrame.TransmissionPackedFrame.PackAtLeastOneMsg</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>438</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>545</internalId></specobject>
    <specobject>
      <id>TS_XCPR_SeqCorr_MultiplePdusInOneFrame_Master</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_SeqCorrection/source/application/EbTest.c.m4</sourcefile>
      <sourceline>339</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Check the sequence correction functionality, verify that all messages are forwarded with the correct frame counter
      when external bus supports multiple XcpR messages in one FlexRay frame.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    MASTER NETWORK:
      Bus type: FlexRay
      XcpRSourcePackMultiMsgInOneFlexRayFrame = true
      XcpRDestinationPackMultiMsgInOneFlexRayFrame = true
      XcpRSourceSequenceCorrectionEnabled = true
      XcpRDestinationSequenceCorrectionEnabled = true
    REMOTE SLAVE NETWORK:
      Bus type: FlexRay
      XcpRSourcePackMultiMsgInOneFlexRayFrame = false
      XcpRDestinationPackMultiMsgInOneFlexRayFrame = false
      XcpRSourceSequenceCorrectionEnabled = true
      XcpRDestinationSequenceCorrectionEnabled = true
      XcpRSrcPduSupportRxFromRxIndication = true
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate a positive response from the XCP on remote ECU when no connection is established.
    03. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the Slave is DISCONNECTED.
    04. Simulate reception of a CONNECT command with MODE = 1 on FlexRay (XcpR_RxIndication()
        is called and command 0xFF, MODE = 1).
    05. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode): Check that the
        XcpR calls the transmit interface of the lower layer and FlexRay sequence correction header
        counter has the correct value (0x00).
    06. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    07. VP(XcpR.Impl.CheckStatusConnection): Verify that the XcpR calls the transmit interface of the lower
        layer and FlexRay sequence correction header counter has the correct value (0x00).
    08. Simulate reception, on master FlexRay bus, of SET_DAQ_LIST_MODE frame command
        (Data Stimulation Mode) to be sent from Xcp master to Xcp slave.
    09. VP (XcpR.dsn.ReceptionPackedFrame.SendMessageIndependently, XcpR.Impl.TransmissionOfConsecutiveMessages):
        Verify that the packages are routed to the Xcp instance on the remote ECU (FrIf_Transmit is called three times)
        and FlexRay sequence correction header counters have the correct values (0x01, 0x02, 0x03).
    10. Simulate that slave XCP responses, on FlexRay bus, with positive responses for
        SET_DAQ_LIST_MODE commands (remote Xcp slave calls XcpR_RxIndication).
    11. VP(XcpR.Impl.AdaptBusInfo, XcpR.dsn.ReceptionFromRxIndication.TransmissionPackedFrame.PackMsgIntoFrame):
        Verify that the XcpR calls the transmit interface of the lower layer and FlexRay sequence correction header
        counter has the correct value (0x01).
    12. Simulate reception, on FlexRay bus, of StartDaqList command frame
             to be sent from Xcp master to the remote Xcp slave.
    13. VP (XcpR.dsn.ReceptionPackedFrame.SendMessageIndependently): Verify that the packages
        are routed to the Xcp instance on the remote ECU (FrIf_Transmit is called three times)
        and FlexRay sequence correction header counters have the correct values (0x04, 0x05, 0x06).
    14. Simulate that XCP responses, on FlexRay bus, with positive responses for
        START_STOP_DAQ_LIST commands (remote Xcp slave calls XcpR_RxIndication).
    15. VP(XcpR.dsn.ReceptionFromRxIndication.TransmissionPackedFrame.PackMsgIntoFrame): Verify that the XcpR
        calls the transmit interface of the lower layer and FlexRay sequence correction header counter has the
        correct value (0x02).
    16. Simulate reception, on FlexRay bus, of one simulation data frame
        to be sent from Xcp master to the remote Xcp slave.
    17. VP (XcpR.dsn.ReceptionPackedFrame.SendMessageIndependently) Verify that the packages are routed
        to the Xcp instance on the remote ECU (FrIf_Transmit is called three times) and FlexRay sequence
        correction header counters have the correct values (0x07, 0x08, 0x09).
    18. Set the result as success.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Disabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>124</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.BusTypesRemoteConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.ReceptionPackedFrame.SendMessageIndependently</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>435</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.AdaptBusInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>147</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.ReceptionFromRxIndication.TransmissionPackedFrame.PackMsgIntoFrame</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>432</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.ReceptionPackedFrame.AbortUnpacking</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>433</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.ReceptionPackedFrame.CheckTxConfirmation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>434</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>546</internalId></specobject>
    <specobject>
      <id>TS_XCPR_SeqCorr_MultiplePdusInOneFrame_RemoteXcpSlave</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_SeqCorrection/source/application/EbTest.c.m4</sourcefile>
      <sourceline>638</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Check the sequence correction functionality, verify that all messages are forwarded with the correct frame counter
      when internal bus supports multiple XcpR messages in one FlexRay frame.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    MASTER NETWORK:
      Bus type: FlexRay
      XcpRSourcePackMultiMsgInOneFlexRayFrame = false
      XcpRDestinationPackMultiMsgInOneFlexRayFrame = false
      XcpRSourceSequenceCorrectionEnabled = true
      XcpRDestinationSequenceCorrectionEnabled = true
      XcpRSrcPduSupportRxFromRxIndication = true
    REMOTE SLAVE NETWORK:
      Bus type: FlexRay
      XcpRSourcePackMultiMsgInOneFlexRayFrame = true
      XcpRDestinationPackMultiMsgInOneFlexRayFrame = true
      XcpRSourceSequenceCorrectionEnabled = true
      XcpRDestinationSequenceCorrectionEnabled = true
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate a positive response from the XCP on remote ECU when no connection is established.
    03. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the Slave is DISCONNECTED.
    04. Simulate reception of a CONNECT command with MODE = 1 on FlexRay (XcpR_RxIndication()
        is called and command 0xFF, MODE = 1).
    05. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode): Check that the
        XcpR calls the transmit interface of the lower layer and FlexRay sequence correction header counter
        has the correct value (0x00).
    06. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    07. VP(XcpR.Impl.CheckStatusConnection): Verify that the XcpR calls the transmit interface of
        the lower layerand FlexRay sequence correction header counter has the correct value (0x00).
    08. Simulate reception, on FlexRay bus, of three SET_DAQ_LIST_MODE commands for three different DAQs.
    09. VP (XcpR.Impl.TransmissionOfConsecutiveMessages, XcpR.dsn.ReceptionFromRxIndication.TransmissionPackedFrame.PackMsgIntoFrame):
        Verify that the package is routed to the Xcp instance on the remote ECU in one frame (FrIf_Transmit is called once) and FlexRay
        sequence correction header counter has the correct value (0x01).
    10. Simulate that XCP responses, on the internal bus, with a positive response to 
        SET_DAQ_LIST_MODE commands (Xcp calls XcpR_RxIndication).
    11. VP(XcpR.dsn.ReceptionPackedFrame.SendMessageIndependently): Verify that the XcpR calls the
        transmit interface of the lower layer (e.g FrIf_Transmit is called three times) and FlexRay
        sequence correction header counters have the correct values (0x01, 0x02, 0x03).
    12. Simulate reception, on FlexRay bus, of three START_STOP_DAQ_LIST commands for three different DAQs.
    13. VP (XcpR.dsn.ReceptionFromRxIndication.TransmissionPackedFrame.PackMsgIntoFrame): Verify
        that the packages are routed to the Xcp instance on the remote ECU in one frame and FlexRay
        sequence correction header counter has the correct value (0x02).
    14. Simulate that remote XCP slave responses, on FlexRay bus, with a positive response to
        START_STOP_DAQ_LIST commands (remote Xcp slave calls XcpR_RxIndication).
    15. VP(XcpR.dsn.ReceptionPackedFrame.SendMessageIndependently): Verify that the XcpR calls
        the transmit interface of the lower layer (e.g FrIf_Transmit is called three times) and
        FlexRay sequence correction header counters have the correct values (0x04, 0x05, 0x06).
    16. Simulate reception, on FlexRay bus, of three different packages with simulation data
        to be sent from Xcp master to remote Xcp slave.
    17. VP (XcpR.dsn.ReceptionFromRxIndication.TransmissionPackedFrame.PackMsgIntoFrame): Verify that the packages
        are routed to the Xcp instance on the remote ECU in one frame (remote slave FrIf_Transmit is called once) and
        FlexRay sequence correction header counter has the correct value (0x03).
    18. Set the result as success.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Disabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>124</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.BusTypesRemoteConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.AdaptBusInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>147</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.ReceptionFromRxIndication.TransmissionPackedFrame.PackMsgIntoFrame</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>432</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.ReceptionPackedFrame.SendMessageIndependently</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>435</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.ReceptionPackedFrame.AbortUnpacking</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>433</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.ReceptionPackedFrame.CheckTxConfirmation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>434</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>547</internalId></specobject>
    <specobject>
      <id>TS_XCPR_SeqCorr</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_SeqCorrection/source/application/EbTest.c.m4</sourcefile>
      <sourceline>933</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Check the sequence correction functionality, verify that all messages are forwarded with the correct counter.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    MASTER NETWORK:
      Bus type: FlexRay
      XcpRSourcePackMultiMsgInOneFlexRayFrame = false
      XcpRDestinationPackMultiMsgInOneFlexRayFrame = false
      XcpRSourceSequenceCorrectionEnabled = true
      XcpRDestinationSequenceCorrectionEnabled = true
      XcpRSrcPduSupportRxFromRxIndication = true
    REMOTE SLAVE NETWORK:
      Bus type: FlexRay
      XcpRSourcePackMultiMsgInOneFlexRayFrame = false
      XcpRDestinationPackMultiMsgInOneFlexRayFrame = false
      XcpRSourceSequenceCorrectionEnabled = true
      XcpRDestinationSequenceCorrectionEnabled = true
      XcpRSrcPduSupportRxFromRxIndication = true
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate a positive response from the XCP on remote ECU when no connection is established.
    03. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the Slave is DISCONNECTED.
    04. Simulate reception of a CONNECT command with MODE = 1 on FlexRay (XcpR_RxIndication()
        is called and command 0xFF, MODE = 1).
    05. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode): Check that the
        XcpR calls the transmit interface of the lower layer and FlexRay sequence correction header counter
        has the correct value (0x00).
    06. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    07. VP(XcpR.Impl.CheckStatusConnection, XcpR.Impl.AdaptBusInfo): Verify that the XcpR calls the transmit
        interface of the lower layer and FlexRay sequence correction header counter has the correct value (0x00).
    08. Simulate reception, on FlexRay bus, of three SET_DAQ_LIST_MODE commands for three different DAQs.
    09. VP (XcpR.Impl.TransmissionOfConsecutiveMessages) Verify that the packages are routed to the
        Xcp instance on the remote ECU (FrIf_Transmit is called three times) and FlexRay sequence
        correction header counters have the correct values (0x01, 0x02, 0x03)
    10. Simulate that slave XCP responses, on FlexRay bus, with positive responses for 
        SET_DAQ_LIST_MODE commands (remote Xcp slave calls XcpR_RxIndication).
    11. VP(XcpR.Impl.AdaptBusInfo): Verify that the XcpR calls the transmit interface of the lower
        layer (e.g FrIf_Transmit is called three times) and FlexRay sequence correction header
        counters have the correct values (0x01, 0x02, 0x03).
    12. Simulate reception, on FlexRay bus, of three START_STOP_DAQ_LIST commands for three different DAQs .
    13. VP (XcpR.Impl.TransmissionOfConsecutiveMessages, XcpR.Impl.AdaptBusInfo): Verify that the packages
        are routed to the Xcp instance on the remote ECU (FrIf_Transmit is called three times) and FlexRay
        sequence correction header counters have the correct values (0x04, 0x05, 0x06).
    14. Simulate that remote XCP slave responses, on FlexRay bus, with positive responses for 
        START_STOP_DAQ_LIST commands (Xcp calls XcpR_RxIndication).
    15. VP(XcpR.Impl.TransmissionOfConsecutiveMessages, XcpR.Impl.AdaptBusInfo): Verify that the XcpR calls the
        transmit interface of the lower layer (e.g FrIf_Transmit is called three times) and FlexRay sequence
        correction header counters have the correct values (0x04, 0x05, 0x06).
    16. Simulate reception, on FlexRay bus, of three packages with simulation data
        to be sent from Xcp master to remote Xcp slave.
    17. VP (XcpR.Impl.TransmissionOfConsecutiveMessages, XcpR.Impl.AdaptBusInfo) Verify that the packages are routed
        to the Xcp instance on the remote ECU (FrIf_Transmit is called three times) and FlexRay sequence correction header
        counters have the correct values (0x07, 0x08, 0x09).
    18. Set the result as success.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Disabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>124</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.BusTypesRemoteConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.AdaptBusInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>147</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.ReceptionPackedFrame.AbortUnpacking</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>433</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>548</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_XCPR_TransmissionRx_MultiplePdusInOneFrame</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_TransmissionRx/source/application/EbTest.c.m4</sourcefile>
      <sourceline>44</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Test the transmission from RxIndication functionality when both master and remote networks support multiple XcpR
      messanges in one FlexRay frame functionality.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    MASTER NETWORK:
      Bus type: FlexRay
      XcpRSourcePackMultiMsgInOneFlexRayFrame       = true
      XcpRDestinationPackMultiMsgInOneFlexRayFrame  = true
      XcpRRxSrcPduSupportTxFromRxIndication         = true
      XcpRRxSrcPduSupportTxFromRxIndication         = true
    REMOTE SLAVE NETWORK:
      Bus type: FlexRay
      XcpRSourcePackMultiMsgInOneFlexRayFrame       = true
      XcpRDestinationPackMultiMsgInOneFlexRayFrame  = true
      XcpRRxSrcPduSupportTxFromRxIndication         = true
      XcpRRxSrcPduSupportTxFromRxIndication         = true
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a package from remote Xcp slave when no connection is established
        (XcpR_RxIndication() is called).
    03. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the slave is DISCONNECTED.
    04. Simulate reception of a CONNECT command with MODE = 1 (XcpR_RxIndication()
        is called and command 0xFF, MODE = 1).
    05. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.dsn.ReceptionPackedFrame.TransmissionPackedFrame.AddHeaderInfo,
        XcpR.Impl.RemoteConnections.ConnectMode, XcpR.Impl.TransmitFromRxIndication): Check that the XcpR calls the
        transmit interface of the lower layer (e.g PM_Tst_Slave_Bus_Type\-::-/Transmit is called and the XCP package
        is the same with the one received from XCP).
    06. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    07. VP(XcpR.Impl.CheckStatusConnection, XcpR.Impl.TransmitFromRxIndication, XcpR.dsn.ReceptionPackedFrame.TransmissionPackedFrame.AddHeaderInfo):
        Verify that the XcpR calls the transmit interface of the lower layer (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and
        the XCP master package is the same with the one received from remote XCP but header is adapted).
    08. Simulate reception of one SET_DAQ_LIST_MODE commands frame
        (Data Stimulation Mode)  to be sent from Xcp master to Xcp slave.
    09. VP (XcpR.dsn.ReceptionPackedFrame.TransmissionPackedFrame.AddHeaderInfo, XcpR.Impl.TransmissionOfConsecutiveMessages,
        XcpR.Impl.TransmitFromRxIndication) Verify that the package is routed to the Xcp instance on the remote ECU in one frame
        (PM_Tst_Slave_Bus_Type\-::-/Transmit is called).
    10. Call XCPR main processing function to check that there is no other transmission.
    11. VP: The internal queue is empty and no transmission is performed.
    12. Simulate that XCP responses, on remote FlexRay bus, with a positive response to
        SET_DAQ_LIST_MODE commands frame (remote Xcp slave calls XcpR_RxIndication).
    13. VP(XcpR.dsn.ReceptionPackedFrame.TransmissionPackedFrame.AddHeaderInfo): Verify that the XcpR calls
        the transmit interface of the lower layer (e.g master PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP master package
        is the same with the one received from remote XCP slave but header is adapted).
    14. Simulate reception of one START_STOP_DAQ_LIST command frame
        to be sent from Xcp master to remote Xcp slave.
    15. VP (XcpR.Impl.TransmitFromRxIndication, XcpR.dsn.ReceptionPackedFrame.TransmissionPackedFrame.AddHeaderInfo):
        Verify that the packages are routed to the Xcp instance on the remote ECU in one frame (remote
        slave PM_Tst_Slave_Bus_Type\-::-/Transmit is called).
    16. Simulate that remote XCP slave responses with a START_DAQ_LIST commands
        frame (remote Xcp slave  calls XcpR_RxIndication).
    17. VP(XcpR.Impl.TransmitFromRxIndication, XcpR.dsn.ReceptionPackedFrame.TransmissionPackedFrame.AddHeaderInfo):
        Verify that the XcpR calls the transmit interface of the lower layer (e.g master PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP
        package is the same with the one received from remote XCP slave but header is adapted).
    18. Simulate reception of one simulation data frame to be sent
        from Xcp master to Xcp slave.
    19. VP (XcpR.Impl.TransmitFromRxIndication, XcpR.dsn.ReceptionPackedFrame.TransmissionPackedFrame.AddHeaderInfo):
        Verify that the packages are routed to the Xcp instance on the remote ECU in one frame (remote slave PM_Tst_Slave_Bus_Type\-::-/Transmit is called).
    20. Set the result as success.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.BusTypesRemoteConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.ReceptionPackedFrame.TransmissionPackedFrame.AddHeaderInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>437</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmitFromRxIndication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>164</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.ReceptionPackedFrame.TransmissionPackedFrame.PackAtLeastOneMsg</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>438</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>549</internalId></specobject>
    <specobject>
      <id>TS_XCPR_TransmissionRx_MultiplePdusInOneFrame_Master</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_TransmissionRx/source/application/EbTest.c.m4</sourcefile>
      <sourceline>321</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Test the transmission from RxIndication functionality when master network supports multiple XcpR
      messanges in one FlexRay frame functionality (packing/unpacking from/to the remote network)
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    MASTER NETWORK:
      Bus type: FlexRay
      XcpRSourcePackMultiMsgInOneFlexRayFrame       = true
      XcpRDestinationPackMultiMsgInOneFlexRayFrame  = true
      XcpRRxSrcPduSupportTxFromRxIndication         = true
      XcpRRxSrcPduSupportTxFromRxIndication         = true
    REMOTE SLAVE NETWORK
      Bus type: PM_Tst_Slave_Bus_Type
      XcpRRxSrcPduSupportTxFromRxIndication         = true
      XcpRRxSrcPduSupportTxFromRxIndication         = true
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a package consisting in command different than CONNECT command
        (XcpR_RxIndication() is called) when no connection is established.
    03. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the Slave is DISCONNECTED.
    04. Simulate reception of a CONNECT command with MODE = 1 (XcpR_RxIndication()
        is called and command 0xFF, MODE = 1).
    05. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode, XcpR.Impl.TransmitFromRxIndication):
        Check that the XcpR calls the transmit interface of the lower layer (e.g PM_Tst_Slave_Bus_Type\-::-/Transmit is called
        and the XCP package is the same with the one received from XCP).
    06. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    07. VP(XcpR.Impl.CheckStatusConnection, XcpR.Impl.TransmitFromRxIndication): Verify that the XcpR
        calls the transmit interface of the lower layer (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP master package
        is the same with the one received from remote XCP slave but header is adapted).
    08. Simulate reception of one SET_DAQ_LIST_MODE command frame
        (Data Stimulation Mode)  to be sent from Xcp master to Xcp slave.
    09. VP (XcpR.dsn.ReceptionPackedFrame.SendMessageIndependently, XcpR.Impl.TransmitFromRxIndication,
        XcpR.Impl.TransmissionOfConsecutiveMessages) Verify that the packages are routed to the Xcp instance
        on the remote ECU (PM_Tst_Slave_Bus_Type\-::-/Transmit is called three times).
    10. Simulate that the remote XCP slave responses with positive response for all the three
        SET_DAQ_LIST_MODE commands (remote Xcp slave calls XcpR_RxIndication).
    11. VP(XcpR.Impl.TransmitFromRxIndication): Verify that the XcpR calls the transmit interface of the
        lower layer (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called the XCP data packages are the same with the one
        received from remote XCP slave but header is adapted).
    12. Simulate reception of one START_STOP_DAQ_LIST commands frame
        to be sent from Xcp master to remote Xcp slave.
    13. VP (XcpR.dsn.ReceptionPackedFrame.SendMessageIndependently, XcpR.Impl.TransmitFromRxIndication):
        Verify that the packages are routed to the Xcp instance on the remote ECU (PM_Tst_Slave_Bus_Type\-::-/Transmit is called three times).
    14. Simulate that XCP responses with a positive responses to 
        START_STOP_DAQ_LIST commands (remote Xcp slave calls XcpR_RxIndication).
    15. VP(XcpR.Impl.TransmitFromRxIndication): Verify that the XcpR calls the transmit interface of the
        layer (e.g PM_Tst_Slave_Bus_Type\-::-/Transmit is called the XCP data packages are the same with the one
        received from remote XCP slave but header is adapted).
    16. Call XCPR main processing function to check that there is no other transmission.
    17. VP: The internal queue is empty and no transmission is performed.
    18. Simulate reception of one simulation data frame to be sent
        from Xcp master to Xcp slave.
    19. VP (XcpR.dsn.ReceptionPackedFrame.SendMessageIndependently, XcpR.Impl.TransmitFromRxIndication):
        Verify that the packages are routed to the Xcp instance on the remote ECU (PM_Tst_Slave_Bus_Type\-::-/Transmit is called three times).
    20. Set the result as success.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.BusTypesRemoteConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmitFromRxIndication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>164</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.ReceptionPackedFrame.SendMessageIndependently</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>435</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>550</internalId></specobject>
    <specobject>
      <id>TS_XCPR_TransmissionRx_MultiplePdusInOneFrame_RemoteXcpSlave</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_TransmissionRx/source/application/EbTest.c.m4</sourcefile>
      <sourceline>596</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Test the transmission from RxIndication functionality when remote network supports multiple XcpR
      messanges in one FlexRay frame functionality (packing/unpacking from/to the master network)
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    MASTER NETWORK:
      Bus type: PM_Tst_Master_Bus_Type
      XcpRRxSrcPduSupportTxFromRxIndication         = true
      XcpRRxSrcPduSupportTxFromRxIndication         = true
    REMOTE SLAVE NETWORK
      Bus type: FlexRay
      XcpRSourcePackMultiMsgInOneFlexRayFrame       = true
      XcpRDestinationPackMultiMsgInOneFlexRayFrame  = true
      XcpRRxSrcPduSupportTxFromRxIndication         = true
      XcpRRxSrcPduSupportTxFromRxIndication         = true
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a package consisting in command different than CONNECT command
        on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called) when no connection is established.
    03. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the Slave is DISCONNECTED.
    04. Simulate reception of a CONNECT command with MODE = 1 on PM_Tst_Master_Bus_Type bus (XcpR_RxIndication()
        is called and command 0xFF, MODE = 1).
    05. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode, XcpR.Impl.TransmitFromRxIndication):
        Check that the XcpR calls the transmit interface of the lower layer (e.g PM_Tst_Slave_Bus_Type\-::-/Transmit is called
        and the XCP package is the same with the one received from XCP).
    06. Call XCPR main processing function to check that there is no other transmission.
    07. VP: The internal queue is empty and no transmission is performed.
    08. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
          and data equals to CONNECT positive response).
    09. VP(XcpR.Impl.CheckStatusConnection, XcpR.Impl.TransmitFromRxIndication): Verify that the XcpR calls the transmit
        interface of the lower layer (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package is the same with the
        one received from remote XCP slave but header is adapted).
    10. Simulate reception, on PM_Tst_Master_Bus_Type bus, of three SET_DAQ_LIST_MODE commands.
    11. VP (XcpR.Impl.TransmitFromRxIndication, XcpR.Impl.TransmissionOfConsecutiveMessages): Verify that the
        package is routed to the Xcp instance on the remote ECU (PM_Tst_Slave_Bus_Type\-::-/Transmit is called three times,
        three individual frames).
    12. Simulate that remote XCP slave responses with a positive response to all the three
        SET_DAQ_LIST_MODE commands (Xcp calls XcpR_RxIndication).
    13. VP(XcpR.Impl.TransmitFromRxIndication,  XcpR.dsn.ReceptionPackedFrame.SendMessageIndependently):
        Verify that the XcpR calls the transmit interface of the lower layer (e.g PM_Tst_Master_Bus_Type\-::-/Transmit
        is called three times and the XCP master data packages are the same with the one received from remote XCP
        but header is adapted).
    14. Simulate reception of the START_STOP_DAQ_LIST commands.
    15. VP (XcpR.Impl.TransmitFromRxIndication) Verify that the packages are routed
        to the Xcp instance on the remote ECU (PM_Tst_Slave_Bus_Type\-::-/Transmit is called three times, three individual frames).
    16. Simulate that XCP responses with positive responses to all the three
        START_STOP_DAQ_LIST commands (remote Xcp slave calls XcpR_RxIndication).
    17. VP(XcpR.Impl.TransmitFromRxIndication,  XcpR.dsn.ReceptionPackedFrame.SendMessageIndependently):
        Verify that the XcpR calls the transmit interface of the lower layer (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called
        three times and the XCP master data packages are the same with the one received from  remote XCP slave
        but header is adapted).
    18. Simulate reception, on PM_Tst_Master_Bus_Type bus, of three simulation data packages
        to be sent from Xcp master to remote Xcp slave.
    19. VP (XcpR.Impl.TransmitFromRxIndication) Verify that the packages are routed
        to the Xcp instance on the remote ECU (PM_Tst_Slave_Bus_Type\-::-/Transmit is called three times, individual frames).
    20. Set the result as success.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.BusTypesRemoteConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmitFromRxIndication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>164</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.ReceptionPackedFrame.SendMessageIndependently</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>435</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>551</internalId></specobject>
    <specobject>
      <id>TS_XCPR_TransmissionRx</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_TransmissionRx/source/application/EbTest.c.m4</sourcefile>
      <sourceline>875</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Test the transmission from RxIndication functionality.
      Master network:
        Bus type: PM_Tst_Master_Bus_Type
        Enabled transmission from RxIndication
      Remote network:
        Bus type: PM_Tst_Slave_Bus_Type
        Enabled transmission from RxIndication
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    Master network:
      XcpRRxSrcPduSupportTxFromRxIndication         = true
      XcpRRxSrcPduSupportTxFromRxIndication         = true
    Remote slave network:
      XcpRRxSrcPduSupportTxFromRxIndication         = true
      XcpRRxSrcPduSupportTxFromRxIndication         = true
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a package consisting in command different than CONNECT command
        on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called) when no connection is established.
    03. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the Slave is DISCONNECTED.
    04. Simulate reception of a CONNECT command with MODE = 1 on PM_Tst_Master_Bus_Type
        (XcpR_RxIndication() is called and command 0xFF, MODE = 1).
    05. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode, XcpR.Impl.TransmitFromRxIndication):
        Check that the XcpR calls the transmit interface of the lower layer (e.g PM_Tst_Slave_Bus_Type\-::-/Transmit is called
        and the XCP package is the same with the one received from XCP).
    06. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    07. VP(XcpR.Impl.CheckStatusConnection, XcpR.Impl.TransmitFromRxIndication): Verify that the XcpR calls
        the transmit interface of the lower layer (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP
        package is the same with the one received from XCP but header is adapted).
    08. Simulate reception of the SET_DAQ_LIST_MODE command.
    09. VP (XcpR.Impl.TransmitFromRxIndication, XcpR.Impl.TransmissionOfConsecutiveMessages):
        Verify that the package is routed to the Xcp instance on the remote ECU
        (PM_Tst_Slave_Bus_Type\-::-/Transmit is called).
    10. Simulate that slave XCP responses with positive response to the
        SET_DAQ_LIST_MODE command (remote Xcp slave calls XcpR_RxIndication).
    11. VP(XcpR.Impl.TransmitFromRxIndication): Verify that the XcpR calls the transmit interface of the lower layer
      (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP data package is the same with the one received from XCP but header is adapted).
    12. Simulate reception of the START_STOP_DAQ_LIST command.
    13. VP (XcpR.Impl.TransmitFromRxIndication) Verify that the package is routed to the Xcp instance
        on the remote ECU (PM_Tst_Slave_Bus_Type\-::-/Transmit is called ).
    14. Simulate that XCP responses, on PM_Tst_Slave_Bus_Type bus, with a positive responses to the
        START_STOP_DAQ_LIST command (remote Xcp slave calls XcpR_RxIndication).
    15. VP(XcpR.Impl.TransmitFromRxIndication): Verify that the XcpR calls the transmit interface of
        the lower layer (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP data package is the
        same with the one received from XCP but header is adapted).
    16. Simulate reception, on PM_Tst_Master_Bus_Type bus, of the simulation data package
        to be sent from the Xcp master to the remote Xcp slave.
    17. VP (XcpR.Impl.TransmitFromRxIndication) Verify that the package is routed
        to the Xcp instance on the remote ECU (PM_Tst_Slave_Bus_Type\-::-/Transmit is called).
    18. Set the result as success.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.BusTypesRemoteConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmitFromRxIndication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>164</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>552</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_XCPR_DataStim_PacketGreaterThan255Bytes</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_TransmitLargePackages/source/application/EbTest.c.m4</sourcefile>
      <sourceline>88</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Verify that XcpR successfully forward stimulation data packages greater than 255 bytes from Xcp master to remote Xcp slave.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
      01. Initialize stubs and XcpR.
      02. Simulate reception of a CONNECT command with MODE = 1 (XcpR_RxIndication()
        is called and command 0xFF, MODE = 1).
      03. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode): Check that the XcpR
        calls the transmit interface of the lower layer (e.g PM_Tst_Slave_Bus_Type\-::-/Transmit is called and the XCP
        package is the same with the one received from XCP).
      04. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called and the data
        equals a CONNECT positive response).
      05. VP(XcpR.Impl.CheckStatusConnection): Verify that the XcpR calls the transmit interface of the lower
        layer (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP master package is the same with the one
        received from remote XCP but header is adapted).
    m4_ifelse(PM_Tst_Master_XcpRPackMultiMsgInOneFrame,true,\-:m4_dnl
      06. Simulate reception of a command frame SET_DAQ_LIST_MODE (Data Stimulation Mode) to be sent from Xcp
        master to Xcp slave.
:-/,m4_ifelse( :else: )\-:m4_dnl
      06. Simulate reception, on PM_Tst_Master_Bus_Type bus, of 3 individual commands SET_DAQ_LIST_MODE.
:-/m4_ifelse( :endif: ))\-::-/m4_dnl
      07. VP (XcpR.Impl.TransmissionOfConsecutiveMessages): Verify that the payload has been sent successfully
        from master to remote (the message structure has been adapted to the remote bus type).
      08. Call XCPR main processing function to check that there is no other transmission.
      09. VP: The internal queue is empty and no transmission is performed.
    m4_ifelse(PM_Tst_Slave_XcpRPackMultiMsgInOneFrame,true,\-:m4_dnl
      10. Simulate that remote XCP responds with a positive response to commands SET_DAQ_LIST_MODE (remote Xcp
        slave calls XcpR_RxIndication).
:-/,m4_ifelse( :else: )\-:m4_dnl
      10. Simulate that the remote XCP slave responds with positive responses for all 3 commands SET_DAQ_LIST_MODE
        (remote Xcp slave calls XcpR_RxIndication).
:-/m4_ifelse( :endif: ))\-::-/m4_dnl
      11. VP (XcpR.Impl.TransmissionOfConsecutiveMessages): Verify that the payload has been sent successfully
        from remote to master (the message structure has been adapted to the master bus type).
    m4_ifelse(PM_Tst_Master_XcpRPackMultiMsgInOneFrame,true,\-:m4_dnl
      12. Simulate reception of a simulation data frame to be sent from Xcp master to Xcp slave.
:-/,m4_ifelse( :else: )\-:m4_dnl
      12. Simulate reception of three simulation data packages to be sent from Xcp master to remote Xcp slave.
:-/m4_ifelse( :endif: ))\-::-/m4_dnl
      13. VP (XcpR.Impl.TransmissionOfConsecutiveMessages): Verify that the payload has been sent successfully
        from master to remote (the message structure has been adapted to the master bus type).
      14. Call XCPR main processing function to check that there is no other transmission.
      15. VP: The internal queue is empty and no transmission is performed.
      16. Set the result as success.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.BusTypesRemoteConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>553</internalId></specobject>
    <specobject>
      <id>TS_XCPR_AcqData_PacketGreaterThan255Bytes</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_TransmitLargePackages/source/application/EbTest.c.m4</sourcefile>
      <sourceline>364</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Verify that XcpR successfully forward data acquisition packages greater than 255 bytes from remote Xcp to Xcp master.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
      01. Initialize stubs and XcpR.
      02. Simulate reception of a CONNECT command with MODE = 1 (XcpR_RxIndication() is called
          and command 0xFF, MODE = 1).
      03. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode): Check that the XcpR
          calls the transmit interface of the lower layer (e.g PM_Tst_Slave_Bus_Type\-::-/Transmit is called and the XCP
          package is the same with the one received from XCP).
      04. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called and the data
          equals a CONNECT positive response).
      05. VP(XcpR.Impl.CheckStatusConnection): Verify that the XcpR calls the transmit interface of the lower
          layer (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP master package is the same with the one
          received from remote XCP but header is adapted).
    m4_ifelse(PM_Tst_Master_XcpRPackMultiMsgInOneFrame,true,\-:m4_dnl
      06. Simulate the reception of a command frame SET_DAQ_LIST_MODE (Data Acquisition Mode) to be sent from
          Xcp remote to Xcp master.
:-/,m4_ifelse( :else: )\-:m4_dnl
      06. Simulate reception, on PM_Tst_Master_Bus_Type bus, of three SET_DAQ_LIST_MODE commands.
:-/m4_ifelse( :endif: ))\-::-/m4_dnl
      07. VP (XcpR.Impl.TransmissionOfConsecutiveMessages): Verify that the payload has been sent successfully
          from master Xcp to remote Xcp (the message structure has been adapted to the remote bus type).
      08. Call XCPR main processing function to check that there is no other transmission.
      09. VP: The internal queue is empty and no transmission is performed.
    m4_ifelse(PM_Tst_Slave_XcpRPackMultiMsgInOneFrame,true,\-:m4_dnl
      10. Simulate that remote XCP responds with a positive response to commands SET_DAQ_LIST_MODE (remote Xcp
          slave calls XcpR_RxIndication).
:-/,m4_ifelse( :else: )\-:m4_dnl
      10. Simulate that the remote XCP slave responds with positive responses for all 3 commands
          SET_DAQ_LIST_MODE (remote Xcp slave calls XcpR_RxIndication).
:-/m4_ifelse( :endif: ))\-::-/m4_dnl
      11. VP (XcpR.Impl.TransmissionOfConsecutiveMessages): Verify that the payload has been sent successfully
          from remote Xcp to master Xcp (the message structure has been adapted to the master bus type).
    m4_ifelse(PM_Tst_Slave_XcpRPackMultiMsgInOneFrame,true,\-:m4_dnl
      12. Simulate that remote Xcp slave responds with a data acquisition frame packet to be sent to Xcp master.
:-/,m4_ifelse( :else: )\-:m4_dnl
      12. Simulate that remote Xcp slave responds with 3 individual data acquisition packets to be sent to Xcp master.
:-/m4_ifelse( :endif: ))\-::-/m4_dnl
      13. VP (XcpR.Impl.TransmissionOfConsecutiveMessages): Verify that the payload has been sent successfully
          from master to remote (the message structure has been adapted to the master bus type).
      14. Call XCPR main processing function to check that there is no other transmission.
      15. VP: The internal queue is empty and no transmission is performed.
      16. Set the result as success.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.BusTypesRemoteConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.GeneralDescription</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>411</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>554</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_XCPR_FrToCdd_TrigTrans_PackPdus_RemoteXcpSlave</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_TrigTrans_PackPdus/source/application/EbTest.c</sourcefile>
      <sourceline>40</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Test trigger transmit and packing multiple pdus in one frame functionality. Check that messages sent
      from Xcp Master are forwarded to the Xcp Slave on the remote ECU only if the connection is established
      through a CONNECT command.
      * MASTER NETWORK: FlexRay
      * REMOTE SLAVE NETWORK: Cdd
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a package consisting in command different than CONNECT command
        on FlexRay (XcpR_RxIndication() is called) when no connection is established (simulate GET_STATUS
        command).
    03. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without
        any action because the Slave is DISCONNECTED.
    04. Simulate reception of a CONNECT command with MODE = 1 on FlexRay (XcpR_RxIndication()
        is called and command 0xFF, MODE = 1).
    05. Transmit data using the trigger transmit.
    06. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode): Check that the XcpR
        calls the transmit interface of the lower layer (e.g Cdd_Transmit is called and the XCP
        package is the same with the one received from XCP).
    07. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    08. Transmit data using the trigger transmit.
    09. VP(XcpR.Impl.CheckStatusConnection): Verify that the XcpR calls the transmit interface
        of the lower layer (e.g FrIf_Transmit is called and the XCP package is the same with the
        one received from XCP but header is adapted).
    10. Simulate reception, on FlexRay bus, of one frame with SET_DAQ_LIST_MODE
        (Data Stimulation Mode) commands to be sent from Xcp master to Xcp slave.
    11. Transmit data using the trigger transmit.
    12. VP (XcpR.Impl.TransmissionOfConsecutiveMessages, XcpR.dsn.ReceptionPackedFrame.SendMessageIndependently)
        Verify that the first package is routed to the Xcp instance on the remote ECU (Cdd_Transmit is called).
    13. Simulate confirming the first package after FrIf_Transmit() was processed from step 10.
    14. Transmit data using the trigger transmit.
    15. VP (XcpR.Impl.TransmissionOfConsecutiveMessages, XcpR.dsn.ReceptionPackedFrame.SendMessageIndependently)
        Verify that the second package is routed to the Xcp instance on the remote ECU (Cdd_Transmit is called).
    16. Simulate confirming the second package after FrIf_Transmit() was processed from step 10.
    17. Simulate that slave XCP responses, on CDD bus, with positive responses for 
        SET_DAQ_LIST_MODE commands (remote Xcp slave calls XcpR_RxIndication).
    18. Transmit data using the trigger transmit.
    19. VP(XcpR.dsn.ReceptionFromRxIndication.TransmissionPackedFrame.PackMsgIntoFrame): Verify that the XcpR
        calls the transmit interface of the lower layer (e.g FrIf_Transmit is called and the XCP package is the same with
        the one received from XCP but header is adapted).
    20. Simulate confirming the package after FrIf_Transmit() was processed from step 17.
    21. Set the result as success.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.ReceptionPackedFrame.SendMessageIndependently</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>435</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.ReceptionFromRxIndication.TransmissionPackedFrame.PackMsgIntoFrame</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>432</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>555</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_XCPR_FlexRay_TrigTrans_PackPdus_SeqCor_RemoteXcpSlave</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_TrigTrans_PackPdus_SeqCor/source/application/EbTest.c</sourcefile>
      <sourceline>40</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Test trigger transmit, packing multiple pdus in one frame and sequence correction functionality.
      Check that messages sent from Xcp Master are forwarded to the Xcp Slave on the remote ECU only
      if the connection is established.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a package, from remote Xcp slave, when no connection is established.
    03. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the Slave is DISCONNECTED.
    04. Simulate reception of a CONNECT command with MODE = 1 on FlexRay (XcpR_RxIndication()
        is called and command 0xFF, MODE = 1).
    05. Transmit data using the trigger transmit.
    06. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.dsn.ReceptionPackedFrame.TransmissionPackedFrame.AddHeaderInfo,
        XcpR.Impl.RemoteConnections.ConnectMode): Check that the XcpR calls the transmit interface of the lower layer.
        XCP package is the same with the one received and the FlexRay sequence correction header counter has the correct value (0x00).
    07. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    08. VP(XcpR.Impl.CheckStatusConnection, XcpR.Impl.AdaptBusInfo, XcpR.dsn.ReceptionPackedFrame.TransmissionPackedFrame.AddHeaderInfo):
        Verify that the XcpR calls the transmit interface of the lower layer. XCP package is the same with the one received
        and the FlexRay sequence correction header counter has the correct value (0x00)
    09. Simulate reception, on master FlexRay bus, of one frame with SET_DAQ_LIST_MODE
        (Data Stimulation Mode) commands to be sent from Xcp master to Xcp slave.
    10. Transmit data using the trigger transmit.
    11. VP (XcpR.dsn.ReceptionPackedFrame.TransmissionPackedFrame.AddHeaderInfo, XcpR.Impl.TransmissionOfConsecutiveMessages):
        Verify that the package is routed to the Xcp instance on the remote ECU in one frame and the FlexRay sequence correction
        header counter has the correct value (0x01)
    12. Simulate that XCP responses, on remote FlexRay bus, with a positive response for
        SET_DAQ_LIST_MODE commands (Xcp calls XcpR_RxIndication).
    13. VP(XcpR.Impl.AdaptBusInfo, XcpR.dsn.ReceptionPackedFrame.TransmissionPackedFrame.AddHeaderInfo):
        Verify that the XcpR calls the transmit interface of the lower layer and the FlexRay sequence correction
        header counter has the correct value (0x01)
    14. Simulate reception, on FlexRay bus, of START_DAQ_LIST frame command
        to be sent from Xcp master to Xcp slave.
    15. Transmit data using the trigger transmit.
    16. VP (XcpR.dsn.ReceptionPackedFrame.TransmissionPackedFrame.AddHeaderInfo) Verify that the
        packages are routed to the Xcp instance on the remote ECU in one frame and the FlexRay sequence correction
        header counter has the correct value (0x02)
    17. Simulate that XCP responses, on FlexRay bus, with a positive response for
        START_DAQ_LIST commands (Xcp calls XcpR_RxIndication).
    18. VP(XcpR.dsn.ReceptionPackedFrame.TransmissionPackedFrame.AddHeaderInfo): Verify that the XcpR calls
        the transmit interface of the lower layer and the FlexRay sequence correction header counter has the 
        correct value (0x02).
    19. Simulate reception, on FlexRay bus, of simulation data frame packet
        to be sent from Xcp master to remote Xcp slave.
    20. Transmit data using the trigger transmit.
    21. VP (XcpR.Impl.AdaptBusInfo, XcpR.dsn.ReceptionPackedFrame.TransmissionPackedFrame.AddHeaderInfo):
        Verify that the packages are routed to the Xcp instance on the remote ECU in one frame and the FlexRay sequence
        correction header counter has the correct value (0x03).
    22. Set the result as success.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.ReceptionPackedFrame.TransmissionPackedFrame.AddHeaderInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>437</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.AdaptBusInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>147</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>556</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_XCPR_FlexRay_TrigTrans_SeqCor_RemoteXcpSlave</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_TrigTrans_SeqCor/source/application/EbTest.c</sourcefile>
      <sourceline>40</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Test trigger transmit and sequence correction functionality. Check that messages sent
      from Xcp Master are forwarded to the Xcp Slave on the remote ECU only if the connection
      is established.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate a positive response from the XCP on remote ECU when no connection is established.
    03. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the Slave is DISCONNECTED.
    04. Simulate reception of a CONNECT command with MODE = 1 on FlexRay (XcpR_RxIndication()
        is called and command 0xFF, MODE = 1).
    05. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode): Check that the
        XcpR calls the transmit interface of the lower layer and the FlexRay sequence correction header counter
        has the correct value (0x00).
    06. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    07. Transmit data using the trigger transmit.
    08. VP(XcpR.Impl.CheckStatusConnection, XcpR.Impl.AdaptBusInfo): Verify that the XcpR calls the transmit
        interface of the lower layer and the FlexRay sequence correction header counter
        has the correct value (0x00).
    09. Simulate reception, on FlexRat bus, of a package consisting in command different than CONNECT command.
    10. VP (XcpR.Impl.TransmissionOfConsecutiveMessages) Verify that the command is routed to the XCP instance on
        the remote ECU (FrIf_Transmit is called and the FlexRay sequence correction header counter
        has the correct value (0x01)
    11. Simulate that XCP responses with a positive response (XcpR_RxIndication is called
        and data equals to GET_STATUS positive response).
    12. Transmit data using the trigger transmit.
    13. VP(XcpR.Impl.TransmissionOfConsecutiveMessages): Verify that the XcpR calls the transmit interface of
        the lower layer and the FlexRay sequence correction header counter has the correct value (0x01).
    14. Set the result as success.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.AdaptBusInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>147</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>557</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_XCPR_ConnectCmd_PosRes_RemoteXcp_TriggerTransmit</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_TriggerTransmit/source/application/EbTest.c.m4</sourcefile>
      <sourceline>43</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Test trigger transmit functionality. Check that messages sent from Xcp Master are forwarded
      to the Xcp Slave on the remote ECU only if the connection is established
      through a CONNECT command.
      * MASTER NETWORK: PM_Tst_Master_Bus_Type
      * REMOTE SLAVE NETWORK: PM_Tst_Slave_Bus_Type
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a package consisting in command different than CONNECT command
        on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called when no connection is established).
    03. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the Slave is DISCONNECTED.
    04. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    05. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because no connection is established.
    06. Simulate reception of a CONNECT command with MODE = 1 on PM_Tst_Master_Bus_Type (XcpR_RxIndication()
        is called and command 0xFF, MODE = 1).
    07. Transmit data using the trigger transmit.
    08. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode): Check that the
        XcpR calls the transmit interface of the lower layer (e.g PM_Tst_Slave_Bus_Type\-::-/Transmit is called
        and the XCP package is the same with the one received from XCP).
    09. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    10. Transmit data using the trigger transmit.
    11. VP(XcpR.Impl.CheckStatusConnection): Verify that the XcpR calls the transmit interface of the lower
        layer (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package is the same with the one received
        from XCP but header is adapted).
    12. Simulate reception, on PM_Tst_Master_Bus_Type bus, of the first package (GET_STATUS command)
        to be sent from Xcp master to Xcp slave.
    13. Transmit data using the trigger transmit.
    14. VP (XcpR.Impl.TransmissionOfConsecutiveMessages) Verify that the command is routed to the XCP instance on
        the remote ECU (PM_Tst_Slave_Bus_Type\-::-/Transmit is called and the XCP package is the same with the one
        received from XCP but header is adapted).
    15. Simulate that XCP responses with a positive response (XcpR_RxIndication is called
        and data equals to GET_STATUS positive response).
    16. Transmit data using the trigger transmit.
    17. VP(XcpR.Impl.TransmissionOfConsecutiveMessages): Verify that the XcpR calls the transmit interface of
        the lower layer (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package is the same with the
        one received from XCP).
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.BusTypesRemoteConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.Communication.FlexRay.DecoupledAccess</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>138</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.Communication.CDD.DecoupledAccess</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>140</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DoNotForward.TriggerTransmit.LowerLayer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>163</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.PublicHeader</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>141</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>558</internalId></specobject>
    <specobject>
      <id>TS_XCPR_ConnectCmd_NegRes_RemoteXcp_TriggerTransmit</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_TriggerTransmit/source/application/EbTest.c.m4</sourcefile>
      <sourceline>301</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Test trigger transmit functionality. Check that messages sent from Xcp Master are NOT forwarded to the Xcp Slave
      on the remote ECU if the connection is not established through a CONNECT command.
      * MASTER NETWORK: PM_Tst_Master_Bus_Type
      * REMOTE SLAVE NETWORK: PM_Tst_Slave_Bus_Type
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a package consisting in command different than CONNECT command
        (simulate GET_STATUS command.
    03. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the Slave is DISCONNECTED.
    04. Simulate reception of a CONNECT command with MODE = 1 on PM_Tst_Master_Bus_Type (XcpR_RxIndication()
        is called and command 0xFF, MODE = 1).
    05. Transmit data using the trigger transmit.
    06. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode): Check that the
        and the XCP package is the same with the one received from XCP).
    07. Simulate a negative response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT negative response).
    08. Transmit data using the trigger transmit.
m4_ifelse(PM_Permutation,CddToCddDetRuntimeOff,\-:m4_dnl
    09. Check that XcpR does not store a Det runtime error if XcpRDetRuntimeChecks is set to false.
:-/,m4_ifelse( :else: )\-:
    09. VP(XcpR.Impl.AdaptBusInfo): Verify that the XcpR calls the transmit interface of the lower layer
        from XCP but header is adapted).
:-/m4_ifelse( :endif: ))
    10. Simulate reception, on PM_Tst_Master_Bus_Type bus, of a package consisting in command different than CONNECT command.
    11. VP (XcpR.Impl.DisconnectedState.CommandResponse) Received package is ignored without any action.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.BusTypesRemoteConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.AdaptBusInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>147</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.Communication.FlexRay.DecoupledAccess</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>138</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.Communication.CDD.DecoupledAccess</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>140</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>559</internalId></specobject>
    <specobject>
      <id>TS_XCPR_ConnectCmd_PosRes_LocalXcp_TriggerTransmit</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_TriggerTransmit/source/application/EbTest.c.m4</sourcefile>
      <sourceline>481</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Test trigger transmit functionality. Check that messages sent from Xcp Master are forwarded
      to the Xcp Slave on the local ECU only if the connection is established
      through a CONNECT command.
      * MASTER NETWORK: PM_Tst_Master_Bus_Type
      * LOCAL SLAVE NETWORK: CDD
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception, on PM_Tst_Master_Bus_Type bus, of a package consisting in command different than CONNECT command.
    03. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the slave is DISCONNECTED.
    04. Simulate reception of a CONNECT command with MODE = 0 on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called and command 0xFF, MODE = 0).
    05. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_0): Verify that the XcpR calls the indication interface of the
        upper layer (e.g Xcp_CddRxIndication is called and the XCP package is the same with the one received).
    06. Simulate a positive response from the Xcp on local ECU (Xcp calls XcpR_Transmit with CONNECT positive response).
    07. VP(XcpR.Impl.TxConfirmation.UpperLayer): Verify that the XcpR calls the confirmation interface
        of the upper layer (e.g Xcp_CddTxConfirmation is called with the correct Pdu id).
    08. VP(XcpR.Impl.TriggerTransmit.UpperLayer): Verify that the XcpR calls the trigger transmit interface of the upper layer.
    09. Transmit data using the trigger transmit.
    10. VP(XcpR.Impl.CheckStatusConnection): Verify that the XcpR calls the transmit interface of the lower
        layer (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the master Xcp package is the same with the one
        received from the local slave Xcp but header is adapted).
    11. Simulate confirming the response after PM_Tst_Master_Bus_Type\-::-/Transmit() was processed from step 06.
    12. Simulate reception, on PM_Tst_Master_Bus_Type bus, of a package consisting in command different
        than CONNECT command.
    13. Simulate reception, on PM_Tst_Master_Bus_Type bus, of a second package consisting in command different
        than CONNECT command. The second package will be ignored because the assigned receive Pdu buffer is full.
m4_ifelse(PM_Permutation,CddToCddDetRuntimeOff,\-:m4_dnl
    14. Check that XcpR does not store a Det runtime error if XcpRDetRuntimeChecks is set to false..
:-/,m4_ifelse( :else: )\-:
    14. VP(XcpR.dsn.RxIndication.DetOn.PduBufferFull): Check that XcpR throws the runtime error XCPR_E_PDU_BUFFER_FULL.
:-/m4_ifelse( :endif: ))
    15. VP (XcpR.Impl.TransmissionOfConsecutiveMessages) Verify that the command is routed to the Xcp instance
    16. Simulate that XCP responses, on CDD bus, with a positive response (Xcp calls XcpR_Transmit
    17. VP(XcpR.Impl.TxConfirmation.UpperLayer): Verify that the XcpR calls the confirmation interface
        of the upper layer (e.g Xcp_CddTxConfirmation is called with the correct Pdu id).
    18. VP(XcpR.Impl.TriggerTransmit.UpperLayer): Verify that the XcpR calls the trigger transmit interface of the upper layer.
    19. Transmit data using the trigger transmit.
    20. VP(XcpR.Impl.TransmissionOfConsecutiveMessages): Verify that the XcpR calls the transmit interface of
        the lower layer (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package is the same with the one received from XCP).
    21. Simulate confirming the response after PM_Tst_Master_Bus_Type\-::-/Transmit() was processed from step 13.
    22. Set the result as success.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.CddLocalConnectionsOnly</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>149</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_0</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>122</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TxConfirmation.UpperLayer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>160</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.RxIndication.DetOn.PduBufferFull</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>448</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TriggerTransmit.UpperLayer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>161</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>560</internalId></specobject>
    <specobject>
      <id>TS_XCPR_ConnectCmd_NegRes_LocalXcp_TriggerTransmit</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_TriggerTransmit/source/application/EbTest.c.m4</sourcefile>
      <sourceline>731</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Test trigger transmit functionality. Check that messages sent from Xcp Master are NOT forwarded to the Xcp Slave
      on the local ECU if the connection is not established through a CONNECT command.
      * MASTER NETWORK: PM_Tst_Master_Bus_Type
      * LOCAL SLAVE NETWORK: PM_Tst_Slave_Bus_Type
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a CONNECT command with MODE = 0 on PM_Tst_Master_Bus_Type ( XcpR_RxIndication() is
        called and command 0xFF, MODE = 0).
    03. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_0): Verify that the XcpR calls the indication
        interface of the upper layer (e.g Xcp_CddRxIndication is called and the XCP package is the
        same with the one received).
    04. Simulate a negative response from the Xcp on local ECU (Xcp calls XcpR_Transmit
          with CONNECT negative response).
    05. VP(XcpR.Impl.TxConfirmation.UpperLayer): Verify that the XcpR calls the confirmation
        interface of the upper layer (Xcp_CddTxConfirmation is called with the correct pdu id).
    06. VP(XcpR.Impl.TriggerTransmit.UpperLayer): Verify that the XcpR calls the trigger transmit interface of the upper layer.
    07. Transmit data using the trigger transmit.
    08. VP(XcpR.Impl.AdaptBusInfo): Verify that the XcpR calls the transmit interface
        of the lower layer (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP
        package is the same with the one received from XCP but header is adapted).
    07. Simulate reception, on PM_Tst_Master_Bus_Type bus, of a package consisting in command
        different than CONNECT command.
    08. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the Slave is DISCONNECTED.
    09. Simulate reception of a CONNECT command with MODE = 0 on PM_Tst_Master_Bus_Type ( XcpR_RxIndication() is
        called and command 0xFF, MODE = 0).
    10. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_0): Verify that the XcpR calls the indication interface of the upper layer
        (e.g Xcp_CddRxIndication is called and the XCP package is the same with the one received).
    11. Simulate a positive response from the Xcp on local ECU (Xcp calls XcpR_Transmit
        with a CONNECT positive response).
    12. VP(XcpR.Impl.TxConfirmation.UpperLayer): Verify that the XcpR calls the confirmation
        interface of the upper layer (Xcp_CddTxConfirmation is called with the correct pdu id).
    13. VP(XcpR.Impl.TriggerTransmit.UpperLayer): Verify that the XcpR calls the trigger transmit interface of the upper layer.
    14. Transmit data using the trigger transmit.
    15. VP(XcpR.Impl.CheckStatusConnection): Verify that the XcpR calls the transmit interface of the lower layer
        (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the master Xcp package is the same with the one received
        from the local slave Xcp but header is adapted).
    16. Simulate confirming the response after PM_Tst_Master_Bus_Type\-::-/Transmit() was processed from step 11.
    17. Simulate reception, on PM_Tst_Master_Bus_Type bus, of a package consisting in command different than CONNECT command.
    18. VP (XcpR.Impl.TransmissionOfConsecutiveMessages) Verify that the command is routed to the Xcp instance on
        the local ECU (Xcp_CddRxIndication is called and the XCP package is the same with the one received from XCP
        but header is adapted).
    19. Simulate that XCP responses, on CDD bus, with a positive response (Xcp calls XcpR_Transmit
        with GET_STATUS positive response).
    20. VP(XcpR.Impl.TxConfirmation.UpperLayer): Verify that the XcpR calls the confirmation
        interface of the upper layer (Xcp_CddTxConfirmation is called with the correct pdu id).
    21. VP(XcpR.Impl.TriggerTransmit.UpperLayer): Verify that the XcpR calls the trigger transmit interface of the upper layer.
    22. Transmit data using the trigger transmit.
    23. VP(XcpR.Impl.TransmissionOfConsecutiveMessages): Verify that the XcpR calls the transmit interface of the lower layer
        (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called once and only GET_STATUS positive response is forward to Xcp master).
    20. Simulate confirming the response after PM_Tst_Master_Bus_Type\-::-/Transmit() was processed from step 19.
    21. Set the result as success.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.CddLocalConnectionsOnly</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>149</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_0</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>122</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.AdaptBusInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>147</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TxConfirmation.UpperLayer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>160</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>561</internalId></specobject>
    <specobject>
      <id>TS_XCPR_LocalXcp_TriggerTransmit_NegRes</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_TriggerTransmit/source/application/EbTest.c.m4</sourcefile>
      <sourceline>1040</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Verify XcpR trigger transmit functionality when TriggerTransmit returns E_NOT_OK.
      * MASTER NETWORK: PM_Tst_Master_Bus_Type
      * LOCAL SLAVE NETWORK: PM_Tst_Slave_Bus_Type
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    XcpRTxDestinationPduSupportForCddTriggerTransmit (to the master Xcp) is enabled.
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a CONNECT command with MODE = 0 on PM_Tst_Master_Bus_Type ( XcpR_RxIndication() is
        called and command 0xFF, MODE = 0).
    03. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_0): Verify that the XcpR calls the indication
        interface of the upper layer (e.g Xcp_CddRxIndication is called and the XCP package is the
        same with the one received).
    04. Simulate a positive response from the Xcp on local ECU (Xcp calls XcpR_Transmit
        with a CONNECT positive response).
    05. VP(XcpR.Impl.TriggerTransmit.UpperLayer): Verify that the XcpR calls the trigger transmit interface of the upper layer.
    06. VP(XcpR.Impl.TxConfirmation.UpperLayer): Verify that the XcpR did not call the confirmation interface
        of the upper layer because positive response message from local Xcp was not successfully stored in the XcpR internal queue.
    07. Simulate reception of a package consisting in command different than CONNECT command
        on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called when no connection is established).
    08. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the connection with the Slave is NOT established yet.
    09. Simulate again a positive response from the Xcp on local ECU. The Tst_XcpRSimulateResponseFromLocalXcp is called again because Xcp
        does not discard the package when the TriggerTransmit returns E_NOT_OK..
    10. VP(XcpR.Impl.TxConfirmation.UpperLayer): Verify that the XcpR calls the confirmation
        interface of the upper layer (Xcp_CddTxConfirmation is called with the correct pdu id).
    11. VP(XcpR.Impl.TriggerTransmit.UpperLayer): Verify that the XcpR calls the trigger transmit interface of the upper layer.
    12. Transmit data using the trigger transmit.
    13. VP(XcpR.Impl.CheckStatusConnection): Verify that the XcpR calls the transmit interface of the lower
        received from the local slave Xcp but header is adapted).
    14. Simulate confirming the response after PM_Tst_Master_Bus_Type\-::-/Transmit() was processed from step 04.
    15. Simulate reception, on PM_Tst_Master_Bus_Type bus, of a package consisting in command different than CONNECT command.
    16. VP (XcpR.Impl.TransmissionOfConsecutiveMessages) Verify that the command is routed to the Xcp instance on
        the local ECU (Xcp_CddRxIndication is called and the XCP package is the same with the one received from XCP
        but header is adapted).
    17. Simulate that XCP responses, on CDD bus, with a positive response (Xcp calls XcpR_Transmit
        with GET_STATUS positive response).
    18. VP(XcpR.Impl.TriggerTransmit.UpperLayer): Verify that the XcpR calls the trigger transmit interface of the upper layer.
    19. VP(XcpR.Impl.TxConfirmation.UpperLayer): Verify that the XcpR did not call the confirmation interface
        of the upper layer because positive response message from local Xcp was not successfully stored in the XcpR internal queue.
    20. Simulate that XCP responses, on CDD bus, with a positive response (Xcp calls XcpR_Transmit
        with GET_STATUS positive response).
    21. VP(XcpR.Impl.TxConfirmation.UpperLayer): Verify that the XcpR calls the confirmation
        interface of the upper layer (Xcp_CddTxConfirmation is called with the correct pdu id).
    22. VP(XcpR.Impl.TriggerTransmit.UpperLayer): Verify that the XcpR calls the trigger transmit interface of the upper layer.
    23. Transmit data using the trigger transmit.
    24. VP(XcpR.Impl.TransmissionOfConsecutiveMessages): Verify that the XcpR calls the transmit interface of the lower layer
        (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called once and only GET_STATUS positive response is forward to Xcp master).
    25. Simulate confirming the response after PM_Tst_Master_Bus_Type\-::-/Transmit() was processed from step 20.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.CddLocalConnectionsOnly</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>149</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_0</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>122</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.AdaptBusInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>147</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TxConfirmation.UpperLayer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>160</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>562</internalId></specobject>
    <specobject>
      <id>TS_XCPR_SwitchLocalXcpToRemoteXcp_TriggerTransmit</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_TriggerTransmit/source/application/EbTest.c.m4</sourcefile>
      <sourceline>1338</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
     Verify that XcpR can connect with the remote Xcp slave after disconnecting from the local
     Xcp slave when trigger transmit functionality is enabled.
      * MASTER NETWORK: PM_Tst_Master_Bus_Type
      * LOCAL SLAVE NETWORK: CDD
      * REMOTE SLAVE NETWORK: PM_Tst_Slave_Bus_Type
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    MASTER NETWORK:
      TriggerTransmit functionality enabled.
    REMOTE SLAVE NETWORK:
      TriggerTransmit functionality enabled.
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception, on PM_Tst_Master_Bus_Type bus, of a package consisting in command different than CONNECT command.
    03. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the Slave is DISCONNECTED.
    04. Simulate reception of a CONNECT command with MODE = 0 on PM_Tst_Master_Bus_Type ( XcpR_RxIndication() is
        called and command 0xFF, MODE = 0).
    05. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_0): Verify that the XcpR calls the indication interface of the upper layer
        (e.g Xcp_CddRxIndication is called and the XCP package is the same with the one received).
    06. Simulate a positive response from the Xcp on local ECU (Xcp calls XcpR_Transmit
        with CONNECT positive response).
    07. VP(XcpR.Impl.TxConfirmation.UpperLayer): Verify that the XcpR calls the confirmation
        interface of the upper layer (Xcp_CddTxConfirmation is called with the correct pdu id).
    08. VP(XcpR.Impl.TriggerTransmit.UpperLayer): Verify that the XcpR calls the trigger transmit interface of the upper layer.
    09. Transmit data using the trigger transmit.
    10. VP(XcpR.Impl.CheckStatusConnection): Verify that the XcpR calls the transmit interface of the lower layer
        (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the master Xcp package is the same with the one received
        from the local slave Xcp but header is adapted).
    11. Simulate confirming the response after PM_Tst_Master_Bus_Type\-::-/Transmit() was processed from step 06.
    12. Simulate reception of a package consisting in a DISCONNECT command.
    13. VP(XcpR.Impl.TransmissionOfConsecutiveMessages): Verify that the command is routed to the XCP instance
        on the remote ECU (Cdd_Transmit is called and the XCP package is the same with the one received from
        XCP but header is adapted).
    14. Simulate that XCP responses with a positive response (XcpR_RxIndication is called and
        data equals to DISCONNECT negative response).
    15. VP(XcpR.Impl.TxConfirmation.UpperLayer): Verify that the XcpR calls the confirmation
        interface of the upper layer (Xcp_CddTxConfirmation is called with the correct pdu id).
    16. VP(XcpR.Impl.TriggerTransmit.UpperLayer): Verify that the XcpR calls the trigger transmit interface of the upper layer.
    17. Transmit data using the trigger transmit.
    18. VP(XcpR.dsn.NegativeResponseDisconnect.DetOn.ErrorCodePduLost) Verify that the XcpR calls the transmit interface
        of the lower layer (PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package is the same with the one received
        from XCP but header is adapted).
    19. Simulate confirming the response after PM_Tst_Master_Bus_Type\-::-/Transmit() was processed from step 14.
    20. Simulate reception of a package consisting in a DISCONNECT command.
    21. VP(XcpR.Impl.TransmissionOfConsecutiveMessages): Verify that the command is routed to the XCP instance
        on the remote ECU (Cdd_Transmit is called and the XCP package is the same with the one received from
        XCP but header is adapted).
    22. Simulate that XCP responses with a positive response (XcpR_Transmit and
        data equals DISCONNECT positive response).
    23. VP(XcpR.Impl.TxConfirmation.UpperLayer): Verify that the XcpR calls the confirmation
        interface of the upper layer (Xcp_CddTxConfirmation is called with the correct pdu id).
    24. VP(XcpR.Impl.TriggerTransmit.UpperLayer): Verify that the XcpR calls the trigger transmit interface of the upper layer.
    25. Transmit data using the trigger transmit.
    26. VP(XcpR.Impl.TransmissionOfConsecutiveMessages): Verify that the XcpR calls the transmit interface of the lower layer
        (PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package is the same with the one received from XCP but
        header is adapted).
    27. Simulate confirming the response after PM_Tst_Master_Bus_Type\-::-/Transmit() was processed from step 22.
    28. Simulate reception of a CONNECT command with MODE = 1 on PM_Tst_Master_Bus_Type (XcpR_RxIndication()
        is called and command 0xFF, MODE = 1).
    29. Transmit data using the trigger transmit.
    30. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode): Check that the
        XcpR calls the transmit interface of the lower layer (e.g PM_Tst_Slave_Bus_Type\-::-/Transmit is called
        and the XCP package is the same with the one received from XCP).
    31. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    32. Transmit data using the trigger transmit.
    33. VP(XcpR.Impl.CheckStatusConnection): Verify that the XcpR calls the transmit interface of the lower layer
        (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package is the same with the one received from
        XCP but header is adapted).
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Enabled.TwoDestinationPDUs</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>125</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CddLocalConnectionsOnly</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>149</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.BusTypesRemoteConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_0</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>122</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TxConfirmation.UpperLayer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>160</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TriggerTransmit.UpperLayer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>161</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.NegativeResponseDisconnect.DetOn.ErrorCodePduLost</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>421</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.Communication.FlexRay.DecoupledAccess</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>138</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.Communication.CDD.DecoupledAccess</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>140</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>563</internalId></specobject>
    <specobject>
      <id>TS_XCPR_TriggerTransmit_TxRetries_MessageCmd</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_TriggerTransmit/source/application/EbTest.c.m4</sourcefile>
      <sourceline>1717</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Verify Tx bus retries functionality on internal BUS. XcpR remains in connected state
      and can send messsages after the internal BUS is running again.
      * Xcp Master over PM_Tst_Master_Bus_Type
      * Remote Xcp Slave over PM_Tst_Slave_Bus_Type
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    MASTER NETWORK:
      TriggerTransmit functionality enabled.
    REMOTE SLAVE NETWORK:
      TriggerTransmit functionality enabled.
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a package consisting in command different than CONNECT command
        on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called when no connection is established).
    03. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the Slave is DISCONNECTED.
    04. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    05. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because no connection is established.
    06. Simulate reception of a CONNECT command with MODE = 1 on PM_Tst_Master_Bus_Type (XcpR_RxIndication()
        is called and command 0xFF, MODE = 1).
    07. Transmit data using the trigger transmit.
    08. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode): Check that the
        XcpR calls the transmit interface of the lower layer (e.g PM_Tst_Slave_Bus_Type\-::-/Transmit is called
        and the XCP package is the same with the one received from XCP).
    09. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    10. Transmit data using the trigger transmit.
    11. VP(XcpR.Impl.CheckStatusConnection): Verify that the XcpR calls the transmit interface of the lower
        layer (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package is the same with the one received
        from XCP but header is adapted).
    12. Simulate reception of a package consisting in command different than CONNECT command
        on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called).
    13. Loop until bus retry count.
        Call XcpR_MainFunction in order to make the retries.
        14. Verify that the transmission is not succeed.
m4_ifelse(PM_Permutation,CddToCddDetRuntimeOff,\-:m4_dnl
    15. Check that XcpR does not store a Det runtime error if XcpRDetRuntimeChecks is set to false.
:-/,m4_ifelse( :else: )\-:
    15. VP(XcpR.dsn.TxRetry.RuntimeError.MasterToSlave): Check that XcpR throws the runtime error XCPR_E_INTERNAL_BUS.
:-/m4_ifelse( :endif: ))
    16. Simulate reception, on PM_Tst_Master_Bus_Type bus, of the first package (GET_STATUS command)
        to be sent from Xcp master to Xcp slave.
    17. Transmit data using the trigger transmit.
    18. VP (XcpR.Impl.TransmissionOfConsecutiveMessages) Verify that the command is routed to the XCP instance on
        the remote ECU (PM_Tst_Slave_Bus_Type\-::-/Transmit is called and the XCP package is the same with the one
        received from XCP but header is adapted).
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.RuntimeErrors</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>143</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.AdaptBusInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>147</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.TxRetry.RuntimeError.MasterToSlave</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>468</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.TxRetry.DiscardMessage</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>467</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.Transmission.DetOn.ErrorCodeExternalBus</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>453</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>564</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_XCPR_TriggerTransmit_RemoteXcpSlave</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_TriggerTransmit_RemoteXcpSlave/source/application/EbTest.c.m4</sourcefile>
      <sourceline>41</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Test trigger transmit functionality on remote Xcp slave. Check if messages are forwarded using
      trigger transmit to the Xcp Slave on the remote ECU only if the connection is established
      through a CONNECT command.
      * MASTER NETWORK: PM_Tst_Master_Bus_Type
      * REMOTE SLAVE NETWORK: PM_Tst_Slave_Bus_Type
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    REMOTE SLAVE NETWORK:
      TriggerTransmit functionality enabled.
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a package consisting in command different than CONNECT command
        command.
    03. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the Slave is DISCONNECTED.
    04. Simulate reception of a CONNECT command with MODE = 1 on PM_Tst_Master_Bus_Type (XcpR_RxIndication()
        is called and command 0xFF, MODE = 1).
    05. Verify that trying to transmit data using the trigger transmit functionality with a wrong pdu id has no effect.
    06. Transmit data using the trigger transmit.
    07. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode): Check that the
        XcpR calls the transmit interface of the lower layer (e.g PM_Tst_Slave_Bus_Type\-::-/Transmit is called
        and the XCP package is the same with the one received from XCP).
    08. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    09. VP(XcpR.Impl.CheckStatusConnection): Verify that the XcpR calls the transmit interface of the lower
        layer (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package is the same with the one received
        from XCP but header is adapted).
    10. Simulate reception, on PM_Tst_Master_Bus_Type bus, of the first package (GET_STATUS command)
        to be sent from Xcp master to Xcp slave.
    11. Transmit data using the trigger transmit.
    12. VP(XcpR.Impl.TransmissionOfConsecutiveMessages) Verify that the command is routed to the XCP instance
        on the remote ECU (PM_Tst_Slave_Bus_Type\-::-/Transmit is called and the XCP package is the same with the one
        received from XCP but header is adapted).
    13. Simulate that XCP responses with a positive response (XcpR_RxIndication is called
        and data equals to a GET_STATUS positive response).
    14. VP(XcpR.Impl.TransmissionOfConsecutiveMessages): Verify that the XcpR calls the transmit interface of the lower layer
        (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package is the same
        with the one received from XCP).
    15. Set the result as success.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Disabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>124</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.BusTypesRemoteConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>565</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_XCPR_TxBusRetries_MasterNoTxConf_LocalXcp</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_TxBusRetry/source/application/EbTest.c.m4</sourcefile>
      <sourceline>78</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Verify the XcpR BusMonitor functionality when a TxConfirmation from the master Xcp is not received.
      * Xcp Master over PM_Tst_Master_Bus_Type
      * Local Xcp Slave over Cdd
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a package consisting in command different than CONNECT command
        on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called) when no connection is established.
    03. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the slave is DISCONNECTED.
    04. Simulate reception of a CONNECT command with MODE = 0 on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is
        called and command 0xFF, MODE = 0).
    05. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_0): Verify that the XcpR calls the indication interface of the upper layer
        (e.g Xcp_CddRxIndication is called and the XCP package is the same with the one received).
    06. Simulate a positive response from the Xcp on local ECU (Xcp calls XcpR_Transmit
        with a CONNECT positive response).
    07. VP(XcpR.Impl.TxConfirmation.UpperLayer): Verify that the XcpR calls the confirmation interface
        of the upper layer (e.g Xcp_CddTxConfirmation is called with the correct pdu id).
    08. VP(XcpR.Impl.CheckStatusConnection): Verify that the XcpR calls the transmit interface of the lower layer
        (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package is the same with the one received
        from XCP  but header is adapted).
    09. Simulate reception of a package consisting in command different than CONNECT command
        on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called) when the connection is established.
    10. VP(XcpR.Impl.TransmissionOfConsecutiveMessages) Verify that the command is routed to the Xcp instance
        on the local ECU (Xcp_CddRxIndication is called and the XCP package is the same with the one received from
        XCP but header is adapted).
    11. Simulate that local XCP responses with a positive response (XcpR_Transmit is called
        and data equals to GET_STATUS positive response).
    12. PM_Tst_Master_Bus_Type\-::-/Trasmit shall be called only once .
    13. Loop until number of times the data will be retried for transmission when no confirmation is received.
        14. Loop until a timeout occurs.
            Call XcpR_MainFunction in order to make the retries.
            No TxConfirmation is received.
    15. Perform the last bus timeout so that the bus retry count reaches the max allowed by the configuration.
    16. Verify that no TxConfirmation is received.
    17. Call an extra main function - now the EV_SESSION_TERMINATED should be sent.
    18. VP(XcpR.dsn.BusMonitor.SendSessionTerminatedEvent): Verify the session terminated
        event was sent (XcpR calls the transmit interface of the lower layer
        (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called).
    19. Simulate reception of a package consisting in command different than CONNECT command
        on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called) when no connection is established.
    20. VP(XcpR.dsn.BusMonitor.DisconnectAfterFailedRetries): Received package is ignored without any action
        because the slave is DISCONNECTED.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.CddLocalConnectionsOnly</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>149</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_0</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>122</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TxConfirmation.UpperLayer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>160</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.BusMonitor.SendSessionTerminatedEvent</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>405</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.BusMonitor.DisconnectAfterFailedRetries</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>401</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.BusMonitor.RetryTransmission</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>403</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.BusMonitor.RuntimeError.DisconnectAfterFailedRetries</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>404</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>566</internalId></specobject>
    <specobject>
      <id>TS_XCPR_TxBusRetries_MasterENotOkTxConf_LocalXcp</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_TxBusRetry/source/application/EbTest.c.m4</sourcefile>
      <sourceline>352</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Verify the XcpR BusMonitor functionality when a TxConfirmation from the master Xcp is received with E_NOT_OK.
      * Xcp Master over PM_Tst_Master_Bus_Type
      * Local Xcp Slave over Cdd
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a package consisting in command different than CONNECT command
        on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called) when no connection is established.
    03. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the slave is DISCONNECTED.
    04. Simulate reception of a CONNECT command with MODE = 0 on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is
        called and command 0xFF, MODE = 0).
    05. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_0): Verify that the XcpR calls the indication interface of the upper layer
        (e.g Xcp_CddRxIndication is called and the XCP package is the same with the one received).
    06. Simulate a positive response from the Xcp on local ECU (Xcp calls XcpR_Transmit
        with a CONNECT positive response).
    07. VP(XcpR.Impl.TxConfirmation.UpperLayer): Verify that the XcpR calls the confirmation interface
        of the upper layer (e.g Xcp_CddTxConfirmation is called with the correct pdu id).
    08. VP(XcpR.Impl.CheckStatusConnection): Verify that the XcpR calls the transmit interface of the lower layer
        (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package is the same with the one received
        from XCP  but header is adapted).
    09. Simulate reception of a package consisting in command different than CONNECT command
        on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called) when the connection is established.
    10. VP(XcpR.Impl.TransmissionOfConsecutiveMessages) Verify that the command is routed to the Xcp instance
        on the local ECU (Xcp_CddRxIndication is called and the XCP package is the same with the one received from
        XCP but header is adapted).
    11. Simulate that local XCP responses with a positive response (XcpR_Transmit is called
        and data equals to GET_STATUS positive response).
    12. PM_Tst_Master_Bus_Type\-::-/Trasmit shall be called only once .
    13. Loop until number of times the data will be retried for transmission when no E_OK confirmation is received.
        14. Loop until a timeout occurs.
            Call XcpR_MainFunction in order to make the retries.
            Simulate confirming the response after PM_Tst_Master_Bus_Type\-::-/Transmit() was processed from step 11 but with E_NOT_OK result.
    15. Perform the last bus timeout so that the bus retry count reaches the max allowed by the configuration.
    16. Call an extra main function - now the EV_SESSION_TERMINATED should be sent.
    17. VP(XcpR.dsn.BusMonitor.SendSessionTerminatedEvent): Verify the session terminated
        event was sent (XcpR calls the transmit interface of the lower layer
        (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called).
    18. Simulate reception of a package consisting in command different than CONNECT command
        on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called) when no connection is established.
    19. VP(XcpR.dsn.BusMonitor.DisconnectAfterFailedRetries): Received package is ignored without any action
        because the slave is DISCONNECTED.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.TxConfirmation.E_NOT_OK</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>197</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CddLocalConnectionsOnly</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>149</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TxConfirmation.UpperLayer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>160</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.BusMonitor.SendSessionTerminatedEvent</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>405</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.BusMonitor.DisconnectAfterFailedRetries</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>401</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.BusMonitor.RetryTransmission</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>403</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.BusMonitor.RuntimeError.DisconnectAfterFailedRetries</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>404</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>567</internalId></specobject>
    <specobject>
      <id>TS_XCPR_TxBusRetries_MasterNoTxConf_RemoteXcp</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_TxBusRetry/source/application/EbTest.c.m4</sourcefile>
      <sourceline>623</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Verify the XcpR BusMonitor functionality when a TxConfirmation from the master Xcp is not received.
      * Xcp Master over PM_Tst_Master_Bus_Type
      * Remote Xcp Slave over PM_Tst_Slave_Bus_Type
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a package consisting in command different than CONNECT command
        on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called) when no connection is established.
    03. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the slave is DISCONNECTED.
    04. Simulate reception of a CONNECT command with MODE = 1 on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called
        and command 0xFF, MODE = 1).
    05. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode): Check that the
        XcpR calls the transmit interface of the lower layer (e.g PM_Tst_Slave_Bus_Type\-::-/Transmit is called
        and the XCP package is the same with the one received from XCP).
    06. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    07. VP(XcpR.Impl.CheckStatusConnection): Verify that the XcpR calls the transmit interface of the lower layer
        (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package is the same with the one received from XCP).
    08. Simulate reception of a package consisting in command different than CONNECT command
        on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called) when the connection is established.
    09. VP (XcpR.Impl.TransmissionOfConsecutiveMessages) Verify that the first command is routed to the XCP instance
        on the remote ECU (PM_Tst_Slave_Bus_Type\-::-/Transmit is called and the XCP package is the same with the one
        received from XCP but header is adapted) and the second package is ignored.
    10. Simulate that XCP responses with a positive response (XcpR_RxIndication is called
        and data equals to GET_STATUS positive response).
    11. VP: PM_Tst_Master_Bus_Type\-::-/Trasmit shall be called only once .
    12. Loop until number of times the data will be retried for transmission when no confirmation is received.
        13. Loop until a timeout occurs.
            Call XcpR_MainFunction in order to make the retries.
            No TxConfirmation is received.
    14. Perform the last bus timeout so that the bus retry count reaches the max allowed by the configuration.
        Call XcpR_MainFunction in order to make the retries.
        No TxConfirmation is received.
m4_ifelse(PM_Permutation,EthTcpToFrDetRuntimeOff,\-:m4_dnl
   15. Check that XcpR does not store a Det runtime error if XcpRDetRuntimeChecks is set to false.
:-/,m4_ifelse( :else: )\-:
   15. VP(XcpR.dsn.BusMonitor.DetOn.ErrorCodeNoTxExternalBus): Check that XcpR throws the runtime
        error XCPR_E_NO_TX_EXTERNAL_BUS because a TxConfirmation from the master Xcp is not received.
:-/m4_ifelse( :endif: ))
    16. VP(XcpR.dsn.BusMonitor.SendSessionTerminatedEvent): Verify the session terminated
        event was sent (XcpR calls the transmit interface of the lower layer,
        e.g CanIf_Transmit is called).
    17. VP (XcpR.dsn.BusMonitor.SendSessionTerminatedEvent, XcpR.dsn.BusMonitor.DisconnectAfterFailedRetries):
        Verify that the command is routed to  the XCP instance on the remote ECU (PM_Tst_Slave_Bus_Type\-::-/Transmit
        is called and the XCP package is the same with the one received from XCP but header is adapted).
    18. Simulate reception of a package consisting in command from Xcp Master
    19. Simulate that XCP responses with a positive response (XcpR_RxIndication is called and
        data equals to DISCONNECT positive response).
    20. Verify that the response is not forwared to Xcp master.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.BusTypesRemoteConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.BusMonitor.DetOn.ErrorCodeNoTxExternalBus</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>399</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.BusMonitor.SendSessionTerminatedEvent</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>405</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.BusMonitor.DisconnectAfterFailedRetries</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>401</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.BusMonitor.RetryTransmission</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>403</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.BusMonitor.RuntimeError.DisconnectAfterFailedRetries</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>404</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.BusMonitor.TriggerAutonomousDisconnect</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>406</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>568</internalId></specobject>
    <specobject>
      <id>TS_XCPR_TxBusRetries_MasterENotOkTxConf_RemoteXcp</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_TxBusRetry/source/application/EbTest.c.m4</sourcefile>
      <sourceline>913</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Verify the XcpR BusMonitor functionality when a TxConfirmation from the master Xcp is not received.
      * Xcp Master over PM_Tst_Master_Bus_Type
      * Remote Xcp Slave over PM_Tst_Slave_Bus_Type
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a package consisting in command different than CONNECT command
        on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called) when no connection is established.
    03. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the slave is DISCONNECTED.
    04. Simulate reception of a CONNECT command with MODE = 1 on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called
        and command 0xFF, MODE = 1).
    05. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode): Check that the
        XcpR calls the transmit interface of the lower layer (e.g PM_Tst_Slave_Bus_Type\-::-/Transmit is called
        and the XCP package is the same with the one received from XCP).
    06. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    07. VP(XcpR.Impl.CheckStatusConnection): Verify that the XcpR calls the transmit interface of the lower layer
        (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package is the same with the one received from XCP).
    08. Simulate reception of a package consisting in command different than CONNECT command
        on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called) when the connection is established.
    09. VP (XcpR.Impl.TransmissionOfConsecutiveMessages) Verify that the first command is routed to the XCP instance
        on the remote ECU (PM_Tst_Slave_Bus_Type\-::-/Transmit is called and the XCP package is the same with the one
        received from XCP but header is adapted) and the second package is ignored.
    10. Simulate that XCP responses with a positive response (XcpR_RxIndication is called
        and data equals to GET_STATUS positive response).
    11. VP: PM_Tst_Master_Bus_Type\-::-/Trasmit shall be called only once .
    12. Loop until number of times the data will be retried for transmission when no E_OK confirmation is received.
        13. Loop until a timeout occurs.
            Call XcpR_MainFunction in order to make the retries.
            Simulate TxConfirmation after PM_Tst_Slave_Bus_Type\-::-/Transmit() was processed but with E_NOT_OK result
    14. Perform the last bus timeout so that the bus retry count reaches the max allowed by the configuration.
        Call XcpR_MainFunction in order to make the retries.
        Simulate TxConfirmation after PM_Tst_Slave_Bus_Type\-::-/Transmit() was processed but with E_NOT_OK result
m4_ifelse(PM_Permutation,EthTcpToFrDetRuntimeOff,\-:m4_dnl
   15. Check that XcpR does not store a Det runtime error if XcpRDetRuntimeChecks is set to false.
:-/,m4_ifelse( :else: )\-:
   15. VP(XcpR.dsn.BusMonitor.DetOn.ErrorCodeNoTxExternalBus): Check that XcpR throws the runtime
        error XCPR_E_NO_TX_EXTERNAL_BUS because a TxConfirmation from the master Xcp is not received.
:-/m4_ifelse( :endif: ))
    16. VP(XcpR.dsn.BusMonitor.SendSessionTerminatedEvent): Verify the session terminated
        event was sent (XcpR calls the transmit interface of the lower layer,
        e.g CanIf_Transmit is called).
    17. VP (XcpR.dsn.BusMonitor.SendSessionTerminatedEvent, XcpR.dsn.BusMonitor.DisconnectAfterFailedRetries):
        Verify that the command is routed to  the XCP instance on the remote ECU (PM_Tst_Slave_Bus_Type\-::-/Transmit
        is called and the XCP package is the same with the one received from XCP but header is adapted).
    18. Simulate reception of a package consisting in command from Xcp Master
    19. Simulate that XCP responses with a positive response (XcpR_RxIndication is called and
        data equals to DISCONNECT positive response).
    20. Verify that the response is not forwared to Xcp master.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.TxConfirmation.E_NOT_OK</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>197</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.BusTypesRemoteConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.BusMonitor.DetOn.ErrorCodeNoTxExternalBus</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>399</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.BusMonitor.SendSessionTerminatedEvent</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>405</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.BusMonitor.DisconnectAfterFailedRetries</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>401</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.BusMonitor.RetryTransmission</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>403</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.BusMonitor.RuntimeError.DisconnectAfterFailedRetries</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>404</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.BusMonitor.TriggerAutonomousDisconnect</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>406</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>569</internalId></specobject>
    <specobject>
      <id>TS_XCPR_TxBusRetries_MasterNoTxConfConnect_RemoteXcp</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_TxBusRetry/source/application/EbTest.c.m4</sourcefile>
      <sourceline>1206</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Verify the XcpR BusMonitor functionality when a TxConfirmation from the master Xcp is not received
      when a positive response for a Connect Command.
      * Xcp Master over PM_Tst_Master_Bus_Type
      * Remote Xcp Slave over PM_Tst_Slave_Bus_Type
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    01. Initialize stubs and XcpR
    02. Simulate reception of a CONNECT command with MODE = 0 (XcpR_RxIndication() is
        called and command 0xFF, MODE = 0)
    03. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_0): Verify that the XcpR calls the indication interface of the upper layer
    04. Simulate a positive response from the Xcp on local ECU (Xcp calls XcpR_Transmit
        with a CONNECT positive response)
    05. VP(XcpR.Impl.CheckStatusConnection): Verify that the XcpR calls the transmit interface of the lower layer
    06. Loop until number of times the data will be retried for transmission when no confirmation is received
    07. Loop until a timeout occurs
    08. Perform the last bus timeout so that the bus retry count reaches the max allowed by the configuration
m4_ifelse(PM_Permutation,EthTcpToFrDetRuntimeOff,\-:m4_dnl
    09. Check that XcpR does not store a Det runtime error if XcpRDetRuntimeChecks is set to false.
:-/,m4_ifelse( :else: )\-:
    09. VP(XcpR.dsn.BusMonitor.DetOn.ErrorCodeNoTxExternalBus): Check that XcpR throws the runtime
        error XCPR_E_NO_TX_EXTERNAL_BUS because a TxConfirmation from the master Xcp is not received
:-/m4_ifelse( :endif: ))
    10. VP(XcpR.dsn.BusMonitor.SendSessionTerminatedEvent): Verify the session terminated
        event was sent (XcpR calls the transmit interface of the lower layer
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.RuntimeErrors</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>143</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.BusMonitor.DetOn.ErrorCodeNoTxExternalBus</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>399</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.BusMonitor.SendSessionTerminatedEvent</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>405</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.BusMonitor.DisconnectAfterFailedRetries</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>401</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.BusMonitor.RetryTransmission</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>403</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.BusMonitor.RuntimeError.DisconnectAfterFailedRetries</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>404</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.BusMonitor.TriggerAutonomousDisconnect</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>406</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>570</internalId></specobject>
    <specobject>
      <id>TS_XCPR_TxBusRetries_MessageCmd_RemoteXcpNoTxConf</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_TxBusRetry/source/application/EbTest.c.m4</sourcefile>
      <sourceline>1369</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Verify the XcpR BusMonitor functionality when a TxConfirmation from the remote Xcp is not received.
      * Xcp Master over PM_Tst_Master_Bus_Type
      * Remote Xcp Slave over PM_Tst_Slave_Bus_Type
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a package consisting in command different than CONNECT command
        on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called) when no connection is established.
    03. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the slave is DISCONNECTED.
    04. Simulate reception of a CONNECT command with MODE = 1 on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called
        and command 0xFF, MODE = 1).
    05. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode): Check that the
        XcpR calls the transmit interface of the lower layer (e.g PM_Tst_Slave_Bus_Type\-::-/Transmit is called
        and the XCP package is the same with the one received from XCP).
    06. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    07. VP(XcpR.Impl.CheckStatusConnection): Verify that the XcpR calls the transmit interface of the lower layer
        (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package is the same with the one received
        from XCP).
    08. Simulate reception of a package consisting in command different than CONNECT command
        on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called) when the connection is established.
    09. VP: PM_Tst_Master_Bus_Type\-::-/Trasmit shall be called only once .
    10. Loop until number of times the data will be retried for transmission when no confirmation is received.
        11. Loop until a timeout occurs.
            Call XcpR_MainFunction in order to make the retries.
            No TxConfirmation is received.
    12. Perform the last bus timeout so that the bus retry count reaches the max allowed by the configuration.
        Call XcpR_MainFunction in order to make the retries.
        No TxConfirmation is received.
m4_ifelse(PM_Permutation,EthTcpToFrDetRuntimeOff,\-:m4_dnl
    13. Check that XcpR does not store a Det runtime error if XcpRDetRuntimeChecks is set to false.
:-/,m4_ifelse( :else: )\-:
    13. VP(XcpR.dsn.BusMonitor.DetOn.ErrorCodeNoTxInternalBus): Check that XcpR throws the runtime
        error XCPR_E_NO_TX_INTERNAL_BUS because a TxConfirmation from the remote slave Xcp is not received.
:-/m4_ifelse( :endif: ))
    14. Simulate reception of a package consisting in command different than CONNECT command
        on CanIf (XcpR_RxIndication() is called) when no connection is established.
    15. VP (XcpR.Impl.TransmissionOfConsecutiveMessages) Verify that the first command is routed to the
        XCP instance on the remote ECU (PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package is the
        same with the one received from XCP but header is adapted) and the second package is ignored.
    16. Simulate that XCP responses with a positive response (XcpR_RxIndication is called
        and data equals to GET_STATUS positive response).
    17. VP(XcpR.Impl.TransmissionOfConsecutiveMessages, XcpR.Impl.AdaptBusInfo): Verify that the XcpR
        calls the transmit interface of the lower layer (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and
        the XCP package is the same with the one received from XCP).
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.RuntimeErrors</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>143</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.BusTypesRemoteConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.BusMonitor.DetOn.ErrorCodeNoTxInternalBus</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>400</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.AdaptBusInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>147</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.BusMonitor.RetryTransmission</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>403</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.BusMonitor.RuntimeError.DisconnectAfterFailedRetries</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>404</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>571</internalId></specobject>
    <specobject>
      <id>TS_XCPR_TxBusRetries_ConnectCmd_RemoteXcpNoTxConf</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_TxBusRetry/source/application/EbTest.c.m4</sourcefile>
      <sourceline>1621</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Verify the XcpR BusMonitor functionality when a TxConfirmation from the remote Xcp
      is not received to a CONNECT command.
      * Xcp Master over PM_Tst_Master_Bus_Type
      * Remote Xcp Slave over PM_Tst_Slave_Bus_Type
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a package consisting in command different than CONNECT command
        on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called) when no connection is established.
    03. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the slave is DISCONNECTED.
    04. Simulate reception of a CONNECT command with MODE = 1 on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called
        and command 0xFF, MODE = 1).
    05. VP: PM_Tst_Master_Bus_Type\-::-/Trasmit shall be called only once .
    06. Loop until number of times the data will be retried for transmission when no confirmation is received.
        07. Loop until a timeout occurs.
            No TxConfirmation is received. 
    08. Perform the last bus timeout so that the bus retry count reaches the max allowed by the configuration.
          No TxConfirmation is received.
m4_ifelse(PM_Permutation,EthTcpToFrDetRuntimeOff,\-:m4_dnl
    13. Check that XcpR does not store a Det runtime error if XcpRDetRuntimeChecks is set to false.
:-/,m4_ifelse( :else: )\-:
    13. VP(XcpR.dsn.BusMonitor.DetOn.ErrorCodeNoTxInternalBus): Check that XcpR throws the runtime
        error XCPR_E_NO_TX_INTERNAL_BUS because a TxConfirmation from the remote slave Xcp is not received.
:-/m4_ifelse( :endif: ))
    14. Simulate reception of a package consisting in command different than CONNECT command
        on CanIf (XcpR_RxIndication() is called) when no connection is established.
    14. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
             because the slave is DISCONNECTED.
    15. Simulate reception of a CONNECT command with MODE = 1 on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called
        and command 0xFF, MODE = 1).
    16. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode): Check that the
        XcpR calls the transmit interface of the lower layer (e.g PM_Tst_Slave_Bus_Type\-::-/Transmit is called
        and the XCP package is the same with the one received from XCP).
    17. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    18. VP(XcpR.Impl.CheckStatusConnection): Verify that the XcpR calls the transmit interface of the lower layer
        (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package is the same with the one received from XCP).
    19. Simulate reception of a package consisting in command different than CONNECT command
        on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called) when no connection is established.
    20. VP (XcpR.Impl.TransmissionOfConsecutiveMessages) Verify that the first command is routed to the XCP instance
        on the remote ECU (PM_Tst_Slave_Bus_Type\-::-/Transmit is called and the XCP package is the same with the one
        received from XCP but header is adapted) and the second package is ignored.
        Set the result as success.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.BusMonitor.DetOn.ErrorCodeNoTxInternalBus</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>400</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>572</internalId></specobject>
    <specobject>
      <id>TS_XCPR_TxBusRetries_BeforeReachingDisconnectTriggerPoint</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_TxBusRetry/source/application/EbTest.c.m4</sourcefile>
      <sourceline>1859</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Verify the XcpR BusMonitor functionality when a TxConfirmation is received,
      from the remote Xcp slave, before reaching the disconnect trigger point.
      * Xcp Master over PM_Tst_Master_Bus_Type
      * Remote Xcp Slave over PM_Tst_Slave_Bus_Type
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a package consisting in command different than CONNECT command
        on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called) when no connection is established.
    03. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the slave is DISCONNECTED.
    04. Simulate reception of a CONNECT command with MODE = 1 on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called
        and command 0xFF, MODE = 1).
    05. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode): Check that the
        XcpR calls the transmit interface of the lower layer (e.g PM_Tst_Slave_Bus_Type\-::-/Transmit is called
        and the XCP package is the same with the one received from XCP).
    06. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    07. VP(XcpR.Impl.CheckStatusConnection): Verify that the XcpR calls the transmit interface of the lower layer
        (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package is the same with the one received from XCP).
    08. Simulate reception of a package consisting in command different than CONNECT command
        on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called) when the connection is established.
    09. VP (XcpR.Impl.TransmissionOfConsecutiveMessages) Verify that the XcpR calls the transmit
        interface of the lower layer (XCP package is the same with the one received).
    10. Loop until number of times the data will be retried for transmission when no confirmation is received.
        11. Loop until a timeout occurs.
            Call XcpR_MainFunction in order to make the retries.
            12. No TxConfirmation is received.
    13. Simulate confirming the package, before reaching the point of triggering disconnect, from step 08.
    14. Simulate that XCP responses with a positive response (XcpR_RxIndication is called
        and data equals to GET_STATUS positive response).
    15. VP(XcpR.Impl.TransmissionOfConsecutiveMessages, XcpR.Impl.AdaptBusInfo): Verify that the XcpR
        calls the transmit interface of the lower layer (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and
        the XCP package is the same with the one received from XCP).
    16. Simulate reception of a package consisting in command different than CONNECT command
        on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called).
    17. VP(XcpR.Impl.TransmissionOfConsecutiveMessages): Verify that the XcpR calls the transmit interface of
        the lower layer (e.g PM_Tst_Slave_Bus_Type\-::-/Transmit is called.
    18. Set the result as success.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.RuntimeErrors</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>143</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.BusTypesRemoteConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.AdaptBusInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>147</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>573</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_XCPR_TxRetries_ConnectPosRes_FromRemoteXcp</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_TxRetry/source/application/EbTest.c.m4</sourcefile>
      <sourceline>87</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Verify Tx bus retries functionality on external BUS when simulate
      a CONNECT positive response from remote Xcp slave.
      * Xcp Master over PM_Tst_Master_Bus_Type
      * Remote Xcp Slave over PM_Tst_Slave_Bus_Type
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    XcpRDetRuntimeChecks = PM_Tst_XcpRDetRuntimeChecks
    XcpREventPacketEnabled = PM_Tst_XcpREventPacketEnabled
    XcpRTxRetryCount = PM_Tst_XcpRTxRetryCount
    XcpRTxBusRetry = PM_Tst_XcpRTxBusRetry
    XcpRTxBusTimeout = PM_Tst_XcpRTxBusTimeout
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a package consisting in command different than CONNECT command
        on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called) when no connection is established.
    03. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the slave is DISCONNECTED.
    04. Simulate reception of a CONNECT command with MODE = 1 on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called
        and command 0xFF, MODE = 1).
    05. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode): Check that the
        XcpR calls the transmit interface of the lower layer (e.g PM_Tst_Slave_Bus_Type\-::-/Transmit is called
        and the XCP package is the same with the one received from XCP).
        Set return value of the PM_Tst_Master_Bus_Type\-::-/Transmit to E_NOT_OK.
    06. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    07. Loop until bus retry count.
        Call XcpR_MainFunction in order to make the retries.
        08. VP: Check that the message was not sent successfully.
m4_ifelse(PM_Tst_XcpRDetRuntimeChecks,false,\-:m4_dnl
    09. Check that XcpR does not store a Det runtime error if XcpRDetRuntimeChecks is set to false.
:-/,m4_ifelse( :else: )\-:
    09. VP(XcpR.dsn.TxRetry.RuntimeError.SlaveToMaster): Check that XcpR throws the runtime error XCPR_E_EXTERNAL_BUS.
:-/m4_ifelse( :endif: ))
m4_ifelse(m4_ifelse(PM_Permutation,EthTcpToFrSessionTerminatedOff,eq,ne),ne,\-:m4_dnl
    10. VP(XcpR.dsn.BusMonitor.SendSessionTerminatedEvent): Verify the session terminated
        event was sent (XcpR calls the transmit interface of the lower layer
        (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called).
:-/,m4_ifelse( :else: )\-:
    10. VP(XcpR.Config.XcpRGeneral.XcpREventPacketEnabled): Verify the session terminated
        event was NOT sent because transmission of EV_SESSION_TERMINATED events is disabled
        (XcpR does NOT call the transmit interface of the lower layer, e.g PM_Tst_Master_Bus_Type\-::-/Transmit is NOT called).
:-/m4_ifelse( :endif: ))
    11. VP (XcpR.dsn.TxRetry.SlaveToMaster.TriggerAutonomousDisconnect) Verify that the command is routed to
        the XCP instance on the remote ECU (PM_Tst_Slave_Bus_Type\-::-/Transmit is called and the XCP package is the same with the one
        received from XCP but header is adapted).
        Set return value of the PM_Tst_Master_Bus_Type\-::-/Transmit to E_OK.
    12. Simulate that XCP responses with a positive response (XcpR_RxIndication is called and
        data equals DISCONNECT positive response).
    13. Verify that the DISCONNECT response is not forwarded to Xcp master.
    14. Simulate reception of a package consisting in command different than CONNECT command
        on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called) when no connection is established.
    15. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the slave is DISCONNECTED.
    16. Simulate reception of a CONNECT command with MODE = 1 on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called
        and command 0xFF, MODE = 1).
    17. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode): Check that the
        XcpR calls the transmit interface of the lower layer (e.g PM_Tst_Slave_Bus_Type\-::-/Transmit is called
        and the XCP package is the same with the one received from XCP).
    18. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    19. VP(XcpR.Impl.CheckStatusConnection): Verify that the XcpR calls the transmit interface of the lower layer
        (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package is the same with the one received
        from XCP).
    20. Simulate reception of a package consisting in command different than CONNECT command
        on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called).
    21. VP (XcpR.Impl.TransmissionOfConsecutiveMessages) Verify that the first command is routed to the XCP
        instance on the remote ECU (PM_Tst_Slave_Bus_Type\-::-/Transmit is called and the XCP package is the same with
        the one received from XCP but header is adapted) and the second package is ignored.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.RuntimeErrors</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>143</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.BusTypesRemoteConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.TxRetry.RuntimeError.SlaveToMaster</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>469</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.BusMonitor.SendSessionTerminatedEvent</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>405</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.TxRetry.SlaveToMaster.TriggerAutonomousDisconnect</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>471</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.TxRetry.DiscardMessage</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>467</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.Transmission.DetOn.ErrorCodeExternalBus</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>453</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.PublicHeader</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>141</internalId></provcov>
        <provcov>
          <linksto>XcpR.Config.XcpRGeneral.XcpREventPacketEnabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>19</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>574</internalId></specobject>
    <specobject>
      <id>TS_XCPR_TxRetries_ConnectPosRes_FromLocalXcp</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_TxRetry/source/application/EbTest.c.m4</sourcefile>
      <sourceline>427</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Verify Tx bus retries functionality on external BUS when simulate
      a CONNECT positive response from local Xcp slave.
      * Xcp Master over PM_Tst_Master_Bus_Type
      * Local Xcp Slave over CDD
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    XcpRDetRuntimeChecks = PM_Tst_XcpRDetRuntimeChecks
    XcpREventPacketEnabled = PM_Tst_XcpREventPacketEnabled
    XcpRTxRetryCount = PM_Tst_XcpRTxRetryCount
    XcpRTxBusRetry = PM_Tst_XcpRTxBusRetry
    XcpRTxBusTimeout = PM_Tst_XcpRTxBusTimeout
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a package consisting in command different than CONNECT command
        on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called) when no connection is established.
    03. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the slave is DISCONNECTED.
    04. Simulate reception of a CONNECT command with MODE = 0 on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is
        called and command 0xFF, MODE = 0).
    05. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_0): Verify that the XcpR calls the indication interface of the upper layer
        (e.g Xcp_CddRxIndication is called and the XCP package is the same with the one received).
        Set return value of the PM_Tst_Master_Bus_Type\-::-/Transmit to E_NOT_OK.
    06. Simulate a positive response from the Xcp on local ECU (Xcp calls XcpR_Transmit
        with CONNECT positive response).
    07. Loop until bus retry count.
        Call XcpR_MainFunction in order to make the retries.
        08. VP: Check that the message was not sent successfully.
m4_ifelse(PM_Tst_XcpRDetRuntimeChecks,false,\-:m4_dnl
    09. Check that XcpR does not store a Det runtime error if XcpRDetRuntimeChecks is set to false.
:-/,m4_ifelse( :else: )\-:
    09. VP(XcpR.dsn.TxRetry.RuntimeError.SlaveToMaster): Check that XcpR throws the runtime error XCPR_E_EXTERNAL_BUS.
:-/m4_ifelse( :endif: ))
m4_ifelse(m4_ifelse(PM_Permutation,EthTcpToFrSessionTerminatedOff,eq,ne),ne,\-:m4_dnl
    10. VP(XcpR.dsn.BusMonitor.SendSessionTerminatedEvent): Verify the session terminated
        event was sent (XcpR calls the transmit interface of the lower layer
        (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called).
:-/,m4_ifelse( :else: )\-:
    10. VP(XcpR.Config.XcpRGeneral.XcpREventPacketEnabled): Verify the session terminated
        event was NOT sent because transmission of EV_SESSION_TERMINATED events is disabled
        (XcpR does NOT call the transmit interface of the lower layer, e.g PM_Tst_Master_Bus_Type\-::-/Transmit is NOT called).
:-/m4_ifelse( :endif: ))
    11. VP (XcpR.dsn.TxRetry.TriggerAutonomousDisconnect): Verify that the DISCONNECT command is routed to the
        XCP instance on the local ECU (Xcp_CddRxIndication is called and the XCP package is the same with the
        one received from XCP but header is adapted).
        Set return value of the PM_Tst_Master_Bus_Type\-::-/Transmit to E_OK.
    12. Simulate that XCP responses with a positive response (XcpR_Transmit is called and
        data equals to DISCONNECT positive response).
    13. Verify that the DISCONNECT response is not forwarded to Xcp master.
    14. Simulate reception of a package consisting in command different than CONNECT command
        on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called) when no connection is established.
    15. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the slave is DISCONNECTED.
    16. Simulate reception of a CONNECT command with MODE = 0 on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is
        called and command 0xFF, MODE = 0).
    17. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_0): Verify that the XcpR calls the indication interface of the upper layer
        (e.g Xcp_CddRxIndication is called and the XCP package is the same with the one received).
    18. Simulate a positive response from the Xcp on local ECU (Xcp calls XcpR_Transmit
        with CONNECT positive response).
    19. VP(XcpR.Impl.TxConfirmation.UpperLayer): Verify that the XcpR calls the confirmation interface
        of the upper layer (e.g Xcp_CddTxConfirmation is called with the correct pdu id).
    20. VP(XcpR.Impl.CheckStatusConnection): Verify that the XcpR calls the transmit interface of the lower layer
        (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package is the same with the one received
        from XCP  but header is adapted).
    21. Simulate confirming the response after PM_Tst_Master_Bus_Type\-::-/Transmit() was processed from step 18.
    22. Simulate reception of a package consisting in command different than CONNECT command
        on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called).
    23. VP(XcpR.Impl.TransmissionOfConsecutiveMessages) Verify that the command is routed to the Xcp instance
        but header is adapted).
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_0</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>122</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.TxRetry.RuntimeError.SlaveToMaster</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>469</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.BusMonitor.SendSessionTerminatedEvent</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>405</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.TxRetry.TriggerAutonomousDisconnect</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>472</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TxConfirmation.UpperLayer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>160</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.TxRetry.DiscardMessage</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>467</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.Transmission.DetOn.ErrorCodeExternalBus</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>453</internalId></provcov>
        <provcov>
          <linksto>XcpR.Config.XcpRGeneral.XcpREventPacketEnabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>19</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>575</internalId></specobject>
    <specobject>
      <id>TS_XCPR_TxRetries_ConnectCmd_ToRemoteXcp</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_TxRetry/source/application/EbTest.c.m4</sourcefile>
      <sourceline>757</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Verify Tx bus retries functionality on internal BUS when simulate
      a CONNECT command to remote Xcp slave.
      * Xcp Master over PM_Tst_Master_Bus_Type
      * Remote Xcp Slave over PM_Tst_Slave_Bus_Type
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    XcpRDetRuntimeChecks = PM_Tst_XcpRDetRuntimeChecks
    XcpREventPacketEnabled = PM_Tst_XcpREventPacketEnabled
    XcpRTxRetryCount = PM_Tst_XcpRTxRetryCount
    XcpRTxBusRetry = PM_Tst_XcpRTxBusRetry
    XcpRTxBusTimeout = PM_Tst_XcpRTxBusTimeout
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a package consisting in command different than CONNECT command
        on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called) when no connection is established.
    03. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the slave is DISCONNECTED.
        Set return value of the PM_Tst_Slave_Bus_Type\-::-/Transmit to E_NOT_OK.
    04. Simulate reception of a CONNECT command with MODE = 1 on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called
        and command 0xFF, MODE = 1).
    05. Loop until bus retry count.
        Call XcpR_MainFunction in order to make the retries.
    06. VP: Check that the message was not sent successfully.
m4_ifelse(PM_Tst_XcpRDetRuntimeChecks,false,\-:m4_dnl
    07. Check that XcpR does not store a Det runtime error if XcpRDetRuntimeChecks is set to false.
:-/,m4_ifelse( :else: )\-:
    07. VP(XcpR.dsn.TxRetry.RuntimeError.MasterToSlave): Check that XcpR throws the runtime error XCPR_E_INTERNAL_BUS.
:-/m4_ifelse( :endif: ))
        Set return value of the PM_Tst_Slave_Bus_Type\-::-/Transmit to E_NOT_OK.
    08. Simulate reception of a CONNECT command with MODE = 1 on PM_Tst_Master_Bus_Type (XcpR_RxIndication()
        is called and command 0xFF, MODE = 1).
    09. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode): Check that the
        XcpR calls the transmit interface of the lower layer (e.g PM_Tst_Slave_Bus_Type\-::-/Transmit is called
        and the XCP package is the same with the one received from XCP).
    10. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    11. VP(XcpR.Impl.CheckStatusConnection, XcpR.Impl.AdaptBusInfo): Verify that the XcpR calls the transmit
        interface of the lower layer (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package is the
        same with the one received from XCP).
    12. Simulate reception of a package consisting in command different than CONNECT command
        on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called).
    13. VP(XcpR.Impl.TransmissionOfConsecutiveMessages): Verify that the XcpR calls the transmit interface of
        the lower layer (e.g PM_Tst_Slave_Bus_Type\-::-/Transmit is called.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.TxRetry.RuntimeError.MasterToSlave</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>468</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.AdaptBusInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>147</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.Transmission.DetOn.ErrorCodeInternalBus</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>454</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>576</internalId></specobject>
    <specobject>
      <id>TS_XCPR_TxRetries_successfullyTransmit_ToRemoteXcp</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_TxRetry/source/application/EbTest.c.m4</sourcefile>
      <sourceline>956</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Verify that if messages which are received while TxRetry is blocking the transmission
      buffer are sent after the buffer is free.
      .
      * Xcp Master over PM_Tst_Master_Bus_Type
      * Remote Xcp Slave over PM_Tst_Slave_Bus_Type
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    XcpRDetRuntimeChecks = PM_Tst_XcpRDetRuntimeChecks
    XcpREventPacketEnabled = PM_Tst_XcpREventPacketEnabled
    XcpRTxRetryCount = PM_Tst_XcpRTxRetryCount
    XcpRTxBusRetry = PM_Tst_XcpRTxBusRetry
    XcpRTxBusTimeout = PM_Tst_XcpRTxBusTimeout
  
Test Execution: 
    01. Initialize stubs and XcpR
    02. Simulate reception of a CONNECT command with MODE = 1 (XcpR_RxIndication() is called
        and command 0xFF, MODE = 1)
    03. Retry to transmit the Connect Command
    04. Simulate reception of another CONNECT command with MODE = 1 (XcpR_RxIndication() is called
        and command 0xFF, MODE = 1)
    05. Call XCPR main processing function to process the command
    06. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode): Check that the
        XcpR calls the transmit interface of the lower layer
    07. Call XCPR main function to process the second message
    08. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode): Check that the
        XcpR calls the transmit interface of the lower layer
    09. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response)
    10. VP(XcpR.Impl.CheckStatusConnection, XcpR.Impl.AdaptBusInfo): Verify that the XcpR calls the transmit
        interface of the lower layer
    11. Simulate reception of a package consisting in command different than CONNECT command
    12. VP(XcpR.Impl.TransmissionOfConsecutiveMessages): Verify that the XcpR calls the transmit interface of
        the lower layer
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.dsn.TransmissionOngoing.QueuedMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>455</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.AdaptBusInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>147</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>577</internalId></specobject>
    <specobject>
      <id>TS_XCPR_TxRetries_ConnectSuccedes</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_TxRetry/source/application/EbTest.c.m4</sourcefile>
      <sourceline>1131</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Verify that if XcpR retries to transmit a connect command that failed previosly,
      and manage to transmit it before reaching the threshold, the connect will be corectly
      established.
      * Xcp Master over PM_Tst_Master_Bus_Type
      * Remote Xcp Slave over PM_Tst_Slave_Bus_Type
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    XcpRDetRuntimeChecks = PM_Tst_XcpRDetRuntimeChecks
    XcpREventPacketEnabled = PM_Tst_XcpREventPacketEnabled
    XcpRTxRetryCount = PM_Tst_XcpRTxRetryCount
    XcpRTxBusRetry = PM_Tst_XcpRTxBusRetry
    XcpRTxBusTimeout = PM_Tst_XcpRTxBusTimeout
  
Test Execution: 
    01. Initialize stubs and XcpR
    02. Simulate reception of a CONNECT command with MODE = 1 (XcpR_RxIndication() is called
        and command 0xFF, MODE = 1)
    03. Retry to transmit the Connect Command
    04. Call XCPR main processing function to process the command
    05. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode): Check that the
        XcpR calls the transmit interface of the lower layer
    06. Simulate a positive response from the XCP on remote ECU
    07. Call XCPR main processing function to try forwarding the response
    08. VP(XcpR.Impl.CheckStatusConnection, XcpR.Impl.AdaptBusInfo): Verify that the XcpR calls the transmit
        interface of the lower layer
    09. Simulate reception of a package consisting in command different than CONNECT command
    10. VP(XcpR.Impl.TransmissionOfConsecutiveMessages): Verify that the XcpR calls the transmit interface of
        the lower layer
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.dsn.InternalState.TransmissionFailed.PreviousCommandConnect</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>415</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.InternalState.TransmissionFailed.WaitingConnectConfirmation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>416</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.AdaptBusInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>147</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>578</internalId></specobject>
    <specobject>
      <id>TS_XCPR_TxRetries_MessagePosRes_FromLocalXcp</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_TxRetry/source/application/EbTest.c.m4</sourcefile>
      <sourceline>1296</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Verify Tx bus retries functionality in CONNECTED XcpR state on external BUS when simulate
      a positive response from local Xcp slave.
      * Xcp Master over PM_Tst_Master_Bus_Type
      * Local Xcp Slave over Cdd
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    XcpRDetRuntimeChecks = PM_Tst_XcpRDetRuntimeChecks
    XcpREventPacketEnabled = PM_Tst_XcpREventPacketEnabled
    XcpRTxRetryCount = PM_Tst_XcpRTxRetryCount
    XcpRTxBusRetry = PM_Tst_XcpRTxBusRetry
    XcpRTxBusTimeout = PM_Tst_XcpRTxBusTimeout
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a package consisting in command different than CONNECT command
        on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called) when no connection is established.
    03. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the slave is DISCONNECTED.
    04. Simulate reception of a CONNECT command with MODE = 0 on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is
        called and command 0xFF, MODE = 0).
    05. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_0): Verify that the XcpR calls the indication interface of the upper layer
        (e.g Xcp_CddRxIndication is called and the XCP package is the same with the one received).
    06. Simulate a positive response from the Xcp on local ECU (Xcp calls XcpR_Transmit
        with CONNECT positive response).
    07. VP(XcpR.Impl.TxConfirmation.UpperLayer): Verify that the XcpR calls the confirmation
        interface of the upper layer (e.g Xcp_CddTxConfirmation is called with the correct Pdu id).
    08. VP(XcpR.Impl.CheckStatusConnection): Verify that the XcpR calls the transmit interface of the lower layer
        (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package is the same with the one received
        from XCP  but header is adapted).
    09. Simulate confirming the response after PM_Tst_Master_Bus_Type\-::-/Transmit() was processed from step 06.
    10. Simulate reception of a package consisting in command different than CONNECT command
        on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called).
    11. VP (XcpR.Impl.TransmissionOfConsecutiveMessages) Verify that the command is routed to the Xcp
        instance on the local ECU (Xcp_CddRxIndication is called and the XCP package is the same with the one
        received from XCP but header is adapted).
        Set return value of the PM_Tst_Master_Bus_Type\-::-/Transmit to E_NOT_OK.
    12. Simulate that XCP responses with a positive response (local Xcp slave calls XcpR_Transmit
        with GET_STATUS positive response).
    13. Loop until bus retry count.
        Call XcpR_MainFunction in order to make the retries.
        14. Check that the message was not sent successfully.
m4_ifelse(PM_Tst_XcpRDetRuntimeChecks,false,\-:m4_dnl
    15. Check that XcpR does not store a Det runtime error if XcpRDetRuntimeChecks is set to false.
:-/,m4_ifelse( :else: )\-:
    15. VP(XcpR.dsn.TxRetry.RuntimeError.SlaveToMaster): Check that XcpR throws the runtime error XCPR_E_EXTERNAL_BUS.
:-/m4_ifelse( :endif: ))
    16. VP (XcpR.dsn.TxRetry.TriggerAutonomousDisconnect): Verify that the DISCONNECT command is routed to
        the XCP instance on the local ECU (Xcp_CddRxIndication is called and the XCP package is the same
        with the one received from XCP but header is adapted).
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_0</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>122</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TxConfirmation.UpperLayer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>160</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.TxRetry.RuntimeError.SlaveToMaster</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>469</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.TxRetry.TriggerAutonomousDisconnect</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>472</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.TxRetry.DiscardMessage</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>467</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.Transmission.DetOn.ErrorCodeExternalBus</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>453</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>579</internalId></specobject>
    <specobject>
      <id>TS_XCPR_TxRetries_MessagePosRes_FromRemoteXcp</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_TxRetry/source/application/EbTest.c.m4</sourcefile>
      <sourceline>1525</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Verify Tx bus retries functionality in CONNECTED XcpR state on external BUS when simulate
      a positive response from remote Xcp slave.
      * Xcp Master over PM_Tst_Master_Bus_Type
      * Remote Xcp Slave over PM_Tst_Slave_Bus_Type
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    XcpRDetRuntimeChecks = PM_Tst_XcpRDetRuntimeChecks
    XcpREventPacketEnabled = PM_Tst_XcpREventPacketEnabled
    XcpRTxRetryCount = PM_Tst_XcpRTxRetryCount
    XcpRTxBusRetry = PM_Tst_XcpRTxBusRetry
    XcpRTxBusTimeout = PM_Tst_XcpRTxBusTimeout
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a package consisting in command different than CONNECT command
        on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called) when no connection is established.
    03. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the slave is DISCONNECTED.
    04. Simulate reception of a CONNECT command with MODE = 1 on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called
        and command 0xFF, MODE = 1).
    05. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode): Check that the
        XcpR calls the transmit interface of the lower layer (e.g PM_Tst_Slave_Bus_Type\-::-/Transmit is called
        and the XCP package is the same with the one received from XCP).
    06. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
             and data equals to CONNECT positive response).
    07. VP(XcpR.Impl.CheckStatusConnection, XcpR.Impl.AdaptBusInfo): Verify that the XcpR calls the transmit
        interface of the lower layer (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package is the
        same with the one received from XCP).
    08. Simulate reception of a package consisting in command different than CONNECT command
        on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called) when no connection is established.
    09. VP (XcpR.Impl.TransmissionOfConsecutiveMessages) Verify that the first command is routed to the XCP
        instance on the remote ECU (PM_Tst_Slave_Bus_Type\-::-/Transmit is called and the XCP package is the same with
        the one received from XCP but header is adapted) and the second package is ignored.
        Set return value of the PM_Tst_Master_Bus_Type\-::-/Transmit to E_NOT_OK.
    10. Simulate that XCP responses with a positive response (XcpR_RxIndication is called
        and data equals Tst_GET_STATUSPositiveResponse).
    11. Loop until bus retry count.
        Call XcpR_MainFunction in order to make the retries.
        12. VP: Check that the message was not sent successfully.
m4_ifelse(PM_Tst_XcpRDetRuntimeChecks,false,\-:m4_dnl
    13. Check that XcpR does not store a Det runtime error if XcpRDetRuntimeChecks is set to false.
:-/,m4_ifelse( :else: )\-:
    13. VP(XcpR.dsn.TxRetry.RuntimeError.SlaveToMaster): Check that XcpR throws the runtime error XCPR_E_EXTERNAL_BUS.
:-/m4_ifelse( :endif: ))
        Set return value of the CanIf_Transmit to E_OK.
    14. Simulate reception of a package consisting in command different than CONNECT command
        on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called).
    15. VP (XcpR.Impl.TransmissionOfConsecutiveMessages) Verify that the command is routed to the
        same with the one received from XCP but header is adapted) and the second package is ignored.
    16. Simulate that XCP responses with a positive response (XcpR_RxIndication is called
        and data equals to GET_STATUS positive response).
    17. VP(XcpR.Impl.TransmissionOfConsecutiveMessages, XcpR.Impl.AdaptBusInfo): Verify that the XcpR calls
        the transmit interface of the lower layer (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP
        package is the same with the one received from XCP).
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.RuntimeErrors</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>143</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>580</internalId></specobject>
    <specobject>
      <id>TS_XCPR_TxRetries_MessageCmd_ToRemoteXcp</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_TxRetry/source/application/EbTest.c.m4</sourcefile>
      <sourceline>1789</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Verify Tx bus retries functionality in CONNECTED XcpR state on external BUS when simulate
      a command to remote Xcp slave.
      * Xcp Master over PM_Tst_Master_Bus_Type
      * Remote Xcp Slave over PM_Tst_Slave_Bus_Type
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    XcpRDetRuntimeChecks = PM_Tst_XcpRDetRuntimeChecks
    XcpREventPacketEnabled = PM_Tst_XcpREventPacketEnabled
    XcpRTxRetryCount = PM_Tst_XcpRTxRetryCount
    XcpRTxBusRetry = PM_Tst_XcpRTxBusRetry
    XcpRTxBusTimeout = PM_Tst_XcpRTxBusTimeout
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a package consisting in command different than CONNECT command
        on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called) when no connection is established.
    03. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the slave is DISCONNECTED.
    04. Simulate reception of a CONNECT command with MODE = 1 on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called
        and command 0xFF, MODE = 1).
    05. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode): Check that the
        XcpR calls the transmit interface of the lower layer (e.g PM_Tst_Slave_Bus_Type\-::-/Transmit is called
        and the XCP package is the same with the one received from XCP).
    06. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    07. VP(XcpR.Impl.CheckStatusConnection, XcpR.Impl.AdaptBusInfo): Verify that the XcpR calls the transmit
        interface of the lower layer (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package is the
        same with the one received from XCP).
        Set return value of the PM_Tst_Slave_Bus_Type\-::-/Transmit to E_NOT_OK.
    08. Simulate reception of a package consisting in command different than CONNECT command
        on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called).
    09. Loop until bus retry count.
        Call XcpR_MainFunction in order to make the retries.
    10. Check that the message was not sent successfully.
m4_ifelse(PM_Tst_XcpRDetRuntimeChecks,false,\-:m4_dnl
    11. Check that XcpR does not store a Det runtime error if XcpRDetRuntimeChecks is set to false.
:-/,m4_ifelse( :else: )\-:
    11. VP(XcpR.dsn.TxRetry.RuntimeError.MasterToSlave): Check that XcpR throws the runtime error XCPR_E_INTERNAL_BUS.
:-/m4_ifelse( :endif: ))
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.AdaptBusInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>147</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.TxRetry.RuntimeError.MasterToSlave</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>468</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.TxRetry.DiscardMessage</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>467</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.Transmission.DetOn.ErrorCodeExternalBus</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>453</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>581</internalId></specobject>
    <specobject>
      <id>TS_XCPR_TxRetries_DisconnectPosRes_FromRemoteXcp</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_TxRetry/source/application/EbTest.c.m4</sourcefile>
      <sourceline>1968</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Verify Tx bus retries functionality on external BUS when simulate
      a positive DISCONNECT response from remote Xcp slave.
      * Xcp Master over PM_Tst_Master_Bus_Type
      * Remote Xcp Slave over PM_Tst_Slave_Bus_Type
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    XcpRDetRuntimeChecks = PM_Tst_XcpRDetRuntimeChecks
    XcpREventPacketEnabled = PM_Tst_XcpREventPacketEnabled
    XcpRTxRetryCount = PM_Tst_XcpRTxRetryCount
    XcpRTxBusRetry = PM_Tst_XcpRTxBusRetry
    XcpRTxBusTimeout = PM_Tst_XcpRTxBusTimeout
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a package consisting in command different than CONNECT command
        on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called) when no connection is established.
    03. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the slave is DISCONNECTED.
    04. Simulate reception of a CONNECT command with MODE = 1 on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called
        and command 0xFF, MODE = 1).
    05. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode): Check that the
        XcpR calls the transmit interface of the lower layer (e.g PM_Tst_Slave_Bus_Type\-::-/Transmit is called
        and the XCP package is the same with the one received from XCP).
    06. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    07. VP(XcpR.Impl.CheckStatusConnection): Verify that the XcpR calls the transmit interface of the lower layer
        (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package is the same with the one received
        from XCP).
    08. Simulate reception of a package consisting in a DISCONNECT command.
    09. VP (XcpR.Impl.TransmissionOfConsecutiveMessages) Verify that the command is routed
        to the XCP instance on the remote ECU (PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP
        package is the same with the one received from XCP but header is adapted).
        Set return value of the PM_Tst_Master_Bus_Type\-::-/Transmit to E_NOT_OK.
    10. Simulate that XCP responses with a positive response (XcpR_RxIndication is called and
          data equals DISCONNECT positive response).
    11. Loop until bus retry count.
        Call XcpR_MainFunction in order to make the retries.
        12. Check that the message was not sent successfully.
    13. Simulate reception of a package consisting in command different than CONNECT command
        on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called) when no connection is established.
    14. VP(XcpR.Impl.DisconnectedState.CommandResponse, XcpR.dsn.TxRetry.SlaveToMaster.DisconnectXcpR):
        Received package is ignored without any action because the slave is DISCONNECTED.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.TxRetry.SlaveToMaster.DisconnectXcpR</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>470</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.TxRetry.DiscardMessage</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>467</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>582</internalId></specobject>
    <specobject>
      <id>TS_XCPR_TxRetries_DisconnectPosRes_FromLocalXcp</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_TxRetry/source/application/EbTest.c.m4</sourcefile>
      <sourceline>2171</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Verify Tx bus retries functionality on external BUS when simulate
      a positive DISCONNECT response from local Xcp slave.
      * Xcp Master over PM_Tst_Master_Bus_Type
      * Local Xcp Slave over Cdd
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    XcpRDetRuntimeChecks = PM_Tst_XcpRDetRuntimeChecks
    XcpREventPacketEnabled = PM_Tst_XcpREventPacketEnabled
    XcpRTxRetryCount = PM_Tst_XcpRTxRetryCount
    XcpRTxBusRetry = PM_Tst_XcpRTxBusRetry
    XcpRTxBusTimeout = PM_Tst_XcpRTxBusTimeout
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a package consisting in command different than CONNECT command
        on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called) when no connection is established.
    03. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the slave is DISCONNECTED.
    04. Simulate reception of a CONNECT command with MODE = 0 on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is
        called and command 0xFF, MODE = 0).
    05. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_0): Verify that the XcpR calls the indication interface of the upper layer
        (e.g Xcp_CddRxIndication is called and the XCP package is the same with the one received).
    06. Simulate a positive response from the Xcp on local ECU (Xcp calls XcpR_Transmit
        with CONNECT positive response).
    07. VP(XcpR.Impl.TxConfirmation.UpperLayer): Verify that the XcpR calls the confirmation interface
        of the upper layer (e.g Xcp_CddTxConfirmation is called with the correct Pdu id).
    08.  VP(XcpR.Impl.CheckStatusConnection): Verify that the XcpR calls the transmit interface of the lower layer
        (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package is the same with the one received
        from XCP  but header is adapted).
    09. Simulate reception of a package consisting in a DISCONNECT command.
    10. VP (XcpR.Impl.TransmissionOfConsecutiveMessages) Verify that the command is routed to the XCP
        instance on the local ECU (Xcp_CddRxIndication is called and the XCP package is the same with the one
        received from XCP but header is adapted).
        Set return value of the PM_Tst_Master_Bus_Type\-::-/Transmit to E_NOT_OK.
    11. Simulate that XCP responses with a positive response (XcpR_Transmit and
        data equals to DISCONNECT positive response).
    12. Loop until bus retry count.
        Call XcpR_MainFunction in order to make the retries.
        13. VP: Check that the message was not sent successfully.
    14. Simulate reception of a package consisting in command different than CONNECT command
        on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called) when no connection is established.
    15. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the slave is DISCONNECTED.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.RuntimeErrors</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>143</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_0</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>122</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TxConfirmation.UpperLayer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>160</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>583</internalId></specobject>
    <specobject>
      <id>TS_XCPR_TxRetries_TwoConnectCmds_ToRemoteXcp</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_TxRetry/source/application/EbTest.c.m4</sourcefile>
      <sourceline>2372</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Verify Tx retries functionality to remote Xcp slave.
      XcpR cannot forward the first CONNECT command from Xcp Master to the remote Xcp Slave.
      XcpR cannot forward the second CONNECT command from Xcp Master to the remote Xcp Slave.
      XcpR remains in DISCONNECTED state.
      XcpR establishes a successful connection.
        * Xcp Master over PM_Tst_Master_Bus_Type
        * Remote Xcp Slave over PM_Tst_Slave_Bus_Type
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    XcpRDetRuntimeChecks = PM_Tst_XcpRDetRuntimeChecks
    XcpREventPacketEnabled = PM_Tst_XcpREventPacketEnabled
    XcpRTxRetryCount = PM_Tst_XcpRTxRetryCount
    XcpRTxBusRetry = PM_Tst_XcpRTxBusRetry
    XcpRTxBusTimeout = PM_Tst_XcpRTxBusTimeout
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a package consisting in command different than CONNECT command
        on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called) when no connection is established.
    03. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the slave is DISCONNECTED.
    04. Simulate reception of a CONNECT command with MODE = 1 on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called
        and command 0xFF, MODE = 1).
    05. Loop until bus retry count.
        Call XcpR_MainFunction in order to make the retries.
    06. VP: Check that the message was not sent successfully.
m4_ifelse(PM_Tst_XcpRDetRuntimeChecks,false,\-:m4_dnl
    07. Check that XcpR does not store a Det runtime error if XcpRDetRuntimeChecks is set to false.
:-/,m4_ifelse( :else: )\-:
    07. VP(XcpR.dsn.TxRetry.RuntimeError.MasterToSlave): Check that XcpR throws the runtime error XCPR_E_INTERNAL_BUS.
:-/m4_ifelse( :endif: ))
    08. Simulate reception of a CONNECT command with MODE = 1 on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called
        and command 0xFF, MODE = 1).
    09. Loop until bus retry count.
        Call XcpR_MainFunction in order to make the retries.
    10. VP: Check that the message was not sent successfully.
m4_ifelse(PM_Tst_XcpRDetRuntimeChecks,false,\-:m4_dnl
    11. Check that XcpR does not store a Det runtime error if XcpRDetRuntimeChecks is set to false.
:-/,m4_ifelse( :else: )\-:
    11. VP(XcpR.dsn.TxRetry.RuntimeError.MasterToSlave): Check that XcpR throws the runtime error XCPR_E_INTERNAL_BUS.
:-/m4_ifelse( :endif: ))
    12. Simulate reception of a package consisting in command different than CONNECT command
        on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called) when no connection is established.
    13. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the slave is DISCONNECTED.
    15. Simulate reception of a CONNECT command with MODE = 1 on PM_Tst_Master_Bus_Type (XcpR_RxIndication()
        is called and command 0xFF, MODE = 1).
    16. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode): Check that the
        XcpR calls the transmit interface of the lower layer (e.g PM_Tst_Slave_Bus_Type\-::-/Transmit is called
        and the XCP package is the same with the one received from XCP).
    17. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    18. VP(XcpR.Impl.CheckStatusConnection, XcpR.Impl.AdaptBusInfo): Verify that the XcpR calls the transmit
        interface of the lower layer (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package is the
        same with the one received from XCP).
    19. Simulate reception of a package consisting in command different than CONNECT command
        on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called).
    20. VP(XcpR.Impl.TransmissionOfConsecutiveMessages): Verify that the XcpR calls the transmit interface of
        the lower layer (e.g PM_Tst_Slave_Bus_Type\-::-/Transmit is called.
    21. Set the result as success.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.TxRetry.RuntimeError.MasterToSlave</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>468</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.AdaptBusInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>147</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>584</internalId></specobject>
    <specobject>
      <id>TS_XCPR_TxRetries_NoAutonomousDisconnect</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_TxRetry/source/application/EbTest.c.m4</sourcefile>
      <sourceline>2638</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Verify Tx bus retries functionality the configured amount of times to
      retry the transmission is 255
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    XcpRDetRuntimeChecks = PM_Tst_XcpRDetRuntimeChecks
    XcpREventPacketEnabled = PM_Tst_XcpREventPacketEnabled
    XcpRTxRetryCount = PM_Tst_XcpRTxRetryCount
    XcpRTxBusRetry = PM_Tst_XcpRTxBusRetry
    XcpRTxBusTimeout = PM_Tst_XcpRTxBusTimeout
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a package consisting in command different than CONNECT command
        on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called) when no connection is established.
    03. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the slave is DISCONNECTED.
    04. Simulate reception of a CONNECT command with MODE = 1 on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called
        and command 0xFF, MODE = 1).
    05. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode): Check that the
        XcpR calls the transmit interface of the lower layer (e.g PM_Tst_Slave_Bus_Type\-::-/Transmit is called
        and the XCP package is the same with the one received from XCP).
    06. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    07. VP(XcpR.Impl.CheckStatusConnection, XcpR.Impl.AdaptBusInfo): Verify that the XcpR calls the transmit
        interface of the lower layer (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package is the
        same with the one received from XCP).
        Set return value of the PM_Tst_Slave_Bus_Type\-::-/Transmit to E_NOT_OK.
    08. Simulate reception of a package consisting in command different than CONNECT command
        on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called).
    09. Loop to verify that no autonomous disconnect occurs.
    10. Loop until a timeout occurs
        Call XcpR_MainFunction in order to make the retries.
        No TxConfirmation is received.
    11. VP(XcpR.dsn.BusMonitor.RetryTransmisionWithoutAutonDisconnect): Check that no error  has occurred.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.AdaptBusInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>147</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.BusMonitor.RetryTransmisionWithoutAutonDisconnect</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>402</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>585</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_XCPR_TxRetries_ConnectPosRes_FromRemoteXcp_PackMaster</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_TxRetry_PackPdus/source/application/EbTest.c.m4</sourcefile>
      <sourceline>82</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Verify Tx bus retries functionality on external BUS when simulate
      a CONNECT positive response from remote Xcp slave.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    MASTER NETWORK:
      Bus type: PM_Tst_Master_Bus_Type
      XcpRSourcePackMultiMsgInOneFrame(FlexRay / Ethernet) is enabled.
      XcpRDestinationPackMultiMsgInOneFrame(FlexRay / Ethernet) is enabled.
    REMOTE SLAVE NETWORK:
      Bus type: PM_Tst_Slave_Bus_Type
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a package consisting in command different than CONNECT command
        on master bus (XcpR_RxIndication() is called) when no connection is established.
    03. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the slave is DISCONNECTED.
    04. Simulate reception of a CONNECT command with MODE = 1 on master bus (XcpR_RxIndication() is called
        and command 0xFF, MODE = 1).
    05. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode): Check that the
        XcpR calls the transmit interface of the lower layer (e.g PM_Tst_Slave_Bus_Type\-::-/Transmit is called
        and the XCP package is the same with the one received from XCP).
    06. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    07. Loop until bus retry count.
        08. VP: Verify that the transmission is not succeed.
    09. VP(XcpR.dsn.TxRetry.RuntimeError.SlaveToMaster): Check that XcpR throws the runtime error XCPR_E_EXTERNAL_BUS.
    10. VP(XcpR.dsn.BusMonitor.SendSessionTerminatedEvent): Verify the session terminated
        event was sent (XcpR calls the transmit interface of the lower layer, e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called).
    11. VP (XcpR.dsn.TxRetry.SlaveToMaster.TriggerAutonomousDisconnect) Verify that the command is routed to
        the XCP instance on the remote ECU (PM_Tst_Slave_Bus_Type\-::-/Transmit is called and the XCP package is the same with the one
        received from XCP but header is adapted).
    12. Simulate that XCP responses with a positive response (XcpR_RxIndication is called and
        data equals to DISCONNECT positive response).
    13. Verify that the DISCONNECT response is not forwarded to Xcp master.
    14. Simulate reception of a package consisting in command different than CONNECT command
        on master bus (XcpR_RxIndication() is called) when no connection is established.
    15. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the slave is DISCONNECTED.
    16. Simulate reception of a CONNECT command with MODE = 1  (XcpR_RxIndication() is called
        and command 0xFF, MODE = 1).
    17. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode): Check that the
        XcpR calls the transmit interface of the lower layer (e.g PM_Tst_Slave_Bus_Type\-::-/Transmit is called
        and the XCP package is the same with the one received from XCP).
    18. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    19. VP(XcpR.Impl.CheckStatusConnection): Verify that the XcpR calls the transmit interface of the lower layer
        (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package is the same with the one received
        from XCP).
    20. Simulate reception of a package consisting in command different than CONNECT command
        on master bus (XcpR_RxIndication() is called).
    21. VP (XcpR.Impl.TransmissionOfConsecutiveMessages) Verify that the first command is routed to the XCP
        instance on the remote ECU (PM_Tst_Slave_Bus_Type\-::-/Transmit is called and the XCP package is the same with
        the one received from XCP but header is adapted) and the second package is ignored.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.RuntimeErrors</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>143</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.BusTypesRemoteConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.TxRetry.RuntimeError.SlaveToMaster</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>469</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.BusMonitor.SendSessionTerminatedEvent</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>405</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.TxRetry.SlaveToMaster.TriggerAutonomousDisconnect</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>471</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.TxRetry.DiscardMessage</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>467</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.Transmission.DetOn.ErrorCodeExternalBus</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>453</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>586</internalId></specobject>
    <specobject>
      <id>TS_XCPR_TxRetries_MessagePosRes_FromLocalXcp_PackMaster</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_TxRetry_PackPdus/source/application/EbTest.c.m4</sourcefile>
      <sourceline>394</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Verify Tx bus retries functionality in CONNECTED XcpR state on external BUS when simulate
      a positive response from local Xcp slave.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    MASTER NETWORK:
      Bus type: PM_Tst_Master_Bus_Type
      XcpRSourcePackMultiMsgInOneFrame(FlexRay / Ethernet) is enabled.
      XcpRDestinationPackMultiMsgInOneFrame(FlexRay / Ethernet) is enabled.
    LOCAL SLAVE NETWORK:
      Bus type: CDD
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a package consisting in command different than CONNECT command
        on master bus (XcpR_RxIndication() is called) when no connection is established.
    03. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the slave is DISCONNECTED.
    04. Simulate reception of a CONNECT command with MODE = 0 on master bus (XcpR_RxIndication() is
        called and command 0xFF, MODE = 0).
    05. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_0): Verify that the XcpR calls the indication interface of the upper layer
        (e.g Xcp_CddRxIndication is called and the XCP package is the same with the one received).
    06. Simulate a positive response from the Xcp on local ECU (Xcp calls XcpR_Transmit
        with a CONNECT positive response).
    07. VP(XcpR.Impl.TxConfirmation.UpperLayer): Verify that the XcpR calls the confirmation
        interface of the upper layer (e.g Xcp_CddTxConfirmation is called with the correct Pdu id).
    08. VP(XcpR.Impl.CheckStatusConnection): Verify that the XcpR calls the transmit interface of the lower layer
        (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package is the same with the one received
        from XCP but header is adapted).
    09. Simulate confirming the response after PM_Tst_Master_Bus_Type\-::-/Transmit() was processed from step 06.
    10. Simulate reception of a package consisting in command different than CONNECT command
        on master bus (XcpR_RxIndication() is called).
    11. VP (XcpR.Impl.TransmissionOfConsecutiveMessages) Verify that the command is routed to the Xcp
        instance on the local ECU (Xcp_CddRxIndication is called and the XCP package is the same with the one
        received from XCP but header is adapted).
    12. Simulate that XCP responses with a positive response (local Xcp slave calls XcpR_Transmit
        with a GET_STATUS positive response).
    13. Loop until bus retry count.
        14. Verify that the transmission is not succeed.
    15. VP(XcpR.dsn.TxRetry.RuntimeError.SlaveToMaster): Check that XcpR throws the runtime error XCPR_E_EXTERNAL_BUS.
    16. VP (XcpR.dsn.TxRetry.TriggerAutonomousDisconnect): Verify that the DISCONNECT command is routed to
        the XCP instance on the local ECU (Xcp_CddRxIndication is called and the XCP package is the same
        with the one received from XCP but header is adapted).
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.RuntimeErrors</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>143</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_0</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>122</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TxConfirmation.UpperLayer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>160</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.TxRetry.RuntimeError.SlaveToMaster</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>469</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.TxRetry.TriggerAutonomousDisconnect</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>472</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.TxRetry.DiscardMessage</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>467</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>587</internalId></specobject>
    <specobject>
      <id>TS_XCPR_TxRetries_MultipleMessagesReceived_FromLocalAndMaster</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_TxRetry_PackPdus/source/application/EbTest.c.m4</sourcefile>
      <sourceline>609</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Verify Tx bus retries functionality in CONNECTED XcpR state on external BUS when two messages
      have been received, one from the Xcp Master and one from the Xcp Slave.
      This test is a regression test for ticket ASCXCPR-88.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    MASTER NETWORK:
      Bus type: FlexRay
      XcpRSourcePackMultiMsgInOneFlexRayFrame is enabled.
      XcpRDestinationPackMultiMsgInOneFlexRayFrame is enabled.
    LOCAL SLAVE NETWORK:
      Bus type: CDD
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a CONNECT command with MODE = 0 on master bus (XcpR_RxIndication() is
        called and command 0xFF, MODE = 0).
    03. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_0): Verify that the XcpR calls the indication interface of the upper layer
        (e.g Xcp_CddRxIndication is called and the XCP package is the same with the one received).
    04. Simulate a positive response from the Xcp on local ECU.
    05. Simulate confirming the response.
    06. Simulate a message received from the Xcp on local ECU.
    07. Simulate a message from Master XCP.
    08. Try to transmit for bus retry count times.
    09. VP: Verify that the transmission did not succeed.
    10. VP(XcpR.dsn.TxRetry.RuntimeError.SlaveToMaster): Check that XcpR throws the runtime error XCPR_E_EXTERNAL_BUS
    11. VP (XcpR.dsn.TxRetry.TriggerAutonomousDisconnect): Verify that the DISCONNECT command is routed to
        the XCP instance on the local ECU.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_0</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>122</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.TxRetry.RuntimeError.SlaveToMaster</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>469</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.TxRetry.TriggerAutonomousDisconnect</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>472</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.Transmission.DetOn.ErrorCodeExternalBus</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>453</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>588</internalId></specobject>
    <specobject>
      <id>TS_XCPR_TxRetries_ConnectPosRes_FromRemoteXcp_Pack</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_TxRetry_PackPdus/source/application/EbTest.c.m4</sourcefile>
      <sourceline>760</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Verify Tx bus retries functionality when both Xcp master and remote slave supports multiple
      PDUs in one frame. Simulate a CONNECT positive response from remote Xcp slave until
      bus retry count is reached. XcpR must send session terminated event FRAME to the master Xcp and
      DISCONNECT command FRAME to the remote slave.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    MASTER NETWORK:
      Bus type: PM_Tst_Master_Bus_Type
      XcpRSourcePackMultiMsgInOneFrame(FlexRay / Ethernet) is enabled.
      XcpRDestinationPackMultiMsgInOneFrame(FlexRay / Ethernet) is enabled.
    REMOTE SLAVE NETWORK:
      Bus type: PM_Tst_Slave_Bus_Type
      XcpRSourcePackMultiMsgInOneFrame(FlexRay / Ethernet) is enabled.
      XcpRDestinationPackMultiMsgInOneFrame(FlexRay / Ethernet) is enabled.
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a package consisting in command different than CONNECT command
        on master bus (XcpR_RxIndication() is called) when no connection is established.
    03. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the slave is DISCONNECTED.
    04. Simulate reception of a CONNECT command with MODE = 1 on master bus (XcpR_RxIndication() is called
        and command 0xFF, MODE = 1).
    05. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode): Check that the
        XcpR calls the transmit interface of the lower layer (e.g PM_Tst_Slave_Bus_Type\-::-/Transmit is called
        and the XCP package is the same with the one received from XCP).
    06. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    07. Loop until bus retry count.
        08. VP: Verify that the transmission is not succeed.
    09. VP(XcpR.dsn.TxRetry.RuntimeError.SlaveToMaster): Check that XcpR throws the runtime error XCPR_E_EXTERNAL_BUS.
    10. VP(XcpR.dsn.BusMonitor.SendSessionTerminatedEvent): Verify the session terminated
        event was sent (XcpR calls the transmit interface of the lower layer, e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called).
    11. VP (XcpR.dsn.TxRetry.SlaveToMaster.TriggerAutonomousDisconnect) Verify that the command is routed to
        the XCP instance on the remote ECU (PM_Tst_Slave_Bus_Type\-::-/Transmit is called and the XCP package is the same with the one
        received from XCP but header is adapted).
    12. Simulate that XCP responses with a positive response (XcpR_RxIndication is called and
        data equals DISCONNECT positive response).
    13. Verify that the DISCONNECT response is not forwarded to Xcp master.
    14. Simulate reception of a package consisting in command different than CONNECT command
        on master bus (XcpR_RxIndication() is called) when no connection is established.
    15. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the slave is DISCONNECTED.
    16. Simulate reception of a CONNECT command with MODE = 1  (XcpR_RxIndication() is called
        and command 0xFF, MODE = 1).
    17. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode): Check that the
        XcpR calls the transmit interface of the lower layer (e.g PM_Tst_Slave_Bus_Type\-::-/Transmit is called
        and the XCP package is the same with the one received from XCP).
    18. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    19. VP(XcpR.Impl.CheckStatusConnection): Verify that the XcpR calls the transmit interface of the lower layer
        (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package is the same with the one received
        from XCP).
    20. Simulate reception of a package consisting in command different than CONNECT command
        on master bus (XcpR_RxIndication() is called).
    21. VP (XcpR.Impl.TransmissionOfConsecutiveMessages) Verify that the first command is routed to the XCP
        instance on the remote ECU (PM_Tst_Slave_Bus_Type\-::-/Transmit is called and the XCP package is the same with
        the one received from XCP but header is adapted) and the second package is ignored.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.BusTypesRemoteConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.TxRetry.RuntimeError.SlaveToMaster</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>469</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.BusMonitor.SendSessionTerminatedEvent</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>405</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.TxRetry.SlaveToMaster.TriggerAutonomousDisconnect</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>471</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.TxRetry.DiscardMessage</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>467</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.Transmission.DetOn.ErrorCodeExternalBus</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>453</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.PublicHeader</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>141</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>589</internalId></specobject>
    <specobject>
      <id>TS_XCPR_TxRetries_ConnectPosRes_FromRemoteXcp_PackRemoteSlave</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_TxRetry_PackPdus/source/application/EbTest.c.m4</sourcefile>
      <sourceline>1072</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Verify Tx bus retries functionality on external BUS. Verify that a successful connection
      is established after the Xcp slave was disconnected by Tx bus retry.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    MASTER NETWORK:
      Bus type: PM_Tst_Master_Bus_Type
    REMOTE SLAVE NETWORK:
      Bus type: PM_Tst_Slave_Bus_Type
      XcpRSourcePackMultiMsgInOneFrame(FlexRay / Ethernet) is enabled.
      XcpRDestinationPackMultiMsgInOneFrame(FlexRay / Ethernet) is enabled.
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a package consisting in command different than CONNECT command
        on PM_Tst_Master_Bus_Type bus (XcpR_RxIndication() is called) when no connection is established.
    03. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the slave is DISCONNECTED.
    04. Simulate reception of a CONNECT command with MODE = 1 on PM_Tst_Master_Bus_Type (XcpR_RxIndication() is called
        and command 0xFF, MODE = 1).
    05. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode): Check that the
        XcpR calls the transmit interface of the lower layer (e.g PM_Tst_Slave_Bus_Type\-::-/Transmit is called and the XCP package
        is the same with the one received from XCP).
    06. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    07. Loop until bus retry count.
        08. VP: Verify that the transmission is not succeed.
    09. VP(XcpR.dsn.TxRetry.RuntimeError.SlaveToMaster): Check that XcpR throws the runtime error XCPR_E_EXTERNAL_BUS.
    10. VP(XcpR.dsn.BusMonitor.SendSessionTerminatedEvent): Verify the session terminated
        event was sent (XcpR calls the transmit interface of the lower layer, e.g PM_Tst_Slave_Bus_Type\-::-/Transmit is called).
    11. VP (XcpR.dsn.TxRetry.SlaveToMaster.TriggerAutonomousDisconnect) Verify that the command is routed to
        the XCP instance on the remote ECU (PM_Tst_Slave_Bus_Type\-::-/Transmit is called and the XCP package is the same with the one
        received from XCP but header is adapted).
    12. Simulate that XCP responses with a positive response (XcpR_RxIndication is called and
        data equals to DISCONNECT positive response).
    13. Verify that the DISCONNECT response is not forwarded to Xcp master.
    14. Simulate reception of a package consisting in command different than CONNECT command
        on master bus (XcpR_RxIndication() is called) when no connection is established.
    15. VP(XcpR.Impl.DisconnectedState.CommandResponse): Received package is ignored without any action
        because the slave is DISCONNECTED.
    16. Simulate reception of a CONNECT command with MODE = 1  (XcpR_RxIndication() is called
        and command 0xFF, MODE = 1).
    17. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_1, XcpR.Impl.RemoteConnections.ConnectMode): Check that the
        XcpR calls the transmit interface of the lower layer (e.g PM_Tst_Slave_Bus_Type\-::-/Transmit is called
        and the XCP package is the same with the one received from XCP).
    18. Simulate a positive response from the XCP on remote ECU (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    19. VP(XcpR.Impl.CheckStatusConnection): Verify that the XcpR calls the transmit interface of the lower layer
        (e.g PM_Tst_Master_Bus_Type\-::-/Transmit is called and the XCP package is the same with the one received
        from XCP).
    20. Simulate reception of a package consisting in command different than CONNECT command
        on master bus (XcpR_RxIndication() is called).
    21. VP (XcpR.Impl.TransmissionOfConsecutiveMessages) Verify that the first command is routed to the XCP
        instance on the remote ECU (PM_Tst_Slave_Bus_Type\-::-/Transmit is called and the XCP package is the same with
        the one received from XCP but header is adapted) and the second package is ignored.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.RuntimeErrors</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>143</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.RemoteConnections.ConnectMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.BusTypesRemoteConnections</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.DisconnectedState.CommandResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.TxRetry.RuntimeError.SlaveToMaster</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>469</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.BusMonitor.SendSessionTerminatedEvent</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>405</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.TxRetry.SlaveToMaster.TriggerAutonomousDisconnect</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>471</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TransmissionOfConsecutiveMessages</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.TxRetry.DiscardMessage</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>467</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.Transmission.DetOn.ErrorCodeExternalBus</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>453</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>590</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_XCPR_NotificationsToULXcp</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_UL_Notifications/source/application/EbTest.c</sourcefile>
      <sourceline>64</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Test is used to verify that XcpR successfully receives data acquisition packages from the local slave Xcp
      and immediately responds with TriggerTransmit and TxConfirmation requests.
      The test also verifies that XcpR can receive multiple messages from the local Xcp slave and then pack them
      to be sent to the master Xcp.
      The mechanism for notifications between XcpR and the slave Xcp are independent compared to interactions between
      XcpR and the master Xcp (i.e. the local slave Xcp does not have to wait for notifications to be triggered by FrIf)
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    01. Initialize stubs and XcpR.
    02. Simulate reception of a CONNECT command request from master on PDU ID = 0.
    03. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_0, XcpR.Impl.AdaptBusInfo): Verify that the XcpR calls
        the interface of the upper layer (e.g Xcp_CddRxIndication is called and the XCP package
        is the same with the one received from the XCP master but header is adapted).
    04. Simulate a positive response from the local XCP slave (XcpR_RxIndication is called
        and data equals to CONNECT positive response).
    05. VP(XcpR.Impl.TxConfirmation.UpperLayer): Verify that the XcpR calls the confirmation
        interface of the upper layer (Xcp_CddTxConfirmation is called with the correct pdu id).
    06. VP(XcpR.Impl.TriggerTransmit.UpperLayer): Verify that the XcpR calls the trigger transmit interface of the upper layer.
    07. Transmit data using the trigger transmit.
    08. VP(XcpR.Impl.CheckStatusConnection, XcpR.Impl.AdaptBusInfo): Verify that the XcpR calls
        the transmit interface of the lower layer (e.g FrIf_Transmit is called and the XCP package is
        the same with the one received from XCP slave but header is adapted).
    09. Simulate reception of START_STOP_DAQ_LIST on PDU ID = 0 in order to start XcpDaqList_0,
        XcpDaqList_1, XcpDaqList_2, XcpDaqList_3, XcpDaqList_4, XcpDaqList_5.
      10. Simulate reception, on FlexRay bus, of START_STOP_DAQ_LIST command.
      11. Verify that the package is routed to the Xcp instance on the local ECU (Xcp_CddRxIndication is called)
          and the XCP package is the same with the one received but header is adapted.
      12. Simulate that local XCP slave responses, on CDD bus, with positive response for
          START_STOP_DAQ_LIST command (local Xcp slave calls XcpR_Transmit).
      13. VP(XcpR.Impl.TxConfirmation.UpperLayer): Verify that the XcpR calls the confirmation
          interface of the upper layer (Xcp_CddTxConfirmation is called with the correct pdu id).
      14. VP(XcpR.Impl.TriggerTransmit.UpperLayer): Verify that the XcpR calls the trigger transmit interface of the upper layer.
      15. Transmit data using the trigger transmit.
      16. Verify that the XcpR calls the transmit interface of the lower layer
          (e.g FrIf_Transmit is called and the master XCP package is the same with the one received
          from the local slave XCP but header is adapted).
    17. Simulate reception of stimulation data from XCP master on PDU ID = 1 for DAQ 0 and DAQ 1.
    18. Verify that the packages are routed to the Xcp instance on the local ECU (Xcp_CddRxIndication is called twice).
    19. Simulate reception, on CDD bus, of data acquisition package for DAQ 2 and DAQ 3.
    20. VP(XcpR.Impl.TxConfirmation.UpperLayer): Verify that the XcpR calls the confirmation
        interface of the upper layer (Xcp_CddTxConfirmation is called twice with the correct pdu id).
    21. VP(XcpR.Impl.TriggerTransmit.UpperLayer): Verify that the XcpR calls the trigger transmit interface of the upper layer.
    22. Transmit data using the trigger transmit.
    23. Verify that expected data is transmitted to XCP master using correct PDU ID.
    24. Simulate reception, on CDD bus, of data acquisition package for DAQ 4 and DAQ 5.
    25. VP(XcpR.Impl.TxConfirmation.UpperLayer): Verify that the XcpR calls the confirmation
        interface of the upper layer (Xcp_CddTxConfirmation is called twice with the correct pdu id).
    26. VP(XcpR.Impl.TriggerTransmit.UpperLayer): Verify that the XcpR calls the trigger transmit interface of the upper layer.
    27. Transmit data using the trigger transmit.
    28. Verify that expected data is transmitted to XCP master using correct PDU ID.
    29. Set the result as success.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_0</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>122</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.AdaptBusInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>147</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TxConfirmation.UpperLayer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>160</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TriggerTransmit.UpperLayer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>161</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>591</internalId></specobject>
    <specobject>
      <id>TS_XCPR_NotificationsToULXcp_DifferentPduIds</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Conformance/IN/XcpR_ConTest_UL_Notifications/source/application/EbTest.c</sourcefile>
      <sourceline>465</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Test is used to verify that XcpR correctly receives DAQ data from the local Xcp from 2 different PduIds and correctly
      routes data to 2 different destination PduIds.
      These 2 destinations are configured with "multiple packing" enabled even if only 1 message is packed.
      The test should verify that the single message in a frame is correctly identified as the last message and that XcpR
      correctly adds the frame ending data: a 0 for frame ending and another 0 for rounding up the length.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    01. Initialize stubs and XcpR
    02. Simulate reception of a CONNECT command request from master on PDU ID = 0
    03. VP(XcpR.Impl.XcpRMultipleSlaves.Mode_0, XcpR.Impl.AdaptBusInfo): Verify that the XcpR calls
        the interface of the upper layer (e.g Xcp_CddRxIndication is called and the XCP package
        is the same with the one received from the XCP master but header is adapted)
    04. Simulate a positive response from the local XCP slave (XcpR_RxIndication is called
        and data equals to CONNECT positive response)
    05. VP(XcpR.Impl.TxConfirmation.UpperLayer): Verify that the XcpR calls the confirmation
        interface of the upper layer (Xcp_CddTxConfirmation is called with the correct pdu id)
    06. VP(XcpR.Impl.TriggerTransmit.UpperLayer): Verify that the XcpR calls the trigger transmit interface of the upper layer
    07. Transmit data using the trigger transmit
    08. VP(XcpR.Impl.CheckStatusConnection, XcpR.Impl.AdaptBusInfo): Verify that the XcpR calls
        the transmit interface of the lower layer (e.g FrIf_Transmit is called and the XCP package is
        the same with the one received from XCP slave but header is adapted)
    09. Simulate reception of START_STOP_DAQ_LIST on PDU ID = 0 in order to start XcpDaqList_6
    10. Verify that the package is routed to the Xcp instance on the local ECU (Xcp_CddRxIndication is called)
        and the XCP package is the same with the one received but header is adapted
    11. Simulate that local XCP slave responses, on CDD bus, with positive response for
        START_STOP_DAQ_LIST command (local Xcp slave calls XcpR_Transmit)
    12. VP(XcpR.Impl.TxConfirmation.UpperLayer): Verify that the XcpR calls the confirmation
        interface of the upper layer (Xcp_CddTxConfirmation is called with the correct pdu id)
    13. VP(XcpR.Impl.TriggerTransmit.UpperLayer): Verify that the XcpR calls the trigger transmit interface of the upper layer
    14. Transmit data using the trigger transmit
    15. Verify that the XcpR calls the transmit interface of the lower layer
        (e.g FrIf_Transmit is called and the master XCP package is the same with the one received
        from the local slave XCP but header is adapted)
    16. Simulate reception, on CDD bus, of data acquisition package for DAQ_List_6
    17. VP(XcpR.Impl.TxConfirmation.UpperLayer): Verify that the XcpR calls the confirmation
        interface of the upper layer (Xcp_CddTxConfirmation is called twice with the correct pdu id)
    18. VP: bug-fix ASCXCPR-86: Verify that expected data is transmitted to XCP master using correct PDU ID (2 different PDU IDs)
    19. Set the result as success
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.XcpRMultipleSlaves.Mode_0</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>122</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.AdaptBusInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>147</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.CheckStatusConnection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>XcpR.Impl.TxConfirmation.UpperLayer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>160</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>592</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_XCPR_GEN_InvalidRef_SoAdRxSocketConnOrSocketConnBundleRef</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Generic/IN/XcpR_GenTest_SoAd_InvalidRef/source/application/EbTest_Config.h</sourcefile>
      <sourceline>27</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Check the following code generator error: "Invalid value for node SoAdRxSocketConnOrSocketConnBundleRef: Invalid reference."
      when the configured master source from XcpR is XCPR_CONNECTION_OVER_ETHERNET (UDP) and the SoAdRxSocketConnOrSocketConnBundleRef
      corresponding to master source has an invalid value.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    VP: Check if an error is trown if a bad configuration is given.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.dsn.GeneralDescription</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>411</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.PrecompileTimeConfig</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>423</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>593</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_XCPR_GEN_InvalidSoAdConfiguration_SameEcuCPdu</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Generic/IN/XcpR_GenTest_SoAd_InvalidSoAdRoute/source/application/EbTest_Config.h</sourcefile>
      <sourceline>27</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Check the following code generator error:
        "More than one configuration instances for the EcuC PDU referenced from the current RX XcpR source were found into the
         given SoAd configuration. It is allowed to have that PDU referenced just once (refer to 'SoAdRxPduRef')"
        "More than one configuration instances for the EcuC PDU referenced from the current TX XcpR destination were found into the
         given SoAd configuration. It is allowed to have that PDU referenced just once (refer to 'SoAdTxPduRef')"
      when the Rx/Tx Pdu Id from XcpR configuration (source/destination) is referenced in multiple entries from SoAd (SoAdSocketRoute/SoAdPduRoute).
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    VP: Check if an error is thrown if a bad configuration is given.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.dsn.GeneralDescription</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>411</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.PrecompileTimeConfig</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>423</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>594</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_XCPR_GEN_InvalidXdmCheck_LocalXcpNotShareSimilarTxPduId</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Generic/IN/XcpR_GenTest_XdmCheck_01/source/application/EbTest_Config.h</sourcefile>
      <sourceline>27</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Check the following code generator error:
      "The XcpR configuration contains a TxSource which does not share a similar TxPduId EcuC
      reference as a TxPdu from the Xcp configuration. As a consequence, the XcpTxPduId for
      TxConfirmation cannot be derived"
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    VP: Check if an error is trown if a bad configuration is given.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.dsn.GeneralDescription</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>411</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.PrecompileTimeConfig</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>423</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>595</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_XCPR_GEN_InvalidXdmCheck_LocalXcpNotShareSimilarRxPduId</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Generic/IN/XcpR_GenTest_XdmCheck_02/source/application/EbTest_Config.h</sourcefile>
      <sourceline>27</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Check the following code generator error:
      "The XcpR configuration contains a RxDestination which does not share a similar RxPduId
      EcuC reference as a RxPdu from the Xcp configuration. As a consequence, the XcpRxPduId
      for Xcp_RxIndication() cannot be derived."
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    VP: Check if an error is trown if a bad configuration is given.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.dsn.GeneralDescription</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>411</internalId></provcov>
        <provcov>
          <linksto>XcpR.dsn.PrecompileTimeConfig</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>423</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>596</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_XCPR_MSG_QUEUE_7</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Implementation/IN/XcpR_ImpTest_MsgQueue/source/application/EbTest.c.m4</sourcefile>
      <sourceline>36</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Verifies the queue is correctly updated and read via the get API's when the
    message payload is contained both at the end and the beginning of the queue
    (this happens in case of a roll over).
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    01: Ensure the queue initial head position is set in such a way
        that the message payload will require the queue to be rolled over
    02: Insert the message
    03: Verify that the get API's return the correct values and the queue
        is correctly updated afterwards
    04: Dequeue the message
    05: Ensure the head and the tail are equal
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.ConfigurableInternalQueue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>148</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>597</internalId></specobject>
    <specobject>
      <id>TS_XCPR_MSG_QUEUE_6</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Implementation/IN/XcpR_ImpTest_MsgQueue/source/application/EbTest.c.m4</sourcefile>
      <sourceline>107</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Stress test for the XcpR message queue. Random messages are inserted then removed and various
    consistency checks are done at each step to ensure the queue is correctly updated.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    01:  Ensure the random number generator uses a different seed
         each time the test is executed
    02:  Initialize the queue in such a way that each time the head
         and tail are at a random initial position
    03:  Generate a message with a random length
    04b: If the message can still fit into the queue, insert it
    04a: If the message cannot fit into the queue, remove a random
         number of elements from the queue
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.ConfigurableInternalQueue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>148</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>598</internalId></specobject>
    <specobject>
      <id>TS_XCPR_MSG_QUEUE_5</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Implementation/IN/XcpR_ImpTest_MsgQueue/source/application/EbTest.c.m4</sourcefile>
      <sourceline>218</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Verifies that XcpR_InsertMsgInQueue returns E_NOT_OK when a new message cannot be inserted due
    to the queue not having sufficient space.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    01: Insert a message larger than the available queue space and verify
        that XcpR_InsertMsgInQueue returns E_NOT_OK
    02: Ensure that the queue hasn't been modified in any way
    03: Insert a message smaller than the available queue space and verify
        that XcpR_InsertMsgInQueue returns E_OK
    04: Ensure that the queue has been correctly updated
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.ConfigurableInternalQueue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>148</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>599</internalId></specobject>
    <specobject>
      <id>TS_XCPR_MSG_QUEUE_4</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Implementation/IN/XcpR_ImpTest_MsgQueue/source/application/EbTest.c.m4</sourcefile>
      <sourceline>282</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Verifies the XcpR message queue functionality by first inserting a fixed size message at an arbitrary
    position and then inserting a second message with a variable size immediately after.
    XcpR_ReadMsgLength, XcpR_ReadMsgSrcPduId, XcpR_ReadMsgSrcPduType, XcpR_ReadMsgFirstByte, XcpR_ReadMsgSecondByte,
    XcpR_GetMsgLength, XcpR_GetMsgSrcPduId, and XcpR_GetMsgSrcPduType API's are used to ensure the queue was updated
    correctly.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    01: Insert the first message
    02: Dequeue the first message
    03: Check the dequeued message is correct
    04: Insert the second message
    05: Dequeue the second message
    06: Check the dequeued message is correct
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.ConfigurableInternalQueue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>148</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>600</internalId></specobject>
    <specobject>
      <id>TS_XCPR_MSG_QUEUE_3</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Implementation/IN/XcpR_ImpTest_MsgQueue/source/application/EbTest.c.m4</sourcefile>
      <sourceline>427</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Verifies the XcpR_ReadMsgLength, XcpR_ReadMsgSrcPduId, XcpR_ReadMsgSrcPduType,
    XcpR_ReadMsgFirstByte, XcpR_ReadMsgSecondByte, XcpR_GetMsgLength, XcpR_GetMsgSrcPduId,
    XcpR_GetMsgSrcPduType API's.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    01: Flush the XcpR message queue
    02: Enqueue 10 bytes
    03: Ensure the API's that read and get the various queue fields
        return the expected values and that the queue is updated
        accordingly after the get API's are called.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.ConfigurableInternalQueue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>148</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>601</internalId></specobject>
    <specobject>
      <id>TS_XCPR_MSG_QUEUE_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Implementation/IN/XcpR_ImpTest_MsgQueue/source/application/EbTest.c.m4</sourcefile>
      <sourceline>515</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Verifies the XcpR_EnqueueByteInMsgQueue and XcpR_IsMsgQueueEmpty API's.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    01: Flush the XcpR message queue
    02: Check XcpR_IsMsgQueueEmpty returns TRUE
    03: Enqueue one byte
    04: Verify that XcpR_IsMsgQueueEmpty returns FALSE
    05: Enqueue multiple bytes and verify XcpR_IsMsgQueueEmpty returns FALSE
        and that the queue is not rolled over yet
    06: Enqueue one last byte so TST_MSG_QUEUE_SIZE is reached
    07: Verify that the queue is now rolled over
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.ConfigurableInternalQueue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>148</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>602</internalId></specobject>
    <specobject>
      <id>TS_XCPR_MSG_QUEUE_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_XcpR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_XcpR/test/ts5/Implementation/IN/XcpR_ImpTest_MsgQueue/source/application/EbTest.c.m4</sourcefile>
      <sourceline>591</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Verifies if the XcpR_FlushMsgQueue API works correctly.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    01: Flush the XcpR message queue
    02: Check the XcpR message queue is properly initialized:
        - head and tail are 0
        - number of bytes is 0
        - flag if the tail is rolled over is FALSE
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>XcpR.Impl.ConfigurableInternalQueue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>148</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>603</internalId></specobject>
  </specobjects>
  </specdocument>
  <violations/>
  <oreqmViolations/>
</tracingresults>
