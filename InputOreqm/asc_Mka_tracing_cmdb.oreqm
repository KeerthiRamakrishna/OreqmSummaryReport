<?xml version="1.0" encoding="UTF-8"?>
<tracingresults>
  <environment>
    <toolname>ReqM2</toolname>
    <toolversion>1.30.0 (stable)</toolversion>
    <toolcopyright>Copyright 2010 - 2018 Elektrobit Automotive GmbH</toolcopyright>
    <libxmlversion>2.0207</libxmlversion>
    <libxml2compileversion>2.9.10</libxml2compileversion>
    <libxml2runtimeversion>20912</libxml2runtimeversion>
    <perlversion>v5.32.1</perlversion>
    <perlptrsize>64</perlptrsize>
    <commandline>-t -q -o asc_Mka_tracing_cmdb.oreqm -O /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/TestProtocols/LogBase/requirements -c /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_PluginBuildEnv/common/config/AutoCoreReqM2Rules_RMP4_0.xml -s approved,rejected --wfatal WDUPLICATEID,WDUPLICATEIDANDVER /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/build/reqm/ReqM2_Native/asc_Mka_public_modulereference_integration_req.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/build/reqm/ReqM2_Native/asc_Mka_requirements_EcuC.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/build/reqm/ReqM2_Native/asc_Mka_requirements_IEEE_802.1X_11_Eapol.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/build/reqm/ReqM2_Native/asc_Mka_requirements_IEEE_802.1X_9_15_MkaParticipantTimerValues.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/build/reqm/ReqM2_Native/asc_Mka_requirements_IEEE_802.1X_9_2_MkaProtocol.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/build/reqm/ReqM2_Native/asc_Mka_requirements_IEEE_802.1X_9_3_MkaKeyHierarchy.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/build/reqm/ReqM2_Native/asc_Mka_requirements_IEEE_802.1X_9_4_MkaTransport.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/build/reqm/ReqM2_Native/asc_Mka_requirements_IEEE_802.1X_9_5_KeyServerElection.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/build/reqm/ReqM2_Native/asc_Mka_requirements_Mka_SWS_R22-11.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/build/reqm/ReqM2_Native/asc_Mka_requirements_manConfTests.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/build/reqm/ReqM2_Native/asc_Mka_requirements_rfc3394.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/build/reqm/ReqM2_GenericImporter/reqm_DEV.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/build/reqm/ReqM2_GenericImporter/reqm_IMPL.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/build/reqm/ReqM2_GenericImporter/reqm_IMPLXML.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/build/reqm/ReqM2_DocBookImporter/reqm_SWDD.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/build/reqm/ReqM2_OldCImporter/reqm_SWUTS_LEGACY.reqm</commandline>
    <timestamp>Mon Jun 17 19:39:14 2024</timestamp>
  </environment>
  <cmdline>
    <cmdparam>
      <name>I</name>
      <values>
        <value>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/TestProtocols/LogBase/requirements</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>O</name>
      <values>
        <value>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/TestProtocols/LogBase/requirements</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>c</name>
      <values>
        <value>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_PluginBuildEnv/common/config/AutoCoreReqM2Rules_RMP4_0.xml</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>o</name>
      <values>
        <value>asc_Mka_tracing_cmdb.oreqm</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>q</name>
    </cmdparam>
    <cmdparam>
      <name>s</name>
      <values>
        <value>approved</value>
        <value>rejected</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>t</name>
    </cmdparam>
    <cmdparam>
      <name>wfatal</name>
      <values>
        <value>WDUPLICATEID</value>
        <value>WDUPLICATEIDANDVER</value>
      </values>
    </cmdparam>
  </cmdline>
  <inputfiles>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/build/reqm/ReqM2_Native/asc_Mka_public_modulereference_integration_req.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/build/reqm/ReqM2_Native/asc_Mka_requirements_EcuC.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/build/reqm/ReqM2_Native/asc_Mka_requirements_IEEE_802.1X_11_Eapol.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/build/reqm/ReqM2_Native/asc_Mka_requirements_IEEE_802.1X_9_15_MkaParticipantTimerValues.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/build/reqm/ReqM2_Native/asc_Mka_requirements_IEEE_802.1X_9_2_MkaProtocol.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/build/reqm/ReqM2_Native/asc_Mka_requirements_IEEE_802.1X_9_3_MkaKeyHierarchy.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/build/reqm/ReqM2_Native/asc_Mka_requirements_IEEE_802.1X_9_4_MkaTransport.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/build/reqm/ReqM2_Native/asc_Mka_requirements_IEEE_802.1X_9_5_KeyServerElection.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/build/reqm/ReqM2_Native/asc_Mka_requirements_Mka_SWS_R22-11.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/build/reqm/ReqM2_Native/asc_Mka_requirements_manConfTests.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/build/reqm/ReqM2_Native/asc_Mka_requirements_rfc3394.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/build/reqm/ReqM2_GenericImporter/reqm_DEV.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/build/reqm/ReqM2_GenericImporter/reqm_IMPL.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/build/reqm/ReqM2_GenericImporter/reqm_IMPLXML.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/build/reqm/ReqM2_DocBookImporter/reqm_SWDD.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/build/reqm/ReqM2_OldCImporter/reqm_SWUTS_LEGACY.reqm</inputfile>
  </inputfiles>
  <configuration>
    <doctypes>
    <regexs>
      <!-- external level -->
      <regex>creq</regex>       <!-- since 10/1018: introduced for updated tracing model-->

      <!-- product line level -->
      <regex>fea</regex>
      <regex>swpad</regex>      <!-- since 10/1018: introduced for updated tracing model-->
      <regex>swts</regex>

      <!-- bundle level -->
      <regex>swrs</regex>
      <regex>swad</regex>
      <regex>swintts</regex>

      <!-- module level -->
      <regex>swdd</regex>
      <regex>swurs</regex>      <!-- since 10/1018: introduced for updated tracing model-->
      <regex>swmts</regex>      <!-- since 01/1010: introduced for updated tracing model RMP4.0-->
      <regex>swuts</regex>
      <regex>impl</regex>

      <!-- legacy items -->
      <regex>dev</regex>
      <regex>man</regex>
      <regex>lim</regex>
    </regexs>
  </doctypes>
    <rules>
    <!-- The Ruleset for RMP4.0 is currently identical to the previous rule set. This rule is
        intoduce to show that the right file is uses. It will be removed when the RMP4.0 rule set is
    reworked -->
    <rule>
      <name>INFO.Rule set RMP4.0</name>
      <description>This rules indicates that RMP4.0 rule set is used.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(./status!='approved') and (./status!='rejected')]</applyto>
          <condition>false()</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>WRN.general.doctypes</name>
      <description>The used doctype is not part of the tracing model</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobjects/@doctype</applyto>
          <condition>((. != 'creq') or (. != 'fea') or (. != 'swpad') or (. != 'swts') or (. != 'swrs') or (. !='swad') or (. != 'swintts') or (.!= 'swdd') or (. != 'swurs') or (. != 'swmts') or (. != 'swuts') or (. != 'impl') or (. != 'dev') or (. != 'man') or (. != 'lim'))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.general.status</name>
      <description>All specification objects must be either in status=approved or in status=rejected. Other
        statuses are not allowed. How to fix: Set status to rejected or approved.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(./status!='approved') and (./status!='rejected')]</applyto>
          <condition>false()</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.general.rejected</name>
      <description>Status status=rejected is only allowed for requirements. How to fix: set to approved for specification object that are not requirements.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype!='swrs')  and (../@doctype!='swmrs') and (../@doctype!='swurs') and (./status='rejected')]</applyto>
          <condition>false()</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.general.comment</name>
      <description>Specification objects with status=rejected shall have a comment or rationale that
        starts with on of the following texts: "This requirement is informational only", "This requirement is not applicable".
        How to fix: Add some text starting with "This requirement is informational only"
        or "This requirement is not applicable" to either the comment or to the rationale.
        Comment: Implementation of check checks for contains instead of starts-with since there is
        no trim function in the used XPATH engine.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(./status='rejected')]</applyto>
          <condition>contains(./comment,"This requirement is informational only") or contains(./rationale,"This requirement is informational only") or contains(./comment,"This requirement is not applicable") or contains(./rationale,"This requirement is not applicable")</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.general.rejected.coverage</name>
      <description>Specification objects with status=rejected shall not need coverage. How to fix: remove need for coverage.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(./status='rejected')]</applyto>
          <condition>count(./needscoverage)=0</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swurs.needscoverage.count</name>
      <description>Unit requirements with status=approved need to be covered, exceptions from
      this rule: configuration requirements (postfix "_CONF" or "_Conf" or prefix "ECUC_") and requirements with
      a comment starting with "The adherence to this requirement is ensured by the following
      release check (URL to the checklist template plus ID of the check):".
      How to fix: Provide a needsobj element for those specobjects or comment according to the rule.
      </description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swurs') and (./status='approved') and count(./needscoverage/needsobj)=0 and count(./fulfilledby/ffbObj)=0]</applyto>
          <!--This condition is false if the id of a specification object does not end with '_Conf' or '_CONF' or does not start with ECUC_ -->
          <condition>substring-after(./id,"ECUC_")!="" or substring-before(./id,"_Conf")!="" or substring-before(./id,"_CONF")!="" or contains(./comment,"The adherence to this requirement is ensured by the following release check (URL to the checklist template plus ID of the check):")</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swurs.needscoverage.rationale</name>
      <description>Requirements with status=approved and without coverage needs that are
        configuration requirements (postfix "_CONF" or "_Conf" or prefix "ECUC_") shall have a comment or rationale
        with the following text: "This is a configuration parameter requirement without functional
        specification.". How to fix: Add some text starting with "This is a configuration parameter
        requirements without functional specification" to either the comment or to the rationale.</description>
      <regexchecks>
        <regexcheck>
          <applyto>//specobject[(../@doctype='swurs') and (./status='approved') and count(./needscoverage/needsobj)=0 and (substring-after(./id,"ECUC_")!="" or substring-before(./id,"_CONF")!="" or substring-before(./id,"_Conf")!="")]</applyto>
          <regex>This is a configuration parameter requirement without functional specification.</regex>
        </regexcheck>
      </regexchecks>
    </rule>

    <rule>
      <name>ERR.swrs.needscoverage.rationale</name>
      <description>Requirements with status=approved and without coverage needs that are
        configuration requirements (postfix "_CONF" or "_Conf" or prefix "ECUC_") shall have a comment or rationale
        with the following text: "This is a configuration parameter requirement without functional
        specification.". How to fix: Add some text starting with "This is a configuration parameter
        requirements without functional specification" to either the comment or to the rationale.</description>
      <regexchecks>
        <regexcheck>
          <applyto>//specobject[(../@doctype='swrs') and (./status='approved') and count(./needscoverage/needsobj)=0 and (substring-after(./id,"ECUC_")!="" or substring-before(./id,"_CONF")!="" or substring-before(./id,"_Conf")!="")]</applyto>
          <regex>This is a configuration parameter requirement without functional specification.</regex>
        </regexcheck>
      </regexchecks>
    </rule>

    <rule>
      <name>ERR.swurs.releases</name>
      <description>Requirements which originates from AUTOSAR (source tag contains term 'AUTOSAR_SWS', 'AUTOSAR_TPS',
        'AUTOSAR_ASWS' or 'AUTOSAR_TR') shall have their release tag set to 'AUTOSAR {major}.{minor}.{patch}' (e.g. 'AUTOSAR 4.3.0').
        Other requirements (including refinements of AUTOSAR requirements) must not contain any of the listed prefixes as
        part of the source tag.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swurs') and (contains(./source,'AUTOSAR_SWS') or contains(./source,'AUTOSAR_TPS') or contains(./source,'AUTOSAR_ASWS') or contains(./source,'AUTOSAR_TR'))]</applyto>
          <condition>contains(./releases/release,'AUTOSAR')</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swrs.releases</name>
      <description>Requirements which originates from AUTOSAR (source tag contains term 'AUTOSAR_SWS', 'AUTOSAR_TPS',
        'AUTOSAR_ASWS' or 'AUTOSAR_TR') shall have their release tag set to 'AUTOSAR {major}.{minor}.{patch}' (e.g. 'AUTOSAR 4.3.0').
        Other requirements (including refinements of AUTOSAR requirements) must not contain any of the listed prefixes as
        part of the source tag.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swrs') and (contains(./source,'AUTOSAR_SWS') or contains(./source,'AUTOSAR_TPS') or contains(./source,'AUTOSAR_ASWS') or contains(./source,'AUTOSAR_TR'))]</applyto>
          <condition>contains(./releases/release,'AUTOSAR')</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swdd.needscoverage.count</name>
      <description>Design elements with status=approved need to be covered.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swdd') and (./status='approved') and count(./needscoverage/needsobj)=0]</applyto>
          <condition>false()</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swurs.needscoverage.doctypes</name>
      <description>Requirements can be covered only by swurs, swad, dev, lim, swdd, impl, swuts, swmts, or man</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swurs')]</applyto>
          <condition>(./needscoverage/needsobj="swurs" or ./needscoverage/needsobj="swad" or ./needscoverage/needsobj="dev" or ./needscoverage/needsobj="lim" or ./needscoverage/needsobj="swdd" or ./needscoverage/needsobj="impl" or ./needscoverage/needsobj="swuts" or ./needscoverage/needsobj="swmts" or ./needscoverage/needsobj="man" or (count(./needscoverage/needsobj)=0))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swrs.needscoverage.doctypes</name>
      <description>Requirements of type swrs can be covered only by swrs, swurs, swad, swintts or man</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swrs')]</applyto>
          <condition>(./needscoverage/needsobj="swrs" or ./needscoverage/needsobj="swurs" or ./needscoverage/needsobj="swad" or ./needscoverage/needsobj="swuts" or ./needscoverage/needsobj="swintts" or ./needscoverage/needsobj="man" or (count(./needscoverage/needsobj)=0))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swdd.needscoverage.doctypes</name>
      <description>Design elements of type swdd can only be covered by swdd, swurs, impl, swuts, lim or man</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swdd')]</applyto>
          <condition>(./needscoverage/needsobj="swdd" or ./needscoverage/needsobj="swurs" or ./needscoverage/needsobj="impl" or ./needscoverage/needsobj="swuts" or ./needscoverage/needsobj="swmts" or ./needscoverage/needsobj="lim" or ./needscoverage/needsobj="man" or (count(./needscoverage/needsobj)=0))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.dev.needscoverage.count</name>
      <description>Deviations shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='dev')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swuts.needscoverage.count</name>
      <description>Test case sepecifications shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swuts')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swmts.needscoverage.count</name>
      <description>Test case sepecifications shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swmts')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swintts.needscoverage.count</name>
      <description>Test case sepecifications shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swintts')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swts.needscoverage.count</name>
      <description>Test case sepecifications shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swts')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.man.needscoverage.count</name>
      <description>Manual test cases shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='man')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.impl.needscoverage.count</name>
      <description>Source code shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='impl')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.lim.needscoverage.count</name>
      <description>Limitations shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='lim')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.fea.needscoverage.test</name>
      <description>Features shall be tested by software test ('swts') or manuel test ('man'). If no test is planned a justification shall be given.
                   A justification can be given in the futherinfo tag. The justification shall start with this rule name.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='fea')]</applyto>
          <condition>(
               ./needscoverage/needsobj="swts" or ./needscoverage/needsobj="man" or ./fulfilledby/ffbObj/ffbType="swts" or ./fulfilledby/ffbObj/ffbType="man" or contains(./furtherinfo,"fea.needscoverage.test") or contains(./furtherinfo,"fea.needscoverage.doctypes"))</condition>
        </conditioncheck>
      </conditionchecks>
          </rule>

    <rule>
      <name>WRN.fea.needscoverage.impl</name>
      <description>Features shall be covered by implementation fea, swrs, swad, swpad, swurs, man and swts. For lagacy features a justification is acceppted. A justification can be given in the futherinfo tag. The justification shall start with this rule name.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='fea')]</applyto>
          <condition>( ./needscoverage/needsobj="swrs" or ./fulfilledby/ffbObj/ffbType="swrs" or ./fulfilledby/ffbObj/ffbType="swad" or ./needscoverage/needsobj="swpad" or ./fulfilledby/ffbObj/ffbType="swpad" or ./needscoverage/needsobj="swurs" or ./fulfilledby/ffbObj/ffbType="swurs" or ./needscoverage/needsobj="fea" or ./fulfilledby/ffbObj/ffbType="fea" or contains(./furtherinfo,"fea.needscoverage.impl"))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>


    <rule>
      <name>ERR.swad.fulfilledby.doctypes</name>
      <description>Architectural design objects of type swad can only be covered by swurs, swad, swdd, swintts, man, otherwise they should be refined with swrs</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swad')]</applyto>
          <condition>(./fulfilledby/ffbObj/ffbType="swurs" or ./needscoverage/needsobj="swurs" or ./fulfilledby/ffbObj/ffbType="req" or ./needscoverage/needsobj="req" or ./fulfilledby/ffbObj/ffbType="swad" or ./needscoverage/needsobj="swad" or ./fulfilledby/ffbObj/ffbType="swdd" or ./fulfilledby/ffbObj/ffbType="swintts" or ./needscoverage/needsobj="swintts" or ./fulfilledby/ffbObj/ffbType="man" or ./needscoverage/needsobj="man") </condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swmts.providescoverage.doctypes</name>
      <description>Test case specifications (tcs) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='tcs')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.man.providescoverage.doctypes</name>
      <description>Manual test case specification (man) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='man')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

   <rule>
      <name>ERR.swuts.providescoverage.doctypes</name>
      <description>Software unit test case specification (swuts) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swuts')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

   <rule>
      <name>ERR.swintts.providescoverage.doctypes</name>
      <description>Software integration test case specification (swintts) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swintts')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

   <rule>
      <name>ERR.swts.providescoverage.doctypes</name>
      <description>Software test case specification (swts) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swts')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

  </rules>
    <oreqmRules>

        <rule>
            <name>WRN.swts.needscoverage.count</name>
            <description>Violated if there are more than 10 swts specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swts']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swts']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swts.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>
        <rule>
            <name>WRN.man.needscoverage.count</name>
            <description>Violated if there are more than 10 man specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='man']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='man']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>man.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>
        <rule>
            <name>WRN.swintts.needscoverage.count</name>
            <description>Violated if there are more than 10 swintts specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swintts']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swintts']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swintts.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>
        <rule>
            <name>WRN.swmts.needscoverage.count</name>
            <description>Violated if there are more than 10 swmts specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swmts']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swmts']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swmts.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swuts.needscoverage.count</name>
            <description>Violated if there are more than 10 swuts specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swuts']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swuts']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swuts.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swpad.needscoverage.count</name>
            <description>Violated if there are more than 10 swpad specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swpad']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swpad']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swpad.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swrs.needscoverage.count</name>
            <description>Violated if there are more than 10 swrs specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swrs']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swrs']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swrs.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swad.needscoverage.count</name>
            <description>Violated if there are more than 10 swad specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swad']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swad']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swad.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swurs.needscoverage.count</name>
            <description>Violated if there are more than 10 swurs specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swurs']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swurs']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swurs.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swdd.needscoverage.count</name>
            <description>Violated if there are more than 10 swdd specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swdd']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swdd']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swdd.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.impl.needscoverage.count</name>
            <description>Violated if there are more than 10 impl specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='impl']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='impl']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>impl.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swrs.fulfilledby.count</name>
            <description>Violated if there are more than 10 swrs specobjects as fulfilledby link to one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swrs'])) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swrs'])) &gt; 10]/furtherinfo</applyto>
                                        <regex>swrs.fulfilledby.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swad.fulfilledby.count</name>
            <description>Violated if there are more than 10 swad specobjects as fulfilledby link to one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swad'])) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swad'])) &gt; 10]/furtherinfo</applyto>
                                        <regex>swad.fulfilledby.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swurs.fulfilledby.count</name>
            <description>Violated if there are more than 10 swurs specobjects as fulfilledby link to one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swurs'])) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swurs'])) &gt; 10]/furtherinfo</applyto>
                                        <regex>swurs.fulfilledby.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swdd.fulfilledby.count</name>
            <description>Violated if there are more than 10 swdd specobjects as fulfilledby link to one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swdd'])) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swdd'])) &gt; 10]/furtherinfo</applyto>
                                        <regex>swdd.fulfilledby.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>
  </oreqmRules>
  </configuration>
  <specdocument>
    <specobjects doctype="lim">

    <specobject>
      <id>Mka.EB_INTREQ_Mka_0001</id>
      <status>approved</status>
      <source>EB integration requirement</source>
      <version>1</version>
      <description>
        The reinitialization process shall not interrupt other module functions.
        If reinitialization of the module is required, the call of
        <function>Mka_Init()</function> shall not interrupt other module functions.
      </description>
      <rationale>
        The reinitialization process resets all internal variables. Continuing an interrupted
        module function after reinitialization can lead to undefined module behaviour.
      </rationale>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>0</internalId></specobject>

    <specobject>
      <id>Mka.EB_INTREQ_Mka_0002</id>
      <status>approved</status>
      <source>EB integration requirement</source>
      <version>1</version>
      <description>
        <function>Mka_Init()</function> shall not be preempted by any other module API calls.
        It needs to be ensured that the function call <function>Mka_Init()</function> is not
        preempted by any other module API calls.
      </description>
      <rationale>
        During the call of <function>Mka_Init()</function> global variables and pointers get
        initialized. It is easy for the integrator to avoid this preemption, thus no data protection
        mechanism has been implemented for function <function>Mka_Init()</function>.
      </rationale>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1</internalId></specobject>

    <specobject>
      <id>Mka.EB_INTREQ_Mka_0003</id>
      <status>approved</status>
      <source>EB integration requirement</source>
      <version>1</version>
      <description>
        <para>
          The integrator shall ensure that the listed <code>Mka</code> lower layer functions and
          <code>Mka_MainFunction()</code> do not preempt each other.
        </para>
        <para>
          List of <code>Mka</code> lower layer functions:
          <code>Mka_LinkStateChange()</code>,
          <code>Mka_RxIndication()</code>,
          <code>Mka_TxConfirmation()</code>,
          <code>Mka_GetMacSecStatisticsNotification()</code>.
        </para>
        <para>
          In the classic AUTOSAR environment this can be achieved by setting
          EthIf and Eth driver in polling mode (e.g. disabling of <code>EthIfEnableRxInterrupt</code>,
          <code>EthCtrlEnableRxInterrupt</code>, <code>EthIfEnableTxInterrupt</code> and
          <code>EthCtrlEnableTxInterrupt</code>) to enforce that lower layer API are called only in the
          context of main functions. In addition all Eth stack main functions (e.g.
          <code>EthIf_MainFunctionRx()</code>, <code>EthIf_MainFunctionTx()</code>,
          <code>EthIf_MainFunctionState()</code>, <code>TcpIp_MainFunction()</code>,
          <code>TcpIp_MainFunctionTx()</code>, <code>EthSM_MainFunction()</code>,
          <code>SoAd_MainFunctionTx()</code>, <code>SoAd_MainFunction()</code>)
          need to be in the same Os task or have the same task priority as
          the module main functions to eliminate preemption.
        </para>
      </description>
      <rationale>
        This limitation reduces code size and execution time by eliminating the need for extensive
        use of exclusive areas.
      </rationale>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2</internalId></specobject>

    <specobject>
      <id>Mka.EB_INTREQ_Mka_0004</id>
      <status>approved</status>
      <source>EB integration requirement</source>
      <version>1</version>
      <description>
        The Integrator must assure that locally configured pre-shared keys (PSK) are read-in before the initialization of Mka.
      </description>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>3</internalId></specobject>

    <specobject>
      <id>Mka.EB_INTREQ_Mka_0005</id>
      <status>approved</status>
      <source>EB integration requirement</source>
      <version>1</version>
      <description>
        The Integrator must assure that either Dem preinit is configured and called before Mka is initialized or Dem module
        is initialized before Mka.
      </description>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>4</internalId></specobject>

    <specobject>
      <id>Mka.EB_INTREQ_Mka_0006</id>
      <status>approved</status>
      <source>EB integration requirement</source>
      <version>1</version>
      <description>
        The Integrator must assure that the following modules are initialized before Mka:
        NvR (non-volatile memory), Csm, Det and EthIf.
      </description>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>5</internalId></specobject>

    <specobject>
      <id>Mka.EB_INTREQ_Mka_0007</id>
      <status>approved</status>
      <source>EB integration requirement</source>
      <version>1</version>
      <description>
        <para>
          The integrator shall ensure that <code>Mka_HandleEvents()</code> API does not interrupt <code>Mka_MainFunction()</code>, nor
          any other Eth stack main functions listed in EB_INTREQ_Mka_0003.
          This can be achieved by calling this API from the Os task that has the same task priority as the task Mka is running in.
        </para>
      </description>
      <rationale>
        This API is used to trigger processing of an external asynchronous events received by Mka, e.g. crypto stack notifications,
        EthTrcv notifications, etc. In a normal operation these notifications are processed during <code>Mka_MainFunction()</code>
        tick, which introduces delays between the moment event is received and the moment it is processed.
        By calling this API, the caller, e.g. the process that delivered an event to Mka can request faster processing.
        However, it is important that the caller does not interrupt Mka_MainFunction(), in order to avoid sharing data between the two
        processes.
      </rationale>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>6</internalId></specobject>

  </specobjects>
    <specobjects doctype="swurs">

    <specobject>
      <id>EcuC_Timers.dsn.Api.InitTimerHandler</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Service Name:       EcuC_Timers_InitTimerHandler
        Syntax:             void EcuC_Timers_InitTimerHandler(
                                                               EcuC_Timers_TimerHandlerType    *TimerHandlerPtr,
                                                               EcuC_Timers_TimerHandlerCfgType *TimerHndCfgPtr
                                                             );
        Sync/Async:         Synchronous
        Reentrancy:         Non-reentrant
        Parameters (in):    TimerHandlerPtr      Timer handler pointer.
        Parameters (in):    TimerHndCfgPtr       Timer handler configuration pointer.
        Parameters (inout): None
        Parameters (out):   None
        Return value:       None
        Description:        This function initializes timer handler according to provided timer handler configuration TimerHndCfgPtr.
        Available via:      EcuC_Timers.h
      </description>
      <verifycrit>
        Verify that, after initializing and starting the timers, after the configured timeout has passed, the timeout counter has reached zero.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/EcuC_Timers.c_45</srcid><srcstatus/><internalId>527</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EcuC_Timers_01001_InitTimerHandler</srcid><srcstatus/><internalId>1793</internalId></linkedfrom><linkedfrom><srcid>EcuC_Timers_01020_InitTimerHandler_Failed</srcid><srcstatus/><internalId>1812</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>7</internalId></specobject>

    <specobject>
      <id>EcuC_Timers.dsn.Api.InitTimerHandler.Ignore</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If the EcuC_Timers_InitTimerHandler is called with parameters TimerHandlerPtr or TimerHndCfgPtr as a NULL_PTR, the call shall be ignored and no progress shall be made.
      </description>
      <verifycrit>
        Verify that if only TimerHandlerPtr was a NULL_PTR, the call was ignored (no timer has been started).
        Verify that if only TimerHndCfgPtr was a NULL_PTR, the call was ignored (no timer has been started).
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EcuC_Timers_01002_InitTimerHandler_Ignore</srcid><srcstatus/><internalId>1794</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>8</internalId></specobject>

    <specobject>
      <id>EcuC_Timers.dsn.Api.StartTimer</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Service Name:       EcuC_Timers_StartTimer
        Syntax:             void EcuC_Timers_StartTimer(
                                                         EcuC_Timers_TimerHandlerType *TimerHandlerPtr,
                                                         EcuC_Timers_GroupIdxType     GroupIdx,
                                                         EcuC_Timers_TimerIdxType     TimerIdxInGroup,
                                                         EcuC_Timers_TimerCounterType TimeoutValue
                                                       );
        Sync/Async:         Synchronous
        Reentrancy:         Non-reentrant
        Parameters (in):    TimerHandlerPtr      Timer handler pointer.
        Parameters (in):    GroupIdx             Timer group index.
        Parameters (in):    TimerIdxInGroup      Timer index in group.
        Parameters (in):    TimeoutValue         Timer timeout value.
        Parameters (inout): None
        Parameters (out):   None
        Return value:       None
        Description:        This function starts timer that will timeout after specified TimeoutValue and call timer callback that is set for specified group.
                            User needs to restart timer after timeout. Restart can also be done inside of callback.
        Available via:      EcuC_Timers.h
      </description>
      <verifycrit>
        Verify that, after starting the timer and after the timeout has passed, the timeout counter has reached zero.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/EcuC_Timers.h_144</srcid><srcstatus/><internalId>533</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EcuC_Timers_01000_AutoTestTimers</srcid><srcstatus/><internalId>1792</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>9</internalId></specobject>

    <specobject>
      <id>EcuC_Timers.dsn.Api.StartTimer.Ignore</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If the EcuC_Timers_StartTimer is called with parameter TimerHandlerPtr as a NULL_PTR, the call shall be ignored and no progress shall be made.
      </description>
      <verifycrit>
        Verify that if only TimerHandlerPtr was a NULL_PTR, the call was ignored (no timer has been started).
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EcuC_Timers_01003_StartTimer_Ignore</srcid><srcstatus/><internalId>1795</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>10</internalId></specobject>

    <specobject>
      <id>EcuC_Timers.dsn.Api.StartTimer.Uninitialized</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If the EcuC_Timers_StartTimer is called before timers were initialized with EcuC_Timers_InitTimerHandler(), the call shall be ignored and no progress shall be made.
      </description>
      <verifycrit>
        Verify that call to EcuC_Timers_StartTimer, before EcuC_Timers_InitTimerHandler, is ignored.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EcuC_Timers_01004_StartTimer_Uninitialized</srcid><srcstatus/><internalId>1796</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>11</internalId></specobject>

    <specobject>
      <id>EcuC_Timers.dsn.Api.StartTimerAutorepeat</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Service Name:       EcuC_Timers_StartTimerAutorepeat
        Syntax:             void EcuC_Timers_StartTimerAutorepeat(
                                                                   EcuC_Timers_TimerHandlerType *TimerHandlerPtr,
                                                                   EcuC_Timers_GroupIdxType     GroupIdx,
                                                                   EcuC_Timers_TimerIdxType     TimerIdxInGroup
                                                                 );
        Sync/Async:         Synchronous
        Reentrancy:         Non-reentrant
        Parameters (in):    TimerHandlerPtr      Timer handler pointer.
        Parameters (in):    GroupIdx             Timer group index.
        Parameters (in):    TimerIdxInGroup      Timer index in group.
        Parameters (inout): None
        Parameters (out):   None
        Return value:       None
        Description:        This function starts timer that will timeout after timeout value that is specified in GroupAutoRepeatValue and call timer callback
                            that is set for specified group. User does not need to restart timer after timeout. Timer will self restart with GroupAutoRepeatValue.
        Available via:      EcuC_Timers.h
      </description>
      <verifycrit>
        Verify that, after starting the timer and after the timeout has passed, the timeout counter has reached zero.
        Verifty that, a tick after that, timer started counting again.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/EcuC_Timers.h_161</srcid><srcstatus/><internalId>534</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EcuC_Timers_01000_AutoTestTimers</srcid><srcstatus/><internalId>1792</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>12</internalId></specobject>

    <specobject>
      <id>EcuC_Timers.dsn.Api.StartTimerAutorepeat.Ignore</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If the EcuC_Timers_StartTimerAutorepeat is called with parameter TimerHandlerPtr as a NULL_PTR, the call shall be ignored and no progress shall be made.
      </description>
      <verifycrit>
        Verify that if only TimerHandlerPtr was a NULL_PTR, the call was ignored (no timer has been started).
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EcuC_Timers_01005_StartTimerAutorepeat_Ignore</srcid><srcstatus/><internalId>1797</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>13</internalId></specobject>

    <specobject>
      <id>EcuC_Timers.dsn.Api.StartTimerAutorepeat.Uninitialized</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If the EcuC_Timers_StartTimerAutorepeat is called before timers were initialized with EcuC_Timers_InitTimerHandler(), the call shall be ignored and no progress shall be made.
      </description>
      <verifycrit>
        Verify that call to EcuC_Timers_StartTimerAutorepeat, before EcuC_Timers_InitTimerHandler, is ignored.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EcuC_Timers_01006_StartTimerAutorepeat_Uninitialized</srcid><srcstatus/><internalId>1798</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>14</internalId></specobject>

    <specobject>
      <id>EcuC_Timers.dsn.Api.StopTimer</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Service Name:       EcuC_Timers_StopTimer
        Syntax:             void EcuC_Timers_StopTimer(
                                                        EcuC_Timers_TimerHandlerType *TimerHandlerPtr,
                                                        EcuC_Timers_GroupIdxType     GroupIdx,
                                                        EcuC_Timers_TimerIdxType     TimerIdxInGroup
                                                      );
        Sync/Async:         Synchronous
        Reentrancy:         Non-reentrant
        Parameters (in):    TimerHandlerPtr      Timer handler pointer.
        Parameters (in):    GroupIdx             Timer group index.
        Parameters (in):    TimerIdxInGroup      Timer index in group.
        Parameters (inout): None
        Parameters (out):   None
        Return value:       None
        Description:        This function stops timer completely. If timer was paused it can not be resumed any more. Timer can only be started again.
        Available via:      EcuC_Timers.h
      </description>
      <verifycrit>
        Verify that, after stopping the timer, the counter changed to zero.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/EcuC_Timers.c_173</srcid><srcstatus/><internalId>529</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EcuC_Timers_01007_StopTimer</srcid><srcstatus/><internalId>1799</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>15</internalId></specobject>

    <specobject>
      <id>EcuC_Timers.dsn.Api.StopTimer.Ignore</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If the EcuC_Timers_StopTimer is called with parameter TimerHandlerPtr as a NULL_PTR, the call shall be ignored and no progress shall be made.
      </description>
      <verifycrit>
        Verify that if only TimerHandlerPtr was a NULL_PTR, the call was ignored (no timer has been stopped).
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EcuC_Timers_01008_StopTimer_Ignore</srcid><srcstatus/><internalId>1800</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>16</internalId></specobject>

    <specobject>
      <id>EcuC_Timers.dsn.Api.StopTimer.Uninitialized</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If the EcuC_Timers_StopTimer is called before timers were initialized with EcuC_Timers_InitTimerHandler(), the call shall be ignored and no progress shall be made.
      </description>
      <verifycrit>
        Verify that call to EcuC_Timers_StopTimer, before EcuC_Timers_InitTimerHandler, is ignored.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EcuC_Timers_01009_StopTimer_Uninitialized</srcid><srcstatus/><internalId>1801</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>17</internalId></specobject>

    <specobject>
      <id>EcuC_Timers.dsn.Api.PauseTimer</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Service Name:       EcuC_Timers_PauseTimer
        Syntax:             void EcuC_Timers_PauseTimer(
                                                         EcuC_Timers_TimerHandlerType *TimerHandlerPtr,
                                                         EcuC_Timers_GroupIdxType     GroupIdx,
                                                         EcuC_Timers_TimerIdxType     TimerIdxInGroup
                                                       );
        Sync/Async:         Synchronous
        Reentrancy:         Non-reentrant
        Parameters (in):    TimerHandlerPtr      Timer handler pointer.
        Parameters (in):    GroupIdx             Timer group index.
        Parameters (in):    TimerIdxInGroup      Timer index in group.
        Parameters (inout): None
        Parameters (out):   None
        Return value:       None
        Description:        This function pauses timer so that when resumed it will continue where it left off, meaning if there are total 100 ticks for a timer
                            and timer is paused after 40 ticks, when resumed timer will tick 60 times and timeout.
        Available via:      EcuC_Timers.h
      </description>
      <verifycrit>
        Verify that, after pausing the timer and after the timeout has passed, the timeout counter has not reached zero.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/EcuC_Timers.c_199</srcid><srcstatus/><internalId>530</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EcuC_Timers_01012_ResumeTimer</srcid><srcstatus/><internalId>1804</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>18</internalId></specobject>

    <specobject>
      <id>EcuC_Timers.dsn.Api.PauseTimer.Ignore</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If the EcuC_Timers_PauseTimer is called with parameter TimerHandlerPtr as a NULL_PTR, the call shall be ignored and no progress shall be made.
      </description>
      <verifycrit>
        Verify that if only TimerHandlerPtr was a NULL_PTR, the call was ignored (selected timer has not been paused).
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EcuC_Timers_01010_PauseTimer_Ignore</srcid><srcstatus/><internalId>1802</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>19</internalId></specobject>

    <specobject>
      <id>EcuC_Timers.dsn.Api.PauseTimer.Uninitialized</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If the EcuC_Timers_PauseTimer is called before timers were initialized with EcuC_Timers_InitTimerHandler(), the call shall be ignored and no progress shall be made.
      </description>
      <verifycrit>
        Verify that call to EcuC_Timers_PauseTimer, before EcuC_Timers_InitTimerHandler, is ignored.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EcuC_Timers_01011_PauseTimer_Uninitialized</srcid><srcstatus/><internalId>1803</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>20</internalId></specobject>

    <specobject>
      <id>EcuC_Timers.dsn.Api.ResumeTimer</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Service Name:       EcuC_Timers_ResumeTimer
        Syntax:             void EcuC_Timers_ResumeTimer(
                                                          EcuC_Timers_TimerHandlerType *TimerHandlerPtr,
                                                          EcuC_Timers_GroupIdxType     GroupIdx,
                                                          EcuC_Timers_TimerIdxType     TimerIdxInGroup
                                                        );
        Sync/Async:         Synchronous
        Reentrancy:         Non-reentrant
        Parameters (in):    TimerHandlerPtr      Timer handler pointer.
        Parameters (in):    GroupIdx             Timer group index.
        Parameters (in):    TimerIdxInGroup      Timer index in group.
        Parameters (inout): None
        Parameters (out):   None
        Return value:       None
        Description:        This function resumes timer previously paused with EcuC_Timers_PauseTimer().
        Available via:      EcuC_Timers.h
      </description>
      <verifycrit>
        Verify that, after starting and then pausing the timer, between two ticks the counter has not changed.
        Verify that, after the timer has been resumed and the timeout passed, the timeout counter has reached zero.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/EcuC_Timers.c_226</srcid><srcstatus/><internalId>531</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EcuC_Timers_01012_ResumeTimer</srcid><srcstatus/><internalId>1804</internalId></linkedfrom><linkedfrom><srcid>EcuC_Timers_01014_ResumeTimer_Uninitialized</srcid><srcstatus/><internalId>1806</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>21</internalId></specobject>

    <specobject>
      <id>EcuC_Timers.dsn.Api.ResumeTimer.Ignore</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If the EcuC_Timers_ResumeTimer is called with parameter TimerHandlerPtr as a NULL_PTR, the call shall be ignored and no progress shall be made.
      </description>
      <verifycrit>
        Verify that if TimerHandlerPtr was a NULL_PTR, the call was ignored.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EcuC_Timers_01013_ResumeTimer_Ignore</srcid><srcstatus/><internalId>1805</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>22</internalId></specobject>

    <specobject>
      <id>EcuC_Timers.dsn.Api.ResumeTimer.Uninitialized</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If the EcuC_Timers_ResumeTimer is called before timers were initialized with EcuC_Timers_InitTimerHandler(), the call shall be ignored and no progress shall be made.
      </description>
      <verifycrit>
        Verify that call to EcuC_Timers_ResumeTimer, before EcuC_Timers_InitTimerHandler, is ignored.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EcuC_Timers_01014_ResumeTimer_Uninitialized</srcid><srcstatus/><internalId>1806</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>23</internalId></specobject>

    <specobject>
      <id>EcuC_Timers.dsn.Api.IsTimerStarted</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Service Name:       EcuC_Timers_IsTimerStarted
        Syntax:             Std_ReturnType EcuC_Timers_IsTimerStarted(
                                                                       EcuC_Timers_TimerHandlerType *TimerHandlerPtr,
                                                                       EcuC_Timers_GroupIdxType     GroupIdx,
                                                                       EcuC_Timers_TimerIdxType     TimerIdxInGroup
                                                                     );
        Sync/Async:         Synchronous
        Reentrancy:         Non-reentrant
        Parameters (in):    TimerHandlerPtr      Timer handler pointer.
        Parameters (in):    GroupIdx             Timer group index.
        Parameters (in):    TimerIdxInGroup      Timer index in group.
        Parameters (inout): None
        Parameters (out):   RetVal               Indicates if selected timer has been started and is active, or not.
        Return value:       None
        Description:        Function returns if selected timer is started or not.
        Available via:      EcuC_Timers.h
      </description>
      <verifycrit>
        Verify that, before starting the timer and calling EcuC_Timers_IsTimerStarted, the API returned E_NOT_OK.
        Verify that, after starting the timer and callin EcuC_Timers_IsTimerStarted, the API returned E_OK
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/EcuC_Timers.c_268</srcid><srcstatus/><internalId>532</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EcuC_Timers_01015_IsTimerStarted</srcid><srcstatus/><internalId>1807</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>24</internalId></specobject>

    <specobject>
      <id>EcuC_Timers.dsn.Api.IsTimerStarted.Ignore</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If the EcuC_Timers_IsTimerStarted is called with parameter TimerHandlerPtr as a NULL_PTR, the call shall be ignored and E_NOT_OK shall be returned.
      </description>
      <verifycrit>
        Verify that if TimerHandlerPtr was a NULL_PTR, the call was ignored and E_NOT_OK returned.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EcuC_Timers_01016_IsTimerStarted_Ignore</srcid><srcstatus/><internalId>1808</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>25</internalId></specobject>

    <specobject>
      <id>EcuC_Timers.dsn.Api.IsTimerStarted.Uninitialized</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If the EcuC_Timers_IsTimerStarted is called before timers were initialized with EcuC_Timers_InitTimerHandler(), the call shall be ignored and E_NOT_OK shall be returned.
      </description>
      <verifycrit>
        Verify that call to EcuC_Timers_IsTimerStarted, before EcuC_Timers_InitTimerHandler, is ignored.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EcuC_Timers_01017_IsTimerStarted_Uninitialized</srcid><srcstatus/><internalId>1809</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>26</internalId></specobject>

    <specobject>
      <id>EcuC_Timers.dsn.Api.ProcessTimerTimeout</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Service Name:       EcuC_Timers_ProcessTimerTimeout
        Syntax:             void EcuC_Timers_ProcessTimerTimeout(
                                                                  EcuC_Timers_TimerHandlerType *TimerHandlerPtr
                                                                );
        Sync/Async:         Synchronous
        Reentrancy:         Non-reentrant
        Parameters (in):    TimerHandlerPtr      Timer handler pointer.
        Parameters (inout): None
        Parameters (out):   None
        Return value:       None
        Description:        This functions should only be called when CurrentTimerValue == NextTimeoutValue, and is intended to be called from
                            ECUC_TIMERS_PROCESS function like macro.
                            It will loop through all timers and check for next closest timeout value, it will also call callbacks for time outed timers.
        Available via:      EcuC_Timers.h
      </description>
      <verifycrit>
        Verify that, after starting the selected timer and calling EcuC_Timers_ProcessTimerTimeout for number of times equal to that needed for a timeout
        of selected timer, the timeout counter reached zero and the callback function of that timer has been called.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/EcuC_Timers.c_97</srcid><srcstatus/><internalId>528</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EcuC_Timers_01000_AutoTestTimers</srcid><srcstatus/><internalId>1792</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>27</internalId></specobject>

    <specobject>
      <id>EcuC_Timers.dsn.Api.ProcessTimerTimeout.Ignore</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If the EcuC_Timers_ProcessTimerTimeout is called with parameter TimerHandlerPtr as a NULL_PTR, the call shall be ignored and no progress shall be made.
      </description>
      <verifycrit>
        Verify that if TimerHandlerPtr was a NULL_PTR, the call was ignored.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EcuC_Timers_01018_ProcessTimerTimeout_Ignore</srcid><srcstatus/><internalId>1810</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>28</internalId></specobject>

    <specobject>
      <id>EcuC_Timers.dsn.Api.ProcessTimerTimeout.Uninitialized</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If the EcuC_Timers_ProcessTimerTimeout is called before timers were initialized with EcuC_Timers_InitTimerHandler(), the call shall be ignored and no progress shall be made.
      </description>
      <verifycrit>
        Verify that call to EcuC_Timers_ProcessTimerTimeout, before EcuC_Timers_InitTimerHandler, is ignored.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EcuC_Timers_01019_ProcessTimerTimeout_Uninitialized</srcid><srcstatus/><internalId>1811</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>29</internalId></specobject>

  </specobjects>
    <specobjects doctype="swurs">

    <specobject>
      <id>Mka.8021X.Eapol.1</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 11 EAPOL PDUs</source>
      <version>1</version>
      <description>
        EAPOL PDUs (Protocol Data Unit) are exchanged between peer PAEs (Port Access Entity)
        to support authentication using EAP (Extensible Authentication Protocol),
        to support the MKA (MACsec Key Agreement protocol) and to announce network identities and
        other access point capabilities.
        It specifies the following:
          a) Rules for the transmission, addressing, and protocol identification of EAPOL PDUs.
          b) Assignment of the PAE Ethernet Type, to identify EAPOL PDUs.
          c) Rules for the representation and encoding of protocol fields as octets in EAPOL PDUs.
          d) A common structure for EAPOL PDUs.
          e) General rules for EAPOL PDU validation and protocol version handling.
          f) EAPOL Packet Types for use by peer client entities.
          g) EAPOL Packet Body validation and parameter encoding for each Packet Type.
      </description>
      <comment>
        This requirement is informational only.
        Only requirements related to MKA are specified in this file.
      </comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>30</internalId></specobject>

    <specobject>
      <id>Mka.8021X.Eapol.2</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 11.1 EAPOL PDU transmission, addressing and protocol identification</source>
      <version>1</version>
      <description>
        Each EAPOL PDU is transmitted as a single MAC service request, and received as a single
        MAC service indication, with the following parameters:
          a) Destination address.
          b) Source address.
          c) MSDU.
          d) Priority.
      </description>
      <comment>This requirement is informational only.</comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>31</internalId></specobject>

    <specobject>
      <id>Mka.8021X.Eapol.3</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 11.1.1 Destination MAC address</source>
      <version>1</version>
      <description>
        The destination address for each MAC service request used to transmit an EAPOL MPDU is an
        individual address associated with a peer PAE or a group address, as specified for media
        independent operation by Table 11-4. Where a group destination address is used, the choice
        of address depends on the potential scope of the connectivity association that includes the
        desired peer entities.
      </description>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.EB.Eapol.3</srcid><srcstatus/><internalId>33</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Mka.SingleEapolMkaGroupAddressSupported</srcid><srcstatus/><internalId>488</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0100.MkaTransport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>952</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>32</internalId></specobject>

    <specobject>
      <id>Mka.EB.Eapol.3</id>
      <status>approved</status>
      <version>1</version>
      <description>
        All MKPDUs are transmitted with MAC destination address specified in configuration parameter
        MkaMacDestinationAddress. The same address is used for ICV validation when MKPDU is received.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_RxTx_UnitTest01023_EthIf_Transmit_ParamCheck</srcid><srcstatus/><internalId>2336</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0100.MkaTransport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>952</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.Eapol.3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>32</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>33</internalId></specobject>

    <specobject>
      <id>Mka.8021X.Eapol.4</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 11.1.2 Source MAC address</source>
      <version>1</version>
      <description>
        The source address for each MAC service request used to transmit an EAPOL MPDU shall be an
        individual address associated with the service access point at which the request is made.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_RxTx.c_159</srcid><srcstatus/><internalId>800</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0100.MkaTransport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>952</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>34</internalId></specobject>

    <specobject>
      <id>Mka.8021X.Eapol.5</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 11.1.4 Ethertype use and encoding</source>
      <version>1</version>
      <description>
        All EAPOL MPDUs shall be identified using the PAE Ethernet Type value 0x888E.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_RxTx_UnitTest01009_ValidateMkpdu_InvalidEtherHeaderType</srcid><srcstatus/><internalId>2323</internalId></linkedfrom><linkedfrom><srcid>Mka_RxTx_UnitTest01023_EthIf_Transmit_ParamCheck</srcid><srcstatus/><internalId>2336</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_RxTx.c_336</srcid><srcstatus/><internalId>807</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0100.MkaTransport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>952</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>35</internalId></specobject>

    <specobject>
      <id>Mka.8021X.Eapol.6</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 11.2 Representation and encoding of octets</source>
      <version>1</version>
      <description>
        All EAPOL PDUs consist of an integral number of octets, numbered starting from 1 and
        increasing in the order that they are put into a MAC frame. The bits in each octet are
        numbered from 1 to 8, where 1 is the low-order bit. When consecutive octets are used to
        encode a binary number, the lower numbered octet contains the more significant bits of the
        binary number.
      </description>
      <comment>This requirement is informational only.</comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>36</internalId></specobject>

    <specobject>
      <id>Mka.8021X.Eapol.7</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 11.3 Common EAPOL PDU structure</source>
      <version>1</version>
      <description>
        The EAPOL PDU comprises the octets following the PAE Ethertype in an EAPOL MPDU. All EAPOL
        PDUs comprise:
        a) Protocol Version.
        b) Packet Type.
        c) Packet Body Length.
        d) (If Packet Body Length is non-zero) Packet Body. The parameters encoded within the
           Packet Body field, if present, are particular to each Packet Type.
      </description>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.8021X.Eapol.7.1</srcid><srcstatus/><internalId>38</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.7.2</srcid><srcstatus/><internalId>39</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.7.3</srcid><srcstatus/><internalId>40</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0100.MkaTransport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>952</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>37</internalId></specobject>

    <specobject>
      <id>Mka.8021X.Eapol.7.1</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 11.3.1 Protocol Version</source>
      <version>1</version>
      <description>
        Protocol Version field represents an unsigned binary number identifying the EAPOL protocol
        version supported by the transmitter. An implementation conforming to this specification
        shall use the value 0x03.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01007_KaYTransmitMKPDU</srcid><srcstatus/><internalId>2077</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.7</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>37</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0100.MkaTransport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>952</internalId></provcov>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>294</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>38</internalId></specobject>

    <specobject>
      <id>Mka.8021X.Eapol.7.2</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 11.3.2 Packet Type</source>
      <version>1</version>
      <description>
        Packet Type is one octet in length. An implementation conforming to MKA specification shall
        use the value 0x05. If Mka receives EAPOL PDU that has Payload Type different to 0x05, that
        PDU shall be discarded.
      </description>
      <comment>
        All other possible values outside of Table 11-3 of the Packet Type shall not be used,
        they are reserved for future extensions.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01007_KaYTransmitMKPDU</srcid><srcstatus/><internalId>2077</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.7</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>37</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0100.MkaTransport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>952</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>39</internalId></specobject>

    <specobject>
      <id>Mka.8021X.Eapol.7.3</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 11.3.3 Packet Body Length</source>
      <version>1</version>
      <description>
        Packet Body Length two octet field encodes an unsigned binary number that defines the length
        in octets of the Packet Body field. If there is no Packet Body, value shall be 0.
      </description>
      <comment>
        The case when Packet body is not present (i.e. Packet body length == 0) is not applicable for MKA use case - as specified in
        Mka.8021X.Eapol.11, at least  Basic parameter set is always present in MKPDU.
      </comment>
      <verifycrit>
        Receive EAPOL-MKA with correctly basic parameter set and set EAPOL body length to 0.
        Received message shall be discarded.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01007_KaYTransmitMKPDU</srcid><srcstatus/><internalId>2077</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_RxTx.c_345</srcid><srcstatus/><internalId>809</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.7</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>37</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0100.MkaTransport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>952</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>40</internalId></specobject>

    <specobject>
      <id>Mka.8021X.Eapol.7.4</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 11.3.4 Packet Body</source>
      <version>1</version>
      <description>
        If Packet Body Length is non-zero, a Packet Body parameters are encoded within the
        Packet Body field, if present, are particular to each Packet Type.
      </description>
      <comment>
        This requirement is informational only. Each of supported parameter sets are described in detail in other requirements.
      </comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>41</internalId></specobject>

    <specobject>
      <id>Mka.8021X.Eapol.8</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 11.4 Validation of received EAPOL PDUs</source>
      <version>1</version>
      <description>
        A received EAPOL PDU shall be processed as specified by Table 11-3 if and only if
          a) The destination MAC address of the MAC service indication is either the group address recognized
             by the receiving MSAP for the application scenario (see 11.1.1) or the individual MAC address
             of the MSAP used as the source address of transmitted MPDUs; and
          b) The received MPDU contains the PAE Ethernet Type encoded as specified in [Mka.8021X.Eapol.5]; and
          c) The received EAPOL PDU contains at least two octets, i.e., at least a Packet Type field; and
          d) The Packet Type is one of the values specified in Table 11-3, and the receiving EAPOL
             client(s) include a protocol entity of the appropriate type as specified in [Mka.8021X.Eapol.7.2].
          e) Table 11-4 specifies that the receiving EAPOL client receives individual destination addressed
             frames (if the destination address of the MPDU is an individual address) or group addressed frames
             (if the destination address is a group address).
          f) The Packet Body Length denotes a Packet Body that is contained within the octets of the received
             EAPOL MPDU.
      </description>
      <comment>
        IEEE 802.1X standard defines multiple Packet Types (as specified in table 11-3), but value
        (as specified in [Mka.8021X.Eapol.7.2]) is only relevant for MKA protocol implementation.
      </comment>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.8021X.Eapol.8.1</srcid><srcstatus/><internalId>43</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.8.3</srcid><srcstatus/><internalId>45</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.8.4</srcid><srcstatus/><internalId>46</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.8.5</srcid><srcstatus/><internalId>47</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.8.6</srcid><srcstatus/><internalId>48</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.8.7</srcid><srcstatus/><internalId>49</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.8.8</srcid><srcstatus/><internalId>50</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0100.MkaTransport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>952</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>42</internalId></specobject>

    <specobject>
      <id>Mka.8021X.Eapol.8.1</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 11.4 Validation of received EAPOL PDUs</source>
      <version>1</version>
      <description>
        A received EAPOL PDU shall be processed if and only if the destination MAC address of the
        MAC service indication is either the group address recognized by the receiving MSAP for the
        application scenario or the individual MAC address of the MSAP used as the source address of
        transmitted MPDUs.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Lib_UnitTest01001_CorrectlyCalledFunction</srcid><srcstatus/><internalId>2189</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.8</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>42</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0100.MkaTransport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>952</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>43</internalId></specobject>

    <specobject>
      <id>Mka.8021X.Eapol.8.2</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 11.4 Validation of received EAPOL PDUs</source>
      <version>1</version>
      <description>
        A received EAPOL PDU shall be processed if and only if the received MPDU contains the
        PAE Ethernet Type encoded as specified in [Mka.8021X.Eapol.5].
      </description>
      <comment>This requirement is informational only. This is a configurable parameter in Ethernet driver.</comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>44</internalId></specobject>

    <specobject>
      <id>Mka.8021X.Eapol.8.3</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 11.4 Validation of received EAPOL PDUs</source>
      <version>1</version>
      <description>
        A received EAPOL PDU shall be processed if and only if the received MPDU contains at least two octets.
      </description>
      <comment>Only the EAPOL-MKA is supported, which defines minimum MKPDU size of 32 octets [Mka.8021X.Eapol.27.2].</comment>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.8021X.Eapol.27.2</srcid><srcstatus/><internalId>71</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.8</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>42</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0100.MkaTransport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>952</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>45</internalId></specobject>

    <specobject>
      <id>Mka.8021X.Eapol.8.4</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 11.4 Validation of received EAPOL PDUs</source>
      <version>1</version>
      <description>
        A received EAPOL PDU shall be processed if and only if the received MPDU contains the
        Packet Type is one of the values specified in Table 11-3, and the receiving EAPOL client(s)
        include a protocol entity of the appropriate type as specified in [Mka.8021X.Eapol.7.2].
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_RxTx_UnitTest01024_Correct_Packet_Type</srcid><srcstatus/><internalId>2337</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.8</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>42</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0100.MkaTransport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>952</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>46</internalId></specobject>

    <specobject>
      <id>Mka.8021X.Eapol.8.5</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 11.4 Validation of received EAPOL PDUs</source>
      <version>1</version>
      <description>
        A received EAPOL PDU shall be processed if and only if the receiving EAPOL-MKA client
        receives group addressed frames and its destination is KaY.
      </description>
      <comment>
        IEEE 802.1X standard defines multiple Packet Type destination address but only KaY: Group
        Transmission is relevant for MKA protocol implementation.
        Table 11-4 specifies that the receiving EAPOL client receives individual destination addressed
        frames (if the destination address of the MPDU is an individual address) or group addressed frames
        (if the destination address is a group address).
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_RxTx_UnitTest01009_ValidateMkpdu_InvalidEtherHeaderType</srcid><srcstatus/><internalId>2323</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.8</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>42</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0100.MkaTransport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>952</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>47</internalId></specobject>

    <specobject>
      <id>Mka.8021X.Eapol.8.6</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 11.4 Validation of received EAPOL PDUs</source>
      <version>1</version>
      <description>
        A received EAPOL PDU shall be processed if and only if the Packet Body Length denotes a
        Packet Body that is contained within the octets of the received EAPOL MPDU.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_RxTx_UnitTest01025_PacketBodySize_Verification</srcid><srcstatus/><internalId>2338</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.8</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>42</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0100.MkaTransport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>952</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>48</internalId></specobject>

    <specobject>
      <id>Mka.8021X.Eapol.8.7</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 11.4 Validation of received EAPOL PDUs</source>
      <version>1</version>
      <description>
        If any of requirements from [Mka.8021X.Eapol.8.1] to [Mka.8021X.Eapol.8.6] are not fulfilled,
        the received EAPOL PDU shall be discarded.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_RxTx_UnitTest01009_ValidateMkpdu_InvalidEtherHeaderType</srcid><srcstatus/><internalId>2323</internalId></linkedfrom><linkedfrom><srcid>Mka_RxTx_UnitTest01024_Correct_Packet_Type</srcid><srcstatus/><internalId>2337</internalId></linkedfrom><linkedfrom><srcid>Mka_RxTx_UnitTest01025_PacketBodySize_Verification</srcid><srcstatus/><internalId>2338</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.8</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>42</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0100.MkaTransport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>952</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>49</internalId></specobject>

    <specobject>
      <id>Mka.8021X.Eapol.8.8</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 11.4 Validation of received EAPOL PDUs</source>
      <version>1</version>
      <description>
        Any octets following the Packet Body field in the frame conveying the EAPOL PDU shall be ignored.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01025_Eapol_8_8</srcid><srcstatus/><internalId>1714</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.8</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>42</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0100.MkaTransport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>952</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>50</internalId></specobject>

    <specobject>
      <id>Mka.8021X.Eapol.9</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 11.5 EAPOL protocol version handling</source>
      <version>1</version>
      <description>
        To ensure that backward compatibility is maintained between versions of this protocol, a version A protocol
        implementation shall interpret a received EAPOL PDU with protocol version number B as follows:
          a) Where B is greater than or equal to A, the EAPOL PDU shall be interpreted as if it carried the
             supported version number, A, as follows:
            1) All parameters that are defined in version A shall be interpreted in the manner specified for
               version A of the protocol.
            2) All parameters not defined in version A for the given EAPOL Packet Type shall be ignored.
            3) All octets that appear in the EAPOL PDU beyond the largest numbered octet defined for
               version A for the received EAPOL Packet Type shall be ignored.
          b) Where B is less than A, the EAPOL PDU shall be interpreted as specified for the version number,
             B, as follows:
            1) All parameters shall be interpreted in the manner specified for version B of the protocol.
            2) All parameters not defined in version B for the given EAPOL Packet Type shall be ignored.
            3) All octets that appear in the EAPOL PDU beyond the largest numbered octet defined for
               version B for the received EAPOL Packet Type shall be ignored.
      </description>
      <comment>Only version 3 is supported.</comment>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Mka.EapMkaOnlyVer3</srcid><srcstatus/><internalId>493</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0100.MkaTransport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>952</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>51</internalId></specobject>

    <specobject>
      <id>Mka.8021X.Eapol.10</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 11.11 EAPOL-MKA</source>
      <version>1</version>
      <description>
        The Packet Body of each EAPOL PDU with a Packet Type of EAPOL-MKA conveys an MKPDU. The use
        of MKPDU parameters by the MACsec Key Agreement protocol (MKA) is specified in Clause 9, this clause
        specifies their encoding. Validation checks applied to MKPDUs, beyond those specified in this clause
        (see [Mka.8021X.Eapol.7.2]) for EAPOL PDUs, are specified in [Mka.8021X.Eapol.6].
      </description>
      <comment>This requirement is informational only.</comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>52</internalId></specobject>

    <specobject>
      <id>Mka.8021X.Eapol.11</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 11.11 EAPOL-MKA</source>
      <version>1</version>
      <description>
        Each MKPDU (Figure 11-6) comprises a number of parameter sets. The first of these, the
        Basic Parameter Set, is always present, and is followed by zero or more further parameter
        sets, followed by the ICV.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01007_KaYTransmitMKPDU</srcid><srcstatus/><internalId>2077</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0100.MkaTransport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>952</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>53</internalId></specobject>

    <specobject>
      <id>Mka.8021X.Eapol.12</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 11.11 EAPOL-MKA</source>
      <version>1</version>
      <description>
        The ICV comprises the last 16 octets of the MKPDU, as indicated by the EAPOL Packet Body Length.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01000_PeriodicMkpduTransmission</srcid><srcstatus/><internalId>1688</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0100.MkaTransport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>952</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0103.IntegrityCheckValue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>955</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>54</internalId></specobject>

    <specobject>
      <id>Mka.8021X.Eapol.13</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 11.11 EAPOL-MKA</source>
      <version>1</version>
      <description>
        NOTE 1This standard contains a number of provisions to guard against obsolescence by future
        developments in cryptography, without presuming to anticipate what those developments might
        be. These include the ability to select different ICV algorithms and sizes. The ICV will
        comprise the final octets of the Packet Body, whatever its size.
      </description>
      <comment>This requirement is informational only.</comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>55</internalId></specobject>

    <specobject>
      <id>Mka.8021X.Eapol.14</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 11.11 EAPOL-MKA</source>
      <version>1</version>
      <description>
        MKPDU encoding, validation, and decoding follows EAPOLs versioning rules ([Mka.8021X.Eapol.6],
        [Mka.8021X.Eapol.9]). The Basic Parameter Set includes an MKA Version Identifier that
        (with other parameters in the basic set) advertises the capabilities of the transmitting
        MKA implementation. This information can be supplemented both by version specific parameters
        within the basic set and by optional sets. A consistent TLV encoding identifies each set and
        allows it to be skipped if unrecognized by the receiver. Addition of parameters to existing
        sets, and the addition of parameter sets whose support is mandatory for a given version, will
        be accompanied by an MKA Version Identifier increment.
      </description>
      <comment>This requirement is informational only.</comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>56</internalId></specobject>

    <specobject>
      <id>Mka.8021X.Eapol.15</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 11.11 EAPOL-MKA</source>
      <version>1</version>
      <description>
        This standard specifies the use of MKA Version Identifier 3.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01007_KaYTransmitMKPDU</srcid><srcstatus/><internalId>2077</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0100.MkaTransport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>952</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>57</internalId></specobject>

    <specobject>
      <id>Mka.8021X.Eapol.16</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 11.11 EAPOL-MKA, Figure 11-6</source>
      <version>1</version>
      <description>
        EAPOL-MKA Packet Body with MKPDU format:
        Parameter name                                               Size in Octets
        -----------------------------------------------------------------------------------
        Protocol Version                                                  1 Octet
        Packet Type = EAPOL-MKA                                           1 Octet
        Packet Body Length                                                2 Octet
        Packet Body
        {
          Basic Parameter set                                     Multiple of 4 Octets
          Parameter set                                           Multiple of 4 Octets
          Parameter set                                           Multiple of 4 Octets
        }
        ICV                                                               16 Octets
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01000_PeriodicMkpduTransmission</srcid><srcstatus/><internalId>1688</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0100.MkaTransport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>952</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>58</internalId></specobject>

    <specobject>
      <id>Mka.8021X.Eapol.17</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 11.11 EAPOL-MKA</source>
      <version>1</version>
      <description>
        The parameter set encoding is designed to retain quad word octet alignment of parameters
        encoded in 4 or more octets, while efficiently encoding parameters that occupy only a few
        bits, and comprises a 4 octet header that includes a length field, a variable (possibly zero)
        length body, and the fewest number of null padding octets required for the entire parameter
        set to occupy a multiple of four octets. See Figure 11-7.
      </description>
      <comment>This requirement is informational only.</comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>59</internalId></specobject>

    <specobject>
      <id>Mka.8021X.Eapol.18</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 11.11 EAPOL-MKA, Figure 11-7</source>
      <version>1</version>
      <description>
        MKPDUParameter set encoding:
        Parameter name                                  Bits range       Octet number
        -----------------------------------------------------------------------------
        Parameter set type or MKA Version Identifier      1..8                1
        Parameter set specific parameters                 1..8                2
        Parameter set specific parameters                 5..8                3
        Parameter set body length                         1..4                3
        Parameter set body length (cont.)                 1..8                4
        Parameter set body                                1..8                5  (4 + Parameter set body length)
        Padding (null octets)                             1..8                (5 + Parameter set body length)  multiple of 4 octets
      </description>
      <comment>This requirement is informational only.</comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>60</internalId></specobject>

    <specobject>
      <id>Mka.8021X.Eapol.19</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 11.11 EAPOL-MKA, Figure 11-7</source>
      <version>1</version>
      <description>
        NOTE 2IEEE Std 802.1Xbx-2014 added optional support for in-service upgrades including
        suspension of MKA operation and recovery of the most significant bits of the PN for
        MACsec Cipher Suites that use Extended Packet Numbering. The MKA Version Identifier was
        incremented to 2 by this amendment. A single optional parameter set was added, but there
        were also minor changes to the behavior of the CP state machine
        [as a consequence of changes to the specification of the state machine interface variable chgdServer (12.2)].
        Those behavioral changes removed any need for a suspended system to record the identify of
        the Key Server specifically, and also avoid disrupting secure connectivity if another
        participant that is already a CA member takes over the role of Key Server; they are
        transparent to other CA members that are using MKA Version 1.
      </description>
      <comment>This requirement is informational only.</comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>61</internalId></specobject>

    <specobject>
      <id>Mka.8021X.Eapol.20</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 11.11 EAPOL-MKA, Figure 11-7</source>
      <version>1</version>
      <description>
        NOTE 3The MKA Version Identifier was incremented to 3 by IEEE Std 802.1Xck-2018, which did
        not add any new parameter sets to this standard but did impose an ordering on entries in the
        Live Peer List and add the Key Server SSCI to the Live Peer List parameter set (9.10, Figure 11-9).
      </description>
      <comment>This requirement is informational only.</comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>62</internalId></specobject>

    <specobject>
      <id>Mka.8021X.Eapol.21</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 11.11 EAPOL-MKA, Figure 11-7</source>
      <version>1</version>
      <description>
        The parameter types specified in Table 11-6 are encoded as unsigned binary numbers
        ([Mka.8021X.Eapol.6]) within the fixed width field specified in the table. Where one or more
        parameters are encoded in a single octet, the bits used to encoded each parameter are specified
        in the figures for each parameter set, and bits in the octet that do not correspond to flags
        or other parameters defined for the MKPDUs MKA Version Identifier are reserved and shall be
        clear on transmission, i.e., shall take the value 0, and shall be ignored on receipt.
      </description>
      <comment>This requirement is informational only.</comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>63</internalId></specobject>

    <specobject>
      <id>Mka.8021X.Eapol.22</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 11.11.1 MKA parameter encoding</source>
      <version>1</version>
      <description>
        Bits in octets in parameter sets that are not allocated to flags or other parameters according
        to MKPDUs MKA Version Identifier, shall take the value 0, and shall be ignored on receipt.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01010_SakUse</srcid><srcstatus/><internalId>1699</internalId></linkedfrom><linkedfrom><srcid>Mka_ConTest01018_XPN</srcid><srcstatus/><internalId>1707</internalId></linkedfrom><linkedfrom><srcid>Mka_ConTest01023_XPN_ReserveBits_NegativeCase</srcid><srcstatus/><internalId>1712</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01031_MkpduCheckParameterSetTypeOrder</srcid><srcstatus/><internalId>2099</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01087_EbTest_Peer_Announcement_Bits_NegativeCase</srcid><srcstatus/><internalId>2155</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01088_EbTest_Dist_SAK_Reserved_Bits_NegativeCase</srcid><srcstatus/><internalId>2156</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01089_EbTest_Dist_SAK_Reserved_Bits_PositiveCase</srcid><srcstatus/><internalId>2157</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0100.MkaTransport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>952</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>64</internalId></specobject>

    <specobject>
      <id>Mka.8021X.Eapol.23</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 11.11.1 MKA parameter encoding</source>
      <version>1</version>
      <description>
        An SCI is encoded, as specified in Clause 9 and IEEE Std 802.1AE, in a fixed length field of
        eight octets.The CAK Name (CKN) (9.3.1, 6.2.2, 6.3.3) is encoded in a variable length sequence
        of octets within the parameter set body of the Basic Parameter Set.
      </description>
      <comment>This requirement is informational only.</comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>65</internalId></specobject>

    <specobject>
      <id>Mka.8021X.Eapol.24</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 11.11.1 MKA parameter encoding</source>
      <version>1</version>
      <description>
        On receipt of an MKPDU, a PAE that transmits MKPDUs with a given MKA Version Identifier
          a) Shall recognize and process each parameter set specified as mandatory for that version.
          b) May recognize and process parameter sets specified as optional for that version.
          c) Shall ignore any parameter set that is not specified as mandatory or optional for that version.
          d) Shall recognize and process each of the parameters, within each parameter set processed, that are
             specified as mandatory for that version.
          e) May recognize and process each of the parameters, within each parameter set processed, that are
             specified as optional for that version.
          f) Shall ignore any parameter that is not specified as mandatory or optional for that version.
      </description>
      <comment>This requirement is informational only.</comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>66</internalId></specobject>

    <specobject>
      <id>Mka.8021X.Eapol.25</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 11.11.1 MKA parameter encoding, Table 11-7</source>
      <version>1</version>
      <description>
        All parameter sets supported by the current implementation and all parameters form those
        parameter sets are supported in all 3 versions of Mka protocol (1, 2 and 3), with the
        following exception:
          1) Key Servers SSCI parameter in Live peer list is available in version 3 only. This parameter
             is only encoded in MKPDUs that contain a Distributed SAK, and ignored on receipt otherwise.
          2) Offset Confidentiality parameter in Distributed SAK isn't available only in version 1.
      </description>
      <comment>This requirement is informational only. TODO: check if this shall be rejected!</comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>67</internalId></specobject>

    <specobject>
      <id>Mka.8021X.Eapol.26</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 11.11.1 MKA parameter encoding, Figure 11-8</source>
      <version>1</version>
      <description>
        Basic Parameter Set:
        Parameter name                                  Bits range       Octet number
        -----------------------------------------------------------------------------
        MKA Version Identifier                            1...8               1
        Key Server Priority                               1...8               2
        Key Server                                          8                 3
        MACsec Desired                                      7                 3
        MACsec Capability                                 5...6               3
        Parameter set body length                         1...4               3
        Parameter set body length (cont.)                 1...8               4
        SCI                                               1...8               5  12
        Actors Member Identifier                         1...8               13  24
        Actors Message Number                            1...8               25  28
        Algorithm Agility                                 1...8               29  32
        CAK Name                                          1...8               33  (33 + size of CAK name - 1)
        Null padding octets                               1...8               (33 + size of CAK name) - multiple of 4 octets
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01007_KaYTransmitMKPDU</srcid><srcstatus/><internalId>2077</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0100.MkaTransport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>952</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>198</internalId></provcov>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00008.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>309</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>68</internalId></specobject>

    <specobject>
      <id>Mka.8021X.Eapol.27</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 11.11.2 Validation of MKPDUs</source>
      <version>1</version>
      <description>
        All received MKPDUs, irrespective of the conveyed value of the MKA Version Identifier,
        shall be discarded without ICV verification or further processing if any of the following
        conditions apply:
          a) The destination address of the MKPDU was an individual address.
          b) The MKPDU is less than 32 octets long.
          c) The MKPDU is not a multiple of 4 octets long.
          d) The MKPDU comprises fewer octets than indicated by the Basic Parameter Set body length, as
             encoded in bits 4 through 1 of octet 3 and bits 8 through 1 of octet 4, plus 16 octets of ICV.19
          e) The CAK Name is not recognized.
          f) If the Algorithm Agility parameter is unrecognized or not implemented by the receiver.
             Optionally its value can be recorded for diagnosis.
          Otherwise:
          g) If the Algorithm Agility parameter identifies an algorithm that has been implemented by the
             receiver, the ICV shall be verified as specified in [Mka.8021X.MkaTransport.6].
      </description>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.8021X.Eapol.27.1</srcid><srcstatus/><internalId>70</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.27.2</srcid><srcstatus/><internalId>71</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.27.3</srcid><srcstatus/><internalId>72</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.27.4</srcid><srcstatus/><internalId>73</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.27.5</srcid><srcstatus/><internalId>74</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.27.6</srcid><srcstatus/><internalId>75</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.27.7</srcid><srcstatus/><internalId>76</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0100.MkaTransport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>952</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>69</internalId></specobject>

    <specobject>
      <id>Mka.8021X.Eapol.27.1</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 11.11.2 Validation of MKPDUs</source>
      <version>1</version>
      <description>
        Discard MKPDU if the following condition apply:
        The destination address of the MKPDU was an individual address.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_RxTx_UnitTest01006_EAPOL_27_1_Through_4</srcid><srcstatus/><internalId>2320</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Lib.c_197</srcid><srcstatus/><internalId>712</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.27</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>69</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0100.MkaTransport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>952</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>70</internalId></specobject>

    <specobject>
      <id>Mka.8021X.Eapol.27.2</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 11.11.2 Validation of MKPDUs</source>
      <version>1</version>
      <description>
        Discard MKPDU if the following condition apply:
        The MKPDU is less than 32 octets long.
      </description>
      <comment>
        MKPDU length is EAPoL body length thus this requirement can be tested with
        Mka.8021X.Eapol.7.3
      </comment>
      <verifycrit>
        Test case 1 - Receive EAPOL-MKA with EAPoL body length (MKPDU length) set to less than 32.
                      Received message shall be discarded.
        Test case 2 - Receive EAPOL-MKA received data less than 32 + EAPOL header length.
                      Received message shall be discarded.
        Test case 3 - Receive incomplete EAPOL-MKA with correct EAPOL header and EAPOL body length set to more that 32
                      (e.g. Basic Parameter Set + Potential Peer List) with part of EAPOL body missing
                      (Mka_RxTx_RxIndication LenByte parameter lesser than MKPDU size but still larger
                      than minimum size 32 + EAPOL header size).
                      Received message shall be discarded.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01018_InstSM_RunningSelfTransition</srcid><srcstatus/><internalId>2086</internalId></linkedfrom><linkedfrom><srcid>Mka_RxTx_UnitTest01005_RxBufFree_2_WaitIcvVerFin_Fail</srcid><srcstatus/><internalId>2319</internalId></linkedfrom><linkedfrom><srcid>Mka_RxTx_UnitTest01010_ValidateMkpdu_MkpduWithInvalidLengths</srcid><srcstatus/><internalId>2324</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_RxTx.c_338</srcid><srcstatus/><internalId>808</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Mka_RxTx.c_348</srcid><srcstatus/><internalId>810</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.27</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>69</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0100.MkaTransport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>952</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.RxTx.Api.Mka_RxTx_RxIndication.LenByte</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1620</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.Eapol.8.3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>45</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>71</internalId></specobject>

    <specobject>
      <id>Mka.8021X.Eapol.27.3</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 11.11.2 Validation of MKPDUs</source>
      <version>1</version>
      <description>
        Discard MKPDU if the following condition apply:
        The MKPDU is not a multiple of 4 octets long.
      </description>
      <verifycrit>
       Receive MKPDU with Basic Parameter Set filled correctly except use e.g. 3 octets for CKN and do not add padding.
       Received message shall be discarded.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_RxTx_UnitTest01006_EAPOL_27_1_Through_4</srcid><srcstatus/><internalId>2320</internalId></linkedfrom><linkedfrom><srcid>Mka_RxTx_UnitTest01011_ValidateMkpdu_MkpduNotMultipleOf4</srcid><srcstatus/><internalId>2325</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_RxTx.c_351</srcid><srcstatus/><internalId>811</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.27</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>69</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0100.MkaTransport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>952</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>72</internalId></specobject>

    <specobject>
      <id>Mka.8021X.Eapol.27.4</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 11.11.2 Validation of MKPDUs</source>
      <version>1</version>
      <description>
        Discard MKPDU if the following condition apply:
        The MKPDU comprises fewer octets than indicated by the Basic Parameter Set body length, as
        encoded in bits 4 through 1 of octet 3 and bits 8 through 1 of octet 4, plus 16 octets of ICV.
      </description>
      <verifycrit>
        Receive MKPDU with correct basic parameter set of maximum size (CKN 32 octets) and set EAPOL body length
        to basic parameter length - 4.
        Received message shall be discarded.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_RxTx_UnitTest01006_EAPOL_27_1_Through_4</srcid><srcstatus/><internalId>2320</internalId></linkedfrom><linkedfrom><srcid>Mka_RxTx_UnitTest01012_ValidateMkpdu_IndividualPacketBodyLength</srcid><srcstatus/><internalId>2326</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_RxTx.c_362</srcid><srcstatus/><internalId>812</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.27</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>69</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0100.MkaTransport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>952</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>73</internalId></specobject>

    <specobject>
      <id>Mka.8021X.Eapol.27.5</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 11.11.2 Validation of MKPDUs</source>
      <version>1</version>
      <description>
        Discard MKPDU if the following condition apply:
        The CAK Name is not recognized.
      </description>
      <verifycrit>
        Receive MKPDU with CAK name not configured for that controlled port.
        Received message shall be discarded.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_RxTx_UnitTest01007_EAPOL_27_5_Through_6</srcid><srcstatus/><internalId>2321</internalId></linkedfrom><linkedfrom><srcid>Mka_RxTx_UnitTest01013_ValidateMkpdu_InvalidCkn</srcid><srcstatus/><internalId>2327</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_RxTx.c_374</srcid><srcstatus/><internalId>814</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.27</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>69</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0100.MkaTransport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>952</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>74</internalId></specobject>

    <specobject>
      <id>Mka.8021X.Eapol.27.6</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 11.11.2 Validation of MKPDUs</source>
      <version>1</version>
      <description>
        Discard MKPDU if the following condition apply:
        If the Algorithm Agility parameter is unrecognized or not implemented by the receiver, its value can
        be recorded for diagnosis.
      </description>
      <verifycrit>
        Receive MKPDU with Basic Parameter Set parameter Algorithm Agility set to other that IEEE Std 802.1X-2010 (0x0080c201).
        Received message shall be discarded.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_RxTx_UnitTest01007_EAPOL_27_5_Through_6</srcid><srcstatus/><internalId>2321</internalId></linkedfrom><linkedfrom><srcid>Mka_RxTx_UnitTest01014_ValidateMkpdu_NotSupportedAlgorithAgillty</srcid><srcstatus/><internalId>2328</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_RxTx.c_377</srcid><srcstatus/><internalId>815</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.27</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>69</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0100.MkaTransport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>952</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.MkaKeyHierarchy.29</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>75</internalId></specobject>

    <specobject>
      <id>Mka.8021X.Eapol.27.7</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 11.11.2 Validation of MKPDUs</source>
      <version>1</version>
      <description>
        If the Algorithm Agility parameter identifies an algorithm that has been implemented by the
        receiver, the ICV shall be verified as specified in [Mka.8021X.MkaTransport.6].
      </description>
      <verifycrit>
        Test case 1 - Receive MKPDU with correct Basic Parameter Set and ICV.
                      After ICV verification MKPDU should be passed on to Mka_KaY_RxMkpdu.
        Test case 2 - Receive MKPDU with correct Basic Parameter Set and incorrect ICV.
                      After ICV verification MKPDU should be discarded.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_RxTx_UnitTest01008_EAPOL_27_7</srcid><srcstatus/><internalId>2322</internalId></linkedfrom><linkedfrom><srcid>Mka_RxTx_UnitTest01015_ValidateMkpdu_IcvVerification</srcid><srcstatus/><internalId>2329</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_RxTx.c_426</srcid><srcstatus/><internalId>817</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.27</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>69</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0100.MkaTransport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>952</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>76</internalId></specobject>

    <specobject>
      <id>Mka.8021X.Eapol.28</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 11.11.3 Encoding MKPDUs</source>
      <version>1</version>
      <description>
        An implementation that transmits MKPDU PDUs with an MKA Version Identifier of 1, 2, or 3 shall encode
        the protocol parameters provided by the KaY as follows:
          a) The Basic Parameter Set is encoded in the initial octets of each MKPDU as specified in
             Figure 11-8 [Mka.8021X.Eapol.26].
          b) Each of the remaining parameter sets that are to be transmitted, with the exception of
             the Live Peer List, Potential Peer List, and ICV Indicator, are encoded as within the
             MKPDU in parameter set type number order (from low to high) as specified in Figure 11-10
             through Figure 11-13.
          c) If there are one or more Live Peers, their Member Identifier, Message Number tuples are
             encoded within a Live Peer List as specified in Figure 11-9. An implementation that
             transmits MKPDUs with an MKA Version Identifier of 3 shall order the entries in the
             Live Peer List and shall encode the Key Servers SSCI in Octet 2 of the Live Peer List
             parameter set of MKPDUs containing a Distributed SAK parameter set for use with an
             XPN Cipher Suite, as specified in 9.10.
          d) If there are one or more Potential Peers, the Member Identifier, Message Number tuples
             of the Potential Peers are encoded within a Potential Peer List as specified in Figure 11-9.
          e) If Algorithm Agility parameter (see Figure 11-8 [Mka.8021X.Eapol.26], 9.3.3) specifies
             the use of an ICV that is not 16 octets in length, the ICV Indicator is encoded as
             specified in Figure 11-16.
      </description>
      <comment>TODO: Add references to requirements that describe supported parameter sets.</comment>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.8021X.Eapol.28.1</srcid><srcstatus/><internalId>78</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.28.2</srcid><srcstatus/><internalId>79</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.28.3</srcid><srcstatus/><internalId>80</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.28.4</srcid><srcstatus/><internalId>81</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.28.5</srcid><srcstatus/><internalId>82</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0100.MkaTransport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>952</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>77</internalId></specobject>

    <specobject>
      <id>Mka.8021X.Eapol.28.1</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 11.11.3 Encoding MKPDUs</source>
      <version>1</version>
      <description>
        An implementation that transmits MKPDU PDUs with an MKA Version Identifier of 1, 2, or 3
        shall encode the protocol parameters provided by the KaY that:
        The Basic Parameter Set is encoded in the initial octets of each MKPDU as specified in
        Figure 11-8 [Mka.8021X.Eapol.26].
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01007_KaYTransmitMKPDU</srcid><srcstatus/><internalId>2077</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_1617</srcid><srcstatus/><internalId>656</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.28</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>77</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0100.MkaTransport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>952</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>78</internalId></specobject>

    <specobject>
      <id>Mka.8021X.Eapol.28.2</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 11.11.3 Encoding MKPDUs</source>
      <version>1</version>
      <description>
        An implementation that transmits MKPDU PDUs with an MKA Version Identifier of 1, 2, or 3
        shall encode the protocol parameters provided by the KaY that:
        Each of the remaining parameter sets that are to be transmitted, with the exception of
        the Live Peer List, Potential Peer List, and ICV Indicator, are encoded as within the
        MKPDU in parameter set type number order (from low to high) as specified in Figure 11-10
        through Figure 11-13.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01031_MkpduCheckParameterSetTypeOrder</srcid><srcstatus/><internalId>2099</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_1926</srcid><srcstatus/><internalId>677</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.28</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>77</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0100.MkaTransport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>952</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>79</internalId></specobject>

    <specobject>
      <id>Mka.8021X.Eapol.28.3</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 11.11.3 Encoding MKPDUs</source>
      <version>1</version>
      <description>
        An implementation that transmits MKPDU PDUs with an MKA Version Identifier of 1, 2, or 3
        shall encode the protocol parameters provided by the KaY that:
        If there are one or more Live Peers, their Member Identifier, Message Number tuples are
        encoded within a Live Peer List as specified in [Mka.EB.Eapol.30] (Figure 11-9).
        An implementation that transmits MKPDUs with an MKA Version Identifier of 3 shall order the entries in the
        Live Peer List and shall encode the Key Servers SSCI in Octet 2 of the Live Peer List
        parameter set of MKPDUs containing a Distributed SAK parameter set for use with an
        XPN Cipher Suite, as specified in 9.10.
      </description>
      <comment>
        Since only point-to-point use case is supported, peer lists contain only single MI, MI tuple.
        Consequently no ordering of elements in live peer list is relevant.
      </comment>
      <verifycrit>
        Bring peer state machine into KAY_PEER_LIVE state and verify that MKA periodically transmitted MKPDU containing live peer list
        with expected format [Mka.EB.Eapol.30] and that it contains partner's MI and last received MN.
        Verify also that MN in live peer list is incremented according to the received MKPDUs.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01002_PeerList_TxLive</srcid><srcstatus/><internalId>1690</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01030_Peer_SendPeerList</srcid><srcstatus/><internalId>2098</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_1692</srcid><srcstatus/><internalId>660</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.28</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>77</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.MkaTransport.25.4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>185</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.MkaTransport.18</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>172</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0105.PeerLists</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>957</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>80</internalId></specobject>

    <specobject>
      <id>Mka.8021X.Eapol.28.4</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 11.11.3 Encoding MKPDUs</source>
      <version>1</version>
      <description>
        An implementation that transmits MKPDU PDUs with an MKA Version Identifier of 1, 2, or 3
        shall encode the protocol parameters provided by the KaY that:
        If there are one or more Potential Peers, the Member Identifier, Message Number tuples
        of the Potential Peers are encoded within a Potential Peer List as specified in [Mka.EB.Eapol.30] Figure 11-9.
      </description>
      <verifycrit>
        Bring peer state machine into KAY_PEER_POTENTIAL state and verify that MKA periodically transmitted MKPDU
        containing potential  peer list with expected format [Mka.EB.Eapol.30] and that it contains partner's MI and last received MN.
        Verify also that MN in potential peer list is incremented according to the received MKPDUs.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01030_Peer_SendPeerList</srcid><srcstatus/><internalId>2098</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_1733</srcid><srcstatus/><internalId>663</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.28</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>77</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.MkaTransport.25.5</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>186</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.MkaTransport.18</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>172</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0105.PeerLists</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>957</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>81</internalId></specobject>

    <specobject>
      <id>Mka.8021X.Eapol.28.5</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 11.11.3 Encoding MKPDUs</source>
      <version>1</version>
      <description>
        An implementation that transmits MKPDU PDUs with an MKA Version Identifier of 1, 2, or 3
        shall encode the protocol parameters provided by the KaY that:
        If Algorithm Agility parameter (see Figure 11-8 [Mka.8021X.Eapol.26], 9.3.3) specifies
        the use of an ICV that is not 16 octets in length, the ICV Indicator is encoded as
        specified in Figure 11-16.
      </description>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Mka.ParameterSetNotSupported</srcid><srcstatus/><internalId>487</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.28</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>77</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0100.MkaTransport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>952</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0103.IntegrityCheckValue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>955</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>82</internalId></specobject>

    <specobject>
      <id>Mka.8021X.Eapol.29</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 11.11.4 Decoding MKPDUs</source>
      <version>1</version>
      <description>
        An implementation that transmits MKPDU PDUs with an MKA Version Identifier of 1 shall decode the
        protocol parameters of each MKPDU that has been successfully validated as follows:
          a) The Basic Parameter set is decoded from the initial octets as specified in Figure 11-8 [Mka.8021X.Eapol.26].
          b) Each of the following parameter sets, if any, shall be identified by its parameter set type
             and decoded as specified in Table 11-7 [Mka.8021X.Eapol.25], provided that the set is completely present
             (as indicated by its body length parameter) within the MKPDU prior to the ICV and
             the parameter set body length is:
              1) A multiple of 16 octets, if the parameter set is a Live or Potential Peer List.
              2) 0, 40, or more octets, if the parameter set is the MACsec SAK Use parameter set.
              3) 0, 28, 36, or more octets, if the parameter set is the Distributed SAK parameter set.
              4) 28 or more octets, if the parameter set is the Distributed CAK parameter set.
              5) 5 or more octets, if the parameter set is the KMD parameter set.
              Otherwise the parameter set shall be discarded, and the parameters that it contains shall be ignored.
          c) If the ICV Indicator is present, i.e., its initial octet is present where a parameter
             set type is expected, all further parameter sets in the MKPDU (if any) are ignored.
          d) Additional occurrences in an MKPDU of a given parameter set (as identified by the parameter set type)
             and the parameters that it contains shall be ignored, and only the first occurrence processed.
      </description>
      <comment>TODO: Add references to requirements that describe supported parameter sets.</comment>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.8021X.Eapol.29.1</srcid><srcstatus/><internalId>84</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.29.2</srcid><srcstatus/><internalId>85</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.29.3</srcid><srcstatus/><internalId>92</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.29.4</srcid><srcstatus/><internalId>93</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0100.MkaTransport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>952</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>83</internalId></specobject>

    <specobject>
      <id>Mka.8021X.Eapol.29.1</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 11.11.4 Decoding MKPDUs</source>
      <version>1</version>
      <description>
        An implementation that transmits MKPDU PDUs with an MKA Version Identifier of 1 shall decode the
        protocol parameters of each MKPDU that has been successfully validated that:
        The Basic Parameter set is decoded from the initial octets as specified in Figure 11-8 [Mka.8021X.Eapol.26].
      </description>
      <verifycrit>
        Pass MKAPDU buffer with correct data to Mka_Lib_ParSet_ValidateMkaPduData and access individual data
        using MKA_KAY_GET_BASIC_PARSET... macros, verify that acquired data matches expected data that was put in mkpdu.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01032_BasicParSet_29_1</srcid><srcstatus/><internalId>2100</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Lib_ParSet.c_164</srcid><srcstatus/><internalId>723</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.29</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>83</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0100.MkaTransport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>952</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>84</internalId></specobject>

    <specobject>
      <id>Mka.8021X.Eapol.29.2</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 11.11.4 Decoding MKPDUs</source>
      <version>1</version>
      <description>
        An implementation that transmits MKPDU PDUs with an MKA Version Identifier of 1 shall decode the
        protocol parameters of each MKPDU that has been successfully validated that:
        Each of the following parameter sets, if any, shall be identified by its parameter set type
        and decoded as specified in Table 11-7 [Mka.8021X.Eapol.25], provided that the set is completely
        present (as indicated by its body length parameter) within the MKPDU prior to the ICV and
        the parameter set body length is:
          1) A multiple of 16 octets, if the parameter set is a Live or Potential Peer List.
          2) 0, 40, or more octets, if the parameter set is the MACsec SAK Use parameter set.
          3) 0, 28, 36, or more octets, if the parameter set is the Distributed SAK parameter set.
          4) 28 or more octets, if the parameter set is the Distributed CAK parameter set.
          5) 5 or more octets, if the parameter set is the KMD parameter set.
          Otherwise the parameter set shall be discarded, and the parameters that it contains shall be ignored.
      </description>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.8021X.Eapol.29.2.1</srcid><srcstatus/><internalId>86</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.29.2.2</srcid><srcstatus/><internalId>87</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.29.2.3</srcid><srcstatus/><internalId>88</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.29.2.4</srcid><srcstatus/><internalId>89</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.29.2.5</srcid><srcstatus/><internalId>90</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.29.2.6</srcid><srcstatus/><internalId>91</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.29</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>83</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0100.MkaTransport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>952</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>85</internalId></specobject>

    <specobject>
      <id>Mka.8021X.Eapol.29.2.1</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 11.11.4 Decoding MKPDUs</source>
      <version>1</version>
      <description>
        Parameter set shall be identified by its parameter set type and decoded as specified in
        Table 11-7 [Mka.8021X.Eapol.25], provided that the set is completely present within the MKPDU
        prior to the ICV and the parameter set body length is:
        A multiple of 16 octets, if the parameter set is a Live or Potential Peer List.
      </description>
      <verifycrit>
        Test case 1 - Receive MKPDU with Correct Basic Parameter Set and Live Peer List.
                      Verify that Mka_KaY_MkpduType structure has LivePeerListPtr set to beginning of Live peer list.
                      Verify that values retrieved with MKA_KAY_GET_LIVE_PEER_LIST... macros match expected values.
        Test case 2 - Receive MKPDU with Correct Basic Parameter Set and Potential Peer List.
                      Verify that Mka_KaY_MkpduType structure has PotentialPeerListPtr set to beginning of Potential peer list.
                      Verify that values retrieved with MKA_KAY_GET_POTENTIAL_PEER_LIST... macros match expected values.
        Test case 3 - Receive MKPDU with Correct Basic Parameter Set and Live Peer List with extra octet.
                      Verify that received Basic Parameter Set is present and that Live peer list parameter set is discarded.
                      Note: This test case also verifies (Mka.8021X.Eapol.29.2.6).
        Test case 4 - Receive MKPDU with Correct Basic Parameter Set and Potential Peer List with extra octet.
                      Verify that received Basic Parameter Set is present and that Potential peer list parameter set is discarded.
                      Note: This test case also verifies (Mka.8021X.Eapol.29.2.6).
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01033_LivePeerList_29_2_1</srcid><srcstatus/><internalId>2101</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01034_PotentialPeerList_29_2_1</srcid><srcstatus/><internalId>2102</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Lib_ParSet.c_252</srcid><srcstatus/><internalId>725</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Mka_Lib_ParSet.c_275</srcid><srcstatus/><internalId>727</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.29.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>85</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0100.MkaTransport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>952</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>86</internalId></specobject>

    <specobject>
      <id>Mka.8021X.Eapol.29.2.2</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 11.11.4 Decoding MKPDUs</source>
      <version>1</version>
      <description>
        Parameter set shall be identified by its parameter set type and decoded as specified in
        Table 11-7 [Mka.8021X.Eapol.25], provided that the set is completely present within the MKPDU
        prior to the ICV and the parameter set body length is:
        0 or 40 octets, if the parameter set is the MACsec SAK Use parameter set.
      </description>
      <verifycrit>
        Test case 1 - Receive MKPDU with Correct Basic Parameter Set and MACsec SAK use parameter set with
                      parameter set body length of 40 (MACsec supported).
                      Verify that Mka_KaY_MkpduType structure has MacSecSakUsePtr set to beginning of
                      MACsec SAK use parameter set and MacSecSakUse_MacSecSupported set to TRUE.
                      Verify that values retrieved with MKA_KAY_GET_MACSEC_SAK_USE... macros match expected values.
        Test case 2 - Receive MKPDU with Correct Basic Parameter Set and MACsec SAK use parameter set with
                      parameter set body length of 0 (MACsec not supported).
                      Verify that Mka_KaY_MkpduType structure has MacSecSakUsePtr set to beginning of
                      MACsec SAK use parameter set and MacSecSakUse_MacSecSupported set to FALSE.
                      Verify that values retrieved with MKA_KAY_GET_MACSEC_SAK_USE... macros match expected values.
        Test case 3 - Receive MKPDU with Correct Basic Parameter Set and MACsec SAK
                      use with parameter set body length not 0 or 40.
                      Verify that parameter set MACsec SAK use is discarded.
                      Note: This test case also verifies (Mka.8021X.Eapol.29.2.6).
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01035_MACsecSAKUse_29_2_2</srcid><srcstatus/><internalId>2103</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Lib_ParSet.c_298</srcid><srcstatus/><internalId>729</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.29.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>85</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0100.MkaTransport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>952</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>87</internalId></specobject>

    <specobject>
      <id>Mka.8021X.Eapol.29.2.3</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 11.11.4 Decoding MKPDUs</source>
      <version>1</version>
      <description>
        Parameter set shall be identified by its parameter set type and decoded as specified in
        Table 11-7 [Mka.8021X.Eapol.25], provided that the set is completely present within the MKPDU
        prior to the ICV and the parameter set body length is:
        0, 28, or 36 if the parameter set is the Distributed SAK parameter set.
      </description>
      <verifycrit>
        Test case 1 - Receive MKPDU with Correct Basic Parameter Set and Distributed SAK parameter set with
                      parameter set body length of 0 (plain text transmission).
                      Verify that Mka_KaY_MkpduType structure has DistributedSAKPtr set to beginning of
                      Distributed SAK parameter set, DistributedSAK_CypherPtr set to NULL,
                      DistributedSAK_AESKeyWrapPtr set to NULL and DistributedSAK_AESKeyWrapLength set to 0.
                      Verify that values retrieved with MKA_KAY_GET_MACSEC_SAK_USE... macros match expected values.
        Test case 2 - Receive MKPDU with Correct Basic Parameter Set and Distributed SAK parameter set with
                      parameter set body length of 28 (default MACsec Cipher Suite).
                      Verify that Mka_KaY_MkpduType structure has DistributedSAKPtr set to beginning of
                      Distributed SAK parameter set, DistributedSAK_CypherPtr set to NULL,
                      DistributedSAK_AESKeyWrapPtr set to received Distributed SAK AES KeyWrap and
                      DistributedSAK_AESKeyWrapLength set to 24.
        Test case 3 - Receive MKPDU with Correct Basic Parameter Set and Distributed SAK parameter set with
                      parameter set body length of 36 (specifed MACsec Cipher Suite).
                      Verify that Mka_KaY_MkpduType structure has DistributedSAKPtr set to beginning of
                      Distributed SAK parameter set, DistributedSAK_CypherPtr set to specified MACsec Cipher Suite,
                      DistributedSAK_AESKeyWrapPtr set to received Distributed SAK AES KeyWrap and
                      DistributedSAK_AESKeyWrapLength set to 24.
        Test case 3 - Receive MKPDU with Correct Basic Parameter Set and Distributed SAK parameter set
                      with parameter set body length not 0, 28 or 36.
                      Verify that parameter set Distributed SAK is discarded.
                      Note: This test case also verifies (Mka.8021X.Eapol.29.2.6).
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01036_DistributedSAK1_29_2_3</srcid><srcstatus/><internalId>2104</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01037_DistributedSAK2_29_2_3</srcid><srcstatus/><internalId>2105</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01038_DistributedSAK3_29_2_3</srcid><srcstatus/><internalId>2106</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Lib_ParSet.c_328</srcid><srcstatus/><internalId>731</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.29.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>85</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0100.MkaTransport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>952</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>88</internalId></specobject>

    <specobject>
      <id>Mka.8021X.Eapol.29.2.4</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 11.11.4 Decoding MKPDUs</source>
      <version>1</version>
      <description>
        Parameter set shall be identified by its parameter set type and decoded as specified in
        Table 11-7 [Mka.8021X.Eapol.25], provided that the set is completely present within the MKPDU
        prior to the ICV and the parameter set body length is:
        28 or more octets, if the parameter set is the Distributed CAK parameter set.
      </description>
      <comment>
        Distributed CAK parameter set is not supported.
      </comment>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Mka.ParameterSetNotSupported</srcid><srcstatus/><internalId>487</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.29.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>85</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0100.MkaTransport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>952</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>89</internalId></specobject>

    <specobject>
      <id>Mka.8021X.Eapol.29.2.5</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 11.11.4 Decoding MKPDUs</source>
      <version>1</version>
      <description>
        Parameter set shall be identified by its parameter set type and decoded as specified in
        Table 11-7 [Mka.8021X.Eapol.25], provided that the set is completely present within the MKPDU
        prior to the ICV and the parameter set body length is:
        5 or more octets, if the parameter set is the KMD parameter set.
      </description>
      <comment>
        KMD parameter set is not supported.
      </comment>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Mka.ParameterSetNotSupported</srcid><srcstatus/><internalId>487</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.29.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>85</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0100.MkaTransport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>952</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>90</internalId></specobject>

    <specobject>
      <id>Mka.8021X.Eapol.29.2.6</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 11.11.4 Decoding MKPDUs</source>
      <version>1</version>
      <description>
        If any of requirements from [Mka.8021X.Eapol.29.2.1] to [Mka.8021X.Eapol.29.2.5] are not fulfilled,
        parameter set shall be discarded, and the parameters that it contains shall be ignored.
      </description>
      <verifycrit>
        Check tests of Mka.8021X.Eapol.29.2.1, Mka.8021X.Eapol.29.2.2, Mka.8021X.Eapol.29.2.3.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01033_LivePeerList_29_2_1</srcid><srcstatus/><internalId>2101</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01034_PotentialPeerList_29_2_1</srcid><srcstatus/><internalId>2102</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01035_MACsecSAKUse_29_2_2</srcid><srcstatus/><internalId>2103</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01036_DistributedSAK1_29_2_3</srcid><srcstatus/><internalId>2104</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01063_AnnouncementParSet_9_6_Invalid</srcid><srcstatus/><internalId>2131</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01064_XPNParSet_9_7</srcid><srcstatus/><internalId>2132</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Lib_ParSet.c_269</srcid><srcstatus/><internalId>726</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Mka_Lib_ParSet.c_292</srcid><srcstatus/><internalId>728</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Mka_Lib_ParSet.c_322</srcid><srcstatus/><internalId>730</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Mka_Lib_ParSet.c_366</srcid><srcstatus/><internalId>732</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Mka_Lib_ParSet.c_439</srcid><srcstatus/><internalId>738</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Mka_Lib_ParSet.c_462</srcid><srcstatus/><internalId>741</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.29.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>85</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0100.MkaTransport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>952</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>91</internalId></specobject>

    <specobject>
      <id>Mka.8021X.Eapol.29.3</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 11.11.4 Decoding MKPDUs</source>
      <version>1</version>
      <description>
        An implementation that transmits MKPDU PDUs with an MKA Version Identifier of 1 shall decode the
        protocol parameters of each MKPDU that has been successfully validated that:
        If the ICV Indicator is present, i.e., its initial octet is present where a parameter set type
        is expected, all further parameter sets in the MKPDU (if any) are ignored.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01039_ICV_Indicator_29_3</srcid><srcstatus/><internalId>2107</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Lib_ParSet.c_181</srcid><srcstatus/><internalId>724</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.29</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>83</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0100.MkaTransport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>952</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>92</internalId></specobject>

    <specobject>
      <id>Mka.8021X.Eapol.29.4</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 11.11.4 Decoding MKPDUs</source>
      <version>1</version>
      <description>
        An implementation that transmits MKPDU PDUs with an MKA Version Identifier of 1 shall decode the
        protocol parameters of each MKPDU that has been successfully validated that:
        Additional occurrences in an MKPDU of a given parameter set (as identified by the parameter set type)
        and the parameters that it contains shall be ignored, and only the first occurrence processed.
      </description>
      <verifycrit>
        Receive MKPDU with Basic Parameter Set,  Live Peer List, Potential Peer List, MACsec SAK Use and Distributed SAK
        parameter set. Duplicate each parameter set (with some change in set) except basic parameter set.
        Verify that first instance of each parameter set is decoded and other is skipped.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01040_ParSetAdditionalOccurrences1_29_4</srcid><srcstatus/><internalId>2108</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01041_ParSetAdditionalOccurrences2_29_4</srcid><srcstatus/><internalId>2109</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Lib_ParSet.c_130</srcid><srcstatus/><internalId>721</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.29</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>83</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0100.MkaTransport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>952</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>93</internalId></specobject>

    <specobject>
      <id>Mka.8021X.Eapol.30</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 11.11.1 MKA parameter encoding, Figure 11-9</source>
      <version>1</version>
      <description>
        Live Peer List and Potential Peer List parameter sets:
        Parameter name                                  Bits range       Octet number
        -----------------------------------------------------------------------------
        Parameter set type (1 or 2)                       1...8               1
        Key Servers SSCI (a)                             1...8               2
        Parameter set body length                         1...4               3
        Parameter set body length (cont.)                 1...8               4
        Member Identifier                                 1...8               5  16
        Message Number                                    1...8               17  20
        ...
        Member Identifier                                 1...8               (b)
        Message Number                                    1...8

        (a) The least significant octet of the Key Servers transmit SSCI is encoded in MKPDUs containing a Distributed SAK parameter
            set for use with an XPN Cipher Suite; otherwise, 0 is encoded. The Key Servers SSCI is distributed only in Live Peer Lists
            and is transmitted as zero and ignored on receipt in Potential Peer Lists.
        (b) Member Identifier, Message Number tuples are repeated to the end of the parameter set.
      </description>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Mka.PointToPointOnly</srcid><srcstatus/><internalId>489</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.EB.Eapol.30</srcid><srcstatus/><internalId>95</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_1723</srcid><srcstatus/><internalId>661</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0105.PeerLists</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>957</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>94</internalId></specobject>

    <specobject>
      <id>Mka.EB.Eapol.30</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 11.11.1 MKA parameter encoding, Figure 11-9</source>
      <version>1</version>
      <description>
        Live Peer List and Potential Peer List parameter sets:
        Parameter name                                  Bits range       Octet number
        -----------------------------------------------------------------------------
        Parameter set type (1 or 2)                       1...8               1
        Key Servers SSCI (a)                             1...8               2
        Parameter set body length                         1...4               3
        Parameter set body length (cont.)                 1...8               4
        Member Identifier (b)                             1...8               5  16
        Message Number                                    1...8               17  20

        (a) The least significant octet of the Key Servers transmit SSCI is encoded in MKPDUs containing a Distributed SAK parameter
            set for use with an XPN Cipher Suite; otherwise, 0 is encoded. The Key Servers SSCI is distributed only in Live Peer Lists
            and is transmitted as zero and ignored on receipt in Potential Peer Lists.
        (b) Since only point-to-point use case is supported, peer lists contain only single MI, MI tuple.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01030_Peer_SendPeerList</srcid><srcstatus/><internalId>2098</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_1724</srcid><srcstatus/><internalId>662</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.30</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>94</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>95</internalId></specobject>

  </specobjects>
    <specobjects doctype="swurs">

    <specobject>
      <id>Mka.8021X.MkaParticipantTimerValues.1</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.15 MKA participant timer values, Table 9-3</source>
      <version>1</version>
      <description>
        Summarizes each MKA participants use of timers and their timeout values.
        |  Timeout (parameter)  | Timeout (seconds) |
        =============================================
        |   MKA Hello Time      |        2.0        |
        |MKA Bounded Hello Time |        0.5        |
        |     MKA Life Time     |        6.0        |
        | MKA Suspension Limit  |       120.0       |
      </description>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.8021X.MkaParticipantTimerValues.2</srcid><srcstatus/><internalId>97</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.MkaParticipantTimerValues.3</srcid><srcstatus/><internalId>98</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.MkaParticipantTimerValues.4</srcid><srcstatus/><internalId>99</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.MkaParticipantTimerValues.5</srcid><srcstatus/><internalId>100</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.MkaParticipantTimerValues.6</srcid><srcstatus/><internalId>101</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>96</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaParticipantTimerValues.2</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.15 MKA participant timer values</source>
      <version>1</version>
      <description>
        Per participant periodic transmission, initialized on each transmission, transmission on expiry (9.4) and
        expiry timeout shall be MKA Hello Time or MKA Bounded Hello Time.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01005_RandomGenerateFinished_E_OK</srcid><srcstatus/><internalId>2075</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01077_ParticipantRefreshedMi</srcid><srcstatus/><internalId>2145</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.MkaParticipantTimerValues.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>96</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>97</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaParticipantTimerValues.3</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.15 MKA participant timer values</source>
      <version>1</version>
      <description>
        Per peer lifetime, initialized when adding to or refreshing the Potential Peer List or Live Peer List,
        expiry cause removal from the list (9.4.3) and expiry timeout shall be MKA Life Time.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01024_PeerSM_Init2Undetected2Potent2Live</srcid><srcstatus/><internalId>2092</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.MkaParticipantTimerValues.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>96</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>98</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaParticipantTimerValues.4</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.15 MKA participant timer values</source>
      <version>1</version>
      <description>
        Participant lifetime, initialized when participant created or following receipt of an MKPDU,
        expiry causes participant to be deleted (9.14) and expiry timeout shall be MKA Life Time.
      </description>
      <comment>Passive participants are not supported.</comment>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Mka.PassiveParticipantsNotSupported</srcid><srcstatus/><internalId>495</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.MkaParticipantTimerValues.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>96</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>99</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaParticipantTimerValues.5</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.15 MKA participant timer values</source>
      <version>1</version>
      <description>
        Delay after last distributing a SAK, before the Key Server will distribute a fresh SAK following
        a change in the Live Peer List while the Potential Peer List is still not empty and expiry
        timeout shall be MKA Life Time.
      </description>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.EB.KeyServerElection.45.2</srcid><srcstatus/><internalId>254</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.MkaParticipantTimerValues.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>96</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>100</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaParticipantTimerValues.6</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.15 MKA participant timer values</source>
      <version>1</version>
      <description>
        Maximum suspendFor value is MKA Suspension Limit and the maximum suspendedWhile value
        is (MKA Suspension Limit + MKA Life Time).
      </description>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MkaSuspensionNotSupported</srcid><srcstatus/><internalId>490</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.MkaParticipantTimerValues.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>96</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>101</internalId></specobject>

  </specobjects>
    <specobjects doctype="swurs">

    <specobject>
      <id>Mka.8021X.MkaProtocolRequirements</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, Section 9.2 Protocol support requirements</source>
      <version>1</version>
      <description>
        A system that implements MKA shall satisfy this standards requirements for the following:
        a) Random number generation
        b) SC identification
        A system that implements MKA in support of MACsec shall also meet the protocol support requirements specified in IEEE Std 802.1AE.
      </description>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.8021X.MkaProtocolRequirements.RandomNumberGeneration</srcid><srcstatus/><internalId>103</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.MkaProtocolRequirements.ScIdentification</srcid><srcstatus/><internalId>104</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>102</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaProtocolRequirements.RandomNumberGeneration</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, Section 9.2 Protocol support requirements</source>
      <version>1</version>
      <description>
        The system shall provide a strong random number generator (RNG) for the generation of all numbers
        described as random in this standard. If a non-deterministic RNG (e.g., hardware RNG) is not available, the
        system shall make use of sufficient entropy to create a good quality seed for a deterministic RNG and should
        conform to the requirements of NIST Special Publication 800-108.
      </description>
      <comment>
        This requirement is not applicable.
        Random number generator is not a part of the Mka module, but a part of Csm module. It is used implicitly from Mka Crypto unit during
        calls to Csm module for keys generation.
      </comment>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.MkaProtocolRequirements</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>102</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>103</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaProtocolRequirements.ScIdentification</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, Section 9.2 Protocol support requirements</source>
      <version>1</version>
      <description>
        Each SC is identified by an SCI that comprises a MAC address and a Port Identifier, unique within the
        system that has been allocated that address.
      </description>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.dsn.Lib.SciBuffer_Init</srcid><srcstatus/><internalId>1595</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.MkaProtocolRequirements</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>102</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>104</internalId></specobject>

  </specobjects>
    <specobjects doctype="swurs">

    <specobject>
      <id>Mka.8021X.MkaKeyHierarchy.1</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 9.3 MKA key hierarchy</source>
      <version>1</version>
      <description>
        The root of key hierarchy is the secure Connectivity Association key. Possession of a CAK for
        the CA is a prerequisite for membership in each CA supported by MACsec. All potential members
        possess the same CAK and are attached to the same LAN.
      </description>
      <comment>This requirement is informational only.</comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>105</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaKeyHierarchy.2</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.3 MKA key hierarchy</source>
      <version>1</version>
      <description>
        The CAK can be obtained in several different ways:
        a) direct result of a system's participation in EAP
        b) pre-shared key (PSK)
        c) key chosen by an MKA key server and distributed using a prior MKA instance
      </description>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.8021X.MkaKeyHierarchy.2.2</srcid><srcstatus/><internalId>108</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>106</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaKeyHierarchy.2.1</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 6.2 Key hierarchy</source>
      <version>1</version>
      <description>
        The CAK can be obtained in several different ways:
        a) direct result of a system's participation in EAP
      </description>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Mka.EapTlsNotSupported</srcid><srcstatus/><internalId>492</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>107</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaKeyHierarchy.2.2</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 6.2 Key hierarchy</source>
      <version>1</version>
      <description>
        The CAK can be obtained in several different ways:
        b) pre-shared key (PSK)
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_644</srcid><srcstatus/><internalId>846</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.MkaKeyHierarchy.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>106</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>108</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaKeyHierarchy.2.3</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 6.2 Key hierarchy</source>
      <version>1</version>
      <description>
        The CAK can be obtained in several different ways:
        c) key chosen by an MKA key server and distributed using a prior MKA instance
      </description>
      <comment>This requirement is informational only.</comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>109</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaKeyHierarchy.3</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.3 MKA key hierarchy</source>
      <version>1</version>
      <description>
        Each CAK is identified by secure Connectivity Association Key Name (CKN) that allows each of the MKA
        participants to select which CAK, or CAK derived key, to use to process a received MKPDU.
        Network administrator should be aware that accidental use of the same CKN for different CAKs can inhibit
        communication and cause an operator to falsely conclude that security attack is being attempted.
      </description>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.8021X.MkaKeyHierarchy.3.1</srcid><srcstatus/><internalId>111</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>110</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaKeyHierarchy.3.1</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.3 MKA key hierarchy</source>
      <version>1</version>
      <description>
        CAK shall be identified with it's associated CKN
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01038_GetCknPtr_E_OK</srcid><srcstatus/><internalId>1942</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01066_CopyCkn_128</srcid><srcstatus/><internalId>1970</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01092_InvalidCkn2</srcid><srcstatus/><internalId>1987</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_645</srcid><srcstatus/><internalId>847</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.MkaKeyHierarchy.3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>110</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>111</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaKeyHierarchy.4</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.3 MKA key hierarchy</source>
      <version>1</version>
      <description>
        MKA places no restriction on the format of the CKN, save that it comprise an integral number of octets,
        between 1 and 32 (inclusive), and that all potential members of the CA use the same CKN.
      </description>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.8021X.MkaKeyHierarchy.4.1</srcid><srcstatus/><internalId>113</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.MkaKeyHierarchy.4.2</srcid><srcstatus/><internalId>114</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>112</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaKeyHierarchy.4.1</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.3 MKA key hierarchy</source>
      <version>1</version>
      <description>
        CKN shall comprise of an integral number of octets, between 1 and 32 (inclusive).
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01091_InvalidCkn</srcid><srcstatus/><internalId>1986</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01092_InvalidCkn2</srcid><srcstatus/><internalId>1987</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01093_InvalidCkn3</srcid><srcstatus/><internalId>1988</internalId></linkedfrom><linkedfrom><srcid>Mka_UnitTest01025_SetCknStatus_Invalid_Params</srcid><srcstatus/><internalId>2284</internalId></linkedfrom><linkedfrom><srcid>Mka_UnitTest01026_GetCknStatus_Invalid_Params</srcid><srcstatus/><internalId>2285</internalId></linkedfrom><linkedfrom><srcid>Mka_RxTx_UnitTest01028_Invalid_CKN_size_In_Received_BasicParameterSet</srcid><srcstatus/><internalId>2341</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_RxTx.c_368</srcid><srcstatus/><internalId>813</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.MkaKeyHierarchy.4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>112</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>113</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaKeyHierarchy.4.2</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.3 MKA key hierarchy</source>
      <version>1</version>
      <description>
        All potential members of the CA must use the same CKN.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01024_MultiplePeers_DifferentCkn</srcid><srcstatus/><internalId>1713</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.MkaKeyHierarchy.4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>112</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>114</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaKeyHierarchy.5</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 9.3 MKA key hierarchy</source>
      <version>1</version>
      <description>
        CKNs for group CAKs that are generated by a Key Server shall include an RNG of at least
        128 bits to guard against CKN collisions.
      </description>
      <comment>This requirement is informational only.</comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>115</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaKeyHierarchy.6</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.3 MKA key hierarchy</source>
      <version>1</version>
      <description>
        MKA allows the communication between the members of a CA to be supported by a succession
        of MKA instances without interruption. While continuing communication while the CAK is
        changed necessarily implies that all of the systems that are members of the CA both before
        and after the change know both CAs, the two MKA instances each maintain their own CAK and
        derived keys quite separately, and neither instance discloses its CAK or derived keys for
        the other to its participants.
      </description>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.8021X.MkaKeyHierarchy.6.1</srcid><srcstatus/><internalId>117</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.MkaKeyHierarchy.6.2</srcid><srcstatus/><internalId>118</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.MkaKeyHierarchy.6.3</srcid><srcstatus/><internalId>119</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.MkaKeyHierarchy.6.4</srcid><srcstatus/><internalId>120</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>116</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaKeyHierarchy.6.1</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 9.3 MKA key hierarchy</source>
      <version>1</version>
      <description>
        MKA instance shall maintain its own CAK during and after the change of CAK
      </description>
      <comment>This requirement is informational only.</comment>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.MkaKeyHierarchy.6</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>116</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>117</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaKeyHierarchy.6.2</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 9.3 MKA key hierarchy</source>
      <version>1</version>
      <description>
        MKA instance shall maintain its own derived keys during and after the change of CAK
      </description>
      <comment>This requirement is informational only.</comment>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.MkaKeyHierarchy.6</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>116</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>118</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaKeyHierarchy.6.3</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 9.3 MKA key hierarchy</source>
      <version>1</version>
      <description>
        MKA instance shall not disclose its CAK of the other CA to its participants.
      </description>
      <comment>This requirement is informational only.</comment>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.MkaKeyHierarchy.6</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>116</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>119</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaKeyHierarchy.6.4</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 9.3 MKA key hierarchy</source>
      <version>1</version>
      <description>
        MKA instance shall not disclose its derived keys of the other CA to its participants.
      </description>
      <comment>This requirement is informational only.</comment>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.MkaKeyHierarchy.6</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>116</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>120</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaKeyHierarchy.7</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 9.3 MKA key hierarchy</source>
      <version>1</version>
      <description>
        Each of the keys used by MKA is derived from the CAK. The CAK is not used directly.
        The derived keys are tied to the identity of the CAK, and thus restricted to use
        with that particular CAK.
      </description>
      <comment>This requirement is informational only.</comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>121</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaKeyHierarchy.8</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.3 MKA key hierarchy</source>
      <version>1</version>
      <description>
        Each Algorithm Agility parameter value shall be comprised of four octets.
        First three are those of an OUI (Organizationally Unique Identifier) or CID (Company ID)
        allocated by the IEEE Registration Authority.
        The fourth is allocated by the organization to which that OUI or CID has been allocated.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01007_KaYTransmitMKPDU</srcid><srcstatus/><internalId>2077</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>122</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaKeyHierarchy.9</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.3 MKA key hierarchy</source>
      <version>1</version>
      <description>
        The ICK is derived from the CAK using the KDF.
        ICK = KDF(Key, Label, Keyid, ICKlength) where:
        Key = CAK
        Label = "IEEE8021 ICK" (UTF8 string)
        Keyid = the first 16 octets of the CKN, with null octets appended to pad to 16 octets if necessary
        ICKlength = two octets representing an integer value (128 for a 128bit ICK, 256 for 256bit ICK)
                    with the most significant octet first.
      </description>
      <comment>
        KDF uses the AES Cipher in CMAC mode (IETF RFC 4493)
        The Label is a UTF-8 string, without a null or other termination, exactly 12bytes in length.
        The queotes shown do not form part of the string and exactly one space separates '8021' and 'ICK'.
        The length of the Label is chosen to make the input to the PRF within the KDF exactly 32bytes.
      </comment>
      <verifycrit>
        - Use case 1): It shall be verified that ICK is correctly received using the 128bit ICKlength
        - Use case 2): It shall be verified that ICK is correctly received using the 256bit ICKlength
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01094_KekIckGen_Sync_128IckGenInput</srcid><srcstatus/><internalId>1989</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01095_KekIckGen_Sync_256IckGenInput</srcid><srcstatus/><internalId>1990</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.MkaKeyHierarchy.18</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>138</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0101.KeyDerivation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>953</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>123</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaKeyHierarchy.9.1</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.3 MKA key hierarchy</source>
      <version>1</version>
      <description>
        Input string parameter ICKlength from KDF function used to derive ICK shall be exactly 32bytes of size
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01094_KekIckGen_Sync_128IckGenInput</srcid><srcstatus/><internalId>1989</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01095_KekIckGen_Sync_256IckGenInput</srcid><srcstatus/><internalId>1990</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0101.KeyDerivation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>953</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>124</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaKeyHierarchy.10</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 9.3 MKA key hierarchy</source>
      <version>1</version>
      <description>
        To accommodate future developments in cryptography, each of the MKA parameter set types used by MKA
        to communicate a wrapped key identifies the Key Wrap Algorithm and KEK derivation used. The KEK used
        by all parameter set types currently specified in this standard is derived from CAK using the KDF.
      </description>
      <comment>This requirement is informational only.</comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>125</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaKeyHierarchy.10.1</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.3 MKA key hierarchy</source>
      <version>1</version>
      <description>
        SAK shall be wrapped using Key Wrap Algorithm and KEK derivation.
      </description>
      <comment>AES Key Wrap (default IV) is specified by IETF RFC 3394.</comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01003_KSPLow_KSActor</srcid><srcstatus/><internalId>1691</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.37</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>240</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0104.AesKeyWrap</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>956</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>126</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaKeyHierarchy.11</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.3 MKA key hierarchy</source>
      <version>1</version>
      <description>
        The KEK is derived from the CAK using the KDF.
        KEK = KDF(Key, Label, Keyid, ICKlength) where:
        Key = CAK
        Label = "IEEE8021 KEK" (UTF8 string)
        Keyid = the first 16 octets of the CKN, with null octets appended to pad to 16 octets if necessary
        KEKlength = two octets representing an integer value (128 for a 128bit KEK, 256 for 256bit KEK)
                    with the most significant octet first.
      </description>
      <comment>
        KDF uses the AES Cipher in CMAC mode (IETF RFC 4493)
        The Label is a UTF-8 string, without a null or other termination, exactly 12bytes in length.
        The queotes shown do not form part of the string and exactly one space separates '8021' and 'KEK'.
        he length of the Label is chosen to make the input to the PRF within the KDF exactly 32bytes.
      </comment>
      <verifycrit>
        - Use case 1): It shall be verified using the 128bit KEKlength
        - Use case 2): It shall be verified using the 256bit KEKlength
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01096_KekIckGen_Sync_128KekGenInput</srcid><srcstatus/><internalId>1991</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01097_KekIckGen_Sync_256KekGenInput</srcid><srcstatus/><internalId>1992</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.MkaKeyHierarchy.18</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>138</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0101.KeyDerivation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>953</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>127</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaKeyHierarchy.11.1</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.3 MKA key hierarchy</source>
      <version>1</version>
      <description>
        Input string parameter KEKlength from KDF function used to derive KEK shall be exactly 32bytes of size
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01096_KekIckGen_Sync_128KekGenInput</srcid><srcstatus/><internalId>1991</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01097_KekIckGen_Sync_256KekGenInput</srcid><srcstatus/><internalId>1992</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0101.KeyDerivation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>953</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>128</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaKeyHierarchy.12</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 9.3 MKA key hierarchy</source>
      <version>1</version>
      <description>
        Distributed CAKs, when used, shall be random values generated by the MKA Key Server RNG.
      </description>
      <comment>This requirement is informational only.</comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>129</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaKeyHierarchy.13</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 9.3 MKA key hierarchy</source>
      <version>1</version>
      <description>
        Each distributed CAK shall be distinct from previously distributed CAKs.
        This is done so the MKA participant or attacker holding only the current CAK cannot determine
        previously ditributed CAK.
      </description>
      <comment>
        This requirement is informational only.
        This allows implementation of a policy of perfect forward security, with a fresh
        CAK being distributed when each participant joins a CA, so that participant cannot decrypt wrapped keys
        from previously transmitted MKA frames
      </comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>130</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaKeyHierarchy.14</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 6.2 Key hierarchy</source>
      <version>1</version>
      <description>
        The root key in the MACsec Key Agreement key hierarchy is the Connectivity Association Key (CAK), and
        is identified by a CAK Name (CKN). MKA does not use the CAK directly but derives two further
        keys from the CAK using the AES cipher. These are the ICV Key (ICK) used to verify the integrity of MPDUs
        and to prove that the transmitter of the MKPDU possesses the CAK, and the Key Encrypting Key (KEK) used by
        Key Server, elected by MKA, to transport a succession of SAKs, for use by MACsec, to the other member(s) of a CA
      </description>
      <comment>This requirement is informational only.</comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>131</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaKeyHierarchy.15</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 6.2 Key hierarchy</source>
      <version>1</version>
      <description>
        CAK, each possessed only by the Key Server and one other system, can also be used by the Key Server
        to derive ICK and KEK tuples to distribute a further, different, group CAK.
      </description>
      <comment>This requirement is informational only.</comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>132</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaKeyHierarchy.16.1</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 6.2 Key hierarchy</source>
      <version>1</version>
      <description>
        SAK should be generated using the CAK with a random number generated specifically for that SAK and
        contributions from each of the participants in the CAK.
      </description>
      <comment>This requirement is informational only.</comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>133</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaKeyHierarchy.16.2</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 6.2 Key hierarchy</source>
      <version>1</version>
      <description>
        SAK may be generated directly by the Key Server's strong random number generator
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01008_RandomGen_Async128</srcid><srcstatus/><internalId>1912</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01009_RandomGen_Sync128</srcid><srcstatus/><internalId>1913</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0102.RandomNumberGenerator</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>954</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>134</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaKeyHierarchy.17</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 6.2 Key hierarchy</source>
      <version>1</version>
      <description>
        This standard uses a KDF that is compatible with the counter mode KDF described in the NIST Special Publication 800-108.
        The KDF uses a pseudorandom function (PRF) which shall be AES-CMAC-128 when the derivation key is 128 bits,
        and AES-CMAC-256 when the derivation key is 256 bits.
      </description>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.8021X.MkaKeyHierarchy.17.1</srcid><srcstatus/><internalId>136</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.MkaKeyHierarchy.17.2</srcid><srcstatus/><internalId>137</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0101.KeyDerivation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>953</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>135</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaKeyHierarchy.17.1</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 6.2 Key hierarchy</source>
      <version>1</version>
      <description>
        When KDF uses a PRF AES-CMAC-128, the derivation key shall be 128 bits.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01011_KekIckGen_Sync128</srcid><srcstatus/><internalId>1915</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.MkaKeyHierarchy.17</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>135</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0101.KeyDerivation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>953</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>136</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaKeyHierarchy.17.2</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 6.2 Key hierarchy</source>
      <version>1</version>
      <description>
        When KDF uses a PRF AES-CMAC-256, the derivation key shall be 256 bits.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01013_KekIckGen_Sync256</srcid><srcstatus/><internalId>1917</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.MkaKeyHierarchy.17</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>135</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0101.KeyDerivation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>953</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>137</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaKeyHierarchy.18</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 6.2 Key hierarchy</source>
      <version>1</version>
      <description>
        KDF is described as follows:
        Output = KDF(Key, Label, Context, Length)
        Input: Key, a key derivation key of 128 or 256 bits
               Label, a string identifying the purpose of the keys derived using this KDF
               Context, a bit string that provides context to identify the derived key
               Length, the length of the output in bits encoded in two octets with the most significant octet first
        Output: a Length-bit derived value
        Fixed values:
               h, the length of the output of the PRF in bits
               r, denoting the length of the binary representation of the counter i
        iterations = (Length + (h-1))/h
        if iterations gt 2^r - 1, then indicate an error and stop.
        result = ""
        do  i = 1 to iterations
            result = result | PRF(Key, i | Label | 0x00 | Context | Length)
        return first Length bits of result, and securely delete all unused bits.
      </description>
      <comment>Check the passed data from CSM callout stub</comment>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.8021X.MkaKeyHierarchy.9</srcid><srcstatus/><internalId>123</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.MkaKeyHierarchy.11</srcid><srcstatus/><internalId>127</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.MkaKeyHierarchy.19</srcid><srcstatus/><internalId>139</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.MkaKeyHierarchy.20</srcid><srcstatus/><internalId>141</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0101.KeyDerivation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>953</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>138</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaKeyHierarchy.19</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 6.2 Key hierarchy</source>
      <version>1</version>
      <description>
        A pairwise CAK is derived directly from the EAP MSK using the following transform:
        CAK = KDF(Key, Label, mac1|mac2, CAKlength) where:
        Key = MSK[0-15] for 128bit CAK, MSK [0-31] for 256bit CAK
        Label = "IEEE8021 EAP CAK" (UTF8 string)
        mac1 = the lesser of the two source MAC addresses used in the EAPOL-EAP exchange
        mac2 = the greater of the two source MAC addresses used in the EAPOL-EAP exchange
        CAKlength = two octets representing an integer value (128 for a 128bit CAK, 256 for 256bit CAK)
                    with the most significant octet first.
      </description>
      <comment>
        In each case the Label is a UTF-8 string, without a null or other termination, exactly 16 bytes in length (the
        quotes shown above are not part of the string) and exactly one space (a single octet with the value 0x20)
        separates '8021' and 'EAP', and one space separates 'EAP' and 'CAK'. The Label's length is chosen to make
        the concatenated inputs to the PRF within the KDF for the CAK exactly 32 octets
      </comment>
      <verifycrit>
        - Use case 1): It shall be verified using the 128bit CAKlength
        - Use case 2): It shall be verified using the 256bit CAKlength
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Mka.EapTlsNotSupported</srcid><srcstatus/><internalId>492</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.MkaKeyHierarchy.18</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>138</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>139</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaKeyHierarchy.19.1</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 6.2 Key hierarchy</source>
      <version>1</version>
      <description>
        mac1 and mac2 are sequences of 6 octets, with the value of first octet derived from the first 8bits of the 48bit MAC
        address string, the second octet from second set of eight bits and so on. First bit of these octets is least significant.
        The value of each octet in the sequence corresponds to that naturally associated with the hexadecimal representation
        of the LAN MAC Address and the order of the octets corresponds to the left to right order in that representation.
        When two MAC addresses are compared, each is treated as an unsigned binary number, following the convention that binary
        numbers are encoded in octet strings with the most significant octets first. The greater of two addresses is that with the
        greater numeric value.
      </description>
      <comment>This requirement is informational only.</comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>140</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaKeyHierarchy.20</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 6.2 Key hierarchy</source>
      <version>1</version>
      <description>
        16 octet CKN is derived from the EAP session ID using the following transform:
        CKN = KDF(Key, Label, ID|mac1|mac2, CKNlength) where:
        Key = MSK[0-15] for a CKN naming a 128bit CAK, MSK [0-31] for naming a 256bit CAK
        Label = "IEEE8021 EAP CKN" (UTF8 string)
        ID = EAP-Session-ID
        mac1 = the lesser of the two source MAC addresses used in the EAPOL-EAP exchange
        mac2 = the greater of the two source MAC addresses used in the EAPOL-EAP exchange
        CKNlength = two octets representing an integer value (128) with the most significant octet first.
      </description>
      <comment>
        In each case the Label is a UTF-8 string, without a null or other termination, exactly 16 bytes in length (the
        quotes shown above are not part of the string) and exactly one space (a single octet with the value 0x20)
        separates '8021' and 'EAP ', and one space separates 'EAP' and 'CKN'. The Label's length is chosen to make
        the concatenated inputs to the PRF within the KDF for the CAK exactly 32 octets
      </comment>
      <verifycrit>
        - Use case 1): It shall be verified naming a 128bit CAK
        - Use case 2): It shall be verified naming a 256bit CAK
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Mka.EapTlsNotSupported</srcid><srcstatus/><internalId>492</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.MkaKeyHierarchy.18</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>138</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>141</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaKeyHierarchy.21</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 6.2 Key hierarchy</source>
      <version>1</version>
      <description>
        Inputs to the PRF within the KDF for the CAK shall be exactly 32 octets.
      </description>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Mka.EapTlsNotSupported</srcid><srcstatus/><internalId>492</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>142</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaKeyHierarchy.22</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 6.2 Key hierarchy</source>
      <version>1</version>
      <description>
        CAK and its associated CKN may be cached for later use.
      </description>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Mka.EapTlsNotSupported</srcid><srcstatus/><internalId>492</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>143</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaKeyHierarchy.23</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 6.2 Key hierarchy</source>
      <version>1</version>
      <description>
        The scope of use of a CAK is identified as a Key Management Domain (KMD).
        The CAK can be used as a proof of authentication with any port controlled by a PAR that participates
        in the same KMD.
      </description>
      <comment>This requirement is informational only.</comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>144</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaKeyHierarchy.24</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 6.2 Key hierarchy</source>
      <version>1</version>
      <description>
        Neither the CAK or the CKN shall be recalculated following their initial derivation.
      </description>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Mka.EapTlsNotSupported</srcid><srcstatus/><internalId>492</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>145</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaKeyHierarchy.25</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 6.2 Key hierarchy</source>
      <version>1</version>
      <description>
        Algorithm Agility parameter identifies:
        a) How the ICV is derived from the CAK and the data of a given MKPDU
        b) How a CAK is derived from the parameters available to the participants in an EAP exchange
        Knowledge of item a) is required for MKA's use of CAKs in general, while both item a) and item b) are
        required for the validation of MKPDUs that are protected using the results of an EAP exchange. MKA
        instances that transmit MKPDUs with different values of the Algorithm Agility parameter could use a
        different KDF to derive the ICK, could specify the computation of the ICV in a different
        way, and could specify a different way for the participants in an EAP exchange to agree on a CAK.
      </description>
      <comment>This requirement is informational only.</comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>146</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaKeyHierarchy.26</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 6.2 Key hierarchy</source>
      <version>1</version>
      <description>
        MKA's Algorithm Agility parameter does not identify the KDF used to derive the KEK, or the Key Wrap.
        They are identified by the MKA parameter set type used to encode the Key Wrap.
      </description>
      <comment>This requirement is informational only.</comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>147</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaKeyHierarchy.27</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 6.2 Key hierarchy</source>
      <version>1</version>
      <description>
        MKA's parameter SAK uses a particular KDF and Key Wrap as described in Mka.8021X.MkaKeyHierarchy.10.1.
        A different Key Wrap, or a Key Wrap using a differently derived KEK, could be introduced by defining a
        further parameter set type while still allowing MKA participants to communicate by using MKPDUs with a
        familiar Algorithm Agility parameter valuethus allowing negotiation or fallback to known parameter set types.
      </description>
      <comment>This requirement is informational only.</comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>148</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaKeyHierarchy.28</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 6.2 Key hierarchy</source>
      <version>1</version>
      <description>
        Each Mka packet shall have it's own Algorithm Agility parameter transmitted.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01007_KaYTransmitMKPDU</srcid><srcstatus/><internalId>2077</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>149</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaKeyHierarchy.29</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.3 MKA key hierarchy, Table 9-1</source>
      <version>1</version>
      <description>
        MKA Algorithm Agility parameter value shall be 00-80-C2-01.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_RxTx_UnitTest01014_ValidateMkpdu_NotSupportedAlgorithAgillty</srcid><srcstatus/><internalId>2328</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.8021X.Eapol.27.6</srcid><srcstatus/><internalId>75</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>150</internalId></specobject>


  </specobjects>
    <specobjects doctype="swurs">

    <specobject>
      <id>Mka.8021X.MkaTransport.1</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 9.4 MKA transport</source>
      <version>1</version>
      <description>
        MKA provides a secure multipoint-to-multipoint transport between the members of the same CA,
        suitable for conveying information that is constant, or refreshed or acknowledged by the MKA
        applications that make use of that transport.
      </description>
      <comment>This requirement is informational only.</comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>151</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaTransport.2</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.4 MKA transport</source>
      <version>1</version>
      <description>
        The CAK is used to authenticate each protocol data unit (MKPDU) transmitted, providing proof
        of its transmission by a CA member, and each station includes its own randomly chosen
        identifier and a message number in the MKPDU.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_RxTx_UnitTest01004_Initial_2_RxBufFree_2_WaitIcvVerFin_2_RxBufFree</srcid><srcstatus/><internalId>2318</internalId></linkedfrom><linkedfrom><srcid>Mka_RxTx_UnitTest01013_ValidateMkpdu_InvalidCkn</srcid><srcstatus/><internalId>2327</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0100.MkaTransport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>952</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0102.RandomNumberGenerator</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>954</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>152</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaTransport.3</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 9.4 MKA transport</source>
      <version>1</version>
      <description>
        By transmitting MKPDUs that contain the identifiers and recent message numbers of the other
        participants, each member proves that it is in current possession of the CAK and is actively
        participating in the protocol, thus demonstrating the liveness of the MKPDU and
        distinguishing it from MKPDUs that could have been captured by an attacker and played or
        replayed later  with the aim of disrupting the protocol or of influencing its outcome.
      </description>
      <comment>This requirement is informational only.</comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>153</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaTransport.4</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.4 MKA transport</source>
      <version>1</version>
      <description>
        MKPDUs are transmitted at regular intervals (see Table 9-3) of MKA Hello Time or MKA Bounded
        Hello Time (if a bounded receive delay is to be guaranteed, see 9.10), when data to be
        transported changes as specified in this clause (Clause 9), and as specified by the CP state
        machine (setting the state machine variable newInfo, as specified in Clause 12).
      </description>
      <comment>
        TODO: This shall be reinterpreted precisely in our context, or maybe if defined elsewhere
        (duplication) can be made informational only.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01000_PeriodicMkpduTransmission</srcid><srcstatus/><internalId>1688</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0100.MkaTransport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>952</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>154</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaTransport.5</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 9.4 MKA transport</source>
      <version>1</version>
      <description>
        The message numbers also serve to enforce in-order delivery, and each of the MKA
        applications is designed so that the information conveyed in each MKPDU is idempotent,
        i.e., can be repeated without further changing the state of a recipient, and complete,
        i.e., fully expresses the desire of the transmitter for state change at the recipient.
        This design philosophy simplifies protocol analysis and allows a receiver to discard MKPDUs
        with prior message numbers.

        The MKA transport is fully distributed and, as a consequence, robust in the face of the
        failure of any participant or of the LAN connectivity to that participant.

        In principle the MKA transport could be used to communicate its participants desires to
        cooperate in a range of applications that require mutual authentication, and to state the
        relevant capabilities and requirements for each, since the MKPDU format and interoperable
        version rules permit the addition of parameter sets. In practice MKA is focused on MACsec.
        The generality provided by the MKA transport and MKPDU does permit future standardization
        of support for additional applications, alternatives for or additions to MACsec, and
        extensions and refinements for cipher suite negotiation. An example of MKAs
        extensibility is provided by its use to secure announcements (9.13).
      </description>
      <comment>This requirement is informational only.</comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>155</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaTransport.6</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.4 MKA transport</source>
      <version>1</version>
      <description>
        Each protocol data unit (MKPDU) transmitted is integrity protected by an 128 bit ICV,
        generated by AES-CMAC using the ICK (9.3):
        ICV = AES-CMAC(ICK, M, 128)
        M = DA + SA + (MSDU  ICV)
        In other words, M comprises the concatenation of the destination and source MAC addresses,
        each represented by a sequence of 6 octets in canonical format order, with the MSDU
        (MAC Service Data Unit) of the MKPDU including the allocated Ethertype, and up to but not
        including, the generated ICV.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_RxTx.c_302</srcid><srcstatus/><internalId>805</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Mka_RxTx.c_414</srcid><srcstatus/><internalId>816</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_RxTx_UnitTest01002_BufAlloc_2_WaitIcvGenFin_2_BufUnalloc</srcid><srcstatus/><internalId>2316</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0100.MkaTransport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>952</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0103.IntegrityCheckValue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>955</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>156</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaTransport.7</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 9.4 MKA transport</source>
      <version>1</version>
      <description>
        NOTE  M comprises the whole of what is often referred to as the frame considered from the
        point of view of the MAC Service provided by Common Port of the SecY (Figure 6-2) or PAC
        (Figure 6-6) supporting MKPDU transmission. The description does not use the term frame,
        because that Common Port could be supported by additional VLAN tags or other tags
        (consider the upper SecY shown in Figure 7-17) prior to transmission of a MAC frame by a
        system. Any such additional tags would not be covered by the ICV, and would be removed prior
        to MKPDU reception by a peer PAE.

        Since the ICK is not directly distributed by any protocol, but only derived from the CAK,
        verification of the ICV both ensures that the contents of the MKPDU have not been modified
        but also that it was composed by a system that possessed the CAK.
      </description>
      <comment>This requirement is informational only.</comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>157</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaTransport.8</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.4 MKA transport</source>
      <version>1</version>
      <description>
        Each MKPDU contains a secure Connectivity Association Key Name (CKN, 9.3.1) so intended
        recipients can identify the CAK, and hence the ICK, to be used to verify the ICV.
        The Algorithm Agility parameter conveyed in each MKPDU (9.3.3) permits future
        specification of other ICV algorithms and sizes.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01030_Peer_SendPeerList</srcid><srcstatus/><internalId>2098</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0100.MkaTransport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>952</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>158</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaTransport.9</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.4 MKA transport</source>
      <version>1</version>
      <description>
        Each participant in the protocol chooses a random (9.2) 96-bit member identifier (MI) when
        its participation in the protocol begins.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01017_InstSM_WaitFirstMemberId2Running</srcid><srcstatus/><internalId>2085</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0100.MkaTransport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>952</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0102.RandomNumberGenerator</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>954</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>159</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaTransport.10</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.4 MKA transport</source>
      <version>1</version>
      <description>
        MI is used, together with a 32-bit message number (MN) that is initialized to 1 and
        incremented with each MKPDU transmitted, to protect against delayed transmission or replay.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.8021X.MkaTransport.10.1</srcid><srcstatus/><internalId>161</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0100.MkaTransport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>952</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>160</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaTransport.10.1</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.4 MKA transport</source>
      <version>1</version>
      <description>
        32-bit message number (MN) shall be initialized to 1 and incremented with each MKPDU transmitted.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01068_IncrementAn</srcid><srcstatus/><internalId>2136</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.MkaTransport.10</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>160</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0100.MkaTransport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>952</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>161</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaTransport.10.2</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 9.4 MKA transport</source>
      <version>1</version>
      <description>
        MI is used, together with a 32-bit message number (MN) to protect against delayed transmission or replay.
      </description>
      <comment>This requirement is informational only. Dropping of MKPDU in case of invalid MN is described in other requirements.</comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>162</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaTransport.11</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.4 MKA transport</source>
      <version>1</version>
      <description>
        Once a receiver has authenticated (9.4.1) an MKPDU with a given MI and MN, any MKPDUs with
        the same MI and the same or lower MN shall be discarded.
      </description>
      <verifycrit>
        Test case 1 - Test that MKPDU is discarded when received MN is the same as previous one.
        Test case 2 - Test that MKPDU is discarded when received MN is smaller than the previous one.
        Test case 3 - Test that received MKPDU is discarded when received MN in the peer list is smaller than participants MN minus acceptable range.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01027_Peer_LowMI</srcid><srcstatus/><internalId>2095</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01093_MessageNumber_TooLow</srcid><srcstatus/><internalId>2161</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0100.MkaTransport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>952</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>163</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaTransport.12</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 9.4 MKA transport</source>
      <version>1</version>
      <description>
        Use of the randomly chosen MI rather than a permanent unique identifier such as a
        MAC Address as the base for the anti-delay and anti-replay functions provided by the MN
        removes the need for a participant to maintain a record of the last used message number
        when powered off or re-initialized or for that participant to attempt to recover that
        data from its peers when an attacker has to be assumed to be active.
      </description>
      <comment>This requirement is informational only.</comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>164</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaTransport.13</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.4 MKA transport</source>
      <version>1</version>
      <description>
        Use of the MI also solves the issue of new participants understanding a potentially wrapping
        sequence numberwhen the MN reaches its upper limit the participant simply chooses a new MI
        and restarts the MN at 1.
      </description>
      <verifycrit>
        - Use case 1): It shall be verified that when MN reaches its maximum value, new MI shall be chosen and MN set to 1.
        - Use case 2): It shall be verified that MKA protocol shall not be interrupted in a case when live partner choses new MI and
          restarts MN to 1.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01077_ParticipantRefreshedMi</srcid><srcstatus/><internalId>2145</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01078_KeyServerNewMi</srcid><srcstatus/><internalId>2146</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01114_Rekeying_KeyServerChangesMi</srcid><srcstatus/><internalId>2182</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0100.MkaTransport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>952</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>165</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaTransport.14</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 9.4 MKA transport</source>
      <version>1</version>
      <description>
        While the MKPDUs themselves do not rely on the uniqueness of a key-nonce pair to ensure
        confidentiality or to avoid to disclosing data that might lead to the recovery of a key,
        a MAC address forms part of the SCI which is a component of the nonce used by MACsec.
        Use of the MI makes it clear to any observer when, as rarely but occasionally happens,
        a duplicate MAC address is in use, either accidentally or as part of an attack on MACsec.
      </description>
      <comment>This requirement is informational only.</comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>166</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaTransport.15</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.4 MKA transport</source>
      <version>1</version>
      <description>
        The KaY will not enable MACsec transmission if there is any risk of a duplicate SCI.
      </description>
      <verifycrit>
        Verify that the MKPDU is ignored if the Peer has the same SCI as Participant.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_1243</srcid><srcstatus/><internalId>638</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01058_EqualKeyServerPrioAndSci_NotElected</srcid><srcstatus/><internalId>2126</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0100.MkaTransport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>952</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>167</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaTransport.16</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.4 MKA transport</source>
      <version>1</version>
      <description>
        The participant chooses a new MI if its current MI is already in use, as detected by either of the following:
        a) Its presence in the MI field of a received MKPDU.
        b) Its use in the Live Peer List or Potential Peer List of a received MKPDU in combination
           with an MN that is greater than that last transmitted by the participant.
      </description>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.8021X.MkaTransport.16.1</srcid><srcstatus/><internalId>169</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.MkaTransport.16.2</srcid><srcstatus/><internalId>170</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0100.MkaTransport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>952</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>168</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaTransport.16.1</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.4 MKA transport</source>
      <version>1</version>
      <description>
        The participant chooses a new MI if its current MI is already in use, as detected by the following:
        a) Its presence in the MI field of a received MKPDU.
      </description>
      <verifycrit>
        Test case - Bring instance state machine into KAY_INSTANCE_RUNNING state and receive MKPDU with MI equal to the own MI.
        Verify that the following InstSM transitions will occur: Mka.dsn.KaY.InstSM.Running_2_WaitNewMemberId and
        Mka.dsn.KaY.InstSM.WaitNewMemberId_2_Running.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01028_Peer_RepeatedMI</srcid><srcstatus/><internalId>2096</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_3232</srcid><srcstatus/><internalId>705</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.MkaTransport.16</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>168</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0100.MkaTransport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>952</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>169</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaTransport.16.2</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.4 MKA transport</source>
      <version>1</version>
      <description>
        The participant chooses a new MI if its current MI is already in use, as detected by the following:
        b) Its use in the Live Peer List or Potential Peer List of a received MKPDU in combination
           with an MN that is greater than that last transmitted by the participant.
      </description>
      <verifycrit>
        Bring instance state machine into KAY_INSTANCE_RUNNING state and receive the following MKPDU:
        Test case 1 - MKPDU contains potential peer list with an entry containing own MI and MN that is greater then the last transmitted MN.
        Test case 2 - MKPDU contains live peer list with an entry containing own MI and MN that is greater then the last transmitted MN.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01029_Peer_HighMI</srcid><srcstatus/><internalId>2097</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_3240</srcid><srcstatus/><internalId>706</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.MkaTransport.16</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>168</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0100.MkaTransport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>952</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>170</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaTransport.17</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.4 MKA transport</source>
      <version>1</version>
      <description>
        A participant proves liveness to each of its peers by including their MI, together with an
        acceptably recent MN, in an MKPDU with the participants own MI and MN.
      </description>
      <comment>
        This means liveness is proved if peer's MI and MN are included in either live or potential peer list.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01001_PeerList_TxPotentFirst</srcid><srcstatus/><internalId>1689</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_3241</srcid><srcstatus/><internalId>707</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0100.MkaTransport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>952</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>171</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaTransport.18</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.4 MKA transport</source>
      <version>1</version>
      <description>
        To avoid a new participant having to respond to each MKPDU from each partner as it is
        received, or trying to delay its reply until it is likely that MI.MN tuples have been
        received from all potential partners, each participant maintains and advertises both a
        Live Peer List and a Potential Peer List.
      </description>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.8021X.Eapol.28.3</srcid><srcstatus/><internalId>80</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.28.4</srcid><srcstatus/><internalId>81</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01001_PeerList_TxPotentFirst</srcid><srcstatus/><internalId>1689</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01030_Peer_SendPeerList</srcid><srcstatus/><internalId>2098</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0105.PeerLists</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>957</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>172</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaTransport.19</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.4 MKA transport</source>
      <version>1</version>
      <description>
        The Live Peer List includes all the peers that have included the participants MI and a
        recent MN in a recent MKPDU.
      </description>
      <comment>For point-to-point use case live peer list has only single element.</comment>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Mka.PointToPointOnly</srcid><srcstatus/><internalId>489</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.EB.MkaTransport.19</srcid><srcstatus/><internalId>174</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01030_Peer_SendPeerList</srcid><srcstatus/><internalId>2098</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0105.PeerLists</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>957</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>173</internalId></specobject>

    <specobject>
      <id>Mka.EB.MkaTransport.19</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Since only point-to-point use case is supported in the current implementation, number of peers in live peer list is limited to 1.
        Live peer list contains MI and MN of a registered partner that has proved liveness, i.e. that has included participants own MI
        and a recent MN in a recent MKPDU (potential or live peer list).
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01030_Peer_SendPeerList</srcid><srcstatus/><internalId>2098</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.MkaTransport.19</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>173</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0105.PeerLists</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>957</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>174</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaTransport.20</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.4 MKA transport</source>
      <version>1</version>
      <description>
        Potential Peer List includes all the other peers that have transmitted an MKPDU that has
        been directly received by the participant or that were included in the Live Peer List of a
        MKPDU transmitted by a peer that has proved liveness.
      </description>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Mka.PointToPointOnly</srcid><srcstatus/><internalId>489</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.EB.MkaTransport.20</srcid><srcstatus/><internalId>176</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0105.PeerLists</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>957</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>175</internalId></specobject>

    <specobject>
      <id>Mka.EB.MkaTransport.20</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Since only point-to-point use case is supported in the current implementation, number of peers in potential peer list is limited to 1.
        Potential peer list contains MI and MN of a registered partner that has not yet proved liveness, i.e. it has not included
        participants own MI and a recent MN in a recent MKPDU (potential or live peer list).
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01030_Peer_SendPeerList</srcid><srcstatus/><internalId>2098</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.MkaTransport.20</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>175</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0105.PeerLists</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>957</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>176</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaTransport.21</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.4 MKA transport</source>
      <version>1</version>
      <description>
        Peers are removed from each list when an interval of between MKA Life Time (see Table 9-3)
        and MKA Life Time plus MKA Hello Time has elapsed since the participants recent
        MN (see above) was transmitted.
      </description>
      <comment>TODO: Add link to the requirement where Table 9-3 is described.</comment>
      <verifycrit>
        Test case 1 - Equivalent to the test of transition Mka.dsn.KaY.PeerSM.Live_2_Undetected caused by expiration of peer life timer.
        Test case 1 - Equivalent to the test of transition Mka.dsn.KaY.PeerSM.Potential_2_Undetected caused by expiration of peer life timer.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01025_PeerSM_Undetected2Potent2Undetected</srcid><srcstatus/><internalId>2093</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01026_PeerSM_Undetected2Live2Undetected</srcid><srcstatus/><internalId>2094</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0105.PeerLists</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>957</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>177</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaTransport.22</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 9.4 MKA transport</source>
      <version>1</version>
      <description>
        This time is sufficient to ensure that two or more MKPDUs that have been lost or delayed
        prior to the incorrect removal of a live peer.
      </description>
      <comment>This requirement is informational only.</comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>178</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaTransport.23</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 9.4 MKA transport</source>
      <version>1</version>
      <description>
        NOTE 1  The specified use of the Live and Potential Peer Lists thus permits rapid removal
        of participants that are no longer active or attached to the LAN while reducing the number
        of MKPDUs transmitted during group formation. For example, a new participant will be
        admitted to an established group after receiving, then transmitting, one MKPDU.
      </description>
      <comment>This requirement is informational only.</comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>179</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaTransport.24</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 9.4 MKA transport</source>
      <version>1</version>
      <description>
        NOTE 2  A suspended participant (9.18) will be removed from the Live and Potential Peer
        Lists as described, but its associated SecY will still be able to transmit and receive
        secure frames until other CA members adopt a new SAK.
      </description>
      <comment>This requirement is informational only.</comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>180</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaTransport.25</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.4 MKA transport</source>
      <version>1</version>
      <description>
        The MKA transport encodes the following information in each MKPDU:
        a) The CA Key Name
        b) The transmitting participants SCI
        c) The transmitting participants MI and MN
        d) The Live Peer List, comprising the MI and MN of each of the other participants believed
           to be in current possession of the CAK
        e) The Potential Peer List, comprising the MI and MN of each of the other potential
           participants.
      </description>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.8021X.MkaTransport.25.1</srcid><srcstatus/><internalId>182</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.MkaTransport.25.2</srcid><srcstatus/><internalId>183</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.MkaTransport.25.3</srcid><srcstatus/><internalId>184</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.MkaTransport.25.4</srcid><srcstatus/><internalId>185</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.MkaTransport.25.5</srcid><srcstatus/><internalId>186</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0100.MkaTransport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>952</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>181</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaTransport.25.1</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.4 MKA transport</source>
      <version>1</version>
      <description>
        The MKA transport encodes the following information in each MKPDU:
        a) The CA Key Name.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01007_KaYTransmitMKPDU</srcid><srcstatus/><internalId>2077</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.MkaTransport.25</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>181</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0100.MkaTransport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>952</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>182</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaTransport.25.2</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.4 MKA transport</source>
      <version>1</version>
      <description>
        The MKA transport encodes the following information in each MKPDU:
        b) The transmitting participants SCI
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01007_KaYTransmitMKPDU</srcid><srcstatus/><internalId>2077</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.MkaTransport.25</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>181</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0100.MkaTransport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>952</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>183</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaTransport.25.3</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.4 MKA transport</source>
      <version>1</version>
      <description>
        The MKA transport encodes the following information in each MKPDU:
        c) The transmitting participants MI and MN
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01007_KaYTransmitMKPDU</srcid><srcstatus/><internalId>2077</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.MkaTransport.25</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>181</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0100.MkaTransport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>952</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>184</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaTransport.25.4</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.4 MKA transport</source>
      <version>1</version>
      <description>
        The MKA transport encodes the following information in each MKPDU:
        d) The Live Peer List, comprising the MI and MN of each of the other participants believed
           to be in current possession of the CAK.
      </description>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.8021X.Eapol.28.3</srcid><srcstatus/><internalId>80</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01030_Peer_SendPeerList</srcid><srcstatus/><internalId>2098</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.MkaTransport.25</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>181</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0105.PeerLists</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>957</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>185</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaTransport.25.5</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.4 MKA transport</source>
      <version>1</version>
      <description>
        The MKA transport encodes the following information in each MKPDU:
        e) The Potential Peer List, comprising the MI and MN of each of the other potential
           participants.
      </description>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.8021X.Eapol.28.4</srcid><srcstatus/><internalId>81</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01030_Peer_SendPeerList</srcid><srcstatus/><internalId>2098</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.MkaTransport.25</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>181</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0105.PeerLists</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>957</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>186</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaTransport.26</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 9.4 MKA transport</source>
      <version>1</version>
      <description>
        For encoding and decoding convenience, these elements are not consecutively encoded, in
        particular the live and potential peer lists are encoded after the information provided by
        the MKA applications.
      </description>
      <comment>This requirement is informational only.</comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>187</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaTransport.27</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 9.4 MKA transport</source>
      <version>1</version>
      <description>
        The details of MKPDU encoding and preliminary validation of received MKPDUs are specified
        in Clause 11.
      </description>
      <comment>This requirement is informational only.</comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>188</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaTransport.28</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 9.4 MKA transport</source>
      <version>1</version>
      <description>
        A LAN can be an individual LAN, bounded by the extent of its supporting media access method
        and media access method procedures, or can be supported by bridges in a Bridged Local Area
        Network or Virtual Bridged Local Area Network.
        Interoperability, avoiding redundancy, protecting the infrastructure, and the need to
        support communication between stations in the network, all necessitate placing restrictions
        on where, within the interface stack that composes a port (IEEE Std 802.1AC), SecYs are
        placed.
        Clause 11 of IEEE Std 802.1AE-2006 specifies the use of MACsec within systems, and those
        restrictions, but explicitly recognizes that MACsec can be used across, within, and to
        secure access to a Provider Bridged Network.
      </description>
      <comment>This requirement is informational only.</comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>189</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaTransport.29</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.4 MKA transport</source>
      <version>1</version>
      <description>
        The destination address used by MKA has to be aligned with the placement of port-based
        network access control in the interface stack and the corresponding use of MACsec within
        the protocol stack, and shall be a group address.
        Table 11-1 specifies group addresses that support the application scenarios described in
        this standard (Clause 7).
      </description>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.ECUC_Mka_00032</srcid><srcstatus/><internalId>437</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0100.MkaTransport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>952</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>190</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaTransport.30</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 9.4 MKA transport</source>
      <version>1</version>
      <description>
        NOTE  Use of a group address that is filtered by bridges and the inclusion of destination
        and source MAC addresses within the ICV calculation makes attacking MKA from a distance
        more difficult.
      </description>
      <comment>This requirement is informational only.</comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>191</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaTransport.31</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 9.4 MKA transport</source>
      <version>1</version>
      <description>
        The source address of each MKPDU shall be an individual MAC Address assigned to the port
        transmitting that MKPDU.
      </description>
      <comment>
        This requirement is informational only.
        This functionality is out of scope of MKA, i.e. implemented in Ethernet driver.
      </comment>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0100.MkaTransport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>952</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>192</internalId></specobject>

    <specobject>
      <id>Mka.8021X.MkaTransport.32</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.4 MKA transport</source>
      <version>1</version>
      <description>
        A participant can be active (supported), transmitting periodic MKPDUs, or passive (not supported).

        A passive participant will become active for a period of MKA Lifetime following the receipt
        of an MKPDU from a feasible partner, i.e., provided that either the receiving participant
        or the partner is prepared to act as a Key Server.

        Whether a participant is to be active when first created, and whether it is to remain active
        in the absence of feasible partners depends on the port-based network access control
        application.

        The creation of passive participants supports systems that have many potential peers, with
        only one or a few likely to be connected at a time.

        Participants that are always active are desirable where connectivity is provided by media
        that do not reliably signal loss and resumption of connectivity, as can be the case for
        infrastructure links supported by virtual media.

        If all the participants in a potential CA can be passive, and an extended and undetected
        network outage occurs, it is possible that the potential CA members will fail to transmit
        MKPDUs, resulting in a permanent lack of connectivity.

        NOTE 1  The condition of having recently received an MKPDU from a feasible partner can be
        determined by inspecting the participants Live Peer List and Potential Peer List.

        NOTE 2The model of Logon Process operation encompasses participant creation, deletion, and
        control of active or passive participation (12.2, 12.5.2).
        The CAK cache provides management (see activate in 9.16).

        An active participant will remain active, even in the absence of received MKPDUs, while a
        suspension is in progress (provided that the participant is not itself suspended).
        A suspended participant will resume active operation if and only if
        a) Its CAK was previously cached, and
        b) The management controls associated with that cached CAK specify that it is to be active
           on resumption (9.16).
      </description>
      <comment>
        Passive participants are not supported, only the active are.
      </comment>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Mka.PassiveParticipantsNotSupported</srcid><srcstatus/><internalId>495</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0100.MkaTransport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>952</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>193</internalId></specobject>

  </specobjects>
    <specobjects doctype="swurs">

    <specobject>
      <id>Mka.8021X.KeyServerElection.1</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 9.5 Key server election</source>
      <version>1</version>
      <description>
        The participants in a given MKA instance agree on a Key Server, responsible for the following:
          a) Deciding on the use of MACsec,
          b) Cipher suite selection,
          c) SAK generation and distribution,
          d) SA assignment,
          e) Identifying the CA when two or more CAs merge,
          f) CA formation and group CAK distribution,
          g) Initiating, continuing, and terminating MKA suspension.
      </description>
      <comment>This requirement is informational only. Points e), f) and g) are not supported by current implementation.</comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>194</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.2</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.5 Key server election</source>
      <version>1</version>
      <description>
        If the CAK is a pairwise CAK derived directly from EAP (see 6.2.2), the MKA participant for the PAE
        that was the EAP Authenticator will be the Key Server, and will not accept information listed in
        [Mka.8021X.KeyServerElection.1] from any other participant that attempts to act as the Key Server
        for that MKA instance.
      </description>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Mka.EapTlsNotSupported</srcid><srcstatus/><internalId>492</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>195</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.3</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.5 Key server election</source>
      <version>1</version>
      <description>
        Each participant in an MKA instance with a CAK that was not directly derived from EAP, shall use
        the Key Server Priority (an 8-bit integer) encoded in each MKPDU to agree on the Key Server.
      </description>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.EB.KeyServerElection.3</srcid><srcstatus/><internalId>197</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0106.KeyServerElection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>958</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>196</internalId></specobject>

    <specobject>
      <id>Mka.EB.KeyServerElection.3</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Each participant in an MKA instance for which configuration parameter MkaRole is configured to MKA_KEY_SERVER_PRIORITY_BASED,
        shall use the Key Server Priority (an 8-bit integer) encoded in each MKPDU to agree on the Key Server.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_2056</srcid><srcstatus/><internalId>682</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01042_KeySm_Disabled2GenerateNewSak</srcid><srcstatus/><internalId>2110</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01043_KeySm_Disabled2WaitSakDistribution</srcid><srcstatus/><internalId>2111</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>196</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0106.KeyServerElection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>958</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>197</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.4</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.5.1 MKPDU application data</source>
      <version>1</version>
      <description>
        Each MKA participant encodes the following information in every MKPDU transmitted:
          a) Key Server Priority, the priority of the transmitting participant.
          b) Key Server, a flag set if and only if the participant has not decided that another participant
             is or will be the Key Server.
      </description>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.8021X.Eapol.26</srcid><srcstatus/><internalId>68</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.KeyServerElection.4.1</srcid><srcstatus/><internalId>199</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.KeyServerElection.4.2</srcid><srcstatus/><internalId>200</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0106.KeyServerElection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>958</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>198</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.4.1</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.5.1 MKPDU application data</source>
      <version>1</version>
      <description>
        Each MKA participant encodes the following information in every MKPDU transmitted:
          a) Key Server Priority, the priority of the transmitting participant.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01007_KaYTransmitMKPDU</srcid><srcstatus/><internalId>2077</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01055_KeyServerFlagAndPriority_PriorityBased</srcid><srcstatus/><internalId>2123</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01056_KeyServerFlagAndPriority_KeyServer</srcid><srcstatus/><internalId>2124</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01057_KeyServerFlagAndPriority_Peer</srcid><srcstatus/><internalId>2125</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_1620</srcid><srcstatus/><internalId>659</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>198</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0106.KeyServerElection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>958</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>199</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.4.2</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.5.1 MKPDU application data</source>
      <version>1</version>
      <description>
        Each MKA participant encodes the following information in every MKPDU transmitted:
          b) Key Server, a flag set if and only if the participant has not decided that another participant
             is or will be the Key Server.
      </description>
      <comment>
        Key Server field of Basic parameter set is encoded in the following way:
        1) If MkaRole == MKA_PEER, Key Server is always 0.
        2) If MkaRole == MKA_KEY_SERVER, Key Server is always 1.
        3) If MkaRole == MKA_KEY_SERVER_PRIORITY_BASED:
           3.1) Key Server is 1 before live partner is found and key server elected.
           3.2) Key Server is 1 if participant has elected self for key server.
           3.3) Key Server is 0 if participant has elected partner for key server.
      </comment>
      <verifycrit>
        Test the following use cases:
        1) Configure MkaRole = MKA_PEER, and test that Key Server = 0 from the first transmissions of MKPDU
        2) Configure MkaRole = MKA_KEY_SERVER, and test that Key Server = 1 from the first transmissions of MKPDU
        3) Configure MkaRole = MKA_KEY_SERVER_PRIORITY_BASED, execute conformance test where partner has higher key server priority,
           and observe that Key Server = 1 at the beginning of negotiation sequence, and that it becomes 0, once partner is elected
           for key server.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01005_KeyServerFlag_1</srcid><srcstatus/><internalId>1694</internalId></linkedfrom><linkedfrom><srcid>Mka_ConTest01006_KeyServerFlag_2</srcid><srcstatus/><internalId>1695</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01055_KeyServerFlagAndPriority_PriorityBased</srcid><srcstatus/><internalId>2123</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01056_KeyServerFlagAndPriority_KeyServer</srcid><srcstatus/><internalId>2124</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01057_KeyServerFlagAndPriority_Peer</srcid><srcstatus/><internalId>2125</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01059_KeyServerElection_LowerSci</srcid><srcstatus/><internalId>2127</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01060_KeyServerElection_HigherSci</srcid><srcstatus/><internalId>2128</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_2171</srcid><srcstatus/><internalId>687</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>198</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0106.KeyServerElection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>958</internalId></provcov>
       </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>200</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.5</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.5 Key server election</source>
      <version>1</version>
      <description>
        Each such participant selects the live participant advertising the highest priority as its Key Server
        whenever the Live Peer List changes, provided that highest priority participant has not selected another as its
        Key Server or is unwilling to act as the Key Server (as indicated in [Mka.8021X.KeyServerElection.4.1]).
      </description>
      <comment>
        "...Whenever the Live Peer List changes" in case of point-to-point use case can happen only when first (and only) partner proves
        liveness. This implicitly means that key server election can only be done at that moment and cannot change afterwards, i.e. partners
        cannot switch key server roles afterwards.
      </comment>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.EB.KeyServerElection.5</srcid><srcstatus/><internalId>202</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0106.KeyServerElection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>958</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>201</internalId></specobject>

    <specobject>
      <id>Mka.EB.KeyServerElection.5</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        In case MkaRole is configured to MKA_KEY_SERVER_PRIORITY_BASED, participant will chose its partner as a key server
        if the partner has higher priority advertised and if partner want to be a key server (Key Server field is set).
      </description>
      <comment>
        "...Whenever the Live Peer List changes" in case of point-to-point use case can happen only when first (and only) partner proves
        liveness. This implicitly means that key server election can only be done at that moment and cannot change afterwards, i.e. partners
        cannot switch key server roles afterwards.
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_2057</srcid><srcstatus/><internalId>683</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01005_KeyServerFlag_1</srcid><srcstatus/><internalId>1694</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.5</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>201</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0106.KeyServerElection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>958</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>202</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.6</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.5 Key server election</source>
      <version>1</version>
      <description>
        If a Key Server cannot be selected SAKs are not distributed.
      </description>
      <verifycrit>
        Test the following use case:
        - Configure MkaRole = MKA_KEY_SERVER_PRIORITY_BASED, and make valid MKPDU exchange with a partner that has the same Key Server
          Priority and the same SCI. Verify that SAK is not distributed.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_2789</srcid><srcstatus/><internalId>695</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01058_EqualKeyServerPrioAndSci_NotElected</srcid><srcstatus/><internalId>2126</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01094_ParticipantPeer_SamePriority</srcid><srcstatus/><internalId>2162</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0106.KeyServerElection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>958</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0108.SakGenerationDistributionUse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>960</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>203</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.7</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.5 Key server election</source>
      <version>1</version>
      <description>
        In the event of a tie for highest priority Key Server, the member with the highest priority SCI is chosen.
        Note: For consistency with other uses of the SCIs MAC Address component as a priority, numerically
        lower values of the Key Server Priority and SCI are accorded the highest priority.
      </description>
      <verifycrit>
        Test the following use case:
        Use case 1:
        1) Configure MkaRole = MKA_KEY_SERVER_PRIORITY_BASED
        2) Receive MKPDU from a partner that contains live peer list with our MI, and has the same Key Server Priority and the
           numerically lower SCI the ours.
        Verify the following in our next transmitted MKPDU:
        a) Key Server field of a Basic parameter set is set to 0, indicating that we have elected partner for a Key server.
        b) Distributed SAK parameter set is not included.
        Use case 2:
        Perform steps 1) and 2) from use case 1), with a difference that partner's MKPDU shall have numerically greater SCI then ours.
        Verify the following in our next transmitted MKPDU:
        a) Key Server filed of a Basic parameter set is set to 1.
        b) Distributed SAK parameter set is included in MKPDU, indicating that we have elected self for a Key server.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_2075</srcid><srcstatus/><internalId>684</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01059_KeyServerElection_LowerSci</srcid><srcstatus/><internalId>2127</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01060_KeyServerElection_HigherSci</srcid><srcstatus/><internalId>2128</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0106.KeyServerElection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>958</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>204</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.9</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 9.5.1 MKPDU application data, Table 9-2</source>
      <version>1</version>
      <description>
        Recommendations for the use of priority values for various system roles:
        | System role of network access controlled port | Recommended or default value | Recommended range |
        ----------------------------------------------------------------------------------------------------
        |              Infrastructure port              |             0x10             |    0x00  0x1F    |
        |          Primary Network Access Point         |             0x30             |    0x20  0x3F    |
        |    Secondary or backup Network Access Point   |             0x50             |    0x40  0x5F    |
        |                Group CA member                |             0x70             |    0x60  0x7F    |
      </description>
      <comment>This requirement is informational only.</comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>205</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.10</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.8 SAK generation, distribution, and selection</source>
      <version>1</version>
      <description>
        Participants that will never act as a Key Server should advertise priority 0xFF.
      </description>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.CP_SWS_Mka_00011.2</srcid><srcstatus/><internalId>320</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0106.KeyServerElection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>958</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>206</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.11</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 9.5 Key server election</source>
      <version>1</version>
      <description>
        As CA membership changes and before all current participants recognize each other as live, more
        than one participant can decide that it is the Key Server and attempt to fulfil the Key Servers
        responsibilities. The design of the SAK distribution and other applications where the Key Server plays
        a role is such that each member can simply accept data from the Key Server that member has elected.
      </description>
      <comment>
        This requirement is informational only.
      </comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>207</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.12</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.5 Key server election</source>
      <version>1</version>
      <description>
        If a KaY participates in multiple MKA instances so that there are several actors (one per instance)
        for a given port, then only the actor selected as the principal actor (12.1) will (if elected Key Server
        for its CAK) distribute SAKs.
      </description>
      <comment>
        Logon shall take care that PAE (KaY) can have maximum one principal actor, i.e. participant that can generate SAK, and
        control SecY.
      </comment>
      <verifycrit>
        Test the following use case:
        1) Bring participant into a state where it has elected self for a key server.
        2) Do not pronounce this participant as principal actor, i.e. skip call to Mka_KaY_SetPrincipalActor()
        3) Verify that SAK will not be generated and distributed.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_1097</srcid><srcstatus/><internalId>631</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01061_NotPrincipalActor_NoSak</srcid><srcstatus/><internalId>2129</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0108.SakGenerationDistributionUse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>960</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>208</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.13</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 9.8 SAK generation, distribution, and selection</source>
      <version>1</version>
      <description>
        Since the factors that cause a principal actor to be selected from its peers
        are the same for different CAK, CKN tuples with the same distribution, replacement of a principal actor by its
        successor will occur, whenever possible, without a change of Key Server. This succession plan ensures that the
        SAKs distributed using one CAK, CKN tuple can be followed immediately by SAKs distributed by a successor
        CAK, CKN without any loss of MACsec connectivity.
      </description>
      <comment>This requirement is informational only.
        TODO: Maybe this is valid use / test case for EAP-TLS configuration.
      </comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>209</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.14</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.5 Key server election</source>
      <version>1</version>
      <description>
        To minimize the chance of a CA member that possesses both CAKs temporarily losing connectivity,
        a Key Server should not distribute an SAK using the new CAK until MKA Life Time (Table 9-3) has
        elapsed after it has started participating with that CAK, and should not delete the participant
        for the prior CAK until MKA Life Time has elapsed after that new SAK is first distributed.
      </description>
      <comment>
        TODO: "CA member that possesses both CAKs" is unclear. IMO CA has only single CAK.
        Did they mean PAE that has two MKA instances (with different CAKs) and refer to the change of principal actor?
        Also the second part is unclear. Does this mean that Logon cannot delete Mka instance for some period of time?
        And that new SAK shall not be generated of MKA Life Time after instance is created by Logon?
      </comment>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Mka.EapTlsNotSupported</srcid><srcstatus/><internalId>492</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>210</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.15</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 9.5 Key server election</source>
      <version>1</version>
      <description>
        The CP state machine (Figure 12-2) ensures that a new SAK is not distributed until the Key
        Server is receiving and transmitting using a single SAK.
      </description>
      <comment>This requirement is informational only.</comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>211</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.16</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 9.5 Key server election</source>
      <version>1</version>
      <description>
        NOTE 1If two PAEs are each capable of acting as both an EAP Authenticator and an EAP Supplicant,
        their interaction can result in two instances of successful mutual authentication with each acting
        as the Authenticator in one. Thus two MKA instances can be created, and each PAEs KaY will be elected
        Key Server for one instance. However, each KaY will select, as its principal actor, its participant in
        the MKA instance with the highest priority Key Server. That Key Server can then use that MKA instance
        to distribute SAKs (or select unauthenticated connectivity, see 12.3), and the participants in the other
        MKA instance can be deleted.
      </description>
      <comment>This requirement is informational only.</comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>212</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.17</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 9.5 Key server election</source>
      <version>1</version>
      <description>
        NOTE 2A number of KaYs participating in multiple MKA instances will still succeed in configuring a single
        CA even if each participates in a different subset of those instances, provided that the highest priority Key
        Server in each subset itself participates in an MKA instance with a higher priority Key Server or is the highest
        priority Key Server. For example, assume KaYs A, B, C, D (say) in decreasing priority order, with two MKA instances
        with participants {A, B, C} and {B, D} respectively. Although B will be elected Key Server for the {B, D} instance,
        it will not distribute SAKs to D, as Bs principal actor will be in {A, B, C}. Thus a single CA will be created,
        including the ports associated with A, B, and C, but excluding Ds. However, scenarios of this type are most likely
        to result from errors in manual key distribution. They can give rise to temporary interruptions or unwanted connectivity,
        particularly where in-service upgrades are to be performed and need to be eliminated as part of managing upgrades (9.18.6).
      </description>
      <comment>This requirement is informational only.</comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>213</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.18</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.6 Use of MACsec</source>
      <version>1</version>
      <description>
        Each participant advertises whether it is capable of using MACsec, and whether it requests MACsec
        protection of any communication through the Controlled Port of a SecY.
      </description>
      <comment>
        This is interpreted as MACsec Desired and MACsec Capability fields of Basic parameter set.
      </comment>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.8021X.KeyServerElection.27</srcid><srcstatus/><internalId>223</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0107.CipherSuiteSelection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>959</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>214</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.19</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.6 Use of MACsec</source>
      <version>1</version>
      <description>
        The Key Server decides whether all, or none, of the participants in the CA should use MACsec
        to protect transmit frames; thus guarding against partial connectivity within the CA.
      </description>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Mka.PointToPointOnly</srcid><srcstatus/><internalId>489</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>215</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.20</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 9.6 Use of MACsec</source>
      <version>1</version>
      <description>
        NOTE 1The MACsec desired parameter is provided to allow a network administrator to deploy
        MACsec capable systems, to verify their operationincluding their participation in authentication
        and key agreement protocols, and to ensure that network operation does not depend on communication
        with systems that are not MACsec capable, before MKA selects MACsec protection and restricts the CA
        to MACsec capable systems.
      </description>
      <comment>This requirement is informational only.</comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>216</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.21</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 9.6 Use of MACsec</source>
      <version>1</version>
      <description>
        To avoid duplication or conflict with the management controls for the SecYs secure frame generation
        and verification (10.5 and 10.6 of IEEE Std 802.1AE-2018) direct management access to the protectFrames
        parameter is disabled.
      </description>
      <comment>This requirement is informational only.</comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>217</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.22</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 9.6 Use of MACsec</source>
      <version>1</version>
      <description>
        If the Key Server and at least one other live participant are MACsec capable, and at least one
        of those participants requests MACsec protection, the Key Server advertises MACsec protect
        and each participant sets its SecYs protectFrames parameter. Otherwise, protectFrames is cleared.
      </description>
      <comment>
        This requirement is not applicable: "MACsec protect" is not found anywhere in documentation, i.e. it is not
        clear what and how to advertise.
      </comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>218</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.23</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 9.6 Use of MACsec</source>
      <version>1</version>
      <description>
        NOTE 2IEEE Std 802.1AE mandates the capability to disable management access to individual parameters.
      </description>
      <comment>This requirement is informational only.</comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>219</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.24</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 9.6 Use of MACsec</source>
      <version>1</version>
      <description>
        Participants that receive or transmit unprotected frames are responsible for ensuring that their
        protocol clients select appropriate policies.
      </description>
      <comment>This requirement is informational only.</comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>220</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.25</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 9.6 Use of MACsec</source>
      <version>1</version>
      <description>
        Whether any communication is desirable depends on the system configuration (see 7.3.3).
      </description>
      <comment>This requirement is informational only.</comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>221</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.26</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.6 Use of MACsec</source>
      <version>2</version>
      <description>
        If the Key Server selects MACsec protection, any MKA participant that is not capable of using MACsec
        (or the selected cipher suite) will not receive or transmit using the Controlled Port, and will maintain
        MAC_Operational False for that port.
      </description>
      <verifycrit>
        Test case 1:
        1) Bring participant into a state where it has elected a partner to be a key server.
        2) Receive MKPDU from a key server containing Distributed SAK parameter set, having
          a) unsupported cipher suite,
        Verify that MAC_Operational remained False for that port.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01014_UnsupportedCipherSuite</srcid><srcstatus/><internalId>1703</internalId></linkedfrom><linkedfrom><srcid>Mka_ConTest01016_SupportedCipherSuiteAndCapability</srcid><srcstatus/><internalId>1705</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0110.MacSecOperational</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>962</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0108.SakGenerationDistributionUse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>960</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>222</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.27</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.6.1 MKPDU application data</source>
      <version>1</version>
      <description>
        Each MKA participant encodes the following information in every MKPDU transmitted:
          a) MACsec capability which indicating whether MACsec is implemented, and if so whether the implementation
             provides integrity protection only, integrity and integrity with confidentiality, or integrity and
             integrity with confidentiality with a selectable confidentiality offset of 0, 30, or 50 octets.
          b) MACsec desired, a flag, set if the participant desires the use of MACsec to protect frames.
      </description>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.8021X.KeyServerElection.27.1</srcid><srcstatus/><internalId>224</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.KeyServerElection.27.2</srcid><srcstatus/><internalId>226</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.18</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>214</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>223</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.27.1</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.6.1 MKPDU application data</source>
      <version>2</version>
      <description>
        Each MKA participant shall encode the following information in every MKPDU transmitted:
        a) MACsec capability which indicating whether MACsec is implemented, and if so whether the implementation
           provides integrity protection only, integrity and integrity with confidentiality, or integrity and
           integrity with confidentiality with a selectable confidentiality offset of 0, 30, or 50 octets.
      </description>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.EB.KeyServerElection.27.1</srcid><srcstatus/><internalId>225</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0107.CipherSuiteSelection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>959</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.27</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>223</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>224</internalId></specobject>

    <specobject>
      <id>Mka.EB.KeyServerElection.27.1</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Each MKA participant shall encode the following information in every MKPDU transmitted:
        a) MACsec capability, indicating if the implementation provides integrity protection only,
           integrity and integrity with confidentiality, or integrity and integrity with confidentiality
           with a selectable confidentiality offset of 0, 30, or 50 octets (see Table 11-6, IEEE Std 802.1X).

        Capability can have the following values:
          0 - Invalid Capability value (Mkpdu discarded).
          1 - Capable in "integrity protection without confidentiality".
          2 - Capable in "integrity protection without confidentiality" and "integrity protection and confidentiality with a confidentiality offset 0".
          3 - Capable in "integrity protection without confidentiality" and "integrity protection and confidentiality with a confidentiality offset 0, 30 or 50".

        1) If MACsec is disabled, capability is encoded based on configuration.
        2) If MACsec is enabled but before live or potential partner is found it is encoded based on configuration according to the following table:

                   MkaMacSecCapability       |  MKA_INTEGRITY_WITHOUT_CONFIDENTIALITY   |  MKA_INTEGRITY_AND_CONFIDENTIALITY
        MkaMacSecConfidentialityOffset       |                                          |
        MKA_NO_CONFIDENTIALITY_OFFSET (0)    |                     1                    |                  -
        MKA_CONFIDENTIALITY_OFFSET_0  (1)    |                     -                    |                  2
        MKA_CONFIDENTIALITY_OFFSET_30 (2)    |                     -                    |                  3
        MKA_CONFIDENTIALITY_OFFSET_50 (3)    |                     -                    |                  3

        3) When live or potential partner is found (which requests MACsec protection), capability is calculated as a minimum capability of both partners.
      </description>
      <verifycrit>
        Test use cases 1, 2 and 3 from the requirement.
        Test case 4: After use case 3 is verified, let a Peer life timeout to expire and verify that MKPDUs are being transmitted with capability
        calculated out of configuration (case 2 in aforementioned requirement)
        Test case 5: If Mkpdu with Capability value 0 is received, it shall be discarded.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_1619</srcid><srcstatus/><internalId>658</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_2219</srcid><srcstatus/><internalId>689</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_2572</srcid><srcstatus/><internalId>692</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_2676</srcid><srcstatus/><internalId>693</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01005_KeyServerFlag_1</srcid><srcstatus/><internalId>1694</internalId></linkedfrom><linkedfrom><srcid>Mka_ConTest01007_MACsecCapabilityDesired_1</srcid><srcstatus/><internalId>1696</internalId></linkedfrom><linkedfrom><srcid>Mka_ConTest01008_MACsecCapabilityDesired_2</srcid><srcstatus/><internalId>1697</internalId></linkedfrom><linkedfrom><srcid>Mka_ConTest01026_PlainText_Peer</srcid><srcstatus/><internalId>1715</internalId></linkedfrom><linkedfrom><srcid>Mka_ConTest01028_PlainText_KeyServer</srcid><srcstatus/><internalId>1717</internalId></linkedfrom><linkedfrom><srcid>Mka_ConTest01029_MacSecDisabled_NoPlainText_Peer</srcid><srcstatus/><internalId>1718</internalId></linkedfrom><linkedfrom><srcid>Mka_ConTest01030_MacSecDisabled_NoPlainText_KeyServer</srcid><srcstatus/><internalId>1719</internalId></linkedfrom><linkedfrom><srcid>Mka_ConTest01036_Capability_0</srcid><srcstatus/><internalId>1725</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01109_Capability_3</srcid><srcstatus/><internalId>2177</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0107.CipherSuiteSelection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>959</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.27.1</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>224</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>225</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.27.2</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.6.1 MKPDU application data</source>
      <version>2</version>
      <description>
        Each MKA participant shall encodes the following information in every MKPDU transmitted:
        b) MACsec desired, a flag, set if the participant desires the use of MACsec to protect frames.
      </description>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.EB.KeyServerElection.27.2</srcid><srcstatus/><internalId>227</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0107.CipherSuiteSelection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>959</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.27</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>223</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>226</internalId></specobject>

    <specobject>
      <id>Mka.EB.KeyServerElection.27.2</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        Each MKA participant shall encodes the following information in every MKPDU transmitted:
        b) MACsec desired flag shall be set according to MACsec enable/disable status set by external APIs Mka_EnableMacSec()
           and Mka_DisableMacSec().
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_1618</srcid><srcstatus/><internalId>657</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01007_MACsecCapabilityDesired_1</srcid><srcstatus/><internalId>1696</internalId></linkedfrom><linkedfrom><srcid>Mka_ConTest01008_MACsecCapabilityDesired_2</srcid><srcstatus/><internalId>1697</internalId></linkedfrom><linkedfrom><srcid>Mka_ConTest01026_PlainText_Peer</srcid><srcstatus/><internalId>1715</internalId></linkedfrom><linkedfrom><srcid>Mka_ConTest01028_PlainText_KeyServer</srcid><srcstatus/><internalId>1717</internalId></linkedfrom><linkedfrom><srcid>Mka_ConTest01029_MacSecDisabled_NoPlainText_Peer</srcid><srcstatus/><internalId>1718</internalId></linkedfrom><linkedfrom><srcid>Mka_ConTest01030_MacSecDisabled_NoPlainText_KeyServer</srcid><srcstatus/><internalId>1719</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0107.CipherSuiteSelection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>959</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0120.MacSecDisabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>972</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.27.2</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>226</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>227</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.28</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 9.6.1 MKPDU application data</source>
      <version>1</version>
      <description>
        NOTEIEEE Std 802.1AE-2006 introduced the confidentiality offset to facilitate early MACsec deployment
        on existing systems that needed to store received frames before applying MACsec processing and that needed
        to examine the initial octets of received frames to decide where to store those frames. The XPN Cipher Suites
        standardized in IEEE Std 802.1AE do not support confidentiality offsets of other than 0.
      </description>
      <comment>This requirement is informational only.</comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>228</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.29</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.7 Cipher suite selection</source>
      <version>1</version>
      <description>
        The cipher suite, if MACsec is used to protect frames, is selected by the Key Server and advertised with each key.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_2090</srcid><srcstatus/><internalId>685</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01070_DistributedSak_CipherSuite_2</srcid><srcstatus/><internalId>2138</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01071_DistributedSak_CipherSuite_3</srcid><srcstatus/><internalId>2139</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01073_CipherSuiteSelection_HighestPriority</srcid><srcstatus/><internalId>2141</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0107.CipherSuiteSelection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>959</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>229</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.30</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 9.7 Cipher suite selection</source>
      <version>1</version>
      <description>
        Cipher suites are identified by a reference number (Table 14-1 of IEEE Std 802.1AE-2018) [Mka.8021AE.1] comprising eight
        octets, assigned by an organization that has been authorized to use a 24-bit OUI (IEEE Std 802) or a 36-bit
        OUI-36 by the IEEE Registration Authority. If the assignment is OUI based, the first three octets of the
        reference number are the octets of the OUI with the least significant bit of the first octet zero. If the
        assignment is OUI-36 based, the first four octets and the four most significant bits of the fifth octet comprise
        the OUI-36. The remainder of the reference number is assigned by the organization. The reference number
        should not correspond to any other EUI-64 assignment made by the assignee, nor should the first six octets
        be those of any EUI-48 assignment.
      </description>
      <comment>This requirement is informational only.</comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>230</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.31</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.7 Cipher suite selection</source>
      <version>1</version>
      <description>
        An MKA Key Server can also elect not to use MACsec to secure communication, using MKA simply to
        prove prior authentication (see 7.2).
        The Key Server uses an EAPOL-MKPDU to signal such use by including the Distributed SAK parameter set
        with a zero parameter set body length (see Figure 11-13). It is often convenient to refer to the use of
        plain text transmission in this context as use of the Null Cipher Suite.
      </description>
      <verifycrit>
        Verify that in case that key server has chosen not to use MACsec, an empty Distributed SAK is transmitted, with parameter set body
        length set to 0, Distributed AN and Confidentiality offset are 0 too.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_1768</srcid><srcstatus/><internalId>670</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01028_PlainText_KeyServer</srcid><srcstatus/><internalId>1717</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0120.MacSecDisabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>972</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>231</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.32</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 9.7 Cipher suite selection</source>
      <version>1</version>
      <description>
        This standard (IEEE 802.1X-2020) allocates the cipher suite reference number
        FF-FF-FF-FF-FF-FF-FF-FF to identify plain text transmission.
      </description>
      <comment>
        This requirement is not applicable: This requirement is in contradiction with the previous requirement according to which
        Distributed SAK shall be transmitted empty.
      </comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>232</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.33</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.7.1 MKPDU application data</source>
      <version>1</version>
      <description>
        A participant that believes itself to be the Key Server and its KaYs principal actor encodes the following
        information with each MACsec SAK that it distributes, unless the mandatory Default Cipher Suite
        GCM-AES-128 is to be used:
          a) MACsec Cipher Suite, the Cipher Suite reference number.
        The following information is also distributed with each MACsec SAK:
          b) Confidentiality Offset, indicating whether confidentiality is to be provided, and whether an offset of
             0, 30, or 50 octets is used (see IEEE Std 802.1AE).
      </description>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.8021X.KeyServerElection.33.1</srcid><srcstatus/><internalId>234</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.KeyServerElection.33.2</srcid><srcstatus/><internalId>235</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0108.SakGenerationDistributionUse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>960</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>233</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.33.1</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.7.1 MKPDU application data</source>
      <version>1</version>
      <description>
        A participant that believes itself to be the Key Server and its KaYs principal actor encodes the following
        information with each MACsec SAK that it distributes, unless the mandatory Default Cipher Suite GCM-AES-128 is to be used:
        - MACsec Cipher Suite, the Cipher Suite reference number.
      </description>
      <verifycrit>
        Create 4 test configurations each with different cipher suite. For each test configuration:
        1) Bring participant into a state where it is elected as key server and distributes a SAK.
        2) Verify that Distributed SAK parameter set contains configured cipher suite.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01070_DistributedSak_CipherSuite_2</srcid><srcstatus/><internalId>2138</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01071_DistributedSak_CipherSuite_3</srcid><srcstatus/><internalId>2139</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0108.SakGenerationDistributionUse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>960</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.33</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>233</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>234</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.33.2</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.7.1 MKPDU application data</source>
      <version>2</version>
      <description>
        The following information is also distributed with each MACsec SAK:
        - Confidentiality Offset, indicating whether confidentiality is to be provided, and whether an offset of
          0, 30, or 50 octets is used (see IEEE Std 802.1AE).
      </description>
      <comment>
        When MACsec is enabled, confidentiality offset in Distributed SAK parameter set is calculated based on a chosen common capability
        [Mka.EB.KeyServerElection.27.1], according to the following table:

                        Agreed MACsec Capability*  |     1     |     2     |                3                |
            Capability offset in Distributed SAK   |     0     |     1     |  MkaMacSecConfidentialityOffset |
      </comment>
      <verifycrit>
        Test case:
        1) Use participant that has configured the highest capability and capability offset.
        2) Perform MKA exchange with a peer having capability 3, 2 and 1
        3) Verify that MKPDU contains Basic parameter set and Distributed SAK with Capability and Confidentiality offset fields set according
           to the table above.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_1754</srcid><srcstatus/><internalId>669</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01009_DistributedSak</srcid><srcstatus/><internalId>1698</internalId></linkedfrom><linkedfrom><srcid>Mka_ConTest01033_Capability_1</srcid><srcstatus/><internalId>1722</internalId></linkedfrom><linkedfrom><srcid>Mka_ConTest01034_Capability_2</srcid><srcstatus/><internalId>1723</internalId></linkedfrom><linkedfrom><srcid>Mka_ConTest01035_Capability_3</srcid><srcstatus/><internalId>1724</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01070_DistributedSak_CipherSuite_2</srcid><srcstatus/><internalId>2138</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01071_DistributedSak_CipherSuite_3</srcid><srcstatus/><internalId>2139</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01110_VerifyConfidentiality_NoConfidentiality</srcid><srcstatus/><internalId>2178</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01111_VerifyConfidentiality_Confidentiality50</srcid><srcstatus/><internalId>2179</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0108.SakGenerationDistributionUse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>960</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.33</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>233</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>235</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.34</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.7.1 MKPDU application data</source>
      <version>1</version>
      <description>
        NOTEThe XPN Cipher Suites standardized in IEEE Std 802.1AE do not support confidentiality offsets of other than 0.
      </description>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.XDM.CryptoAlgoConfig.OffsetSetForXPN</srcid><srcstatus/><internalId>1667</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0107.CipherSuiteSelection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>959</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>236</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.35</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.7.1 MKPDU application data</source>
      <version>2</version>
      <description>
        If a receiving MKA participant does not implement the referenced Cipher Suite with the selected
        confidentiality offset, the distributed SAK will not be installed (12.4).
      </description>
      <comment>
        Verification of Distributed SAK parameter set is performed in the following steps:
        1) Verify that received capability (in basic parameter set) is smaller than or equal to configured peer's capability
        2) Verify that received Capability offset is according to received capability (as defined in [Mka.8021X.KeyServerElection.33.2]
        3) Verify that received cipher suite is supported by a peer.
      </comment>
      <verifycrit>
        Reuse a test described in [Mka.8021X.KeyServerElection.26] and extend it with testing of non-matching capability and confidentiality
        offset.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_2312</srcid><srcstatus/><internalId>690</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01014_UnsupportedCipherSuite</srcid><srcstatus/><internalId>1703</internalId></linkedfrom><linkedfrom><srcid>Mka_ConTest01015_UnsupportedCapability</srcid><srcstatus/><internalId>1704</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01095_DistributedSak_InvalidCipherSuite</srcid><srcstatus/><internalId>2163</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01096_DistributedSak_NoAesKeyWrap</srcid><srcstatus/><internalId>2164</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0108.SakGenerationDistributionUse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>960</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>237</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.36</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.7.1 MKPDU application data</source>
      <version>1</version>
      <description>
        An MKA participant should advertise any Cipher Suites implemented in addition to the Default
        Cipher Suite by including an Announcement parameter set (11.11.1, Figure 11-15) with a MACsec
        Cipher Suites TLV (11.12.3) in each MKPDU transmitted.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.EB.KeyServerElection.36</srcid><srcstatus/><internalId>239</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01065_KaY_FillCipherAnnouncement</srcid><srcstatus/><internalId>2133</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0107.CipherSuiteSelection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>959</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>238</internalId></specobject>

    <specobject>
      <id>Mka.EB.KeyServerElection.36</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.7.1 MKPDU application data</source>
      <version>1</version>
      <description>
        An MKA participant should advertise ALL configured Cipher Suites including the Default
        Cipher Suite by including an Announcement parameter set (11.11.1, Figure 11-15) with a MACsec
        Cipher Suites TLV (11.12.3) in each MKPDU transmitted, if configuration parameter MkaStopTxAnnouncementAfterCipherSelected is
        disabled.
        In case that MkaStopTxAnnouncementAfterCipherSelected is enabled Announcement parameter set shall be transmitted only until
        cipher suite is selected.
      </description>
      <comment>
        Rationale:
        1) According to MKA SWS, the user can configure up to 4 cipher suites, meaning that default cipher suite can / must be specified.
        2) After key server is elected, Announcement parameter set becomes obsolete, thus it's transmission is stopped.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01031_MkpduCheckParameterSetTypeOrder</srcid><srcstatus/><internalId>2099</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01119_AnnouncementNotStopped</srcid><srcstatus/><internalId>2187</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_1942</srcid><srcstatus/><internalId>679</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_1958</srcid><srcstatus/><internalId>680</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0107.CipherSuiteSelection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>959</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.36</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>238</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>239</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.37</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.8 SAK generation, distribution, and selection</source>
      <version>1</version>
      <description>
        The Key Server is responsible for generating (9.8.1) and distributing MACsec SAKs, using AES Key Wrap
        (9.8.2), to each of the other members of the CA, using the MKA transport.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_1749</srcid><srcstatus/><internalId>664</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_3045</srcid><srcstatus/><internalId>700</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.8021X.MkaKeyHierarchy.10.1</srcid><srcstatus/><internalId>126</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0108.SakGenerationDistributionUse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>960</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0104.AesKeyWrap</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>956</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>240</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.38</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.8 SAK generation, distribution, and selection</source>
      <version>1</version>
      <description>
        Each SAK is identified by a 128-bit Key Identifier (KI), comprising the Key Servers MI
        (providing the more significant bits) and a 32-bit Key Number (KN) assigned by that Key Server
        (sequentially, beginning with 1).
      </description>
      <comment/>
      <verifycrit>
        Verify that when key server distributes SAK for the first time, contained KI consists of key servers's MI + KN which is 1.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_1185</srcid><srcstatus/><internalId>635</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_1750</srcid><srcstatus/><internalId>665</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01010_SakUse</srcid><srcstatus/><internalId>1699</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0108.SakGenerationDistributionUse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>960</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>241</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.39</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 9.8 SAK generation, distribution, and selection</source>
      <version>1</version>
      <description>
        Each KI is used to identify the corresponding SAK for the purposes of SAI assignment (9.9),
        and appears in the clear in MKPDUs, so network management equipment and personnel can observe
        and diagnose MKA operation (if necessary) without having access to any secret key.
      </description>
      <comment>This requirement is informational only.</comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>242</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.40</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 9.8 SAK generation, distribution, and selection</source>
      <version>1</version>
      <description>
        NOTE 1A KN of 0 indicates that MACsec is not being used by the transmitting participant.
        Use of this reserved KN value allows the participant to report that it has elected the
        Key Server whose MI appears in the KI.
      </description>
      <comment>
        This requirement is not applicable: Described use case is not supported. If MACsec protection shall not
        be used, Mka protocol does not run on that PAE.
      </comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>243</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.41</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.8 SAK generation, distribution, and selection</source>
      <version>1</version>
      <description>
        If the Current Cipher Suite is not using extended packet numbering, the Key Server observes the Key
        Identifier and Lowest Acceptable PN for the most recent SAK in use, as transmitted by each CA member
        (the LKI and LLPN if LRX is true, and the OKI and OLPN otherwise; [Mka.8021X.KeyServerElection.77, ch 9.10.1]),
        and shall distribute a fresh SAK (subject to the constraints specified in 9.5 and this clause) if
        that Key Identifier matches the KI of the key most recently distributed and that Lowest Acceptable PN
        equals or exceeds the constant PendingPNExhaustion.
      </description>
      <comment>
        |   Parameter name   |                  Description                  |
        ----------------------------------------------------------------------
        |        LKI         |             Latest key identifier             |
        |        LLPN        |    Lowest acceptable PN for the Latest Key    |
        |        LRX         |                Latest receiving               |
        |        OKI         |             Oldest key identifier             |
        |        OLPN        |      Lowest acceptable PN for the Old Key     |
      </comment>
      <verifycrit>
        Test a use cases where participant acting as a key server has generated and distributed SAK.
        Test case 1)
        Verify that when key server receives SAK Use parameter set from a peer, with:
        1) LRX == TRUE and
        2) LKI matches KI of a last generated SAK, and
        3) Lowest acceptable PN equals PendingPNExhaustion (0xC000 0000),
        key server shall generate and distributed new SAK.
        Test case 2)
        Verify that when key server receives SAK Use parameter set from a peer, with:
        1) ORX == TRUE and
        2) OKI matches KI of a last generated SAK, and
        3) Lowest acceptable PN equals PendingPNExhaustion (0xC000 0000),
        key server shall generate and distributed new SAK.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Cp.c_1443</srcid><srcstatus/><internalId>544</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Mka_Cp.c_2890</srcid><srcstatus/><internalId>568</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_1393</srcid><srcstatus/><internalId>645</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Cp_UnitTest01028_PnExhausted</srcid><srcstatus/><internalId>1840</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01066_SakReKey_LkPnExhaustion</srcid><srcstatus/><internalId>2134</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01067_SakReKey_OkPnExhaustion</srcid><srcstatus/><internalId>2135</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01074_PnExhausted</srcid><srcstatus/><internalId>2142</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0109.SakRekeying</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>961</internalId></provcov>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00014.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>324</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0114.PacketNumbering</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>966</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>244</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.42</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.8 SAK generation, distribution, and selection</source>
      <version>1</version>
      <description>
        PendingPNExhaustion is 0xC000 0000 for 32-bit PNs and 0xC000 0000 0000 0000 for 64-bit PNs.
      </description>
      <verifycrit>
        Please use test case described in [Mka.8021X.KeyServerElection.41] for covering this requirement too.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Cp.c_1444</srcid><srcstatus/><internalId>545</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_1394</srcid><srcstatus/><internalId>646</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Cp_UnitTest01032_L_XLPn_Recovery</srcid><srcstatus/><internalId>1844</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01067_SakReKey_OkPnExhaustion</srcid><srcstatus/><internalId>2135</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01083_XpnSakUse</srcid><srcstatus/><internalId>2151</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0109.SakRekeying</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>961</internalId></provcov>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00014</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>323</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>245</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.43</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.8 SAK generation, distribution, and selection</source>
      <version>1</version>
      <description>
        Subject to conditions [Mka.8021X.KeyServerElection.45] that limit the frequency of SAK changes,
        postponing their generation and distribution until CA membership is likely to be stable,
        the Key Server shall also distribute a fresh SAK whenever a member is added to the live membership
        of CA (as perceived by the Key Serverwith each MI, not the associated SCI, representing each member),
        and can distribute a fresh SAK when a member is removed from the live membership.
      </description>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.EB.KeyServerElection.43</srcid><srcstatus/><internalId>247</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0109.SakRekeying</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>961</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>246</internalId></specobject>

    <specobject>
      <id>Mka.EB.KeyServerElection.43</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Subject to conditions [Mka.8021X.KeyServerElection.45] that limit the frequency of SAK changes, the Key Server shall
        distribute a fresh SAK in the following cases:
        1) Live partner is found (peer has proved liveness).
        2) Live partner has refreshed his MI (received MKPDU with new MI but SCI equals to the registered one, and MN restarted).
      </description>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.EB.KeyServerElection.43.1</srcid><srcstatus/><internalId>248</internalId></linkedfrom><linkedfrom><srcid>Mka.EB.KeyServerElection.43.2</srcid><srcstatus/><internalId>249</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0109.SakRekeying</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>961</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.43</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>246</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>247</internalId></specobject>

    <specobject>
      <id>Mka.EB.KeyServerElection.43.1</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Subject to conditions [Mka.8021X.KeyServerElection.45] that limit the frequency of SAK changes, the Key Server shall
        distribute a fresh SAK in the following case:
        - Live partner is found (peer has proved liveness).
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01068_IncrementAn</srcid><srcstatus/><internalId>2136</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0109.SakRekeying</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>961</internalId></provcov>
        <provcov>
          <linksto>Mka.EB.KeyServerElection.43</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>247</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>248</internalId></specobject>

    <specobject>
      <id>Mka.EB.KeyServerElection.43.2</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Subject to conditions [Mka.8021X.KeyServerElection.45] that limit the frequency of SAK changes, the Key Server shall
        distribute a fresh SAK in the following case:
        - Live partner has refreshed his MI (received MKPDU with new MI but SCI equals to the registered one, and MN restarted).
      </description>
      <verifycrit>
        Perform the following test case: After key server has distributed SAK, receive MKPDU from a partner with MN equals 0xFFFFFFFF,
        then receive MKPDU with new MI, MN set to 1 and the old SCI.
        Verify that key server has distributed new SAK.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01075_LivePartnerRefreshedMI</srcid><srcstatus/><internalId>2143</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0109.SakRekeying</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>961</internalId></provcov>
        <provcov>
          <linksto>Mka.EB.KeyServerElection.43</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>247</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>249</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.44</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.8 SAK generation, distribution, and selection</source>
      <version>1</version>
      <description>
        If the Key Server has not generated a fresh SAK since the last addition to the Key Servers Live Peer List,
        an SAK is not distributed in transmitted MKPDUs.
      </description>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.8021X.KeyServerElection.46</srcid><srcstatus/><internalId>255</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0108.SakGenerationDistributionUse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>960</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>250</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.45</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.8 SAK generation, distribution, and selection</source>
      <version>1</version>
      <description>
        A fresh SAK is not distributed until:
          a) The Key Servers Live Peer List contains at least one peer, and
          b) An MKA suspension is not in progress, i.e., the Key Server either does not support suspension
             (5.11.4), or the Key Servers suspendedWhile timer is zero (9.18), and
          c) Either
            1) MKA Life Time (Table 9-3) has elapsed since the prior SAK was first distributed,
            or
            2) The Key Servers Potential Peer List is empty.
      </description>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.EB.KeyServerElection.45</srcid><srcstatus/><internalId>252</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Mka.PointToPointOnly</srcid><srcstatus/><internalId>489</internalId></linkedfrom><linkedfrom><srcid>dev.MkaSuspensionNotSupported</srcid><srcstatus/><internalId>490</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0108.SakGenerationDistributionUse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>960</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>251</internalId></specobject>

    <specobject>
      <id>Mka.EB.KeyServerElection.45</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.8 SAK generation, distribution, and selection</source>
      <version>1</version>
      <description>
        Since only point-to-point use case is supported while MKA suspension is not, the original requirement
        is simplified into the following:
        A fresh SAK is not distributed until:
          a) The Key Server's partner has proved liveness.
          b) MKA Life Time (Table 9-3, [Mka.8021X.MkaParticipantTimerValues.5]) has elapsed since the prior SAK was first distributed.
      </description>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.EB.KeyServerElection.45.1</srcid><srcstatus/><internalId>253</internalId></linkedfrom><linkedfrom><srcid>Mka.EB.KeyServerElection.45.2</srcid><srcstatus/><internalId>254</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0108.SakGenerationDistributionUse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>960</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.45</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>251</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>252</internalId></specobject>

    <specobject>
      <id>Mka.EB.KeyServerElection.45.1</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.8 SAK generation, distribution, and selection</source>
      <version>1</version>
      <description>
        A fresh SAK is not distributed until the Key Server's partner has proved liveness.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_3067</srcid><srcstatus/><internalId>702</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0108.SakGenerationDistributionUse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>960</internalId></provcov>
        <provcov>
          <linksto>Mka.EB.KeyServerElection.45</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>252</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>253</internalId></specobject>

    <specobject>
      <id>Mka.EB.KeyServerElection.45.2</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.8 SAK generation, distribution, and selection</source>
      <version>1</version>
      <description>
        A fresh SAK is not distributed until a MKA Life Time (Table 9-3, [Mka.8021X.MkaParticipantTimerValues.5])
        has elapsed since the prior SAK was first distributed.
      </description>
      <verifycrit>
        Test the following use case:
        1) Bring participant into state where it has elected self as key server.
        2) Perform exchange of MKPDUs so that SAK is installed for TX and RX.
        3) Provoke SAK rekeying (timer, or PN exhaustion).
        4) Verify new SAK is not distributed until NEW_SAK_DELAY timer has expired.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_3068</srcid><srcstatus/><internalId>703</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01011_SakRekeyDelay</srcid><srcstatus/><internalId>1700</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0108.SakGenerationDistributionUse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>960</internalId></provcov>
        <provcov>
          <linksto>Mka.EB.KeyServerElection.45</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>252</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.MkaParticipantTimerValues.5</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>100</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>254</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.46</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.8 SAK generation, distribution, and selection</source>
      <version>1</version>
      <description>
        Once a Key Server has generated an SAK, it shall be distributed in each MKPDU transmitted by its principal
        actor until all live peers that can use the selected Cipher Suite and Cipher Suite capability (9.6.1) report
        having installed the SAK for receive or until a change in the live membership of the CA requires
        the generation of a fresh SAK.
      </description>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.EB.KeyServerElection.46</srcid><srcstatus/><internalId>256</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.44</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>250</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0108.SakGenerationDistributionUse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>960</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>255</internalId></specobject>

    <specobject>
      <id>Mka.EB.KeyServerElection.46</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.8 SAK generation, distribution, and selection</source>
      <version>1</version>
      <description>
        Transmission of Distributed SAK parameter set stops when key server receives SAK Use parameter set from a peer, with LRX == TRUE,
        and LKI matches KI of a last generated SAK, indicating that peer has received and installed new SAK.
      </description>
      <verifycrit>
        Test a use case where participant acting as a key server has generated and distributed SAK.
        Verify that Distributed SAK is transmitted with every MKPDU.
        Also verify that Distributed SAK transmission stops when key server receives SAK use parameter set from a peer with:
        1) LRX == TRUE and
        2) LKI matches KI of a last generated SAK.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Cp.c_1469</srcid><srcstatus/><internalId>548</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01011_SakRekeyDelay</srcid><srcstatus/><internalId>1700</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.46</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>255</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0108.SakGenerationDistributionUse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>960</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>256</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.47</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 9.8 SAK generation, distribution, and selection</source>
      <version>1</version>
      <description>
        NOTE 2The CP state machine (Figure 12-2) ensures that SAKs are not continually changed faster
        than they can be installed and used by each of the CA members.
      </description>
      <comment>This requirement is informational only.</comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>257</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.48</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 9.8 SAK generation, distribution, and selection</source>
      <version>1</version>
      <description>
        An MKA participant does not retain any record of SAKs used prior to initialization or re-initialization,
        and uses a fresh MI whenever it is initialized, thus forcing distribution of a fresh SAK whenever it has
        no record of prior SAK use.
      </description>
      <comment>This requirement is informational only.</comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>258</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.49</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 9.8 SAK generation, distribution, and selection</source>
      <version>1</version>
      <description>
        An MKA participant is re-initialized, or deleted and a fresh participant created, if the associated SCI is changed.
      </description>
      <comment>
        This requirement is not applicable: SCI change is not foreseen.
      </comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>259</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.50</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.8 SAK generation, distribution, and selection</source>
      <version>1</version>
      <description>
        An MKA participant accepts only SAKs distributed by Key Servers that are mutually live,
        i.e., shall not accept an SAK distributed in any MKPDU that does not contain that participants MI and
        acceptably recent MN in the Live Peer List.
      </description>
      <verifycrit>
        Verify the following use case:
        1) Bring the participant into a state where it has elected partner for a key server.
        2) Send MKPDU with a valid Distributed SAK parameter set, but with Live peer list that does not contain our MI.
        3) Verify that SAK is not accepted, i.e. updated in SecY.
        4) Repeat a test case, but this time attach Live peer list that contains our MI and verify that SAK is accepted.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_2835</srcid><srcstatus/><internalId>697</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01012_SakDistribution_WrongMi</srcid><srcstatus/><internalId>1701</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0108.SakGenerationDistributionUse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>960</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>260</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.51</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.8 SAK generation, distribution, and selection</source>
      <version>1</version>
      <description>
        Inclusion in the Potential Peer List is sufficient to prove that the Key Server is live,
        but not that it has recognized the participant as live and updated the distributed key.
      </description>
      <verifycrit>
        Re-use a test case described in [Mka.8021X.KeyServerElection.50] with the difference:
        - In the received MKPDU add Potential peer list that contains our MI instead of live peer list.
        Verify also that SAK is not accepted, i.e. updated in SecY.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_2836</srcid><srcstatus/><internalId>698</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01013_SakDistribution_Potential</srcid><srcstatus/><internalId>1702</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0108.SakGenerationDistributionUse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>960</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>261</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.52</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 9.8 SAK generation, distribution, and selection</source>
      <version>1</version>
      <description>
        Reinitializing and using a new MI if an SCI is changed prevents use of the new SCI in conjunction
        with a previously distributed SAK, allows the Key Server to check for SCI collision before distributing
        a fresh SAK, and means that the Key Server and other participants are aware of the change when calculating SSCI values.
      </description>
      <comment>
        This requirement is not applicable: SCI change is not foreseen.
      </comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>262</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.53</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 9.8 SAK generation, distribution, and selection</source>
      <version>1</version>
      <description>
        Each participant shall record the values of KI, nextPN for secure frame generation, for the last SAK
        accepted from each Key Server (as identified by the MI that forms part of the KI), to ensure that
        the SAK-nonce pair is not reused if the member switches (or is induced to switch) to a different Key
        Server and back to a previously used Key Server.
      </description>
      <comment>
        This requirement is not applicable: Change of key server is not possible in point-to-point use case.
        TODO: Do we have a possibility to switch to another key server? Is refresh of MI such a case? IMO once key server is
        elected there is no way to change it, peer can only be deleted if no communication for &gt;6 sec.
      </comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>263</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.54</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 9.8 SAK generation, distribution, and selection</source>
      <version>1</version>
      <description>
        Each member shall be capable of recording at least four such KI, nextPN tuples, and shall reinitialize
        (thus choosing a new MI, and forcing distribution of a fresh SAK) if the number of Key Servers used since
        the MI was chosen exceeds its ability to maintain all the relevant tuples, irrespective of the time elapsed
        or perceived to have elapsed since the SAK distributed by a given Key Server was last used.
      </description>
      <comment>
        This requirement is not applicable: Change of key server is not possible in point-to-point use case.
      </comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>264</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.55</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.8 SAK generation, distribution, and selection</source>
      <version>1</version>
      <description>
        Once a Key Server has distributed an SAK, it shall not distribute any previously generated SAK in any subsequent MKPDU.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_3046</srcid><srcstatus/><internalId>701</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0108.SakGenerationDistributionUse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>960</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>265</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.56</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 9.8 SAK generation, distribution, and selection</source>
      <version>1</version>
      <description>
        It is recognized that successive SAKs will have the same value with a probability of no less
        than 1 in 2-keysize when generated as specified (see 9.8.1).
      </description>
      <comment>This requirement is informational only.</comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>266</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.57</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 9.8 SAK generation, distribution, and selection</source>
      <version>1</version>
      <description>
        A Key Server shall distribute a fresh SAK whenever it selects a new MACsec Cipher Suite (9.7)
        unless the new Cipher Suite is the Null Cipher Suite, i.e., plain text transmission is selected.
        The CP state machine (12.4) ensures that this requirement is met.
      </description>
      <comment>
        This requirement is not applicable: Once key server and cipher suites are elected they cannot change until next start-up process
        (and module reconfiguration), so described use case for SAK re-distribution is not valid.
      </comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>267</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.58</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.8.3 MKPDU application data</source>
      <version>1</version>
      <description>
        Each participant that considers itself to be the current Key Server can distribute an SAK by
        encoding the following information in transmitted MKPDUs:
          a) Distributed SAK, the SAK, protected by AES Key Wrap (see 6.2.4, 9.8.2, Figure 11-11).
          b) The KN, 32 bits.
      </description>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.8021X.KeyServerElection.58.1</srcid><srcstatus/><internalId>269</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.KeyServerElection.58.2</srcid><srcstatus/><internalId>270</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0108.SakGenerationDistributionUse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>960</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>268</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.58.1</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.8.3 MKPDU application data</source>
      <version>1</version>
      <description>
        Each participant that considers itself to be the current Key Server can distribute an SAK by
        encoding the following information in transmitted MKPDUs:
        - Distributed SAK, the SAK, protected by AES Key Wrap (see 6.2.4, 9.8.2, Figure 11-11).
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_1751</srcid><srcstatus/><internalId>666</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01003_KSPLow_KSActor</srcid><srcstatus/><internalId>1691</internalId></linkedfrom><linkedfrom><srcid>Mka_ConTest01009_DistributedSak</srcid><srcstatus/><internalId>1698</internalId></linkedfrom><linkedfrom><srcid>Mka_ConTest01026_PlainText_Peer</srcid><srcstatus/><internalId>1715</internalId></linkedfrom><linkedfrom><srcid>Mka_ConTest01027_PlainText_Peer_Permissive</srcid><srcstatus/><internalId>1716</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0108.SakGenerationDistributionUse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>960</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.58</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>268</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>269</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.58.2</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.8.3 MKPDU application data</source>
      <version>1</version>
      <description>
        Each participant that considers itself to be the current Key Server can distribute an SAK by
        encoding the following information in transmitted MKPDUs:
        - The KN, 32 bits.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_1752</srcid><srcstatus/><internalId>667</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01009_DistributedSak</srcid><srcstatus/><internalId>1698</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0108.SakGenerationDistributionUse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>960</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.58</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>268</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>270</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.59</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.8.3 MKPDU application data</source>
      <version>1</version>
      <description>
        Only one Distributed Key is present in an MKPDU, although each participant can be using up to
        two SAKs to protect MACsec data (9.10).
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_1911</srcid><srcstatus/><internalId>676</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0108.SakGenerationDistributionUse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>960</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>271</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.60</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.9 SA assignment</source>
      <version>1</version>
      <description>
        The Key Server identifies the association number (AN) to be used with each key it distributes,
        using ANs in sequence (0,1,2,3,0,) unless it yields to a higher priority key server for a period,
        and beginning the sequence with the first AN following the last SAK in use by any live CA member when
        the SAK was first distributed.
      </description>
      <comment>
        The second part of the requirement "unless it yields to a higher priority key server..."
        is not relevant for the current implementation, where use case of switching key server is not foreseen.
      </comment>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.EB.KeyServerElection.60</srcid><srcstatus/><internalId>273</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0108.SakGenerationDistributionUse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>960</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>272</internalId></specobject>

    <specobject>
      <id>Mka.EB.KeyServerElection.60</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The Key Server identifies the association number (AN) to be used with each key it distributes,
        using ANs in sequence (0,1,2,3,0,).
      </description>
      <verifycrit>
        Re-use test case described in [Mka.8021X.KeyServerElection.41] and send described SAK Use parameter set with exhausted PN several
        times, and verify that AN increments as specified.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_1181</srcid><srcstatus/><internalId>634</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01068_IncrementAn</srcid><srcstatus/><internalId>2136</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.60</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>272</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0108.SakGenerationDistributionUse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>960</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>273</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.61</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.9.1 MKPDU application data</source>
      <version>1</version>
      <description>
        The Key Server encodes the following information in every MKPDU transmitted that includes a
        Distributed SAK, i.e., that has the Key Present flag set:
        - Distributed AN, an enumeration [0,1,2,3].
      </description>
      <comment>
        "Key Present flag" is not found in 802.1X document.
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_1753</srcid><srcstatus/><internalId>668</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01009_DistributedSak</srcid><srcstatus/><internalId>1698</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0108.SakGenerationDistributionUse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>960</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>274</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.62</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 9.10 SAK installation and use</source>
      <version>1</version>
      <description>
        Each CA members KaY uses the LMI supported by the SecY (10.7 of IEEE Std 802.1AE-2018) to create a
        receive SC for each of its live peers SCs and a SA for each receive SC and its own transmit SC(s)
        using the distributed SAK and AN.
      </description>
      <comment>
        This requirement is not applicable: Creation and deletion of SCs is done through EthIf module.
      </comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>275</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.63</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.10 SAK installation and use</source>
      <version>1</version>
      <description>
        NOTE 1As specified in IEEE Std 802.1AE, an MKA participant is associated with each transmit SC even if
        multiple transmit SCs (each with its own SCI) are associated with one KaY. Only one of those participants
        can act as the Key Server at a time. MIs for the others are included in its Live Peer List.
      </description>
      <comment>
        Only point-to-point use case is supported -&gt; only single TX SC and single RX SC are foreseen.
      </comment>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Mka.PointToPointOnly</srcid><srcstatus/><internalId>489</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>276</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.64</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.10 SAK installation and use</source>
      <version>1</version>
      <description>
        Each participant advertises the status of the receive SAs and its transmit SA. The Key Server will enable
        transmission for its transmit SA, immediately if it was not previously transmitting or receiving,
        and when all live peers report that they can receive using the corresponding SAK and AN otherwise.
        The other participants enable transmission when they see that the Key Server is transmitting using the SAK and AN.
        See the CP state machine (12.4, Figure 12-2).
      </description>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.dsn.Cp.CpSM</srcid><srcstatus/><internalId>1097</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0108.SakGenerationDistributionUse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>960</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>277</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.65</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.10 SAK installation and use</source>
      <version>1</version>
      <description>
        If the KaY comprises more than one actor, only SAKs that are received by the principal actor
        (or distributed by that actor if it is the Key Server itself) are installed.
      </description>
      <verifycrit>
        Test case 1)
        1) Create two participants.
        2) Bring both of them into the state where they elected partner as a key server.
        3) Chose one of them to be a principal actor.
        4) Send Distributed SAK to a participant that is not chosen to be a principal actor.
        5) Verify that SAK is not installed into SecY.
        6) Send Distributed SAK to a participant that is principal actor.
        7) Verify that SAK is installed into SecY.
        Test case 2)
        1) Create two participants.
        2) Bring both of them into the state where they elected self as a key server.
        3) Chose one of them to be a principal actor.
        4) Verify that only principal actor has generated and distributed SAK.
        5) Delete principal actor.
        6) Chose remaining participant as principal actor.
        7) Verify SAK is generated and distributed by that participant.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_996</srcid><srcstatus/><internalId>626</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_1093</srcid><srcstatus/><internalId>630</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01044_KSPHigh_KSPartner_Restart</srcid><srcstatus/><internalId>1693</internalId></linkedfrom><linkedfrom><srcid>Mka_ConTest01019_TwoSaks_1</srcid><srcstatus/><internalId>1708</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0108.SakGenerationDistributionUse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>960</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>278</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.66</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.10 SAK installation and use</source>
      <version>1</version>
      <description>
        Each CA member advertises the lowest PN used for each SAK (LLPN, OLPNLowest Acceptable PN for
        the Old Key) within one second prior to transmitting each MKPDU window, and may use the time bounds
        provided by received LPNs and the reflection of its own MI. MN tuples in the Live or Potential Peer List
        to discard delayed traffic.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Cp_UnitTest01027_FillSakUse</srcid><srcstatus/><internalId>1839</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0108.SakGenerationDistributionUse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>960</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0114.PacketNumbering</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>966</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>279</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.67</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 9.10 SAK installation and use</source>
      <version>1</version>
      <description>
        NOTE 2Enforcement of bounded received delay necessitates transmission of MKPDUs at frequent (0.5 s) intervals,
        to meet a maximum data delay of 2 s while minimizing connectivity interruption due to the possibility of lost or delayed
        MKPDUs. MKPDU can therefore operate without data delay protection, to lessen its processing requirements.
      </description>
      <comment>This requirement is informational only.
               TODO: It shall be checked if data delay protection shall be supported or not.
      </comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>280</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.68</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.10 SAK installation and use</source>
      <version>1</version>
      <description>
        When MKA is used in conjunction with an XPN Cipher Suite, an SSCI is required for each SA. As specified
        in IEEE Std 802.1AE, the SA with the numerically greatest SCI uses the SSCI value 0x00000001, that with
        the next to the greatest SCI uses the SSCI value 0x00000002, and so on. The value 0x00000000 is not used.
      </description>
      <verifycrit>
        Verify that correct SSCI is in the live peer list.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01079_CheckSsci_1</srcid><srcstatus/><internalId>2147</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01080_CheckSsci_2</srcid><srcstatus/><internalId>2148</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01081_CheckSsci_3</srcid><srcstatus/><internalId>2149</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0113.Xpn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>965</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>281</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.69</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.10 SAK installation and use</source>
      <version>1</version>
      <description>
        PAEs that implement MKA Version 3 (or higher) order the MIs in the Live Peer List of transmitted
        MKPDUs. The MI associated with the numerically greatest SCI occurs first in the list, that with the
        next to greatest SCI second, and so on. The Key Servers own MI is not included in the Live Peer List.
      </description>
      <comment>
        Not relevant for point-to-point use case, since Live peer list can have maximum one element.
      </comment>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Mka.PointToPointOnly</srcid><srcstatus/><internalId>489</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>282</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.70</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.10 SAK installation and use</source>
      <version>1</version>
      <description>
        The SSCI of the Key Server is also encoded in each MKPDU used to distribute an SAK for an XPN Cipher Suite,
        and indicates not only the value to be used by the Key Server, but also is corresponding to the position
        that it would otherwise occupy in the list. This information allows a receiving participant to determine
        the SCI to SSCI mappings for the transmit SAs used by it and each of the participants in the MKPDUs
        Live Peer List that are also in its own Live Peer List, even if those lists differ as a result of MKPDU
        loss or delay.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01079_CheckSsci_1</srcid><srcstatus/><internalId>2147</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01080_CheckSsci_2</srcid><srcstatus/><internalId>2148</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01081_CheckSsci_3</srcid><srcstatus/><internalId>2149</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0113.Xpn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>965</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>283</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.72</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.10 SAK installation and use</source>
      <version>1</version>
      <description>
        On receipt of a Version 3 or higher MKPDU distributing an SAK for an XPN Cipher Suite, a PAE
        implementing MKA Version 3 determines SSCI values as follows.
        The Key Servers SA takes the SSCI value explicitly encoded in the Live Peer List in the MKPDU.
        The SSCIs are then assigned in order to each of the SAs.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01079_CheckSsci_1</srcid><srcstatus/><internalId>2147</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01080_CheckSsci_2</srcid><srcstatus/><internalId>2148</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01081_CheckSsci_3</srcid><srcstatus/><internalId>2149</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0113.Xpn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>965</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>284</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.73</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.10 SAK installation and use</source>
      <version>1</version>
      <description>
        The MI values that have a position ordinally lower than the Key Servers SSCI are given their
        ordinal value. The MI values that have a position in the Live Peer List of the Key Servers SSCI
        or greater are given an SSCI of their ordinal value + 1.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01079_CheckSsci_1</srcid><srcstatus/><internalId>2147</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01080_CheckSsci_2</srcid><srcstatus/><internalId>2148</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01081_CheckSsci_3</srcid><srcstatus/><internalId>2149</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0113.Xpn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>965</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>285</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.74</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 9.10 SAK installation and use</source>
      <version>1</version>
      <description>
        So, for example, if the Key Servers transmit SAs SSCI is 0x00000002 and there are three MI values
        in the MKPDU Live Peer List, then their transmit SAs SSCIs are
        0x00000001, 0x00000003, and 0x00000004, respectively.
      </description>
      <comment>This requirement is informational only.</comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>286</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.75</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.10 SAK installation and use</source>
      <version>1</version>
      <description>
        A receive SA is not created for any MI that is not in the Live List of a participant receiving a
        distributed SAK, but the ordered Live List from the MKPDU distributing that SAK is retained so the
        receive SA can be created when an MKPDU with that MI, proving liveness and conveying an SCI, is received.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Cp_UnitTest01029_CheckSsci_1</srcid><srcstatus/><internalId>1841</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01030_CheckSsci_2</srcid><srcstatus/><internalId>1842</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01031_CheckSsci_3</srcid><srcstatus/><internalId>1843</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0113.Xpn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>965</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>287</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.76</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.10 SAK installation and use</source>
      <version>1</version>
      <description>
        NOTE 3Since SSCIs are assigned sequentially and MKPDUs can convey information for only a limited number of
        participants, only the least significant octet of the Key Servers SSCI is encoded in MKPDUs; each of the more
        significant octets has the value 0x00.
      </description>
      <comment>
        Not relevant for point-to-point use case, since Live peer list can have maximum one member.
      </comment>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Mka.PointToPointOnly</srcid><srcstatus/><internalId>489</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0113.Xpn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>965</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>288</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.77</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.10.1 MKPDU application data</source>
      <version>1</version>
      <description>
        Each CA member encodes the following information in every MKPDU transmitted, for the latest and
        the old AN:
          a) AN
          b) KI, the Key Identifier for an SAK
          c) LPN, Lowest Acceptable PN (least significant 32 bits for XPN Cipher Suites)
          d) Receiving, TRUE if reception for the SAK is enabled for all the receive SAs identified by AN
          e) Transmitting, TRUE if the SecY is transmitting using the SAK and its own SA with that AN
          f) Delay Protect, TRUE if LPNs are being reported sufficiently frequently to allow the recipient to
             provide data delay protection. If FALSE, the LPN can be reported as zero
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Cp.c_1149</srcid><srcstatus/><internalId>538</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01010_SakUse</srcid><srcstatus/><internalId>1699</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0108.SakGenerationDistributionUse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>960</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>289</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.78</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 9.10.1 MKPDU application data</source>
      <version>1</version>
      <description>
        A fixed format encoding is used. For convenience, these fields can be identified by the names and acronyms
        Latest AN, Old AN (LAN, OAN), Latest Key Identifier/Old Key Identifier (LKI/OKI), Lowest Acceptable
        PN for the Latest Key/Lowest Acceptable PN for the Old Key (LLPN/OLPN), Latest Receiving/Old
        Receiving (LRX/ORX), Latest Transmitting/Old Transmitting (LTX/OTX).
      </description>
      <comment>This requirement is informational only.</comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>290</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.79</id>
      <status>rejected</status>
      <source>IEEE Std 802.1X-2020, 9.10.1 MKPDU application data</source>
      <version>1</version>
      <description>
        NOTE 1The Latest and Old SAKs were not necessarily distributed by the same Key Server, or
        by the current Key Server. Both can be receiving at the same time, to enable transition from
        one SAK to the next without frame loss, although only one will be transmitting at any instant.
      </description>
      <comment>This requirement is informational only.</comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>291</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.80</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.10.1 MKPDU application data</source>
      <version>1</version>
      <description>
        NOTE 2When an XPN Cipher Suite is used the most significant 32 bits of the Lowest Acceptable PNs
        for both ANs are encoded in XPN parameter set.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01018_XPN</srcid><srcstatus/><internalId>1707</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0113.Xpn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>965</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>292</internalId></specobject>

    <specobject>
      <id>Mka.8021X.KeyServerElection.81</id>
      <status>approved</status>
      <source>IEEE Std 802.1X-2020, 9.10.1 MKPDU application data</source>
      <version>1</version>
      <description>
        PAEs that implement MKA Version 3 (or higher) order the MIs in the Live Peer List of transmitted
        MKPDUs as specified above (9.10) and encode the Key Servers transmit SAs SSCI in every MKPDU used
        to distribute an SAK for an XPN Cipher Suite.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01079_CheckSsci_1</srcid><srcstatus/><internalId>2147</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0113.Xpn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>965</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>293</internalId></specobject>

  </specobjects>
    <specobjects doctype="swurs">

<!-- ===================================[General Requirements]================================= -->
    <specobject>
      <id>Mka.CP_SWS_Mka_00001</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        The MKA Module shall implement the EAP-MKA protocol version 3 as specified in [IEEE-802.1X-2020]
        chapter 9 and AUTOSAR Foundation.
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.8021X.Eapol.7.1</srcid><srcstatus/><internalId>38</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>294</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_00001.1</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Note: The MKA Module should be modelled as described in [IEEE-802.1X-2020] chapter 12.
        For the excluded parts please refer to section 4.1.
        Excluded parts:
          - Only participants authentication based on Connectivity Association pre-shared keys (CAKs) is supported.
            (EAP-TLS, EAP-IKEv2, and other variants are not supported).
          - Only MACsec between direct peers is supported (e.g. Point-to-Point configurations).
          - Point-to-Multipoint configurations are not supported.
          - In-service upgrades with EAPoL-MKA frames are not supported.
          - Temporary suspension of MKA operation is not supported.
          - MACsec Cipher Suites is the only currently supported EAPoL-Announcement TLV.
            The following EAPoL Announcements are currently not required:
              - Access Information -&gt; TLV Type 111
              - Key Management Domain -&gt; TLV Type 113
              - NID -&gt; TLV Type 114
          - Dynamic Key Server election based on Key Server priority is not supported (Roles are set per configuration and fixed).
          - The following MKPDU Parameter sets are currently not required:
            - Distributed CAK -&gt; Parameter set type 5
            - KMD -&gt; Parameter set type 6
            - ICV Indicator -&gt; Parameter set type 255
      </description>
      <comment>This requirement is informational only.</comment>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>295</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_00002</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        The MKA Module shall support 1 to n independent Port Access Entities (PAEs) running at the same time through
        different ports.
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01002_LogonIckGenerateFinished_Principal</srcid><srcstatus/><internalId>2192</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>296</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_00002.1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Note: Each physical (Switch port or transceiver) or virtual (MACsec per SW) port will support 0 (No MACsec) or 1 PAE.
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_211</srcid><srcstatus/><internalId>830</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.XDM.MkaPaeEthIfEthTrcvRef_InvalidReference</srcid><srcstatus/><internalId>1685</internalId></linkedfrom><linkedfrom><srcid>Mka.XDM.MkaPaeEthIfEthTrcvRef_UniqueReference</srcid><srcstatus/><internalId>1686</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>297</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_00003</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        The MKA Module shall support a list of VLANs to get MACsec by-passed per PAE (i.e. per physical(Switch port or transceiver)
        or virtual (MACsec per SW) port). The list of bypassed VLANs shall be provided per configuration (MkaBypassVlan).
        Note: The MACsec by-passed traffic will be unprotected traffic through the port.
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Cp_UnitTest01001_CpSM_Uninit2Secured</srcid><srcstatus/><internalId>1813</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0116.BypassRules</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>968</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>298</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_00004</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        The MKA Module shall support a list of EtherTypes to get MACsec by-passed per PAE
        (i.e. per physical (Switch port or transceiver) or virtual (MACsec per SW) port).
        The list of bypassed EtherTypes shall be provided per configuration (MkaBypassEtherType).
        Note: The MACsec by-passed traffic will be unprotected traffic through the port.
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Cp_UnitTest01001_CpSM_Uninit2Secured</srcid><srcstatus/><internalId>1813</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0116.BypassRules</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>968</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>299</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_00005</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        The MKA Module shall support configuring 1 to n CKNs in an specific Port Access Entity (PAE).
        Each CKN configured will start a parallel MACsec participant entity (i.e. MkaKayParticipant)
        through the mentioned PAE.
        Repeated CKNs shall be treated as one for an specific PAE.
        Note: It is recommended to implement a configuration check to avoid duplicated CKNs referred under
        the same MkaKay instance.
      </description>
      <comment>
        Configuration check for duplicated CKNs cannot be implemented since CKN is only known during run-time (externally configured).
      </comment>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.CP_SWS_Mka_00005.1</srcid><srcstatus/><internalId>301</internalId></linkedfrom><linkedfrom><srcid>Mka.CP_SWS_Mka_00005.2</srcid><srcstatus/><internalId>302</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>300</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_00005.1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        The MKA Module shall support configuring 1 to n CKNs in an specific Port Access Entity (PAE).
        Each CKN configured will start a parallel MACsec participant entity (i.e. MkaKayParticipant)
        through the mentioned PAE.
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01014_AutoStart</srcid><srcstatus/><internalId>2204</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>300</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>301</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_00005.2</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Repeated CKNs shall be treated as one for an specific PAE.
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01173_DuplicatedCkn</srcid><srcstatus/><internalId>2068</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Crypto.c_622</srcid><srcstatus/><internalId>578</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>300</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>302</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_00006</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        An MKA KaY participant (MkaKayParticipant) shall not start transmitting or processing MKPDUs until its
        respective CAK is available and the derived keys (ICK and KEK) are ready.
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.KekDerivatedAfterFirstMkpduTransmission</srcid><srcstatus/><internalId>497</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.EB.CP_SWS_Mka_00006</srcid><srcstatus/><internalId>304</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>303</internalId></specobject>

    <specobject>
      <id>Mka.EB.CP_SWS_Mka_00006</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        An MKA KaY participant (MkaKayParticipant) shall not start transmitting or processing MKPDUs until its
        respective CAK is available and the derived ICK key is ready.
      </description>
      <comment>
        In order to speed-up startup process, only ICK is derived from CAK before the first MKPDU transmission. KEK is needed
        in the later phase of MKA exchange for ASK wrapping/unwrapping, thus can be derived after the first MKPDU is transmitted.
      </comment>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_RxTx_UnitTest01008_EAPOL_27_7</srcid><srcstatus/><internalId>2322</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00006</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>303</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>304</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_00007</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        The MKA Module shall support generation of SAKs based on:
          - Key Derivation Function (KDF), see [IEEE-802.1X-2020] chapter 9.8.1.,
          - Random Number Generator (RNG).
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.CP_SWS_Mka_00007.1</srcid><srcstatus/><internalId>306</internalId></linkedfrom><linkedfrom><srcid>Mka.CP_SWS_Mka_00007.2</srcid><srcstatus/><internalId>307</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>305</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_00007.1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        The MKA Module shall support generation of SAKs based on:
          - Key Derivation Function (KDF), see [IEEE-802.1X-2020] chapter 9.8.1.
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Mka.SakKdfGenerationNotSupported</srcid><srcstatus/><internalId>494</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00007</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>305</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>306</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_00007.2</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        The MKA Module shall support generation of SAKs based on:
          - Random Number Generator (RNG).
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01050_SakGenWrap_Async128</srcid><srcstatus/><internalId>1954</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01051_SakGenWrap_Sync128</srcid><srcstatus/><internalId>1955</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01052_SakGenWrap_Async256</srcid><srcstatus/><internalId>1956</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01053_SakGenWrap_Sync256</srcid><srcstatus/><internalId>1957</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00007</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>305</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0102.RandomNumberGenerator</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>954</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>307</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_00008</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        The MKA Module shall support the following MKPDU Parameter sets:
          - Basic Parameter Set,
          - Live Peer List -&gt; Parameter set type 1,
          - Potential Peer List -&gt; Parameter set type 2,
          - MACsec SAK Use -&gt; Parameter set type 3,
          - Distributed SAK -&gt; Parameter set type 4,
          - Announcement -&gt; Parameter set type 7,
          - XPN -&gt; Parameter set type 8.
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.CP_SWS_Mka_00008.1</srcid><srcstatus/><internalId>309</internalId></linkedfrom><linkedfrom><srcid>Mka.CP_SWS_Mka_00008.2</srcid><srcstatus/><internalId>310</internalId></linkedfrom><linkedfrom><srcid>Mka.CP_SWS_Mka_00008.3</srcid><srcstatus/><internalId>311</internalId></linkedfrom><linkedfrom><srcid>Mka.CP_SWS_Mka_00008.4</srcid><srcstatus/><internalId>312</internalId></linkedfrom><linkedfrom><srcid>Mka.CP_SWS_Mka_00008.5</srcid><srcstatus/><internalId>313</internalId></linkedfrom><linkedfrom><srcid>Mka.CP_SWS_Mka_00008.6</srcid><srcstatus/><internalId>314</internalId></linkedfrom><linkedfrom><srcid>Mka.CP_SWS_Mka_00008.7</srcid><srcstatus/><internalId>315</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>308</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_00008.1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        The MKA Module shall support the following MKPDU Parameter sets:
          - Basic Parameter Set.
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.8021X.Eapol.26</srcid><srcstatus/><internalId>68</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00008</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>308</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>309</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_00008.2</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        The MKA Module shall support the following MKPDU Parameter sets:
          - Live Peer List -&gt; Parameter set type 1.
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.dsn.Func0105.PeerLists</srcid><srcstatus/><internalId>957</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00008</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>308</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>310</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_00008.3</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        The MKA Module shall support the following MKPDU Parameter sets:
          - Potential Peer List -&gt; Parameter set type 2.
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.dsn.Func0105.PeerLists</srcid><srcstatus/><internalId>957</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00008</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>308</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>311</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_00008.4</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        The MKA Module shall support the following MKPDU Parameter sets:
          - MACsec SAK Use -&gt; Parameter set type 3.
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01010_SakUse</srcid><srcstatus/><internalId>1699</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00008</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>308</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>312</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_00008.5</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        The MKA Module shall support the following MKPDU Parameter sets:
          - Distributed SAK -&gt; Parameter set type 4.
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01009_DistributedSak</srcid><srcstatus/><internalId>1698</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00008</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>308</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>313</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_00008.6</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        The MKA Module shall support the following MKPDU Parameter sets:
          - Announcement -&gt; Parameter set type 7.
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01062_AnnouncementParSet_9_6</srcid><srcstatus/><internalId>2130</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01065_KaY_FillCipherAnnouncement</srcid><srcstatus/><internalId>2133</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_1860</srcid><srcstatus/><internalId>673</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Mka_Lib_ParSet.c_372</srcid><srcstatus/><internalId>733</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00008</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>308</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0107.CipherSuiteSelection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>959</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>314</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_00008.7</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        The MKA Module shall support the following MKPDU Parameter sets:
          - XPN -&gt; Parameter set type 8.
      </description>
      <verifycrit>
        Test the following use case:
        1) Make sure XPN is enabled in config.
            Verify that XPN parameter set is present in the MKPDU (param.set = 8)
      </verifycrit>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01018_XPN</srcid><srcstatus/><internalId>1707</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01064_XPNParSet_9_7</srcid><srcstatus/><internalId>2132</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Lib_ParSet.c_445</srcid><srcstatus/><internalId>739</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00008</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>308</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0113.Xpn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>965</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>315</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_00009</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        The MKA Module shall implement the EAPoL-MKA-Announcement with TLV type 112 (MACsec cipher suites) as
        specified in [IEEE-802.1X-2020] chapter 11.12.3.
        Note: The EAPoL-Announcement TLV shall be transmitted as a parameter on an EAPoL-MKA Announcement Parameter Set as defined
        in Figure 11-15 of [IEEE-802.1X-2020].
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01063_AnnouncementParSet_9_6_Invalid</srcid><srcstatus/><internalId>2131</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_1876</srcid><srcstatus/><internalId>674</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Mka_Lib_ParSet.c_392</srcid><srcstatus/><internalId>735</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0107.CipherSuiteSelection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>959</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>316</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_00009.1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Note: The MACsec cipher suite announcement serves for the Key Server to recognize the ciphers supported by the other end.
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01065_KaY_FillCipherAnnouncement</srcid><srcstatus/><internalId>2133</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_1883</srcid><srcstatus/><internalId>675</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0107.CipherSuiteSelection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>959</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>317</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_00011</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        The role of an MKA instance (MkaKay) shall be set per configuration (i.e. MKA_KEY_SERVER or MKA_PEER) (MkaRole).
        The Key Server Priority shall be configurable (MkaKeyServerPriority), in case it is not specifically provided
        in configuration the following values shall be used:
          - Key Server = 0,
          - Peer = 255.
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.CP_SWS_Mka_00011.1</srcid><srcstatus/><internalId>319</internalId></linkedfrom><linkedfrom><srcid>Mka.CP_SWS_Mka_00011.2</srcid><srcstatus/><internalId>320</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>318</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_00011.1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        The role of an MKA instance (MkaKay) shall be set per configuration (i.e. MKA_KEY_SERVER or MKA_PEER) (MkaRole).
        The Key Server Priority shall be configurable (MkaKeyServerPriority), in case it is not specifically provided
        in configuration the following values shall be used:
          - Key Server = 0.
      </description>
      <verifycrit>
        Test the following use cases:
        1) Configure participant (KaY) with MkaRole = MKA_KEY_SERVER, and disable MkaKeyServerPriority:
           Verify that transmitted Key Server Priority in MKPDU is 0.
        2) Configure participant (KaY) with MkaRole = MKA_KEY_SERVER, and enable and configure MkaKeyServerPriority:
           Verify that transmitted Key Server Priority in MKPDU is the one configured in MkaKeyServerPriority.
      </verifycrit>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01055_KeyServerFlagAndPriority_PriorityBased</srcid><srcstatus/><internalId>2123</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01056_KeyServerFlagAndPriority_KeyServer</srcid><srcstatus/><internalId>2124</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate_var/xgen/Mka.xgen_735</srcid><srcstatus/><internalId>950</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00011</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>318</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>319</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_00011.2</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        The role of an MKA instance (MkaKay) shall be set per configuration (i.e. MKA_KEY_SERVER or MKA_PEER) (MkaRole).
        The Key Server Priority shall be configurable (MkaKeyServerPriority), in case it is not specifically provided
        in configuration the following values shall be used:
          - Peer = 255.
      </description>
      <verifycrit>
        Test the following use cases:
        1) Configure participant (KaY) with MkaRole = MKA_PEER, and disable MkaKeyServerPriority:
           Verify that transmitted Key Server Priority in MKPDU is 255.
        2) Configure participant (KaY) with MkaRole = MKA_KEY_SERVER, and enable and configure MkaKeyServerPriority:
           Verify that transmitted Key Server Priority in MKPDU is the one configured in MkaKeyServerPriority.
      </verifycrit>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01057_KeyServerFlagAndPriority_Peer</srcid><srcstatus/><internalId>2125</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate_var/xgen/Mka.xgen_738</srcid><srcstatus/><internalId>951</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00011</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>318</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.10</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>206</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>320</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_00012</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        The MKA Module shall support retry for the MKA sequence.
        If an MKA KaY participant (MkaKayParticipant) cannot successfully identify or successfully establish a SC with any
        participant in the Link, it should retry the MKA sequence following a per configuration parametrized retry base delay with
        Exponential Back-off (MkaRetryBaseDelay) until a retry cyclic delay (MkaRetryCyclicDelay).
        Note: As an example, in case MkaRetryBaseDelay = 0.02 and MkaRetryCyclicDelay = 0.5, the retry sequence will be as
        follows 20ms, 40ms, 80ms, 160ms, 320ms, 500ms, 500ms, ...
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01000_PeriodicMkpduTransmission</srcid><srcstatus/><internalId>1688</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0112.ExponentialStartupMkaHelloTime</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>964</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>321</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_00013</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        The MKA Instances (MkaKay) configured with the Key Server (MKA_KEY_SERVER) role shall support re-keying distributed SAKs after a
        configurable time span (MkaSakRekeyTimeSpan).
      </description>
      <verifycrit>
        Test a use cases where participant acting as a key server has generated and distributed SAK.
        KaY unit test case 1)
        Verify that when key server distributes SAK to a peer, then:
        1) Call Mka_KaY_TimerCallback_NewSakDelay(),
        2) Call Mka_KaY_TimerCallback_MkaSakRekeyTimeSpan(),
        3) Check if Mka_Crypto_SakGenWrapAsync() is called,
        4) Call Mka_KaY_SakGenWrapFinished() to finish wraping SAK.
        Check that timers are started for MKA_TIMERS_GROUP_KAY_NEW_SAK_DELAY and MKA_TIMERS_GROUP_KAY_SAK_REKEY.
        Conformance test case 1)
        Verify that when key server distributes SAK to a peer, then:
        1) Tick timer for MkaSakRekeyTimeSpan,
        2) With every expired timer MKA_HELLOTIME, send new MKPDU,
        3) After expired MkaSakRekeyTimeSpan, check that is called Csm_RandomGenerate() and
        4) Try to finish genereting SAK and check if next sent MKPDU contain Distributed SAK.
      </verifycrit>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01017_SakRekeyTimer</srcid><srcstatus/><internalId>1706</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01076_TimerSakRekey</srcid><srcstatus/><internalId>2144</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_1372</srcid><srcstatus/><internalId>644</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0109.SakRekeying</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>961</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>322</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_00014</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        The MKA Instances configured with the Key Server (MKA_KEY_SERVER) role shall rekey distributed SAKs in case the packet number space
        of one direction (sending or receiving) exceeds:
          - 0xC000 0000 for 32-bit PNs.
          - 0xC000 0000 0000 0000 for 64-bit PNs (XPN mode).
        Note: This is required in the [IEEE-802.1X-2020] standard, chapter 9.8.
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.8021X.KeyServerElection.42</srcid><srcstatus/><internalId>245</internalId></linkedfrom><linkedfrom><srcid>Mka.CP_SWS_Mka_00014.1</srcid><srcstatus/><internalId>324</internalId></linkedfrom><linkedfrom><srcid>Mka.CP_SWS_Mka_00014.2</srcid><srcstatus/><internalId>325</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0109.SakRekeying</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>961</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>323</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_00014.1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        The MKA Instances configured with the Key Server (MKA_KEY_SERVER) role shall rekey distributed SAKs in case the packet number space
        of one direction (sending or receiving) exceeds:
          - 0xC000 0000 for 32-bit PNs.
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.8021X.KeyServerElection.41</srcid><srcstatus/><internalId>244</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Cp.c_1445</srcid><srcstatus/><internalId>546</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_1395</srcid><srcstatus/><internalId>647</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00014</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>323</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>324</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_00014.2</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        The MKA Instances configured with the Key Server (MKA_KEY_SERVER) role shall rekey distributed SAKs in case the packet number space
        of one direction (sending or receiving) exceeds:
          - 0xC000 0000 0000 0000 for 64-bit PNs (XPN mode).
      </description>
      <verifycrit>
        Test the following use case:
        1) Make sure XPN is enabled in configuration.
            Verify that new SAK is generated after TxSa LPn (our NextPN - ReplayWindow) exceeds the XPN_Exhaustion.
        2) Make sure XPN is enabled in configuration.
            Verify that new SAK is generated after RxSa LPn (Lpn in peers SAKUse) exceeds the XPN_Exhaustion.
      </verifycrit>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Cp_UnitTest01032_L_XLPn_Recovery</srcid><srcstatus/><internalId>1844</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01083_XpnSakUse</srcid><srcstatus/><internalId>2151</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00014</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>323</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0113.Xpn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>965</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>325</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_00015</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Each MKA instance shall assume exactly two participants per link. Therefore, having exactly one peer.
      </description>
      <comment>
        Note: This implies, that one must take the Key Server role and the other the peer role.
        This requirement permits an MKA instance to immediately continue with the MKA sequence after detecting and successfully
        authenticating another participant in the link which belongs to the same CA, avoiding start-up delays.
      </comment>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01005_KeyServerFlag_1</srcid><srcstatus/><internalId>1694</internalId></linkedfrom><linkedfrom><srcid>Mka_ConTest01006_KeyServerFlag_2</srcid><srcstatus/><internalId>1695</internalId></linkedfrom><linkedfrom><srcid>Mka_ConTest01024_MultiplePeers_DifferentCkn</srcid><srcstatus/><internalId>1713</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>326</internalId></specobject>

<!-- =======================================[Limitations]====================================== -->
    <specobject>
      <id>Mka.CP_SWS_Mka_00016</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        The MKA Module may support Authentication based on EAP as detailed in [IEEE-802.1X-2020] chapter 8.
        Note: Authentication based on EAP is not required as the mutual authentication of participants is achieved based
        on pre-shared Keys.
      </description>
      <comment>EAP-TLS Authentication is not supported.</comment>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Mka.EapTlsNotSupported</srcid><srcstatus/><internalId>492</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>327</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_00017</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        The MKA Module shall support only one MKA Participant (MkaKayParticipant) to success per port (i.e. per PAE MkaPaeInstance).
        If one KaY participant is able to correctly establish a SC, the other started participants (MkaKayParticipant)
        of the same PAE shall give up.
        Note: As specified in [SWS_MKA_00005], a PAE instance can initiate 1 to n MKA participant instances (MkaKayParticipant)
        but only one of them shall succeed configuring a Secure Channel in the port (Point-to-Multipoint architecture
        is not supported).
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01003_ParticipantSuccsessfulActor_DisableNonPrincipalParticipantsOn</srcid><srcstatus/><internalId>2193</internalId></linkedfrom><linkedfrom><srcid>Mka_Logon_UnitTest01011_NextSuccessfulParticipantAsPrincipal</srcid><srcstatus/><internalId>2201</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>328</internalId></specobject>

<!-- ===============================[Cryptographic requirements]=============================== -->
    <specobject>
      <id>Mka.CP_SWS_Mka_CONSTR_00019</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        The MKA Module shall support the following Cipher suites to be configured in the MACsec Entity (either per SW or HW):
          - GCM-AES-128,
          - GCM-AES-256,
          - GCM-AES-XPN-128,
          - GCM-AES-XPN-256.
      </description>
      <comment>
        Note: The MKA Module shall support announcing and configuring the listed ciphers (MkaMacSecCipherSuite).
        Detailed information can be found in [IEEE-802.1X-2020] Figure 11-12 and [IEEE-802.1AE-2018] chapter 14.3.
      </comment>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.CP_SWS_Mka_CONSTR_00019.1</srcid><srcstatus/><internalId>330</internalId></linkedfrom><linkedfrom><srcid>Mka.CP_SWS_Mka_CONSTR_00019.2</srcid><srcstatus/><internalId>331</internalId></linkedfrom><linkedfrom><srcid>Mka.CP_SWS_Mka_CONSTR_00019.3</srcid><srcstatus/><internalId>332</internalId></linkedfrom><linkedfrom><srcid>Mka.CP_SWS_Mka_CONSTR_00019.4</srcid><srcstatus/><internalId>333</internalId></linkedfrom><linkedfrom><srcid>Mka.CP_SWS_Mka_CONSTR_00019.5</srcid><srcstatus/><internalId>334</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>329</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_CONSTR_00019.1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        The MKA Module shall support the following Cipher suites to be configured in the MACsec Entity (either per SW or HW):
          - GCM-AES-128.
      </description>
      <verifycrit>
        Create a test case where specified cipher suite is configured and verify that it is correctly forwarded to SecY with an API call.
      </verifycrit>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01009_DistributedSak</srcid><srcstatus/><internalId>1698</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_1714</srcid><srcstatus/><internalId>891</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_CONSTR_00019</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>329</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>330</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_CONSTR_00019.2</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        The MKA Module shall support the following Cipher suites to be configured in the MACsec Entity (either per SW or HW):
          - GCM-AES-256.
      </description>
      <verifycrit>
        Create a test case where specified cipher suite is configured and verify that it is correctly forwarded to SecY with an API call.
      </verifycrit>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01070_DistributedSak_CipherSuite_2</srcid><srcstatus/><internalId>2138</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_1716</srcid><srcstatus/><internalId>892</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_CONSTR_00019</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>329</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>331</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_CONSTR_00019.3</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        The MKA Module shall support the following Cipher suites to be configured in the MACsec Entity (either per SW or HW):
          - GCM-AES-XPN-128.
      </description>
      <verifycrit>
        Create a test case where specified cipher suite is configured and verify that it is correctly forwarded to SecY with an API call.
      </verifycrit>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01018_XPN</srcid><srcstatus/><internalId>1707</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01032_L_XLPn_Recovery</srcid><srcstatus/><internalId>1844</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01080_CheckSsci_2</srcid><srcstatus/><internalId>2148</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01083_XpnSakUse</srcid><srcstatus/><internalId>2151</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_1718</srcid><srcstatus/><internalId>893</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_CONSTR_00019</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>329</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0113.Xpn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>965</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>332</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_CONSTR_00019.4</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        The MKA Module shall support the following Cipher suites to be configured in the MACsec Entity (either per SW or HW):
          - GCM-AES-XPN-256.
      </description>
      <verifycrit>
        Create a test case where specified cipher suite is configured and verify that it is correctly forwarded to SecY with an API call.
      </verifycrit>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01079_CheckSsci_1</srcid><srcstatus/><internalId>2147</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_1720</srcid><srcstatus/><internalId>894</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_CONSTR_00019</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>329</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0113.Xpn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>965</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>333</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_CONSTR_00019.5</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Note: The MKA Module shall support announcing and configuring the listed ciphers (MkaMacSecCipherSuite).
        Detailed information can be found in [IEEE-802.1X-2020] Figure 11-12 and [IEEE-802.1AE-2018] chapter 14.3.
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01063_AnnouncementParSet_9_6_Invalid</srcid><srcstatus/><internalId>2131</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01065_KaY_FillCipherAnnouncement</srcid><srcstatus/><internalId>2133</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_1827</srcid><srcstatus/><internalId>671</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Mka_Lib_ParSet.c_408</srcid><srcstatus/><internalId>737</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_CONSTR_00019</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>329</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0107.CipherSuiteSelection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>959</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>334</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_CONSTR_00020</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        The MKA Module shall support configuring 1 to 4 cipher suites per MkaCryptoAlgoConfig, each of them with an unique
        MkaMacSecCipherSuitePrio.
        The MkaMacSecCipherSuitePrio shall accept the value 1 to 4, being 1 the higher priority and 4 the lowest priority.
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_1657</srcid><srcstatus/><internalId>889</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_1753</srcid><srcstatus/><internalId>896</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0107.CipherSuiteSelection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>959</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>335</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_CONSTR_00020.1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        The MkaMacSecCipherSuitePrio parameter shall be used by a MkaKayParticipant with MkaRole = KEY_SERVER,
        to select the cipher suite to use for MACsec with the other participant within the common cipher suites supported
        (shared with the EAPoL-MKA-Announcement MACsec cipher suites).
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01073_CipherSuiteSelection_HighestPriority</srcid><srcstatus/><internalId>2141</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>336</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_CONSTR_00020.2</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        The cryptographic operations like the derivation of MACsec keys and authentication based on CAK pre-shared keys
        should be delegated to the CSM Module.
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01010_KekIckGen_Async128</srcid><srcstatus/><internalId>1914</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01050_SakGenWrap_Async128</srcid><srcstatus/><internalId>1954</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0101.KeyDerivation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>953</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>337</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_00022</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Derived keys (specifically ICKs and KEKs) may get pre-calculated and stored in tamper proof manner to optimize the
        initialization time of the module.
        SAKs are implicitly excluded from this requirement. SAKs must not be pre-calculated neither reused.
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest00000_MkaInit</srcid><srcstatus/><internalId>1687</internalId></linkedfrom><linkedfrom><srcid>Mka_ConTest01042_PreSharedKeys</srcid><srcstatus/><internalId>1731</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0124.PresharedIckKek</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>977</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>338</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_00023</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        It shall be supported that Secure Association Keys (SAKs) can directly be installed from a HSM to a MACsec Entity (SecY).
      </description>
      <comment>This requirement is informational only. Communication with SecY is defined by set of APIs described in SWS.</comment>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>339</internalId></specobject>

<!-- =========================[Communication with MACsec Entity (SecY)]======================== -->
    <specobject>
      <id>Mka.CP_SWS_Mka_00024</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        The MKA Module shall propagate the MACsec Entity specific parameters as needed by means of the EthIf API.
        This requirement applies for the initialization, shutdown and maintenance of MACsec related parameters.
      </description>
      <comment>APIs are included from EthIf.h (linked requirement).</comment>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.EB.CP_SWS_Mka_91006</srcid><srcstatus/><internalId>399</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>340</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_00025</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        The MKA Module shall collect the MACsec Entity (SecY) statistics when requested by means of the EthIf API.
        Note: Other modules may request port specific MACsec statistics in order to set DTCs, answer to Diagnostics,
        and for monitoring.
      </description>
      <comment>APIs are included from EthIf.h (linked requirement).</comment>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.EB.CP_SWS_Mka_91006</srcid><srcstatus/><internalId>399</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>341</internalId></specobject>

<!-- ===============================[Configuration of MKA Module]============================== -->
    <specobject>
      <id>Mka.CP_SWS_Mka_00026</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        The status and behavior of an specific MkaPaeInstance shall be configurable per initial configuration.
      </description>
      <comment>
        Note: In case the proposal from [IEEE-802.1X-2020] chapter 12.5 is used, the variable useEAP is currently
        not supported (that means, the value shall be per default set to Never).
      </comment>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_66</srcid><srcstatus/><internalId>825</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>342</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_00027</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        It shall be possible to set the configuration of a specific PAE dynamically through the MKA module API.
        The change shall apply in the next power cycle.
        If a configuration parameter (e.g. through Mka_SetPaePermissiveMode, Mka_SetCknStatus or, Mka_SetEnable) is changed
        by means of the API, the original per configuration set value shall be ignored and the in NVRAM persisted value shall
        be used from the next power cycle onwards.
      </description>
      <verifycrit>
        Verify that initially Mka is started using configuration parameters only, and that Nv configuration memory is filled with
        Post build parameters and default values.
      </verifycrit>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.CP_SWS_Mka_00027.1</srcid><srcstatus/><internalId>344</internalId></linkedfrom><linkedfrom><srcid>Mka.CP_SWS_Mka_00028</srcid><srcstatus/><internalId>345</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01016_MemoryInit</srcid><srcstatus/><internalId>2206</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Logon.c_1743</srcid><srcstatus/><internalId>789</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0122.DynamicControl</linksto><dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1098</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>343</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_00027.1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        The changes described in [Mka.SWS_MKA_00030] shall be applied in the next power cycle.
      </description>
      <verifycrit>
        Verify that Nv Memory configuration values are read only at initialization process and are then used from local buffer.
      </verifycrit>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01017_NvmGetStatus_ValidMemoryBlock</srcid><srcstatus/><internalId>2207</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Logon.c_822</srcid><srcstatus/><internalId>747</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00027</linksto><dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>343</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>344</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_00028</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        In case MkaOnFailPermissiveMode == MKA_TIMEOUT and MkaParticipantActivate == TRUE for a specific MkaPaeInstance, it
        shall be determined that the MKA has failed when all following conditions have been met:
          - MKA sequence did not succeed -&gt; The participants could not reach the state in which the SAK is installed for
            RxSa and TxSa.
          - MKA timeout (MkaOnFailPermissiveModeTimeout) is exceeded.
        Note: The MKA timeout value is set per configuration with the MkaOnFailPermissiveModeTimeout parameter.
      </description>
      <verifycrit>
        Case 1:
                Verify that PermissiveMode has not been started on a port that has PermissiveMode enabled, but a participant became principal
                before the timeout was triggered ( Mka_Lib_StopTimer(MKA_TIMERS_GROUP_LOGON_PERMISSIVE_TIMEOUT) was called ).
        Case 2:
                Verify that PermissiveMode has been entered (Logon unit called Mka_Cp_DisableMacSec) after a PermissiveMode timeout occured.
                No successful principal participants shall be found before timeout.
      </verifycrit>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Logon.c_1143</srcid><srcstatus/><internalId>762</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Mka_Logon.c_1457</srcid><srcstatus/><internalId>774</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01020_PermissiveMode_TimerExpires</srcid><srcstatus/><internalId>1709</internalId></linkedfrom><linkedfrom><srcid>Mka_Logon_UnitTest01032_PermissiveMode_TimerExpires</srcid><srcstatus/><internalId>2222</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.CP_SWS_Mka_00028.1</srcid><srcstatus/><internalId>346</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0111.PermissiveMode</linksto><dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>963</internalId></provcov>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00027</linksto><dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>343</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>345</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_00028.1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        If all of the conditions from Mka.CP_SWS_Mka_00028 are met, the error MKA_E_TIMEOUT shall be triggered.
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Logon.c_1156</srcid><srcstatus/><internalId>763</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01035_Dem_SetEventStatus</srcid><srcstatus/><internalId>2225</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00028</linksto><dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>345</internalId></provcov>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00200</linksto><dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>357</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>346</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_00029</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        The MKA timer for MkaOnFailPermissiveModeTimeout shall start counting after LinkState == Active (ETHTRCV_LINK_STATE_ACTIVE) of the
        referred physical or virtual port.
      </description>
      <verifycrit>
        Case 1:
                Verify that Logon unit didn't call Mka_Lib_StartTimer on a port that has PermissiveMode disabled after LinkState changed to Active.
        Case 2:
                Verify that Logon unit called Mka_Lib_StartTimer(MKA_TIMERS_GROUP_LOGON_PERMISSIVE_TIMEOUT) on a port that has PermissiveMode enabled
                after LinkState changed to Active.
                Then change the LinkState to down and verify that Logon unit called Mka_Lib_StopTimer(MKA_TIMERS_GROUP_LOGON_PERMISSIVE_TIMEOUT).
                Finally, change the LinkState to Active and verify that Mka_Lib_StartTimer(MKA_TIMERS_GROUP_LOGON_PERMISSIVE_TIMEOUT) was called.
                Note: this test can be linked to requirement Mka.CP_SWS_Mka_00030.
      </verifycrit>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01015_StartPae</srcid><srcstatus/><internalId>2205</internalId></linkedfrom><linkedfrom><srcid>Mka_Logon_UnitTest01031_PermissiveMode_StartTimer</srcid><srcstatus/><internalId>2221</internalId></linkedfrom><linkedfrom><srcid>Mka_Logon_UnitTest01033_PermissiveMode_LinkStateUpAndDown</srcid><srcstatus/><internalId>2223</internalId></linkedfrom><linkedfrom><srcid>Mka_Logon_UnitTest01034_PermissiveMode_Disabled</srcid><srcstatus/><internalId>2224</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0111.PermissiveMode</linksto><dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>963</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>347</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_00030</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        The MkaOnFailPermissiveModeTimeout timer shall be reset if the transition from Link_Down (ETHTRCV_LINK_STATE_DOWN) to
        Link_Active (ETHTRCV_LINK_STATE_ACTIVE) of the referred physical or virtual port occured.
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01022_PermissiveMode_TimerResetOnMkpdu_2</srcid><srcstatus/><internalId>1711</internalId></linkedfrom><linkedfrom><srcid>Mka_Logon_UnitTest01033_PermissiveMode_LinkStateUpAndDown</srcid><srcstatus/><internalId>2223</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0111.PermissiveMode</linksto><dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>963</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>348</internalId></specobject>

<!-- ======================================[MKA behavior]====================================== -->
    <specobject>
      <id>Mka.CP_SWS_Mka_00031</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        A MKA Entity (KaY) shall start the MKA sequence(s) through the referred EthIf (MkaEthIfControllerRef) immediately after receiving
        the port link-up signal with the Mka_LinkStateChange function.
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01000_PeriodicMkpduTransmission</srcid><srcstatus/><internalId>1688</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>349</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_00032</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        A MKA Entity (KaY) shall signal the successful configuration of the MACsec protected port to the EthIf with
        the EthIf_MacSecOperational or EthIf_SwitchMacSecOperational function.
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01004_KSPHigh_KSPartner</srcid><srcstatus/><internalId>1692</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0110.MacSecOperational</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>962</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>350</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_00032.1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Note: A MKA Entity determines that the MACsec protected port is successfully configured as soon as MACsec
        protected frames can be transmitted and received from both participants.
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01004_KSPHigh_KSPartner</srcid><srcstatus/><internalId>1692</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0110.MacSecOperational</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>962</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>351</internalId></specobject>

<!-- ===================================[MKA Error Handling]=================================== -->
    <specobject>
      <id>Mka.CP_SWS_Mka_00033</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        If one or more CAKs referenced by MkaCryptoCknCakKeyRef is not initialized, MKA_E_KEY_NOT_PRESENT_INSTANCE shall be
        set to "Fail".
      </description>
      <verifycrit>
        1) Configure stub Csm_KeyElementGet() to return E_NOT_OK or invalid CknSize.
        2) Verify that Crypto unit called Mka_Logon_ReportEvent() for EventId MKA_E_KEY_NOT_PRESENT_INSTANCE and correct PaeIdx.
      </verifycrit>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01046_IckKekGen_KEY_NOT_PRESENT</srcid><srcstatus/><internalId>1734</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01091_InvalidCkn</srcid><srcstatus/><internalId>1986</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01092_InvalidCkn2</srcid><srcstatus/><internalId>1987</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01093_InvalidCkn3</srcid><srcstatus/><internalId>1988</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01174_IckKekGen_KEY_NOT_PRESENT</srcid><srcstatus/><internalId>2069</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01175_IckKekGen_KEY_NOT_PRESENT_CsmCallback</srcid><srcstatus/><internalId>2070</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0118.ProductionErrors</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>970</internalId></provcov>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00201</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>358</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>352</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_00034</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        If the verification of the ICV of MKPDUs or the unwrapping of keys fails for one or more CKNs because of a wrong key,
        MKA_E_KEY_MISMATCH_INSTANCE shall be set to "Fail".
      </description>
      <verifycrit>
        Test case 1:
          1) Make participant a Peer.
          2) Create MKPDU that contain Distributed SAK parameter set.
          3) Call Mka_KaY_SakUnwrapFinished() with Result = E_NOT_OK.
          4) Verify that KaY unit called Mka_Logon_ReportEvent() for EventId MKA_E_KEY_MISMATCH_INSTANCE and correct PaeIdx.
        Test case 2:
          1) Create MKPDU and call Mka_RxTx_RxIndication().
          2) Call Mka_RxTx_IcvVerifyFinished() with Result = E_NOT_OK.
          3) Verify that RxTx unit called Mka_Logon_ReportEvent() for EventId MKA_E_KEY_MISMATCH_INSTANCE and correct PaeIdx.
      </verifycrit>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01054_SakUnwrap_CC</srcid><srcstatus/><internalId>2122</internalId></linkedfrom><linkedfrom><srcid>Mka_RxTx_UnitTest01004_Initial_2_RxBufFree_2_WaitIcvVerFin_2_RxBufFree</srcid><srcstatus/><internalId>2318</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0118.ProductionErrors</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>970</internalId></provcov>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00202</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>359</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>353</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_00035</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        If the MKA peer only supports incompatible cipher suites, MKA_E_ALGO_MISMATCH_INSTANCE shall be set to "Fail".
      </description>
      <verifycrit>
        Testcase 1:
          1) Make participant a Key server.
          2) Create MKPDU that contain Announcement parameter set with unsupported Cipher Suite.
          3) Verify that KaY unit called Mka_Logon_ReportEvent() for EventId MKA_E_ALGO_MISMATCH_INSTANCE and correct PaeIdx.
        Testcase 2:
          1) Make participant a Peer.
          2) Bring participant into PeerSM Live state.
          3) Create MKPDU that contain Distributed SAK parameter set with unsupported Cipher Suite.
          4) Verify that KaY unit called Mka_Logon_ReportEvent() for EventId MKA_E_ALGO_MISMATCH_INSTANCE and correct PaeIdx.
      </verifycrit>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01072_CipherSuiteSelection_NoMatch</srcid><srcstatus/><internalId>2140</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01086_DistributedSak_NoMatch</srcid><srcstatus/><internalId>2154</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0118.ProductionErrors</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>970</internalId></provcov>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00203</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>360</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>354</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_00036</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        MKA_E_TIMEOUT_INSTANCE, MKA_E_KEY_NOT_PRESENT_INSTANCE, MKA_E_KEY_MISMATCH_INSTANCE and MKA_E_ALGO_MISMATCH_INSTANCE
        shall be healed (set to "Pass"), when the error condition is not applicable anymore.
      </description>
      <verifycrit>
        1) While MacSecOperational is FALSE, simulate some errors on multiple PAEs.
        2) Call Mka_Logon_MacSecOperational() with Status = TRUE for only one PAE.
        3) Verify that Logon unit called Dem_SetEventStatus() with status DEM_EVENT_STATUS_PASSED for EventIds that were previously reported
           on given PAE, and for other PAEs, it didn't do anything.
      </verifycrit>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01035_Dem_SetEventStatus</srcid><srcstatus/><internalId>2225</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0118.ProductionErrors</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>970</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>355</internalId></specobject>

<!-- ==================================[Error Classification]================================== -->
    <specobject>
      <id>Mka.CP_SWS_Mka_91035</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Development Errors:
        |--------------------------------------------------------------------------------------------|
        |                 Type of error                   |    Related error code   |   Error value  |
        |--------------------------------------------------------------------------------------------|
        |MKA Component initiated with null configuration. |    MKA_E_CFG_NULL_PTR   |      0x01      |
        |--------------------------------------------------------------------------------------------|
        |     API called with invalid parameter value.    | MKA_E_INVALID_PARAMETER |      0x04      |
        |--------------------------------------------------------------------------------------------|
        |         API called with a NULL pointer.         |   MKA_E_PARAM_POINTER   |      0x05      |
        |--------------------------------------------------------------------------------------------|
        |     API called prior module is initialized.     |       MKA_E_UNINIT      |      0x06      |
        |--------------------------------------------------------------------------------------------|
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_UnitTest01000_SetCknStatus_Uninit_Check</srcid><srcstatus/><internalId>2259</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>356</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_00200</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Error Name:           MKA_E_TIMEOUT_INSTANCE
        Short Description:    MKA Timeout while negotiating with remote peer.
        Long Description:     MKA Timeout while negotiating with remote peer.
                              In case MkaOnFailPermissiveMode == TIMEOUT and
                              MkaOnFailPermissiveModeTimeout is overflowed, the error will be set.
        Detection Criteria:   Fail: If the PAE Instances MkaOnFailPermissiveMode == TIMEOUT and
                                    MkaOnFailPermissiveModeTimeout is overflowed, the error will be set.
                              Pass: If the PAE instances MkaOnFailPermissiveMode == NEVER or
                                    If the PAE instances MkaOnFailPermissiveMode == TIMEOUT, and the MkaKay
                                    could establish a transmission and reception SC with a peer before
                                    MkaOnFailPermissiveModeTimeout is reached the error is not set.
        Secondary Parameters: Not Applicable.
        Time Required:        The time to detect the error is linked to the
                              MkaOnFailPermissiveMode and MkaOnFailPermissiveModeTimeout.
        Monitor Frequency:    Once after Ports link-up per port.
        MIL illumination:     Not Applicable.
      </description>
      <verifycrit>
        1) Wile MacSecOperational is FALSE simulate PermissiveMode timer expiration with function call Mka_Logon_TimerCallback_PermissiveMode().
        2) Verify that Logon unit called Dem_SetEventStatus() for EventId MKA_E_TIMEOUT_INSTANCE and with status DEM_EVENT_STATUS_FAILED.
      </verifycrit>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.CP_SWS_Mka_00028.1</srcid><srcstatus/><internalId>346</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01035_Dem_SetEventStatus</srcid><srcstatus/><internalId>2225</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0118.ProductionErrors</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>970</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>357</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_00201</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Error Name:           MKA_E_KEY_NOT_PRESENT_INSTANCE
        Short Description:    Necessary keys not present to initiate MKA negotiation.
        Long Description:     Pre-shared keys (i.e. CAK, ICK or KEK) to start the MKA sequence are not present in at least
                              one of the active configured Kay Participants.
        Detection Criteria:   Fail: The pre-shared keys of an active MkaKayParticipant are not present.
                              Pass: All Kay Participants have the needed pre-shared keys present.
        Secondary Parameters: Not Applicable.
        Time Required:        0.5
        Monitor Frequency:    Once-per-trip.
        MIL illumination:     Not Applicable.
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.CP_SWS_Mka_00033</srcid><srcstatus/><internalId>352</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0118.ProductionErrors</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>970</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>358</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_00202</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Error Name:           MKA_E_KEY_MISMATCH_INSTANCE
        Short Description:    MKA Negotiation failed due to key mismatch with remote peer (MKPDUs ICV mismatch).
        Long Description:     MKA Negotiation failed due to key mismatch with remote peer (MKPDUs ICV mismatch).
                              Triggered in case MKPDU cannot be validated for received MKPDUs which distribute a matching CKN.
        Detection Criteria:   Fail: A received MKPDU with matching CKN cannot be successfully validated.
                              Pass: All received MKPDUs with matching CKN are successfully validated.
        Secondary Parameters: Not Applicable.
        Time Required:        Not Applicable.
        Monitor Frequency:    Continuous.
        MIL illumination:     Not Applicable.
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.CP_SWS_Mka_00034</srcid><srcstatus/><internalId>353</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0118.ProductionErrors</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>970</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>359</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_00203</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Error Name:           MKA_E_ALGO_MISMATCH_INSTANCE
        Short Description:    MKA Negotiation failed due to incompatible cipher suite with remote peer.
        Long Description:     MKA Negotiation failed due to incompatible cipher suite with remote peer.
                              Triggered in case the participants in the MKA communication do not support any MACsec
                              cipher suite in common and therefore cannot distribute neither install a valid SAK.
        Detection Criteria:   Fail: The KaY Participants of a communication (local and remote) does not support a common
                                    MACsec cipher suite.
                              Pass: The KaY Participants of a communication (local and remote) support one or more common
                                    MACsec cipher suites.
        Secondary Parameters: Not Applicable.
        Time Required:        Not Applicable.
        Monitor Frequency:    Continuous.
        MIL illumination:     Not Applicable.
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.CP_SWS_Mka_00035</srcid><srcstatus/><internalId>354</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0118.ProductionErrors</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>970</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>360</internalId></specobject>

<!-- =====================================[Imported types]===================================== -->
    <specobject>
      <id>Mka.CP_SWS_Mka_91005</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Imported types:
        |-----------------------------------------------------------------|
        |     Module     |     Header File     |       Imported Type      |
        |-----------------------------------------------------------------|
        | ComStack_Types |   ComStack_Types.h  |     BufReq_ReturnType    |
        |-----------------------------------------------------------------|
        |       Eth      |  Eth_GeneralTypes.h |       Eth_BufIdxType     |
        |                |  Eth_GeneralTypes.h |       Eth_FrameType      |
        |-----------------------------------------------------------------|
        |     EthSwt     |  Eth_GeneralTypes.h |    EthSwt_MgmtInfoType   |
        |-----------------------------------------------------------------|
        |     EthTrcv    |  Eth_GeneralTypes.h |   EthTrcv_LinkStateType  |
        |-----------------------------------------------------------------|
        |      IdsM      |     IdsM_Types.h    | IdsM_SecurityEventIdType |
        |-----------------------------------------------------------------|
        |       NvM      |    Rte_NvM_Type.h   |      NvM_BlockIdType     |
        |-----------------------------------------------------------------|
        |       Std      |     Std_Types.h     |       Std_ReturnType     |
        |                |     Std_Types.h     |    Std_VersionInfoType   |
        |-----------------------------------------------------------------|
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/Mka.h_19</srcid><srcstatus/><internalId>504</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/include/Mka_Int.h_18</srcid><srcstatus/><internalId>509</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>361</internalId></specobject>

<!-- ====================================[Type definitions]==================================== -->
    <specobject>
      <id>Mka.CP_SWS_Mka_91002</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Type definitions:
        Name: Mka_MacSecConfigType
        Kind: Structure
        Elements:
          - Name: ProtectFrames
            - Type: boolean
            - Comment: Indicates status if the MACsec protection of the frames is active or not.
          - Name: ReplayProtect
            - Type: boolean
            - Comment: Indicates status if replay protection is enable or disable.
          - Name: ReplayWindow
            - Type: uint32
            - Comment: If ReplayProtect is enable, indicates the used replay protect window.
          - Name: ValidateFrames
            - Type: Mka_ValidateFramesType
            - Comment: Status of the validation of the frames. See Mka_ValidateFramesType for possible values.
          - Name: CurrentCipherSuite
            - Type: uint64
            - Comment: Indicates which cipher suite is used in the SecY to update.
          - Name: ConfidentialityOffset
            - Type: Mka_ConfidentialityOffsetType
            - Comment: Set the Confidentiality Offset. See Mka_ConfidentialityOffsetType for possible values.
          - Name: ControlledPortEnabled
            - Type: boolean
            - Comment: Status if the controlled port is enabled or disabled.
          - Name: BypassedVlanPtrs
            - Type: const uint16*
            - Comment: Pointer to the list of bypassed VLANs.
          - Name: BypassedVlansLength
            - Type: uint8
            - Comment: Length of the list of bypassed VLANs.
          - Name: BypassedEtherTypesPtr
            - Type: const uint16*
            - Comment: Pointer to the list of the bypassed Ethernet Types.
          - Name: BypassedEtherTypesLength
            - Type: uint8
            - Comment: Length of the list of the bypassed Ethernet Types.
        Description: Structure to configure a referred SecY.
        Available via: Mka.h
      </description>
      <comment>
        struct
        {
          uint64  CurrentCipherSuite;
          uint32  ReplayWindow;
          P2CONST(uint16, AUTOMATIC, MKA_APPL_DATA) BypassedVlanPtrs;
          P2CONST(uint16, AUTOMATIC, MKA_APPL_DATA) BypassedEtherTypesPtr;
          Mka_ValidateFramesType ValidateFrames;
          Mka_ConfidentialityOffsetType ConfidentialityOffset;
          uint8   BypassedEtherTypesLength;
          uint8   BypassedVlansLength;
          boolean ControlledPortEnabled;
          boolean ProtectFrames;
          boolean ReplayProtect;
        } Mka_MacSecConfigType;
      </comment>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/Mka_Types.h_82</srcid><srcstatus/><internalId>518</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0116.BypassRules</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>968</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>362</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_91004</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Type definitions:
        Name: Mka_ValidateFramesType
        Kind: Enumeration
        Range:
          - MKA_VALIDATE_DISABLED = 0 -&gt; Disable validation, remove SecTAGs and ICVs (if present) from received frames.
          - MKA_VALIDATE_CHECKED  = 1 -&gt; Enable validation, do not discard invalid frames.
          - MKA_VALIDATE_STRICT   = 2 -&gt; Enable validation and discard invalid frames.
        Description: Controls validation of received frames.
        Available via: Mka.h
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/Mka_Types.h_71</srcid><srcstatus/><internalId>515</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>363</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_91003</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Type definitions:
        Name: Mka_ConfidentialityOffsetType
        Kind: Enumeration
        Range:
          - MKA_CONFIDENTIALITY_NONE      = 0 -&gt; Confidentiality protection disabled.
          - MKA_CONFIDENTIALITY_OFFSET_0  = 1 -&gt; Zero initial octets of each user data without confidentiality protection.
          - MKA_CONFIDENTIALITY_OFFSET_30 = 2 -&gt; 30 initial octets of each user data without confidentiality protection.
          - MKA_CONFIDENTIALITY_OFFSET_50 = 3 -&gt; 50 initial octets of each user data without confidentiality protection.
        Description: Indicates the offset in case of integrity with confidentiality.
        Available via: Mka.h
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/Mka_Types.h_74</srcid><srcstatus/><internalId>516</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>364</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_91008</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Type definitions:
        Name: Mka_Stats_Tx_SecYType
        Kind: Structure
        Elements:
          - Name: OutPkts_Untagged
            - Type: uint64
            - Comment: The number of packets transmitted without a SecTAG.
          - Name: OutPkts_TooLong
            - Type: uint64
            - Comment: The number of transmitted packets discarded because their length is greater than the accepted maximum length (mtu)
                       of the Port.
          - Name: OutOctets_Protected
            - Type: uint64
            - Comment: The number of plain text octets integrity protected but not encrypted in transmitted frames.
          - Name: OutOctets_Encrypted
            - Type: uint64
            - Comment: The number of plain text octets integrity protected and encrypted in transmitted frames.
        Description: MACsec Entity (SecY) transmission statistics.
        Available via: Mka.h
      </description>
      <comment>
        struct
        {
          uint64 OutPkts_Untagged;
          uint64 OutPkts_TooLong;
          uint64 OutOctets_Protected;
          uint64 OutOctets_Encrypted;
        } Mka_Stats_Tx_SecYType;
      </comment>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/Mka_Types.h_98</srcid><srcstatus/><internalId>519</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>365</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_91010</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Type definitions:
        Name: Mka_Stats_Rx_SecYType
        Kind: Structure
        Elements:
          - Name: InPkts_Untagged
            - Type: uint64
            - Comment: The number of packets without the MACsec tag (SecTAG) received if Mka_ValidateFrames was not MKA_VALIDATE_STRICT.
          - Name: InPkts_NoTag
            - Type: uint64
            - Comment: The number of received packets without a SecTAG discarded because Mka_ValidateFrames was MKA_VALIDATE_STRICT.
          - Name: InPkts_BadTag
            - Type: uint64
            - Comment: The number of received packets discarded with an invalid SecTAG, zero value PN, or invalid ICV.
          - Name: InPkts_NoSa
            - Type: uint64
            - Comment: The number of received packets with an unknown SCI or for an unused SA by the security entity.
          - Name: InPkts_NoSaError
            - Type: uint64
            - Comment: The number of packets discarded because the received SCI is unknown or the SA is not in use.
          - Name: InPkts_Overrun
            - Type: uint64
            - Comment: The number of packets discarded because they exceeded cryptographic performance capabilities.
          - Name: InOctets_Validated
            - Type: uint64
            - Comment: The number of plaintext octets recovered from packets that were integrity protected but not encrypted.
          - Name: InOctets_Decrypted
            - Type: uint64
            - Comment: The number of plaintext octets recovered from packets that were integrity protected and encrypted.
        Description: MACsec Entity (SecY) reception statistics.
        Available via: Mka.h
      </description>
      <comment>
        struct
        {
          uint64 InPkts_Untagged;
          uint64 InPkts_NoTag;
          uint64 InPkts_BadTag;
          uint64 InPkts_NoSa;
          uint64 InPkts_NoSaError;
          uint64 InPkts_Overrun;
          uint64 InOctets_Validated;
          uint64 InOctets_Decrypted;
        } Mka_Stats_Rx_SecYType;
      </comment>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/Mka_Types.h_107</srcid><srcstatus/><internalId>520</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>366</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_91009</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Type definitions:
        Name: Mka_Stats_Tx_ScType
        Kind: Structure
        Elements:
          - Name: OutPkts_Protected
            - Type: uint64
            - Comment: The number of integrity protected but not encrypted packets for this transmit SC.
          - Name: OutPkts_Encrypted
            - Type: uint64
            - Comment: The number of integrity protected and encrypted packets for this transmit SC.
        Description: Secure Channel transmission statistics.
        Available via: Mka.h
      </description>
      <comment>
        struct
        {
          uint64 OutPkts_Protected;
          uint64 OutPkts_Encrypted;
        } Mka_Stats_Tx_ScType;
      </comment>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/Mka_Types.h_120</srcid><srcstatus/><internalId>521</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>367</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_91011</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Type definitions:
        Name: Mka_Stats_Rx_ScType
        Kind: Structure
        Elements:
          - Name: InPkts_Ok
            - Type: uint64
            - Comment: The number of packets received for this secure channel successfully validated and within the replay window.
          - Name: InPkts_Unchecked
            - Type: uint64
            - Comment: The number of packets received for this secure channel, if Mka_ValidateFrames was MKA_VALIDATE_DISABLED.
          - Name: InPkts_Delayed
            - Type: uint64
            - Comment: The number of received packets, for this secure channel, with packet number (PN) lower than the lowest acceptable
                       packet number (LowestPn) and ReplayProtect was false.
          - Name: InPkts_Late
            - Type: uint64
            - Comment: The number of packets discarded, for this secure channel, because the received packet number (PN) was lower than the
                       lowest acceptable packet number (LowestPn) and ReplayProtect was true.
          - Name: InPkts_Invalid
            - Type: uint64
            - Comment: The number of packets, for this secure channel, that failed validation but could be received because ValidateFrames
                       was MKA_VALIDATE_CHECKED and the data was not encrypted (so the original frame could be recovered).
          - Name: InPkts_NotValid
            - Type: uint64
            - Comment: The number of packets discarded, for this secure channel, because validation failed and ValidateFrames was
                       MKA_VALIDATE_STRICT or the data was encrypted (so the original frame could not be recovered).
        Description: Secure Channel reception statistics.
        Available via: Mka.h
      </description>
      <comment>
        struct
        {
          uint64 InPkts_Ok;
          uint64 InPkts_Unchecked;
          uint64 InPkts_Delayed;
          uint64 InPkts_Late;
          uint64 InPkts_Invalid;
          uint64 InPkts_NotValid;
        } Mka_Stats_Rx_ScType;
      </comment>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/Mka_Types.h_127</srcid><srcstatus/><internalId>522</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>368</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_91013</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Type definitions:
        Name: Mka_SakKeyPtrType
        Kind: Structure
        Elements:
          - Name: HashKeyPtr
            - Type: const uint8*
            - Comment: Pointer to the Hash Key.
          - Name: SakKeyPtr
            - Type: const uint8*
            - Comment: Pointer to the SAK.
          - Name: SaltKeyPtr
            - Type: const uint8*
            - Comment: Pointer to the Salt.
        Description: SAK key reference.
        Available via: Mka.h
      </description>
      <comment>
        struct
        {
          P2CONST(uint8, AUTOMATIC, MKA_APPL_DATA) SakKeyPtr;
          P2CONST(uint8, AUTOMATIC, MKA_APPL_DATA) HashKeyPtr;
          P2CONST(uint8, AUTOMATIC, MKA_APPL_DATA) SaltKeyPtr;
        } Mka_SakKeyPtrType;
      </comment>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Cp_UnitTest01033_SaltKey</srcid><srcstatus/><internalId>1845</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01034_CorrectKeys</srcid><srcstatus/><internalId>1846</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>369</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_91012</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Type definitions:
        Name: Mka_PermissiveModeType
        Kind: Enumeration
        Range:
          - NEVER   = 0 -&gt; The controlled port will never be set to enabled if the participants cannot establish and successfully use
                           a MACsec Secure Channel.
          - TIMEOUT = 1 -&gt; The controlled port will be set to enabled and MACsec will not be used in the referred port if the timeout value
                           (MkaOnFailPermissiveMode Timeout) is reached and none MKA instance under the PAE instance could success the
                           following conditions:
                             - A participant belonging to the same CA was recognized and authenticated.
                             - A secure channel could be established.
                             - Both participants can transmit and receive MACsec protected traffic through the SC.
        Description: Permissive modes of MKA.
        Available via: Mka.h
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01034_PermissiveMode_Disabled</srcid><srcstatus/><internalId>2224</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>370</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_91028</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Type definitions:
        Name: Mka_Stats_SecYType
        Kind: Structure
        Elements:
          - Name: StatsTxPhy
            - Type: Mka_Stats_Tx_SecYType
            - Comment: Set of statistics in the Security Entity Phy by transmision.
          - Name: StatsRxPhy
            - Type: Mka_Stats_Rx_SecYType
            - Comment: Set of statistics in the Security Entity Phy by reception.
          - Name: StatsTxSc
            - Type: Mka_Stats_Tx_ScType
            - Comment: Set of statistics in the Security Entitys Secure Channel by reception.
          - Name: StatsRxSc
            - Type: Mka_Stats_Rx_ScType
            - Comment: Set of statistics in the Security Entitys Secure Channel by reception.
        Description: Security Entity statistics.
        Available via: Mka.h
      </description>
      <comment>
        struct
        {
          Mka_Stats_Tx_SecYType StatsTxPhy;
          Mka_Stats_Rx_SecYType StatsRxPhy;
          Mka_Stats_Tx_ScType   StatsTxSc;
          Mka_Stats_Rx_ScType   StatsRxSc;
        } Mka_Stats_SecYType;
      </comment>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/Mka_Types.h_145</srcid><srcstatus/><internalId>523</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>371</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_91027</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Type definitions:
        Name: Mka_PaeStatusType
        Kind: Structure
        Elements:
          - Name: ConnectionStatus
            - Type: Mka_MkaStatusType
            - Comment: Status of the MKA.
          - Name: PeerSci
            - Type: uint64
            - Comment: Sci includes the peers MAC and port.
          - Name: CknInUsePtr
            - Type: Array of unsigned char
            - Size: 32
            - Comment: Ckn used for the establishment of the MACsec Secure Channel.
        Description: Structure with the specific information of a PAE.
        Available via: Mka.h
      </description>
      <comment>
        Because of the complexity of casting an array and sending the whole array, it is decided to send the address
        of the first member in the array (pointer) and its length.
        CknInUsePtr is separeted to pointer named CknInUsePtr and its length named CknLength.
        struct
        {
          uint64        PeerSci;
          P2CONST(uint8, AUTOMATIC, MKA_APPL_DATA) CknInUsePtr;
          uint8         CknLength;
          Mka_MkaStatusType ConnectionStatus;
        } Mka_PaeStatusType;
      </comment>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.TypeDefinitionChange</srcid><srcstatus/><internalId>491</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/Mka_Types.h_154</srcid><srcstatus/><internalId>524</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>372</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_91025</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Type definitions:
        Name: Mka_MkaStatusType
        Kind: Enumeration
        Range:
          - MKA_STATUS_MACSEC_RUNNING         = 0     -&gt; MKA session key has been agreed and MACsec link is currently up.
          - MKA_STATUS_WAITING_PEER_LINK      = 1     -&gt; MKA is waiting for a link up of the underlying device to begin negotiation.
          - MKA_STATUS_WAITING_PEER           = 2     -&gt; MKA is waiting for a remote peer to transmit MKPDUs to begin negotiation.
          - MKA_STATUS_IN_PROGRESS            = 3     -&gt; MKA negotiation is ongoing.
          - MKA_STATUS_AUTH_FAIL_UNKNOWN_PEER = 4     -&gt; MKA negotiation is not possible because ICVs of remote peer are invalid
                                                         (ICK and therefore CAK keys are different).
          - MKA_STATUS_UNDEFINED              = 0xFF  -&gt; Undefined state, reported when the given bus is disabled.
        Description: Status of the MKA instance.
        Available via: Mka.h
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/Mka_Types.h_79</srcid><srcstatus/><internalId>517</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>373</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_91026</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Type definitions:
        Name: Mka_ConfigType
        Kind: Structure
        Description: Implementation specific structure of the post build configuration.
        Available via: Mka.h
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate_var/xgen/Mka.xgen_77</srcid><srcstatus/><internalId>948</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>374</internalId></specobject>

<!-- ==================================[Function definitions]================================== -->
    <specobject>
      <id>Mka.CP_SWS_Mka_91001</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Service Name:       Mka_Init
        Syntax:             Std_ReturnType Mka_Init(
                                                     const Mka_ConfigType* ConfigPtr
                                                   );
        Service ID [hex]:   0x01
        Sync/Async:         Synchronous
        Reentrancy:         Non-reentrant
        Parameters (in):    ConfigPtr           Points to the implementation specific structure.
        Parameters (inout): None
        Parameters (out):   None
        Return value:       Std_ReturnType      E_OK:      Initialization successful.
                                                E_NOT_OK:  Initialization failed.
        Description:        Initializes the MKA module.
        Available via:      Mka.h
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest00000_MkaInit</srcid><srcstatus/><internalId>1687</internalId></linkedfrom><linkedfrom><srcid>Mka_UnitTest01017_Init</srcid><srcstatus/><internalId>2276</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>375</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_91014</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Service Name:       Mka_GetVersionInfo
        Syntax:             Std_ReturnType Mka_GetVersionInfo(
                                                               Std_VersionInfoType* VersionInfoPtr
                                                             );
        Service ID [hex]:   0x02
        Sync/Async:         Synchronous
        Reentrancy:         Reentrant
        Parameters (in):    None
        Parameters (inout): None
        Parameters (out):   VersionInfoPtr      Version information of this module.
        Return value:       Std_ReturnType      E_OK:      Request successful.
                                                E_NOT_OK:  Request failed.
        Description:        Returns the version information of this module.
        Available via:      Mka.h
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/Mka.h_76</srcid><srcstatus/><internalId>505</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_UnitTest01040_GetVersionInfo</srcid><srcstatus/><internalId>2299</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>376</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_91015</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Service Name:       Mka_SetCknStatus
        Syntax:             Std_ReturnType Mka_SetCknStatus(
                                                             uint8 MkaPaeIdx,
                                                             boolean Enable,
                                                             const uint8* CknPtr,
                                                             uint8 CknLength
                                                           );
        Service ID [hex]:   0x03
        Sync/Async:         Synchronous
        Reentrancy:         Reentrant for different MkaPaeIdx.
                            Non-reentrant for the same MkaPaeIdx.
        Parameters (in):    MkaPaeIdx           Index of the PAE within the context of the MKA module.
                            Enable              True:  The MKA Participant exchanges MKPDUs.
                                                False: The MKA Participant does not exchange MKPDUs.
                            CknPtr              Connectivity Association Key Name to identify the KaY participant.
                            CknLength           Length of the CKN parameter provided.
        Parameters (inout): None
        Parameters (out):   None
        Return value:       Std_ReturnType      E_OK:     Request successful.
                                                E_NOT_OK: Request failed.
        Description:        Set status of a CKN for a PAE.
        Available via:      Mka.h
      </description>
      <verifycrit>
        Verify that Mka_SetCknStatus shall set call Mka_Logon_SetCknStatus with correct parameters.
      </verifycrit>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_UnitTest01043_SetCknStatus</srcid><srcstatus/><internalId>2302</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Ext.c.m4_399</srcid><srcstatus/><internalId>605</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0122.DynamicControl</linksto><dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1098</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>377</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_01001</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        The function Mka_SetCknStatus shall set the activation status of the MkaKayParticipant which contains the provided Ckn
        under the provided MkaPaeIdx.
        The new activation status shall be persistently stored in NVM and used from next power cycle onwards
        (as required in [CP_SWS_Mka_00027].
        The per configuration provided activation status (MkaParticipantActivate) of the MkaKayParticipant shall not be used if
        a valid value is stored on the NVM.
      </description>
      <verifycrit>
        Verify that Mka_SetCknStatus changed configuration value for given Ckn (Ckn maps to Participant on given PAE) is only applied
        during next initialization process.
        Testcase 1: participant enabled and Mka_SetCknStatus called with Enable == False participant continues to work normally
                    until next initialization. Participant shall not be started in next initialization process.
        Testcase 2: participant disabled and Mka_SetCknStatus called with Enable == True participant remains stopped
                    until next initialization. Participant shall be started in next initialization process.
      </verifycrit>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01020_SetCknStatus_DisableParticipant</srcid><srcstatus/><internalId>2210</internalId></linkedfrom><linkedfrom><srcid>Mka_Logon_UnitTest01021_SetCknStatus_EnableParticipant</srcid><srcstatus/><internalId>2211</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Logon.c_2161</srcid><srcstatus/><internalId>796</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0122.DynamicControl</linksto><dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1098</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>378</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_91016</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Service Name:       Mka_GetCknStatus
        Syntax:             Std_ReturnType Mka_GetCknStatus(
                                                             uint8 MkaPaeIdx,
                                                             const uint8* CknPtr,
                                                             uint8 CknLength,
                                                             boolean* EnablePtr
                                                           );
        Service ID [hex]:   0x04
        Sync/Async:         Synchronous
        Reentrancy:         Reentrant for different MkaPaeIdx.
                            Non reentrant for the same MkaPaeIdx.
        Parameters (in):    MkaPaeIdx           Index of the PAE within the context of the MKA module.
                            CknPtr              Connectivity Association Key Name to identify the KaY participant.
                            CknLength           Length of the CKN parameter provided.
        Parameters (inout): None
        Parameters (out):   EnablePtr           Pointer to the Mka Participant activation status.
        Return value:       Std_ReturnType      E_OK:     Request successful.
                                                E_NOT_OK: Request failed.
        Description:        Get Status of a CKN from a PAE.
        Available via:      Mka.h
      </description>
      <verifycrit>
        Verify that Mka_GetCknStatus shall set call Mka_Logon_GetCknStatus with correct parameters.
      </verifycrit>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_UnitTest01044_GetCknStatus</srcid><srcstatus/><internalId>2303</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Ext.c.m4_440</srcid><srcstatus/><internalId>606</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0122.DynamicControl</linksto><dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1098</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>379</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_91020</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Service Name:       Mka_SetEnable
        Syntax:             Std_ReturnType Mka_SetEnable(
                                                          uint8 MkaPaeIdx,
                                                          boolean Enable
                                                        );
        Service ID [hex]:   0x08
        Sync/Async:         Synchronous
        Reentrancy:         Reentrant for different MkaPaeIdx.
                            Non-reentrant for the same MkaPaeIdx.
        Parameters (in):    MkaPaeIdx           Index of the PAE within the context of the MKA module.
                            Enable              Boolean to control the Mka activation of a PAE.
        Parameters (inout): None
        Parameters (out):   None
        Return value:       Std_ReturnType      E_OK:     The request has been accepted.
                                                E_NOT_OK: The request has not been accepted.
        Description:        Set the MKA activation status of a PAE.
        Available via:      Mka.h
      </description>
      <verifycrit>
        Verify that Mka_SetEnable shall set call Mka_Logon_SetEnable with correct parameters.
      </verifycrit>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_UnitTest01046_SetEnable</srcid><srcstatus/><internalId>2305</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Ext.c.m4_485</srcid><srcstatus/><internalId>607</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0122.DynamicControl</linksto><dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1098</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>380</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_01002</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        The function Mka_SetEnable shall set the activation status of the MkaKay of the provided MkaPaeIdx.
        The new activation status shall be persistently stored in NVM and used from next power cycle onwards
        (as required in [CP_SWS_Mka_00027].
      </description>
      <verifycrit>
        Verify that Mka_SetEnable API changed configuration value for given for given MkaPaeIdx is only applied.
        during next initialization process.
        Testcase 1: PAE is enabled and Mka_SetEnable called with Enable == False, PAE continues to work normally
                    until next initialization. PAE and its participants shall not be started in next initialization process.
        Testcase 2: PAE is disabled and Mka_SetEnable called with Enable == True, PAE remains stopped
                    until next initialization. PAE and its enabled participants shall be started in next initialization process.
      </verifycrit>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01022_SetEnable_DisablePae</srcid><srcstatus/><internalId>2212</internalId></linkedfrom><linkedfrom><srcid>Mka_Logon_UnitTest01023_SetEnable_EnablePae</srcid><srcstatus/><internalId>2213</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Logon.c_1953</srcid><srcstatus/><internalId>792</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0122.DynamicControl</linksto><dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1098</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>381</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_91017</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Service Name:       Mka_GetEnable
        Syntax:             Std_ReturnType Mka_GetEnable(
                                                          uint8 MkaPaeIdx,
                                                          boolean* EnablePtr
                                                        );
        Service ID [hex]:   0x05
        Sync/Async:         Synchronous
        Reentrancy:         Reentrant for different MkaPaeIdx.
                            Non-reentrant for the same MkaPaeIdx.
        Parameters (in):    MkaPaeIdx           Index of the PAE within the context of the MKA module.
        Parameters (inout): None
        Parameters (out):   EnablePtr           Pointer to the Mka activation status of a PAE.
        Return value:       Std_ReturnType      E_OK:     The request has been accepted.
                                                E_NOT_OK: The request has not been accepted.
        Description:        Get the MKA activation status of a PAE.
        Available via:      Mka.h
      </description>
      <verifycrit>
        Verify that Mka_GetEnable shall set call Mka_Logon_GetEnable with correct parameters.
      </verifycrit>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_UnitTest01045_GetEnable</srcid><srcstatus/><internalId>2304</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Ext.c.m4_516</srcid><srcstatus/><internalId>608</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0122.DynamicControl</linksto><dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1098</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>382</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_91018</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Service Name:       Mka_GetPaeStatus
        Syntax:             Std_ReturnType Mka_GetPaeStatus(
                                                             uint8 MkaPaeIdx,
                                                             Mka_PaeStatusType* PaeStatusPtr
                                                           );
        Service ID [hex]:   0x06
        Sync/Async:         Synchronous
        Reentrancy:         Reentrant for different MkaPaeIdx.
                            Non-reentrant for the same MkaPaeIdx.
        Parameters (in):    MkaPaeIdx           Index of the PAE within the context of the MKA module.
        Parameters (inout): None
        Parameters (out):   PaeStatusPtr        Pointer to the status structure, which includes detailed information of a PAE.
        Return value:       Std_ReturnType      E_OK:     The request has been accepted.
                                                E_NOT_OK: The request has not been accepted.
        Description:        Get detailed information of a PAE.
        Available via:      Mka.h
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01003_KSPLow_KSActor</srcid><srcstatus/><internalId>1691</internalId></linkedfrom><linkedfrom><srcid>Mka_ConTest01005_KeyServerFlag_1</srcid><srcstatus/><internalId>1694</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Ext.c.m4_551</srcid><srcstatus/><internalId>609</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0122.DynamicControl</linksto><dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1098</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>383</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_91021</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Service Name:       Mka_SetPaePermissiveMode
        Syntax:             Std_ReturnType Mka_SetPaePermissiveMode(
                                                                     uint8 MkaPaeIdx,
                                                                     Mka_PermissiveModeType PermissiveMode
                                                                   );
        Service ID [hex]:   0x09
        Sync/Async:         Synchronous
        Reentrancy:         Reentrant for different MkaPaeIdx.
                            Non-reentrant for the same MkaPaeIdx.
        Parameters (in):    MkaPaeIdx           Index of the PAE within the context of the MKA module.
                            PermissiveMode      Permissive mode to set in the PAE.
        Parameters (inout): None
        Parameters (out):   None
        Return value:       Std_ReturnType      E_OK:     The request has been accepted.
                                                E_NOT_OK: The request has not been accepted.
        Description:        Set Permissive Mode of a KaY.
        Available via:      Mka.h
      </description>
      <verifycrit>
        Verify that Mka_SetPaePermissiveMode shall set call Mka_Logon_SetPaePermissiveMode with correct parameters.
      </verifycrit>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_UnitTest01047_SetPaePermissiveMode</srcid><srcstatus/><internalId>2306</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Ext.c.m4_587</srcid><srcstatus/><internalId>610</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0122.DynamicControl</linksto><dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1098</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>384</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_01003</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        The function Mka_SetPaePermissiveMode shall set the PermissiveMode of the MkaPaeInstance referred with the MkaPaeIdx.
        The new PermissiveMode shall be persistently stored in NVM and used from next power cycle onwards
        (as required in [CP_SWS_Mka_00027]).
        The per configuration provided MkaOnFailPermissiveMode of the MkaPaeInstance shall not be used if
        a valid value is stored on the NVM.
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01036_PaePermissiveMode_ReInit_Mode_Check</srcid><srcstatus/><internalId>2226</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Logon.c_918</srcid><srcstatus/><internalId>753</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0122.DynamicControl</linksto><dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1098</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>385</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_91022</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Service Name:       Mka_StartPae
        Syntax:             Std_ReturnType Mka_StartPae(
                                                         uint8 MkaPaeIdx
                                                       );
        Service ID [hex]:   0x10
        Sync/Async:         Synchronous
        Reentrancy:         Reentrant for different MkaPaeIdx.
                            Non-reentrant for the same MkaPaeIdx.
        Parameters (in):    MkaPaeIdx           Index of the PAE within the context of the MKA module.
        Parameters (inout): None
        Parameters (out):   None
        Return value:       Std_ReturnType      E_OK:     The request has been accepted.
                                                E_NOT_OK: The request has not been accepted.
        Description:        Manual start of the PAE.
                            (In case MkaPaeConfiguration.Autostart = False this method starts the PAE operation).
        Available via:      Mka.h
      </description>
      <verifycrit>
        Verify that Mka_StartPae shall set call Mka_Logon_StartPae with correct parameters.
      </verifycrit>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.dsn.Logon.ManualPaeStart</srcid><srcstatus/><internalId>1605</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_UnitTest01042_StartPae</srcid><srcstatus/><internalId>2301</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Ext.c.m4_618</srcid><srcstatus/><internalId>611</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0122.DynamicControl</linksto><dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1098</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>386</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_01004</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        The function Mka_StartPae shall start the operation of the MkaPaeInstance referred with the MkaPaeIdx if the
        MkaAutoStart configuration parameter is FALSE.
        If the MkaAutoStart configuration parameter is TRUE, Mka_StartPae will not have any effect on the MkaPaeInstance.
      </description>
      <verifycrit>
        Testcase 1: Configure PAE as MkaAutoStart == false. Verify that Mka_StartPae shall start PAE and its Participant instances.
        Testcase 2: Configure PAE as MkaAutoStart == true. Verify that Mka_StartPae shall not change (start any PAE instance).
      </verifycrit>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01015_StartPae</srcid><srcstatus/><internalId>2205</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Logon.c_933</srcid><srcstatus/><internalId>755</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0122.DynamicControl</linksto><dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1098</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>387</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_91019</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Service Name:       Mka_GetMacSecStatistics
        Syntax:             Std_ReturnType Mka_GetMacSecStatistics(
                                                                    uint8 MkaPaeIdx,
                                                                    const uint8* CknPtr,
                                                                    uint8 CknLength
                                                                  );
        Service ID [hex]:   0x07
        Sync/Async:         Asynchronous
        Reentrancy:         Reentrant for different MkaPaeIdx.
                            Non-reentrant for the same MkaPaeIdx.
        Parameters (in):    MkaPaeIdx           Index of the PAE within the context of the MKA module.
                            CknPtr              Connectivity Association Key Name (CKN) to identify the KaY participant.
                            CknLength           Length of Connectivity Association Key Name (CKN).
        Parameters (inout): None
        Parameters (out):   None
        Return value:       Std_ReturnType      E_OK:     The request has been accepted.
                                                E_NOT_OK: The request has not been accepted.
        Description:        Get Statistics of a PAE.
        Available via:      Mka.h
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.dsn.Mka.GetMacSecStatistics</srcid><srcstatus/><internalId>1455</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>388</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_91023</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Service Name:       Mka_LinkStateChange
        Syntax:             Std_ReturnType Mka_LinkStateChange(
                                                                uint8 MkaPaeIdx,
                                                                EthTrcv_LinkStateType TransceiverLinkState
                                                              );
        Service ID [hex]:   0x1D
        Sync/Async:         Synchronous
        Reentrancy:         Reentrant for different MkaPaeIdx.
                            Non-reentrant for the same MkaPaeIdx.
        Parameters (in):    MkaPaeIdx             Index of the PAE within the context of the MKA module.
                            TransceiverLinkState  The Ethernet link state of a physical Ethernet connection.
        Parameters (inout): None
        Parameters (out):   None
        Return value:       Std_ReturnType        E_OK:     The request has been accepted.
                                                  E_NOT_OK: The request has not been accepted.
        Description:        To inform MKA that a dedicated Trcv/Switch/PAC port link state has changed.
        Available via:      Mka.h
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01048_LinkStateChange_NoActionChange</srcid><srcstatus/><internalId>2238</internalId></linkedfrom><linkedfrom><srcid>Mka_Logon_UnitTest01049_LinkStateChange_LogonInitFalse</srcid><srcstatus/><internalId>2239</internalId></linkedfrom><linkedfrom><srcid>Mka_Logon_UnitTest01057_NvConfig_LastPrincipalGetIdx_InvalidCipherSuiteId</srcid><srcstatus/><internalId>2247</internalId></linkedfrom><linkedfrom><srcid>Mka_Logon_UnitTest01061_LinkState_GetDefaultParticipant_CipherId</srcid><srcstatus/><internalId>2251</internalId></linkedfrom><linkedfrom><srcid>Mka_UnitTest01048_LinkStateChange</srcid><srcstatus/><internalId>2307</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>389</internalId></specobject>

<!-- =================================[Callback notifications]================================= -->
    <specobject>
      <id>Mka.CP_SWS_Mka_91024</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Service Name:       Mka_GetMacSecStatisticsNotification
        Syntax:             void Mka_GetMacSecStatisticsNotification(
                                                                      uint8 MkaPaeIdx,
                                                                      Mka_Stats_SecYType* MacSecStatsPtr
                                                                    );
        Service ID [hex]:   0x1E
        Sync/Async:         Synchronous
        Reentrancy:         Reentrant for different MkaPaeIdx.
                            Non-reentrant for the same MkaPaeIdx.
        Parameters (in):    MkaPaeIdx           Index of the PAE within the context of the MKA module.
                            MacSecStatsPtr      Pointer to a structure including the MACsec statistics of an MKA participant.
        Parameters (inout): None
        Parameters (out):   None
        Return value:       None
        Description:        Callback to notify that Mka_GetMacSecStatistics finished and provide the requested statistics.
        Available via:      Mka.h
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.dsn.Mka.GetMacSecStatisticsNotification</srcid><srcstatus/><internalId>1456</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>390</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_91029</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Service Name:       Mka_RxIndication
        Syntax:             void Mka_RxIndication(
                                                   uint8 CtrlIdx,
                                                   Eth_FrameType FrameType,
                                                   boolean IsBroadcast,
                                                   const uint8* PhysAddrPtr,
                                                   const uint8* DataPtr,
                                                   uint16 LenByte
                                                 );
        Service ID [hex]:   0x1F
        Sync/Async:         Synchronous
        Reentrancy:         Reentrant
        Parameters (in):    CtrlIdx             Index of a ethernet port to which received message is related.
                            FrameType           Value of Ethernet header type-field.
                            IsBroadcast         Indicates if the target MAC address is a broadcast address.
                            PhysAddrPtr         Pointer to Physical source address (MAC address) of received Ethernet frame.
                            DataPtr             Pointer to payload of received Ethernet frame.
                            LenByte             Length (bytes) of the payload in received frame.
        Parameters (inout): None
        Parameters (out):   None
        Return value:       None
        Description:        To inform Mka about the reception of MKA Frames.
        Available via:      Mka.h
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01011_SakRekeyDelay</srcid><srcstatus/><internalId>1700</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>391</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_91030</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Service Name:       Mka_TxConfirmation
        Syntax:             void Mka_TxConfirmation(
                                                     uint8 CtrlIdx,
                                                     Eth_BufIdxType BufIdx,
                                                     Std_ReturnType Result
                                                   );
        Service ID [hex]:   0x20
        Sync/Async:         Synchronous
        Reentrancy:         Reentrant
        Parameters (in):    CtrlIdx             Index of the physical Ethernet controller within the context of the Ethernet Interface.
                            BufIdx              Index of the transmitted buffer.
                            Result              E_OK:     The transmission was successful.
                                                E_NOT_OK: The transmission failed.
        Parameters (inout): None
        Parameters (out):   None
        Return value:       None
        Description:        To inform MKA about the correct transmition of MKA Frames.
        Available via:      Mka.h
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_UnitTest01010_TxConfirmation_Uninit_Check</srcid><srcstatus/><internalId>2269</internalId></linkedfrom><linkedfrom><srcid>Mka_UnitTest01035_TxConfirmation_Invalid_Params</srcid><srcstatus/><internalId>2294</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>392</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_91031</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Service Name:       Mka_MacSecUpdateSecYNotification
        Syntax:             void Mka_MacSecUpdateSecYNotification(
                                                                   uint8 MkaPaeIdx
                                                                 );
        Service ID [hex]:   0x21
        Sync/Async:         Synchronous
        Reentrancy:         Reentrant for different MkaPaeIdx.
                            Non-reentrant for the same MkaPaeIdx.
        Parameters (in):    MkaPaeIdx           Index of the PAE within the context of the MKA module.
        Parameters (inout): None
        Parameters (out):   None
        Return value:       None
        Description:        Callback to notify that EhtIf_MacSecUpdateSecY finished.
        Available via:      Mka.h
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01005_KeyServerFlag_1</srcid><srcstatus/><internalId>1694</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/Mka.h_92</srcid><srcstatus/><internalId>506</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Mka_Ext.c.m4_306</srcid><srcstatus/><internalId>602</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>393</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_91032</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Service Name:       Mka_MacSecAddTxSaNotification
        Syntax:             void Mka_MacSecAddTxSaNotification(
                                                                uint8 MkaPaeIdx
                                                              );
        Service ID [hex]:   0x22
        Sync/Async:         Synchronous
        Reentrancy:         Reentrant for different MkaPaeIdx.
                            Non-reentrant for the same MkaPaeIdx.
        Parameters (in):    MkaPaeIdx           Index of the PAE within the context of the MKA module.
        Parameters (inout): None
        Parameters (out):   None
        Return value:       None
        Description:        Callback to notify that EthIf_MacSecAddTxSa finished.
        Available via:      Mka.h
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01003_KSPLow_KSActor</srcid><srcstatus/><internalId>1691</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/Mka.h_98</srcid><srcstatus/><internalId>507</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Mka_Ext.c.m4_335</srcid><srcstatus/><internalId>603</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>394</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_91033</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Service Name:       Mka_MacSecAddRxSaNotification
        Syntax:             void Mka_MacSecAddRxSaNotification(
                                                                uint8 MkaPaeIdx
                                                              );
        Service ID [hex]:   0x23
        Sync/Async:         Synchronous
        Reentrancy:         Reentrant for different MkaPaeIdx.
                            Non-reentrant for the same MkaPaeIdx.
        Parameters (in):    MkaPaeIdx           Index of the PAE within the context of the MKA module.
        Parameters (inout): None
        Parameters (out):   None
        Return value:       None
        Description:        Callback to notify that EthIf_MacSecAddRxSa finished.
        Available via:      Mka.h
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01003_KSPLow_KSActor</srcid><srcstatus/><internalId>1691</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/Mka.h_104</srcid><srcstatus/><internalId>508</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Mka_Ext.c.m4_367</srcid><srcstatus/><internalId>604</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>395</internalId></specobject>

<!-- ===================================[Scheduled functions]================================== -->
    <specobject>
      <id>Mka.CP_SWS_Mka_91034</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Service Name:       Mka_MainFunction
        Syntax:             void Mka_MainFunction(void);
        Service ID [hex]:   0x24
        Sync/Async:         None
        Reentrancy:         None
        Parameters (in):    None
        Parameters (inout): None
        Parameters (out):   None
        Return value:       None
        Description:        Main function for cyclic call.
        Available via:      Mka.h
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_UnitTest01018_Main</srcid><srcstatus/><internalId>2277</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>396</internalId></specobject>

    <specobject>
      <id>Mka.CP_SWS_Mka_01005</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        The frequency of invocations of Mka_MainFunction is determined by the configuration parameter MkaMainFunctionPeriod.
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.ECUC_Mka_00035</srcid><srcstatus/><internalId>406</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>397</internalId></specobject>

<!-- ===================================[Expected interfaces]================================== -->
<!-- ==================================[Mandatory interfaces]================================== -->
    <specobject>
      <id>Mka.CP_SWS_Mka_91006</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        |-----------------------------------------------------------------------------------------|
        |      API Function      |  Header File  |                   Description                  |
        |------------------------|---------------|------------------------------------------------|
        |  EthIf_ProvideTxBuffe  |    EthIf.h    |   Provides access to a transmit buffer of the  |
        |                        |               |         specified Ethernet controller.         |
        |------------------------|---------------|------------------------------------------------|
        |     EthIf_Transmit     |    EthIf.h    |  Triggers transmission of a previously filled  |
        |                        |               |                transmit buffer.                |
        |------------------------|---------------|------------------------------------------------|
        |    NvM_EraseNvBlock    |     NvM.h     |          Service to erase a NV block.          |
        |------------------------|---------------|------------------------------------------------|
        |      NvM_ReadBlock     |     NvM.h     | Service to copy the data of the NV block to its|
        |                        |               |            corresponding RAM block.            |
        |------------------------|---------------|------------------------------------------------|
        |     NvM_WriteBlock     |     NvM.h     |Service to copy the data of the RAM block to its|
        |                        |               |             corresponding NV block.            |
        |-----------------------------------------------------------------------------------------|
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.EB.CP_SWS_Mka_91006</srcid><srcstatus/><internalId>399</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.Mka.InterfaceUpdate</srcid><srcstatus/><internalId>496</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>398</internalId></specobject>

    <specobject>
      <id>Mka.EB.CP_SWS_Mka_91006</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        |---------------------------------------------------------------------------------------------|
        |      API Function          |  Header File  |                   Description                  |
        |----------------------------|---------------|------------------------------------------------|
        |  EthIf_ProvideTxBuffe      |    EthIf.h    |   Provides access to a transmit buffer of the  |
        |                            |               |         specified Ethernet controller.         |
        |----------------------------|---------------|------------------------------------------------|
        |     EthIf_Transmit         |    EthIf.h    |  Triggers transmission of a previously filled  |
        |                            |               |                transmit buffer.                |
        |----------------------------|---------------|------------------------------------------------|
        |     EthIf_MacSec*          |    EthIf.h    |  Used by MKA module to set MACSec Entity       |
        |                            |               |                specific parameters.            |
        |----------------------------|---------------|------------------------------------------------|
        | EthIf_MacSecGetMacSecStats |    EthIf.h    |    Requests MACSec statistics from the         |
        |                            |               |                MACSec Entity.                  |
        |----------------------------|---------------|------------------------------------------------|
        |   NvM_GetErrorStatus       |     NvM.h     |     Service to read the block dependent        |
        |                            |               |          error/status information.             |
        |----------------------------|---------------|------------------------------------------------|
        | NvM_SetRamBlockStatus      |     NvM.h     | Service for setting the RAM block status of a  |
        |                            |               |    permanent RAM block or the status of the    |
        |                            |               |   explicit synchronization of a NVRAM block.   |
        |----------------------------|---------------|------------------------------------------------|
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Ext.c.m4_683</srcid><srcstatus/><internalId>613</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_7</srcid><srcstatus/><internalId>620</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Mka_Logon.c_1704</srcid><srcstatus/><internalId>785</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Mka_Logon.c_1736</srcid><srcstatus/><internalId>788</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Mka_RxTx.c_217</srcid><srcstatus/><internalId>802</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Mka_RxTx.c_522</srcid><srcstatus/><internalId>820</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_91006</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>398</internalId></provcov>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00024</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>340</internalId></provcov>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00025</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>341</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>399</internalId></specobject>
<!-- ===================================[Optional interfaces]================================== -->
    <specobject>
      <id>Mka.CP_SWS_Mka_91007</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        |---------------------------------------------------------------------------------------------------|
        |      API Function      |  Header File  |                        Description                       |
        |------------------------|---------------|----------------------------------------------------------|
        |     Det_ReportError    |     Det.h     |           Service to report development errors.          |
        |------------------------|---------------|----------------------------------------------------------|
        | Det_ReportRuntimeError |     Det.h     |    Service to report runtime errors. If a callout has    |
        |                        |               |    been configured then this callout shall be called.    |
        |------------------------|---------------|----------------------------------------------------------|
        |    EthIf_GetPhysAddr   |    EthIf.h    |      Obtains the physical source address used by the     |
        |                        |               |                    indexed controller.                   |
        |------------------------|---------------|----------------------------------------------------------|
        |                        |               |  Provides additional management information along to an  |
        |                        |               | Ethernet frame that requires special treatment within the|
        | EthIf_SetSwitchMgmtInfo|    EthIf.h    |            Switch. It has to be called between           |
        |                        |               |    EthIf_ProvideTxBuffer() and EthIf_Transmit() of the   |
        |                        |               |                      related frame.                      |
        |------------------------|---------------|----------------------------------------------------------|
        |  IdsM_SetSecurityEvent |    EthIf.h    |      This API is the application interface to report     |
        |                        |               |               security events to the IdsM.               |
        |---------------------------------------------------------------------------------------------------|
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/Mka_Int.h_38</srcid><srcstatus/><internalId>510</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Mka_Lib.c_187</srcid><srcstatus/><internalId>711</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>400</internalId></specobject>

<!-- ===============================[Configuration specification]============================== -->
<!-- ===========================================[Mka]========================================== -->
    <specobject>
      <id>Mka.ECUC_Mka_00001</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Module Name:                Mka
        Module Description:         Configuration of the MACsec Key Agreement module.
        Post-Build Variant Support: FALSE
        Supported Config Variants:  VARIANT-PRE-COMPILE
        Included Containers:
        |---------------------------------------------------------------------------------------------------------|
        |    Container Name    |  Multiplicity  |                        Scope / Dependency                       |
        |----------------------|----------------|-----------------------------------------------------------------|
        | MkaCryptoAlgoConfig  |     1..255     |              Cryptography configuration for MACsec.             |
        |----------------------|----------------|-----------------------------------------------------------------|
        |      MkaGeneral      |        1       | This container holds the general parameters of the MKA protocol |
        |                      |                |    which apply to ports that are referencing this container.    |
        |----------------------|----------------|-----------------------------------------------------------------|
        |  MkaPaeConfiguration |     1..255     |               Common MKA configuration for a PAE.               |
        |----------------------|----------------|-----------------------------------------------------------------|
        |    MkaPaeInstance    |     1..255     |             MKA configuration of a controlled port.             |
        |---------------------------------------------------------------------------------------------------------|
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_16</srcid><srcstatus/><internalId>822</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_64</srcid><srcstatus/><internalId>823</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_1298</srcid><srcstatus/><internalId>873</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_1467</srcid><srcstatus/><internalId>880</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_1770</srcid><srcstatus/><internalId>897</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MkaConfigSet</srcid><srcstatus/><internalId>501</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>401</internalId></specobject>

<!-- =======================================[MkaGeneral]======================================= -->
    <specobject>
      <id>Mka.ECUC_Mka_00002</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Container Name:           MkaGeneral
        Parent Container:         Mka
        Description:              This container holds the general parameters of the MKA protocol which apply to ports
                                  that are referencing this container.
        Configuration Parameters: MkaDevErrorDetect
                                  MkaHelloTime
                                  MkaLifeTime
                                  MkaMainFunctionPeriod
                                  MkaSakRetireTime
                                  MkaVersionInfoApi
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_1771</srcid><srcstatus/><internalId>898</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MkaConfigSet</srcid><srcstatus/><internalId>501</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>402</internalId></specobject>

    <specobject>
      <id>Mka.ECUC_Mka_00034</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Name:               MkaDevErrorDetect
        Parent Container:   MkaGeneral
        Description:        Switches the development error detection and notification on or off.
                              - true: detection and notification is enabled.
                              - false: detection and notification is disabled.
        Multiplicity:       1
        Type:               EcucBooleanParamDef
        Default value:      FALSE
        Value Configuration Class:
          Pre-compile time: X All Variants
          Link time:        - -
          Post-build time:  - -
        Scope / Dependency: scope: local
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_1787</srcid><srcstatus/><internalId>899</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>403</internalId></specobject>

    <specobject>
      <id>Mka.ECUC_Mka_00007</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Name:               MkaHelloTime
        Parent Container:   MkaGeneral
        Description:        Interval [s] between MKPDUs when two participants have an active MKA communication
                            (the participants are included in the Live Peer list of each other).
        Multiplicity:       1
        Type:               EcucFloatParamDef
        Range:              [0 .. INF]
        Default value:      2
        Value Configuration Class:
          Pre-compile time: X All Variants
          Link time:        - -
          Post-build time:  - -
        Scope / Dependency: scope: local
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_1809</srcid><srcstatus/><internalId>900</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>404</internalId></specobject>

    <specobject>
      <id>Mka.ECUC_Mka_00009</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Name:               MkaLifeTime
        Parent Container:   MkaGeneral
        Description:        Time span [s] since last MKPDU was received from the other participant, to consider it
                            alive.
                            In case no valid MKPDU from the other participant is received after MkaLifeTime,
                            the Secure Channel is shut down.
        Multiplicity:       1
        Type:               EcucFloatParamDef
        Range:              [0 .. INF]
        Default value:      6
        Value Configuration Class:
          Pre-compile time: X All Variants
          Link time:        - -
          Post-build time:  - -
        Scope / Dependency: scope: local
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_1835</srcid><srcstatus/><internalId>901</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>405</internalId></specobject>

    <specobject>
      <id>Mka.ECUC_Mka_00035</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Name:               MkaMainFunctionPeriod
        Parent Container:   MkaGeneral
        Description:        The cycle time of the periodic main function of MKA. Defined in seconds.
        Multiplicity:       1
        Type:               EcucFloatParamDef
        Range:              [0 .. INF]
        Default value:      None
        Value Configuration Class:
          Pre-compile time: X All Variants
          Link time:        - -
          Post-build time:  - -
        Scope / Dependency: scope: local
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_1865</srcid><srcstatus/><internalId>902</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_01005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>397</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>406</internalId></specobject>

    <specobject>
      <id>Mka.ECUC_Mka_00010</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Name:               MkaSakRetireTime
        Parent Container:   MkaGeneral
        Description:        During an SAK rekey, time [s] to retire the previous SAK in use.
        Multiplicity:       1
        Type:               EcucFloatParamDef
        Range:              [0 .. INF]
        Default value:      3
        Value Configuration Class:
          Pre-compile time: X All Variants
          Link time:        - -
          Post-build time:  - -
        Scope / Dependency: scope: local
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_1891</srcid><srcstatus/><internalId>903</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>407</internalId></specobject>

    <specobject>
      <id>Mka.ECUC_Mka_00036</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Name:               MkaVersionInfoApi
        Parent Container:   MkaGeneral
        Description:        Enables / Disables version info API.
        Multiplicity:       1
        Type:               EcucBooleanParamDef
        Default value:      FALSE
        Value Configuration Class:
          Pre-compile time: X All Variants
          Link time:        - -
          Post-build time:  - -
        Scope / Dependency: scope: local
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_1948</srcid><srcstatus/><internalId>905</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>408</internalId></specobject>

<!-- ===================================[MkaPaeConfiguration]================================== -->
    <specobject>
      <id>Mka.ECUC_Mka_00033</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Container Name:           MkaPaeConfiguration
        Parent Container:         Mka
        Description:              Common MKA configuration for a PAE.
        Configuration Parameters: MkaAutoStart
                                  MkaPaeConfigurationIdx
                                  MkaRetryBaseDelay
                                  MkaRetryCyclicDelay
                                  MkaSakRekeyTimeSpan
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_1299</srcid><srcstatus/><internalId>874</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MkaConfigSet</srcid><srcstatus/><internalId>501</internalId></linkedfrom><linkedfrom><srcid>dev.PostBuild</srcid><srcstatus/><internalId>502</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>409</internalId></specobject>

    <specobject>
      <id>Mka.ECUC_Mka_00012</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Name:               MkaAutoStart
        Parent Container:   MkaPaeConfiguration
        Description:        Autostart or manual start of the PAE Instance.
                              - True := Autostart
                              - False := Manual Start
                            If Autostart = False, the method Mka_StartPae is used to start the PAE instance.
        Multiplicity:       1
        Type:               EcucBooleanParamDef
        Default value:      TRUE
        Value Configuration Class:
          Pre-compile time: X All Variants
          Link time:        - -
          Post-build time:  - -
        Scope / Dependency: scope: local
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_1343</srcid><srcstatus/><internalId>876</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>410</internalId></specobject>

    <specobject>
      <id>Mka.ECUC_Mka_00037</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Name:               MkaPaeConfigurationIdx
        Parent Container:   MkaPaeConfiguration
        Description:        Instance ID of the MkaPaeConfiguration.
        Multiplicity:       1
        Type:               EcucIntegerParamDef
        Range:              0 .. 255
        Default value:      None
        Value Configuration Class:
          Pre-compile time: X All Variants
          Link time:        - -
          Post-build time:  - -
        Scope / Dependency: scope: local
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>doc/public/changelog/Deviations.xml_228</srcid><srcstatus/><internalId>499</internalId></linkedfrom><linkedfrom><srcid>dev.PostBuild</srcid><srcstatus/><internalId>502</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.EB.ECUC_Mka_00037</srcid><srcstatus/><internalId>412</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>411</internalId></specobject>

    <specobject>
      <id>Mka.EB.ECUC_Mka_00037</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Name:               MkaPaeConfigurationIdx
        Parent Container:   MkaPaeConfiguration
        Description:        Instance ID of the MkaPaeConfiguration.
        Multiplicity:       1
        Type:               EcucIntegerParamDef
        Range:              0 .. 254
        Default value:      None
        Value Configuration Class:
          Pre-compile time: X All Variants
          Link time:        - -
          Post-build time:  - -
        Scope / Dependency: scope: local
      </description>
      <comment>
        Reduced range from 255 to 254, so that value 255 is reserved as invalid maximum value inside of type uint8.
      </comment>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_1318</srcid><srcstatus/><internalId>875</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.ECUC_Mka_00037</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>411</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>412</internalId></specobject>

    <specobject>
      <id>Mka.ECUC_Mka_00004</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Name:               MkaRetryBaseDelay
        Parent Container:   MkaPaeConfiguration
        Description:        The base delay in seconds for the retry phase of MKA. The retry have an exponential
                            back off delay (1x base delay, 2x base delay, 4x base delay, ...) until the retry delay
                            overflows the MkaRetryCyclicDelay value.
        Multiplicity:       1
        Type:               EcucFloatParamDef
        Range:              [0 .. INF]
        Default value:      None
        Value Configuration Class:
          Pre-compile time: X All Variants
          Link time:        - -
          Post-build time:  - -
        Scope / Dependency: scope: local
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_1373</srcid><srcstatus/><internalId>877</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0112.ExponentialStartupMkaHelloTime</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>964</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>413</internalId></specobject>

    <specobject>
      <id>Mka.ECUC_Mka_00005</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Name:               MkaRetryCyclicDelay
        Parent Container:   MkaPaeConfiguration
        Description:        Interval in seconds between retries after base delay with exponential back off.
        Multiplicity:       1
        Type:               EcucFloatParamDef
        Range:              [0 .. INF]
        Default value:      None
        Value Configuration Class:
          Pre-compile time: X All Variants
          Link time:        - -
          Post-build time:  - -
        Scope / Dependency: scope: local
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_1405</srcid><srcstatus/><internalId>878</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0112.ExponentialStartupMkaHelloTime</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>964</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>414</internalId></specobject>

    <specobject>
      <id>Mka.ECUC_Mka_00024</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Name:               MkaSakRekeyTimeSpan
        Parent Container:   MkaPaeConfiguration
        Description:        Time [s] to trigger the rekey of an in use SAK. If set to 0, the rekey will not be triggered
                            after a time span.
        Multiplicity:       1
        Type:               EcucFloatParamDef
        Range:              [0 .. INF]
        Default value:      None
        Value Configuration Class:
          Pre-compile time: X All Variants
          Link time:        - -
          Post-build time:  - -
        Scope / Dependency: scope: local
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_1436</srcid><srcstatus/><internalId>879</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01082_ImmediateResponse_SakGenerated</srcid><srcstatus/><internalId>2150</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>415</internalId></specobject>

<!-- ===================================[MkaCryptoAlgoConfig]================================== -->
    <specobject>
      <id>Mka.ECUC_Mka_00021</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Container Name:           MkaCryptoAlgoConfig
        Parent Container:         Mka
        Description:              Cryptography configuration for MACsec.
        Configuration Parameters: MkaCryptoAlgoConfigIdx
                                  MkaMacSecCapability
                                  MkaMacSecConfidentialityOffset
                                  MkaMacSecReplayProtection
                                  MkaMacSecReplayProtectionWindow
        Included Containers:
        |---------------------------------------------------------------------------------------------------------|
        |    Container Name    |  Multiplicity  |                        Scope / Dependency                       |
        |----------------------|----------------|-----------------------------------------------------------------|
        |                      |                |  Cipher Suite configuration to use with MACsec. MkaCipherSuite  |
        |    MkaCipherSuites   |      1..4      | Prio is present in case the MKA instance acts as a Key Server to|
        |                      |                |            select the cipher suite to use for MACsec.           |
        |---------------------------------------------------------------------------------------------------------|
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_1475</srcid><srcstatus/><internalId>881</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MkaConfigSet</srcid><srcstatus/><internalId>501</internalId></linkedfrom><linkedfrom><srcid>dev.PostBuild</srcid><srcstatus/><internalId>502</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>416</internalId></specobject>

    <specobject>
      <id>Mka.ECUC_Mka_00053</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Name:               MkaCryptoAlgoConfigIdx
        Parent Container:   MkaCryptoAlgoConfig
        Description:        Instance ID of the configured Crypto configuration.
        Multiplicity:       1
        Type:               EcucIntegerParamDef
        Range:              0 .. 255
        Default value:      None
        Value Configuration Class:
          Pre-compile time: X All Variants
          Link time:        - -
          Post-build time:  - -
        Scope / Dependency: scope: local
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.ReducedRange</srcid><srcstatus/><internalId>500</internalId></linkedfrom><linkedfrom><srcid>dev.PostBuild</srcid><srcstatus/><internalId>502</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.EB.ECUC_Mka_00053</srcid><srcstatus/><internalId>418</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>417</internalId></specobject>

    <specobject>
      <id>Mka.EB.ECUC_Mka_00053</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Name:               MkaCryptoAlgoConfigIdx
        Parent Container:   MkaCryptoAlgoConfig
        Description:        Instance ID of the configured Crypto configuration.
        Multiplicity:       1
        Type:               EcucIntegerParamDef
        Range:              0 .. 254
        Default value:      None
        Value Configuration Class:
          Pre-compile time: X All Variants
          Link time:        - -
          Post-build time:  - -
        Scope / Dependency: scope: local
      </description>
      <comment>
        Reduced range from 255 to 254, so that value 255 is reserved as invalid maximum value inside of type uint8.
      </comment>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_1494</srcid><srcstatus/><internalId>882</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.ECUC_Mka_00053</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>417</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>418</internalId></specobject>

    <specobject>
      <id>Mka.ECUC_Mka_00025</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Name:               MkaMacSecCapability
        Parent Container:   MkaCryptoAlgoConfig
        Description:        MACsec capability to use for MACsec.
        Multiplicity:       1
        Type:               EcucEnumerationParamDef
        Range:              INTEGRITY_AND_CONFIDENTIALITY
                            INTEGRITY_WITHOUT_CONFIDENTIALITY
        Default value:      INTEGRITY_WITHOUT_CONFIDENTIALITY
        Value Configuration Class:
          Pre-compile time: X All Variants
          Link time:        - -
          Post-build time:  - -
        Scope / Dependency: scope: local
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_1519</srcid><srcstatus/><internalId>883</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.PostBuild</srcid><srcstatus/><internalId>502</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>419</internalId></specobject>

    <specobject>
      <id>Mka.ECUC_Mka_00026</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Name:               MkaMacSecConfidentialityOffset
        Parent Container:   MkaCryptoAlgoConfig
        Description:        The confidentiality Offset is only applicable if "Integrity and confidentiality" with a
                            non-XPN cipher suite is selected.
        Multiplicity:       0..1
        Type:               EcucEnumerationParamDef
        Range:              CONFIDENTIALITY_OFFSET_0
                            CONFIDENTIALITY_OFFSET_30
                            CONFIDENTIALITY_OFFSET_50
        Default value:      CONFIDENTIALITY_OFFSET_0
        Value Configuration Class:
          Pre-compile time: X All Variants
          Link time:        - -
          Post-build time:  - -
        Scope / Dependency: scope: local
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_1553</srcid><srcstatus/><internalId>884</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.PostBuild</srcid><srcstatus/><internalId>502</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>420</internalId></specobject>

    <specobject>
      <id>Mka.ECUC_Mka_00027</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Name:               MkaMacSecReplayProtection
        Parent Container:   MkaCryptoAlgoConfig
        Description:        MACsec replay protection parameter for MACsec.
                            The Replay Protection parameter is defined in the IEEE 802.1AE-2018 document,
                            on chapter 10.4. It enables the replay protection if a packet is received with
                            PacketNumber outside of the Window = PN - ProtectionWindow.
        Multiplicity:       1
        Type:               EcucBooleanParamDef
        Default value:      FALSE
        Value Configuration Class:
          Pre-compile time: X All Variants
          Link time:        - -
          Post-build time:  - -
        Scope / Dependency: scope: local
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Cp.c_1738</srcid><srcstatus/><internalId>558</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_1599</srcid><srcstatus/><internalId>886</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0114.PacketNumbering</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>966</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>421</internalId></specobject>

    <specobject>
      <id>Mka.ECUC_Mka_00028</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Name:               MkaMacSecReplayProtectionWindow
        Parent Container:   MkaCryptoAlgoConfig
        Description:        MACsec replay protection parameter for MACsec.
                            The Replay Protection parameter is defined in the IEEE 802.1AE-2018 document,
                            on chapter 10.4. It enables the replay protection if a packet is received with
                            PacketNumber outside of the Window = PN - ProtectionWindow.
        Multiplicity:       0..1
        Type:               EcucIntegerParamDef
        Range:              0 .. 18446744073709551615
        Default value:      None
        Value Configuration Class:
          Pre-compile time: X All Variants
          Link time:        - -
          Post-build time:  - -
        Scope / Dependency: scope: local
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Cp.c_1739</srcid><srcstatus/><internalId>559</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_1625</srcid><srcstatus/><internalId>887</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.PostBuild</srcid><srcstatus/><internalId>502</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0114.PacketNumbering</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>966</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>422</internalId></specobject>

<!-- =====================================[MkaCipherSuites]==================================== -->
    <specobject>
      <id>Mka.ECUC_Mka_00050</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Container Name:           MkaCipherSuites
        Parent Container:         MkaCryptoAlgoConfig
        Description:              Cipher Suite configuration to use with MACsec. MkaCipherSuitePrio is present in case the MKA instance
                                  acts as a Key Server to select the cipher suite to use for MACsec.
        Configuration Parameters: MkaMacSecCipherSuite
                                  MkaMacSecCipherSuitePrio
        Included Containers:      No Included Containers.
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_1655</srcid><srcstatus/><internalId>888</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.PostBuild</srcid><srcstatus/><internalId>502</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>423</internalId></specobject>

    <specobject>
      <id>Mka.ECUC_Mka_00052</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Name:               MkaMacSecCipherSuite
        Parent Container:   MkaCipherSuites
        Description:        Cipher Suite to use for MACsec.
        Multiplicity:       1
        Type:               EcucEnumerationParamDef
        Range:              GCM_AES_128
                            GCM_AES_256
                            GCM_AES_XPN_128
                            GCM_AES_XPN_256
        Default value:      GCM_AES_128
        Value Configuration Class:
          Pre-compile time: X All Variants
          Link time:        - -
          Post-build time:  - -
        Scope / Dependency: scope: local
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_1682</srcid><srcstatus/><internalId>890</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.PostBuild</srcid><srcstatus/><internalId>502</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>424</internalId></specobject>

    <specobject>
      <id>Mka.ECUC_Mka_00051</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Name:               MkaMacSecCipherSuitePrio
        Parent Container:   MkaCipherSuites
        Description:        In case the MKA instance acts as a Key Server, the priority is used to select the Cipher Suite to use with
                            MACsec from the common supported Ciphers (with the client in the link). Value of 1 means the highest priority.
                            Value of 4 means the lowest priority.
        Multiplicity:       1
        Type:               EcucIntegerParamDef
        Range:              1 .. 4
        Default value:      None.
        Value Configuration Class:
          Pre-compile time: X All Variants
          Link time:        - -
          Post-build time:  - -
        Scope / Dependency: scope: local
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_1727</srcid><srcstatus/><internalId>895</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.PostBuild</srcid><srcstatus/><internalId>502</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>425</internalId></specobject>

<!-- =====================================[MkaPaeInstance]===================================== -->
    <specobject>
      <id>Mka.ECUC_Mka_00003</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Container Name:           MkaPaeInstance
        Parent Container:         Mka
        Description:              MKA configuration of a controlled port.
        Configuration Parameters: MkaOnFailPermissiveMode
                                  MkaOnFailPermissiveModeTimeout
                                  MkaPaeIdx
                                  MkaEthIfControllerRef
                                  MkaPaeConfRef
                                  MkaSwitchPortRef
        Included Containers:
        |---------------------------------------------------------------------------------------------------------|
        |    Container Name    |  Multiplicity  |                        Scope / Dependency                       |
        |----------------------|----------------|-----------------------------------------------------------------|
        |        MkaKay        |        1       |         MKA instance (KaY) for a controlled port (PaE).         |
        |---------------------------------------------------------------------------------------------------------|
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_65</srcid><srcstatus/><internalId>824</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MkaConfigSet</srcid><srcstatus/><internalId>501</internalId></linkedfrom><linkedfrom><srcid>dev.PostBuild</srcid><srcstatus/><internalId>502</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>426</internalId></specobject>

    <specobject>
      <id>Mka.ECUC_Mka_00018</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Name:               MkaOnFailPermissiveMode
        Parent Container:   MkaPaeInstance
        Description:        Sets the behavior of the PAE in case MKA does not succeed when MKA is enabled.
        Multiplicity:       1
        Type:               EcucEnumerationParamDef
        Range:              NEVER:      The controlled port will never be set to enabled if the participants cannot
                                        establish and successfully use a MACsec Secure Channel.
                            TIMEOUT:    The controlled port will be set to enabled and MACsec will not be used in the
                                        referred port if the timeout value (MkaOnFailPermissiveModeTimeout) is reached and
                                        none MKA instance under the PAE instance could success the following conditions:
                                          - A participant belonging to the same CA was recognized and authenticated.
                                          - A secure channel could be established.
                                          - Both participants can transmit and receive MACsec protected traffic through the SC.
        Default value:      None
        Value Configuration Class:
          Pre-compile time: X All Variants
          Link time:        - -
          Post-build time:  - -
        Scope / Dependency: scope: local
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_118</srcid><srcstatus/><internalId>827</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.PostBuild</srcid><srcstatus/><internalId>502</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>427</internalId></specobject>

    <specobject>
      <id>Mka.ECUC_Mka_00019</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Name:               MkaOnFailPermissiveModeTimeout
        Parent Container:   MkaPaeInstance
        Description:        Timeout in seconds to enable the controlled port in case MkaOnFailPermissiveMode is set to Timeout.
        Multiplicity:       1
        Type:               EcucFloatParamDef
        Range:              [0 .. INF]
        Default value:      255
        Value Configuration Class:
          Pre-compile time: X All Variants
          Link time:        - -
          Post-build time:  - -
        Scope / Dependency: scope: local
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_157</srcid><srcstatus/><internalId>828</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>428</internalId></specobject>

    <specobject>
      <id>Mka.ECUC_Mka_00011</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Name:               MkaPaeIdx
        Parent Container:   MkaPaeInstance
        Description:        Instance ID of the configured PAE.
        Multiplicity:       1
        Type:               EcucIntegerParamDef
        Range:              0 .. 255
        Default value:      None
        Value Configuration Class:
          Pre-compile time: X All Variants
          Link time:        - -
          Post-build time:  - -
        Scope / Dependency: scope: local
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>doc/public/changelog/Deviations.xml_227</srcid><srcstatus/><internalId>498</internalId></linkedfrom><linkedfrom><srcid>dev.PostBuild</srcid><srcstatus/><internalId>502</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.EB.ECUC_Mka_00011</srcid><srcstatus/><internalId>430</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>429</internalId></specobject>

    <specobject>
      <id>Mka.EB.ECUC_Mka_00011</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Name:               MkaPaeIdx
        Parent Container:   MkaPaeInstance
        Description:        Instance ID of the configured PAE.
        Multiplicity:       1
        Type:               EcucIntegerParamDef
        Range:              0 .. 254
        Default value:      None
        Value Configuration Class:
          Pre-compile time: X All Variants
          Link time:        - -
          Post-build time:  - -
        Scope / Dependency: scope: local
      </description>
      <comment>
        Reduced range from 255 to 254, so that value 255 is reserved as invalid maximum value inside of type uint8.
      </comment>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_93</srcid><srcstatus/><internalId>826</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.ECUC_Mka_00011</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>429</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>430</internalId></specobject>

    <specobject>
      <id>Mka.ECUC_Mka_00013</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Name:               MkaEthIfControllerRef
        Parent Container:   MkaPaeInstance
        Description:        A reference to the EthIfController which is used for transmitting / receiving EAP frames
                            (to configure the controlled port).
        Multiplicity:       1
        Type:               Symbolic name reference to EthIfController
        Default value:      None
        Value Configuration Class:
          Pre-compile time: X All Variants
          Link time:        - -
          Post-build time:  - -
        Scope / Dependency: scope: local
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_186</srcid><srcstatus/><internalId>829</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.PostBuild</srcid><srcstatus/><internalId>502</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>431</internalId></specobject>

    <specobject>
      <id>Mka.ECUC_Mka_00054</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Name:               MkaPaeConfRef
        Parent Container:   MkaPaeInstance
        Description:        Reference to the applicable PAE configuration.
        Multiplicity:       1
        Type:               Reference to MkaPaeConfiguration
        Default value:      None
        Value Configuration Class:
          Pre-compile time: X All Variants
          Link time:        - -
          Post-build time:  - -
        Scope / Dependency: scope: local
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_219</srcid><srcstatus/><internalId>831</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.PostBuild</srcid><srcstatus/><internalId>502</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>432</internalId></specobject>

    <specobject>
      <id>Mka.ECUC_Mka_00014</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Name:               MkaSwitchPortRef
        Parent Container:   MkaPaeInstance
        Description:        A reference to the EthSwtPort enabled and set only in case PAE is attached to a switch port.
        Multiplicity:       0..1
        Type:               Symbolic name reference to EthSwtPort
        Default value:      None
        Value Configuration Class:
          Pre-compile time: X All Variants
          Link time:        - -
          Post-build time:  - -
        Scope / Dependency: scope: local
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_245</srcid><srcstatus/><internalId>832</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.PostBuild</srcid><srcstatus/><internalId>502</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>433</internalId></specobject>

<!-- =========================================[MkaKay]========================================= -->
    <specobject>
      <id>Mka.ECUC_Mka_00017</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Container Name:           MkaKay
        Parent Container:         MkaPaeInstance
        Description:              MKA instance (KaY) for a controlled port (PaE).
        Configuration Parameters: MkaBypassEtherType
                                  MkaBypassVlan
                                  MkaDstMacAddress
                                  MkaKeyServerPriority
                                  MkaRole
                                  MkaSrcMacAddress
        Included Containers:
        |---------------------------------------------------------------------------------------------------------|
        |    Container Name    |  Multiplicity  |                        Scope / Dependency                       |
        |----------------------|----------------|-----------------------------------------------------------------|
        |   MkaKayParticipant  |     1..255     |                  MKA participant configuration.                 |
        |---------------------------------------------------------------------------------------------------------|
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_307</srcid><srcstatus/><internalId>834</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>434</internalId></specobject>

    <specobject>
      <id>Mka.ECUC_Mka_00016</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Name:               MkaBypassEtherType
        Parent Container:   MkaKay
        Description:        Bypassed EtherType. The EtherTypes included will not be MACsec protected.
        Multiplicity:       0..255
        Type:               EcucIntegerParamDef
        Range:              0 .. 65535
        Default value:      None
        Value Configuration Class:
          Pre-compile time: X All Variants
          Link time:        - -
          Post-build time:  - -
        Scope / Dependency: scope: local
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_323</srcid><srcstatus/><internalId>835</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.PostBuild</srcid><srcstatus/><internalId>502</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0116.BypassRules</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>968</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>435</internalId></specobject>

    <specobject>
      <id>Mka.ECUC_Mka_00015</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Name:               MkaBypassVlan
        Parent Container:   MkaKay
        Description:        Bypassed VLAN-ID. The VLAN-IDs included will not be MACsec protected.
                            (VLAN-ID 0 is interpreted as no-VLAN &gt; Bypass untagged traffic)
        Multiplicity:       0..255
        Type:               EcucIntegerParamDef
        Range:              0 .. 4094
        Default value:      None
        Value Configuration Class:
          Pre-compile time: X All Variants
          Link time:        - -
          Post-build time:  - -
        Scope / Dependency: scope: local
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_366</srcid><srcstatus/><internalId>836</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.PostBuild</srcid><srcstatus/><internalId>502</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0116.BypassRules</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>968</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>436</internalId></specobject>

    <specobject>
      <id>Mka.ECUC_Mka_00032</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Name:               MkaDstMacAddress
        Parent Container:   MkaKay
        Description:        Destination MAC address to use by the MKA instance. The destination MAC addresses
                            to use are defined in the IEEE 802.1X-2020 chapter 11.1.1 (Table 11-1).
        Multiplicity:       1
        Type:               EcucStringParamDef
        Default value:      None
        Regular Expression: None
        Value Configuration Class:
          Pre-compile time: X All Variants
          Link time:        - -
          Post-build time:  - -
        Scope / Dependency: scope: local
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_402</srcid><srcstatus/><internalId>837</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.PostBuild</srcid><srcstatus/><internalId>502</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.MkaTransport.29</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>190</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>437</internalId></specobject>

    <specobject>
      <id>Mka.ECUC_Mka_00022</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Name:               MkaKeyServerPriority
        Parent Container:   MkaKay
        Description:        Key Server Priority of the MKA participants. In case it is not provided, the default value
                            is 0 for an MKA_KEY_SERVER and 255 for an MKA_PEER.
        Multiplicity:       0..1
        Type:               EcucIntegerParamDef
        Range:              0 .. 255
        Default value:      None
        Value Configuration Class:
          Pre-compile time: X All Variants
          Link time:        - -
          Post-build time:  - -
        Scope / Dependency: scope: local
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_468</srcid><srcstatus/><internalId>839</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.PostBuild</srcid><srcstatus/><internalId>502</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>438</internalId></specobject>

    <specobject>
      <id>Mka.ECUC_Mka_00029</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Name:               MkaRole
        Parent Container:   MkaKay
        Description:        Role of the MKA instance.
        Multiplicity:       1
        Type:               EcucEnumerationParamDef
        Range:              MKA_KEY_SERVER
                            MKA_PEER
        Default value:      None
        Value Configuration Class:
          Pre-compile time: X All Variants
          Link time:        - -
          Post-build time:  - -
        Scope / Dependency: scope: local
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.EB.ECUC_Mka_00029</srcid><srcstatus/><internalId>440</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.PostBuild</srcid><srcstatus/><internalId>502</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>439</internalId></specobject>

    <specobject>
      <id>Mka.EB.ECUC_Mka_00029</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Name:               MkaRole
        Parent Container:   MkaKay
        Description:        Role of the MKA instance.
        Multiplicity:       1
        Type:               EcucEnumerationParamDef
        Range:              MKA_KEY_SERVER
                            MKA_PEER
                            MKA_KEY_SERVER_PRIORITY_BASED
        Default value:      None
        Value Configuration Class:
          Pre-compile time: X All Variants
          Link time:        - -
          Post-build time:  - -
        Scope / Dependency: scope: local
      </description>
      <comment>
        MKA_KEY_SERVER_PRIORITY_BASED enumeration is added to indicate that key server shall be elected based on exchanged key server
        priority fields, as defined in IEEE 802.1X document.
      </comment>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_498</srcid><srcstatus/><internalId>840</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.ECUC_Mka_00029</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>439</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>440</internalId></specobject>

    <specobject>
      <id>Mka.ECUC_Mka_00031</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Name:               MkaSrcMacAddress
        Parent Container:   MkaKay
        Description:        Source MAC address to use by the MKA instance.
        Multiplicity:       1
        Type:               EcucStringParamDef
        Default value:      None
        Regular Expression: None
        Value Configuration Class:
          Pre-compile time: X All Variants
          Link time:        - -
          Post-build time:  - -
        Scope / Dependency: scope: local
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_438</srcid><srcstatus/><internalId>838</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.PostBuild</srcid><srcstatus/><internalId>502</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>441</internalId></specobject>

<!-- ====================================[MkaKayParticipant]=================================== -->
    <specobject>
      <id>Mka.ECUC_Mka_00038</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Container Name:           MkaKayParticipant
        Parent Container:         MkaKay
        Description:              MKA participant configuration.
        Configuration Parameters: MkaParticipantActivate
                                  MkaCryptoAlgoRef
                                  MkaCryptoCknCakKeyRef
                                  MkaCryptoIckDeriveJobRef
                                  MkaCryptoIcvGenerateJobRef
                                  MkaCryptoIcvVerifyJobRef
                                  MkaCryptoKekDeriveJobRef
                                  MkaCryptoKeyUnwrapJobRef
                                  MkaCryptoKeyWrapJobRef
                                  MkaCryptoRandomJobRef
                                  MkaCryptoSakKeyRef
        Included Containers: None
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_534</srcid><srcstatus/><internalId>841</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.PostBuild</srcid><srcstatus/><internalId>502</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>442</internalId></specobject>

    <specobject>
      <id>Mka.ECUC_Mka_00049</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Name:               MkaParticipantActivate
        Parent Container:   MkaKayParticipant
        Description:        Enabled/Disabled status of the MKA participant.
                              - True = The MKA Participant exchanges MKPDUs.
                              - False = The MKA participant does not exchange MKPDUs.
        Multiplicity:       1
        Type:               EcucBooleanParamDef
        Default value:      FALSE
        Value Configuration Class:
          Pre-compile time: X All Variants
          Link time:        - -
          Post-build time:  - -
        Scope / Dependency: scope: local
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01015_StartPae</srcid><srcstatus/><internalId>2205</internalId></linkedfrom><linkedfrom><srcid>Mka_Logon_UnitTest01025_ManualPaeStart</srcid><srcstatus/><internalId>2215</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Logon.c_1772</srcid><srcstatus/><internalId>790</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_588</srcid><srcstatus/><internalId>843</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>443</internalId></specobject>

    <specobject>
      <id>Mka.ECUC_Mka_00048</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Name:               MkaCryptoAlgoRef
        Parent Container:   MkaKayParticipant
        Description:        Reference to the cryptography to use (MkaAlgoConfiguration Container).
        Multiplicity:       1
        Type:               Reference to MkaCryptoAlgoConfig
        Default value:      None
        Value Configuration Class:
          Pre-compile time: X All Variants
          Link time:        - -
          Post-build time:  - -
        Scope / Dependency: scope: local
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_616</srcid><srcstatus/><internalId>844</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.PostBuild</srcid><srcstatus/><internalId>502</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>444</internalId></specobject>

    <specobject>
      <id>Mka.ECUC_Mka_00040</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Name:               MkaCryptoCknCakKeyRef
        Parent Container:   MkaKayParticipant
        Description:        Reference to the CKN (min. 1 and max. 32 characters) assigned to the KaY Participant in the CSM.
        Multiplicity:       1
        Type:               Symbolic name reference to CsmKey
        Default value:      None
        Value Configuration Class:
          Pre-compile time: X All Variants
          Link time:        - -
          Post-build time:  - -
        Scope / Dependency: scope: local
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.EB.ECUC_Mka_00040.Cak</srcid><srcstatus/><internalId>446</internalId></linkedfrom><linkedfrom><srcid>Mka.EB.ECUC_Mka_00040.Ckn</srcid><srcstatus/><internalId>447</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CakCknSplit</srcid><srcstatus/><internalId>503</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>445</internalId></specobject>

    <specobject>
      <id>Mka.EB.ECUC_Mka_00040.Cak</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Name:               MkaCryptoCakKeyRef
        Parent Container:   MkaKayParticipant
        Description:        Reference to the CAK assigned to the KaY Participant in the CSM.
        Multiplicity:       1
        Type:               Symbolic name reference to CsmKey
        Default value:      None
        Value Configuration Class:
          Pre-compile time: X All Variants
          Link time:        - -
          Post-build time:  - -
        Scope / Dependency: scope: local
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_643</srcid><srcstatus/><internalId>845</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.ECUC_Mka_00040</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>445</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>446</internalId></specobject>

    <specobject>
      <id>Mka.EB.ECUC_Mka_00040.Ckn</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Name:               MkaCryptoCknKeyRef
        Parent Container:   MkaKayParticipant
        Description:        Reference to the CKN (min. 1 and max. 32 characters) assigned to the KaY Participant in the CSM.
        Multiplicity:       1
        Type:               Symbolic name reference to CsmKey
        Default value:      None
        Value Configuration Class:
          Pre-compile time: X All Variants
          Link time:        - -
          Post-build time:  - -
        Scope / Dependency: scope: local
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_683</srcid><srcstatus/><internalId>848</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.ECUC_Mka_00040</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>445</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>447</internalId></specobject>

    <specobject>
      <id>Mka.ECUC_Mka_00042</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Name:               MkaCryptoIckDeriveJobRef
        Parent Container:   MkaKayParticipant
        Description:        Reference to a CSM job for ICK Derivation.
        Multiplicity:       1
        Type:               Symbolic name reference to CsmJob
        Default value:      None
        Value Configuration Class:
          Pre-compile time: X All Variants
          Link time:        - -
          Post-build time:  - -
        Scope / Dependency: scope: local
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_718</srcid><srcstatus/><internalId>849</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.PostBuild</srcid><srcstatus/><internalId>502</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>448</internalId></specobject>

    <specobject>
      <id>Mka.ECUC_Mka_00043</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Name:               MkaCryptoIcvGenerateJobRef
        Parent Container:   MkaKayParticipant
        Description:        Reference to a CSM job for ICV generation (according to IEEE_802.x ICV is always 128 bits).
        Multiplicity:       1
        Type:               Symbolic name reference to CsmJob
        Default value:      None
        Value Configuration Class:
          Pre-compile time: X All Variants
          Link time:        - -
          Post-build time:  - -
        Scope / Dependency: scope: local
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_755</srcid><srcstatus/><internalId>850</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.PostBuild</srcid><srcstatus/><internalId>502</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>449</internalId></specobject>

    <specobject>
      <id>Mka.ECUC_Mka_00044</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Name:               MkaCryptoIcvVerifyJobRef
        Parent Container:   MkaKayParticipant
        Description:        Reference to a CSM job for ICV verification (according to IEEE_802.x ICV is always 128 bits).
        Multiplicity:       1
        Type:               Symbolic name reference to CsmJob
        Default value:      None
        Value Configuration Class:
          Pre-compile time: X All Variants
          Link time:        - -
          Post-build time:  - -
        Scope / Dependency: scope: local
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_793</srcid><srcstatus/><internalId>851</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.PostBuild</srcid><srcstatus/><internalId>502</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>450</internalId></specobject>

    <specobject>
      <id>Mka.ECUC_Mka_00045</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Name:               MkaCryptoKekDeriveJobRef
        Parent Container:   MkaKayParticipant
        Description:        Reference to a CSM job for KEK Derivation.
                            (Note: CAK needs to be set as the KEK Derive job CsmJobKeyRef )
        Multiplicity:       1
        Type:               Symbolic name reference to CsmJob
        Default value:      None
        Value Configuration Class:
          Pre-compile time: X All Variants
          Link time:        - -
          Post-build time:  - -
        Scope / Dependency: scope: local
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_831</srcid><srcstatus/><internalId>852</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.PostBuild</srcid><srcstatus/><internalId>502</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>451</internalId></specobject>

    <specobject>
      <id>Mka.ECUC_Mka_00060</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Name:               MkaCryptoKeyUnwrapJobRef
        Parent Container:   MkaKayParticipant
        Description:        Reference to a CSM job for SAK unwrap (to perform the Decrypt part of RFC3394 ).
        Multiplicity:       1
        Type:               Symbolic name reference to CsmJob
        Default value:      None
        Value Configuration Class:
          Pre-compile time: X All Variants
          Link time:        - -
          Post-build time:  - -
        Scope / Dependency: scope: local
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_870</srcid><srcstatus/><internalId>853</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.PostBuild</srcid><srcstatus/><internalId>502</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>452</internalId></specobject>

    <specobject>
      <id>Mka.ECUC_Mka_00047</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Name:               MkaCryptoKeyWrapJobRef
        Parent Container:   MkaKayParticipant
        Description:        Reference to a CSM job for SAK wrap (to perform the Encrypt part of RFC3394 ).
        Multiplicity:       1
        Type:               Symbolic name reference to CsmJob
        Default value:      None
        Value Configuration Class:
          Pre-compile time: X All Variants
          Link time:        - -
          Post-build time:  - -
        Scope / Dependency: scope: local
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_907</srcid><srcstatus/><internalId>854</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.PostBuild</srcid><srcstatus/><internalId>502</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>453</internalId></specobject>

    <specobject>
      <id>Mka.ECUC_Mka_00041</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Name:               MkaCryptoRandomJobRef
        Parent Container:   MkaKayParticipant
        Description:        Reference to a CSM job for random number generation.
        Multiplicity:       1
        Type:               Symbolic name reference to CsmJob
        Default value:      None
        Value Configuration Class:
          Pre-compile time: X All Variants
          Link time:        - -
          Post-build time:  - -
        Scope / Dependency: scope: local
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_944</srcid><srcstatus/><internalId>855</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.PostBuild</srcid><srcstatus/><internalId>502</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>454</internalId></specobject>

    <specobject>
      <id>Mka.ECUC_Mka_00046</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Name:               MkaCryptoSakKeyRef
        Parent Container:   MkaKayParticipant
        Description:        Reference to a CSM key where SAK shall be stored.
        Multiplicity:       1
        Type:               Symbolic name reference to CsmKey
        Default value:      None
        Value Configuration Class:
          Pre-compile time: X All Variants
          Link time:        - -
          Post-build time:  - -
        Scope / Dependency: scope: local
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_977</srcid><srcstatus/><internalId>856</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.PostBuild</srcid><srcstatus/><internalId>502</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>455</internalId></specobject>

<!-- ===============================[MkaKayDemEventParameterRefs]=============================== -->
    <specobject>
      <id>Mka.ECUC_Mka_00055</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Container Name:           MkaKayDemEventParameterRefs
        Parent Container:         MkaKay
        Description:              Container for the references to DemEventParameter elements which shall be invoked
                                  using the API Dem_SetEventStatus in case the corresponding error occurs. The Event Id
                                  is taken from the referenced DemEventParameters DemEventId symbolic value.
                                  The standardized errors are provided in this container and can be extended by
                                  vendor-specific error references.
        Configuration Parameters: MKA_E_ALGO_MISMATCH_INSTANCE
                                  MKA_E_KEY_MISMATCH_INSTANCE
                                  MKA_E_KEY_NOT_PRESENT_INSTANCE
                                  MKA_E_TIMEOUT_INSTANCE
        Included Containers: None
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_1133</srcid><srcstatus/><internalId>860</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0118.ProductionErrors</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>970</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>456</internalId></specobject>

    <specobject>
      <id>Mka.ECUC_Mka_00059</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Name:                             MKA_E_ALGO_MISMATCH_INSTANCE
        Parent Container:                 MkaKayDemEventParameterRefs
        Description:                      Reference to the DemEventParameter which shall be issued when the MkaKay Instance does not
                                          successfully agree on MACsec keys and at least one MkaKay Participant does not support a
                                          common MACsec cipher suite.
        Multiplicity:                     0..1
        Type:                             Symbolic name reference to DemEventParameter
        Post-Build Variant Multiplicity:  FALSE
        Post-Build Variant Value:         FALSE
        Multiplicity Configuration Class:
          Pre-compile time: X All Variants
          Link time:        - -
          Post-build time:  - -
        Value Configuration Class:
          Pre-compile time: X All Variants
          Link time:        - -
          Post-build time:  - -
        Scope / Dependency: scope: local
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_1152</srcid><srcstatus/><internalId>861</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.PostBuild</srcid><srcstatus/><internalId>502</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0118.ProductionErrors</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>970</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>457</internalId></specobject>

    <specobject>
      <id>Mka.ECUC_Mka_00058</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Name:                             MKA_E_KEY_MISMATCH_INSTANCE
        Parent Container:                 MkaKayDemEventParameterRefs
        Description:                      Reference to the DemEventParameter which shall be issued when the MkaKay Instance does
                                          not successfully agree on MACsec keys and at least one exchange for this MkaKay Instance
                                          encounters an ICV validation failure.
        Multiplicity:                     0..1
        Type:                             Symbolic name reference to DemEventParameter
        Post-Build Variant Multiplicity:  FALSE
        Post-Build Variant Value:         FALSE
        Multiplicity Configuration Class:
          Pre-compile time: X All Variants
          Link time:        - -
          Post-build time:  - -
        Value Configuration Class:
          Pre-compile time: X All Variants
          Link time:        - -
          Post-build time:  - -
        Scope / Dependency: scope: local
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_1186</srcid><srcstatus/><internalId>864</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.PostBuild</srcid><srcstatus/><internalId>502</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0118.ProductionErrors</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>970</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>458</internalId></specobject>

    <specobject>
      <id>Mka.ECUC_Mka_00057</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Name:                             MKA_E_KEY_NOT_PRESENT_INSTANCE
        Parent Container:                 MkaKayDemEventParameterRefs
        Description:                      Reference to the DemEventParameter which shall be issued when the MkaKay Instance does
                                          not successfully agree on MACsec keys and at least one of the keys (CAK) for this MkaKay
                                          Instance is not present.
        Multiplicity:                     0..1
        Type:                             Symbolic name reference to DemEventParameter
        Post-Build Variant Multiplicity:  FALSE
        Post-Build Variant Value:         FALSE
        Multiplicity Configuration Class:
          Pre-compile time: X All Variants
          Link time:        - -
          Post-build time:  - -
        Value Configuration Class:
          Pre-compile time: X All Variants
          Link time:        - -
          Post-build time:  - -
        Scope / Dependency: scope: local
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_1220</srcid><srcstatus/><internalId>867</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.PostBuild</srcid><srcstatus/><internalId>502</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0118.ProductionErrors</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>970</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>459</internalId></specobject>

    <specobject>
      <id>Mka.ECUC_Mka_00056</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MACsec_R22-11</source>
      <version>1</version>
      <description>
        Name:                             MKA_E_TIMEOUT_INSTANCE
        Parent Container:                 MkaKayDemEventParameterRefs
        Description:                      Reference to the DemEventParameter which shall be issued when the MkaKay Instance does
                                          not successfully agree on MACsec keys and at least one exchange for this MkaKay Instance
                                          encounters a timeout.
        Multiplicity:                     0..1
        Type:                             Symbolic name reference to DemEventParameter
        Post-Build Variant Multiplicity:  FALSE
        Post-Build Variant Value:         FALSE
        Multiplicity Configuration Class:
          Pre-compile time: X All Variants
          Link time:        - -
          Post-build time:  - -
        Value Configuration Class:
          Pre-compile time: X All Variants
          Link time:        - -
          Post-build time:  - -
        Scope / Dependency: scope: local
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_1254</srcid><srcstatus/><internalId>870</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.PostBuild</srcid><srcstatus/><internalId>502</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0118.ProductionErrors</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>970</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>460</internalId></specobject>

  </specobjects>
    <specobjects doctype="man">
    <specobject>
      <id>Mka.EB.Manual.RAM_ROM_ConsumptionMonitoring</id>
      <status>approved</status>
      <source>EB manual test</source>
      <version>1</version>
      <description>
        Test Description:
        Check RAM and ROM consumption of a reference configuration and compare it against the
        limits.

        Test Precondition:

        Test Execution:
        All test steps are required to fulfil Mka.swdd.ROMMonitoring and
        Mka.swdd.RAMMonitoring.

        01: Execute conformance test Mka_ConTest02_ResourceConsumption on a lead platform.
        02: Execute script GetMemoryUsage.sh in tools/ according to the instructions at the top of the script.
        03: VP(): Check the output of the script. If the resource consumption is within limits, the script will return 0
            and 1 if resource consumption is above the set limit. If any of limit is not fulfilled the cause needs to be analyzed and justified.           
        04: Commit the changes to the *.map file and ResourceConsumption.txt in 
            ..\asc_Mka\test\ts5\Manual\Mka_ManTest01_ResourceConsumption\.
      </description>
      <providescoverage>
        <provcov>
          <linksto>Mka.swdd.RAMConsumption</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1257</internalId></provcov>
        <provcov>
          <linksto>Mka.swdd.RAMMonitoring</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1258</internalId></provcov>
        <provcov>
          <linksto>Mka.swdd.ROMConsumption</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1255</internalId></provcov>
        <provcov>
          <linksto>Mka.swdd.ROMMonitoring</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1256</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>461</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs">

  <!-- TODO add a hi-level feature requirement and link RFC requirements to it  -->

    <specobject>
      <id>Mka.rfc3394.Algorithms.Limitation</id>
      <status>rejected</status>
      <source>https://datatracker.ietf.org/doc/html/rfc3394#section-2</source>
      <version>1</version>
      <description>
        The AES key wrap algorithm is designed to wrap or encrypt key data.
        The key wrap operates on blocks of 64 bits.  Before being wrapped,
        the key data is parsed into n blocks of 64 bits.
        The only restriction the key wrap algorithm places on n is that n be
        at least two.
      </description>
      <comment>
        This requirement is informational only.
      </comment>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>462</internalId></specobject>

    <specobject>
      <id>Mka.rfc3394.Algorithms.Algorithm</id>
      <status>rejected</status>
      <source>https://datatracker.ietf.org/doc/html/rfc3394#section-2</source>
      <version>1</version>
      <description>
        The specification of the key wrap algorithm requires the use of the
        AES codebook [AES].
      </description>
      <comment>
        This requirement is informational only.
      </comment>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>463</internalId></specobject>

    <specobject>
      <id>Mka.rfc3394.KeyWrap.BlockSize</id>
      <status>approved</status>
      <source>https://datatracker.ietf.org/doc/html/rfc3394#section-2.2.1</source>
      <version>1</version>
      <description>
        The plaintext shall consist of n 64-bit blocks.
      </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01055_SakGenWrap_Rfc3394_Async128</srcid><srcstatus/><internalId>1959</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01056_SakGenWrap_Rfc3394_Sync128</srcid><srcstatus/><internalId>1960</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01057_SakGenWrap_Rfc3394_Async256</srcid><srcstatus/><internalId>1961</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01058_SakGenWrap_Rfc3394_Sync256</srcid><srcstatus/><internalId>1962</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>464</internalId></specobject>

    <specobject>
      <id>Mka.rfc3394.KeyWrap.Shifting</id>
      <status>rejected</status>
      <source>https://datatracker.ietf.org/doc/html/rfc3394#section-2.2.1</source>
      <version>1</version>
      <description>
        The key wrapping process:
          1) Initialize variables.

              Set A0 to an initial value
              For i = 1 to n
                   R[0][i] = P[i]

          2) Calculate intermediate values.

              For t = 1 to s, where s = 6n
                  A[t] = MSB(64, AES(K, A[t-1] | R[t-1][1])) ^ t
                  For i = 1 to n-1
                      R[t][i] = R[t-1][i+1]
                  R[t][n] = LSB(64, AES(K, A[t-1] | R[t-1][1]))

          3) Output the results.

              Set C[0] = A[t]
              For i = 1 to n
                  C[i] = R[t][i]
      </description>
      <comment>
        This requirement is informational only.
      </comment>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>465</internalId></specobject>

    <specobject>
      <id>Mka.rfc3394.KeyWrap.Indexing</id>
      <status>approved</status>
      <source>https://datatracker.ietf.org/doc/html/rfc3394#section-2.2.1</source>
      <version>1</version>
      <description>
        The key wrapping shall use the process described below.
          1) Initialize variables.

              Set A = IV, an initial value
              For i = 1 to n
                  R[i] = P[i]

          2) Calculate intermediate values.

              For j = 0 to 5
                  For i=1 to n
                      B = AES(K, A | R[i])
                      A = MSB(64, B) ^ t where t = (n*j)+i
                      R[i] = LSB(64, B)

          3) Output the results.

              Set C[0] = A
              For i = 1 to n
                  C[i] = R[i]
      </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.rfc3394.KeyWrap.Indexing.1</srcid><srcstatus/><internalId>467</internalId></linkedfrom><linkedfrom><srcid>Mka.rfc3394.KeyWrap.Indexing.2</srcid><srcstatus/><internalId>468</internalId></linkedfrom><linkedfrom><srcid>Mka.rfc3394.KeyWrap.Indexing.3</srcid><srcstatus/><internalId>469</internalId></linkedfrom><linkedfrom><srcid>Mka.rfc3394.KeyWrap.Indexing.4</srcid><srcstatus/><internalId>470</internalId></linkedfrom><linkedfrom><srcid>Mka.rfc3394.KeyWrap.Indexing.5</srcid><srcstatus/><internalId>471</internalId></linkedfrom><linkedfrom><srcid>Mka.rfc3394.KeyWrap.Indexing.6</srcid><srcstatus/><internalId>472</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>466</internalId></specobject>

    <specobject>
      <id>Mka.rfc3394.KeyWrap.Indexing.1</id>
      <status>approved</status>
      <source>https://datatracker.ietf.org/doc/html/rfc3394#section-2.2.1</source>
      <version>1</version>
      <description>
        Calculating intermediate values shall be done in the following way:

              For j = 0 to 5
                  For i=1 to n
                      B = AES(K, A | R[i])
                      A = MSB(64, B) ^ t where t = (n*j)+i
                      R[i] = LSB(64, B)
      </description>
      <comment>
        MSB(j, W)     Return the most significant j bits of W.
        LSB(j, W)     Return the least significant j bits of W.
        B1 ^ B2       The bitwise exclusive or (XOR) of B1 and B2.
      </comment>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01055_SakGenWrap_Rfc3394_Async128</srcid><srcstatus/><internalId>1959</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01056_SakGenWrap_Rfc3394_Sync128</srcid><srcstatus/><internalId>1960</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01057_SakGenWrap_Rfc3394_Async256</srcid><srcstatus/><internalId>1961</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01058_SakGenWrap_Rfc3394_Sync256</srcid><srcstatus/><internalId>1962</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.rfc3394.KeyWrap.Indexing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>466</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>467</internalId></specobject>

    <specobject>
      <id>Mka.rfc3394.KeyWrap.Indexing.2</id>
      <status>approved</status>
      <source>https://datatracker.ietf.org/doc/html/rfc3394#section-2.2.1</source>
      <version>1</version>
      <description>
        Notation n in the wrap algorithm shall represent the number of 64-bit key data blocks.
      </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01055_SakGenWrap_Rfc3394_Async128</srcid><srcstatus/><internalId>1959</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01056_SakGenWrap_Rfc3394_Sync128</srcid><srcstatus/><internalId>1960</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01057_SakGenWrap_Rfc3394_Async256</srcid><srcstatus/><internalId>1961</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01058_SakGenWrap_Rfc3394_Sync256</srcid><srcstatus/><internalId>1962</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.rfc3394.KeyWrap.Indexing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>466</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>468</internalId></specobject>

    <specobject>
      <id>Mka.rfc3394.KeyWrap.Indexing.3</id>
      <status>approved</status>
      <source>https://datatracker.ietf.org/doc/html/rfc3394#section-2.2.1</source>
      <version>1</version>
      <description>
        Notation K in the wrap algorithm shall represent key encryption key (KEK).
      </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01010_KekIckGen_Async128</srcid><srcstatus/><internalId>1914</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.rfc3394.KeyWrap.Indexing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>466</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>469</internalId></specobject>

    <specobject>
      <id>Mka.rfc3394.KeyWrap.Indexing.4</id>
      <status>approved</status>
      <source>https://datatracker.ietf.org/doc/html/rfc3394#section-2.2.1</source>
      <version>1</version>
      <description>
        For first iteration A shall be set to initial value.
      </description>
      <comment>
        Default initial value described in Mka.rfc3394.KeyDataIntegrity.DefaultInitialValue.
      </comment>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01055_SakGenWrap_Rfc3394_Async128</srcid><srcstatus/><internalId>1959</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01056_SakGenWrap_Rfc3394_Sync128</srcid><srcstatus/><internalId>1960</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01057_SakGenWrap_Rfc3394_Async256</srcid><srcstatus/><internalId>1961</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01058_SakGenWrap_Rfc3394_Sync256</srcid><srcstatus/><internalId>1962</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.rfc3394.KeyWrap.Indexing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>466</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>470</internalId></specobject>

    <specobject>
      <id>Mka.rfc3394.KeyWrap.Indexing.5</id>
      <status>approved</status>
      <source>https://datatracker.ietf.org/doc/html/rfc3394#section-2.2.1</source>
      <version>1</version>
      <description>
        For first iteration R value shall be set to the corresponding 64 bit value of the plaintext.
        R[i] = P[i]
      </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01055_SakGenWrap_Rfc3394_Async128</srcid><srcstatus/><internalId>1959</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01056_SakGenWrap_Rfc3394_Sync128</srcid><srcstatus/><internalId>1960</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01057_SakGenWrap_Rfc3394_Async256</srcid><srcstatus/><internalId>1961</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01058_SakGenWrap_Rfc3394_Sync256</srcid><srcstatus/><internalId>1962</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.rfc3394.KeyWrap.Indexing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>466</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>471</internalId></specobject>

    <specobject>
      <id>Mka.rfc3394.KeyWrap.Indexing.6</id>
      <status>approved</status>
      <source>https://datatracker.ietf.org/doc/html/rfc3394#section-2.2.1</source>
      <version>1</version>
      <description>
        The result of the wrap shall be Ciphertext defined as:
         C[0] = A
         C[i] = R[i]
      </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01057_SakGenWrap_Rfc3394_Async256</srcid><srcstatus/><internalId>1961</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.rfc3394.KeyWrap.Indexing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>466</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>472</internalId></specobject>

    <specobject>
      <id>Mka.rfc3394.KeyUnwrap.Shifting</id>
      <status>rejected</status>
      <source>https://datatracker.ietf.org/doc/html/rfc3394#section-2.2.2</source>
      <version>1</version>
      <description>
        The key Unwrapping process:
        1) Initialize variables.

             Set A[s] = C[0] where s = 6n
             For i = 1 to n
                 R[s][i] = C[i]

         2) Calculate the intermediate values.

             For t = s to 1
                 A[t-1] = MSB(64, AES-1(K, ((A[t] ^ t) | R[t][n]))
                 R[t-1][1] = LSB(64, AES-1(K, ((A[t]^t) | R[t][n]))
                 For i = 2 to n
                     R[t-1][i] = R[t][i-1]

         3) Output the results.

             If A[0] is an appropriate initial value,
             Then
                 For i = 1 to n
                     P[i] = R[0][i]
             Else
                 Return an error
      </description>
      <comment>
        This requirement is informational only.
      </comment>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>473</internalId></specobject>

    <specobject>
      <id>Mka.rfc3394.KeyUnwrap.Indexing</id>
      <status>approved</status>
      <source>https://datatracker.ietf.org/doc/html/rfc3394#section-2.2.2</source>
      <version>1</version>
      <description>
        The key Unwrapping shall use the process described below.
          1) Initialize variables.

              Set A = C[0]
              For i = 1 to n
                  R[i] = C[i]

          2) Compute intermediate values.

              For j = 5 to 0
                  For i = n to 1
                      B = AES-1(K, (A ^ t) | R[i]) where t = n*j+i
                      A = MSB(64, B)
                      R[i] = LSB(64, B)

          3) Output results.

          If A is an appropriate initial value,
          Then
              For i = 1 to n
                  P[i] = R[i]
      </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.rfc3394.KeyUnwrap.Indexing.1</srcid><srcstatus/><internalId>475</internalId></linkedfrom><linkedfrom><srcid>Mka.rfc3394.KeyUnwrap.Indexing.2</srcid><srcstatus/><internalId>476</internalId></linkedfrom><linkedfrom><srcid>Mka.rfc3394.KeyUnwrap.Indexing.3</srcid><srcstatus/><internalId>477</internalId></linkedfrom><linkedfrom><srcid>Mka.rfc3394.KeyUnwrap.Indexing.4</srcid><srcstatus/><internalId>478</internalId></linkedfrom><linkedfrom><srcid>Mka.rfc3394.KeyUnwrap.Indexing.5</srcid><srcstatus/><internalId>479</internalId></linkedfrom><linkedfrom><srcid>Mka.rfc3394.KeyUnwrap.Indexing.6</srcid><srcstatus/><internalId>480</internalId></linkedfrom><linkedfrom><srcid>Mka.rfc3394.KeyUnwrap.Indexing.7</srcid><srcstatus/><internalId>481</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>474</internalId></specobject>

    <specobject>
      <id>Mka.rfc3394.KeyUnwrap.Indexing.1</id>
      <status>approved</status>
      <source>https://datatracker.ietf.org/doc/html/rfc3394#section-2.2.2</source>
      <version>1</version>
      <description>
        Calculating intermediate values shall be done in the following way:

              For j = 5 to 0
                  For i = n to 1
                      B = AES-1(K, (A ^ t) | R[i]) where t = n*j+i
                      A = MSB(64, B)
                      R[i] = LSB(64, B)
      </description>
      <comment>
        MSB(j, W)     Return the most significant j bits of W.
        LSB(j, W)     Return the least significant j bits of W.
        B1 ^ B2       The bitwise exclusive or (XOR) of B1 and B2.
      </comment>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01059_SakUnwrap_Async128</srcid><srcstatus/><internalId>1963</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01060_SakUnwrap_Sync128</srcid><srcstatus/><internalId>1964</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.rfc3394.KeyUnwrap.Indexing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>474</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>475</internalId></specobject>

    <specobject>
      <id>Mka.rfc3394.KeyUnwrap.Indexing.2</id>
      <status>approved</status>
      <source>https://datatracker.ietf.org/doc/html/rfc3394#section-2.2.2</source>
      <version>1</version>
      <description>
        Notation n in the unwrap algorithm shall represent the number of 64-bit key data blocks.
      </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01059_SakUnwrap_Async128</srcid><srcstatus/><internalId>1963</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01060_SakUnwrap_Sync128</srcid><srcstatus/><internalId>1964</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.rfc3394.KeyUnwrap.Indexing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>474</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>476</internalId></specobject>

    <specobject>
      <id>Mka.rfc3394.KeyUnwrap.Indexing.3</id>
      <status>approved</status>
      <source>https://datatracker.ietf.org/doc/html/rfc3394#section-2.2.2</source>
      <version>1</version>
      <description>
        Notation K in the unwrap algorithm shall represent key encryption key (KEK).
      </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01010_KekIckGen_Async128</srcid><srcstatus/><internalId>1914</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.rfc3394.KeyUnwrap.Indexing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>474</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>477</internalId></specobject>

    <specobject>
      <id>Mka.rfc3394.KeyUnwrap.Indexing.4</id>
      <status>approved</status>
      <source>https://datatracker.ietf.org/doc/html/rfc3394#section-2.2.2</source>
      <version>1</version>
      <description>
        For first iteration A shall be set to first 64 bits of Ciphertext.
        A = C[0]
      </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01059_SakUnwrap_Async128</srcid><srcstatus/><internalId>1963</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01060_SakUnwrap_Sync128</srcid><srcstatus/><internalId>1964</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.rfc3394.KeyUnwrap.Indexing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>474</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>478</internalId></specobject>

    <specobject>
      <id>Mka.rfc3394.KeyUnwrap.Indexing.5</id>
      <status>approved</status>
      <source>https://datatracker.ietf.org/doc/html/rfc3394#section-2.2.2</source>
      <version>1</version>
      <description>
        For first iteration R value shall be set to the corresponding 64 bit value of the Ciphertext.
        R[i] = C[i]
      </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01059_SakUnwrap_Async128</srcid><srcstatus/><internalId>1963</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01060_SakUnwrap_Sync128</srcid><srcstatus/><internalId>1964</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.rfc3394.KeyUnwrap.Indexing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>474</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>479</internalId></specobject>

    <specobject>
      <id>Mka.rfc3394.KeyUnwrap.Indexing.6</id>
      <status>approved</status>
      <source>https://datatracker.ietf.org/doc/html/rfc3394#section-2.2.2</source>
      <version>1</version>
      <description>
        After the unwrap A shall be equal to the initial value.
      </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01059_SakUnwrap_Async128</srcid><srcstatus/><internalId>1963</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01060_SakUnwrap_Sync128</srcid><srcstatus/><internalId>1964</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.rfc3394.KeyUnwrap.Indexing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>474</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>480</internalId></specobject>

    <specobject>
      <id>Mka.rfc3394.KeyUnwrap.Indexing.7</id>
      <status>approved</status>
      <source>https://datatracker.ietf.org/doc/html/rfc3394#section-2.2.2</source>
      <version>1</version>
      <description>
        If correct initial value was recovered the key shall be specified as:
        For i = 1 to n
           P[i] = R[i]
      </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01059_SakUnwrap_Async128</srcid><srcstatus/><internalId>1963</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01060_SakUnwrap_Sync128</srcid><srcstatus/><internalId>1964</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.rfc3394.KeyUnwrap.Indexing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>474</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>481</internalId></specobject>

    <specobject>
      <id>Mka.rfc3394.KeyDataIntegrity.InitialValue</id>
      <status>approved</status>
      <source>https://datatracker.ietf.org/doc/html/rfc3394#section-2.2.3</source>
      <version>1</version>
      <description>
        The initial value (IV) refers to the value assigned to A[0] in the
        first step of the wrapping process. This value shall be used to obtain an
        integrity check on the key data.
      </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01055_SakGenWrap_Rfc3394_Async128</srcid><srcstatus/><internalId>1959</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01059_SakUnwrap_Async128</srcid><srcstatus/><internalId>1963</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01060_SakUnwrap_Sync128</srcid><srcstatus/><internalId>1964</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>482</internalId></specobject>

    <specobject>
      <id>Mka.rfc3394.KeyDataIntegrity.Match</id>
      <status>approved</status>
      <source>https://datatracker.ietf.org/doc/html/rfc3394#section-2.2.3</source>
      <version>1</version>
      <description>
        In the final step of the unwrapping process, the recovered value of A[0] shall
        be compared to the expected value of A[0].
        If there is a match, the key shall be accepted as valid.
      </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01059_SakUnwrap_Async128</srcid><srcstatus/><internalId>1963</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01060_SakUnwrap_Sync128</srcid><srcstatus/><internalId>1964</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>483</internalId></specobject>

    <specobject>
      <id>Mka.rfc3394.KeyDataIntegrity.NoMatch</id>
      <status>approved</status>
      <source>https://datatracker.ietf.org/doc/html/rfc3394#section-2.2.3</source>
      <version>1</version>
      <description>
        If the unwrapped value A[0] does not match the expected value
        the unwrapping algorithm shall return an error.
      </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01064_SakUnwrap_Async128_NoMatch</srcid><srcstatus/><internalId>1968</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>484</internalId></specobject>

    <specobject>
      <id>Mka.rfc3394.KeyDataIntegrity.DefaultInitialValue</id>
      <status>approved</status>
      <source>https://datatracker.ietf.org/doc/html/rfc3394#section-2.2.3.1</source>
      <version>1</version>
      <description>
        The default initial value (IV) shall be the hexadecimal constant:
            A[0] = IV = A6A6A6A6A6A6A6A6
      </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01055_SakGenWrap_Rfc3394_Async128</srcid><srcstatus/><internalId>1959</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>485</internalId></specobject>

    <specobject>
      <id>Mka.rfc3394.KeyDataIntegrity.AlternativeInitialValues</id>
      <status>rejected</status>
      <source>https://datatracker.ietf.org/doc/html/rfc3394#section-2.2.3.2</source>
      <version>1</version>
      <description>
        NIST will define alternative initial values in future key management publications as needed.
      </description>
      <comment>
        This requirement is informational only.
      </comment>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>486</internalId></specobject>

  </specobjects>
    <specobjects doctype="dev">
    <specobject>
      <id>dev.Mka.ParameterSetNotSupported</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>12</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.28.5</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>82</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.Eapol.29.2.4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>89</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.Eapol.29.2.5</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>90</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>487</internalId></specobject>
    <specobject>
      <id>dev.Mka.SingleEapolMkaGroupAddressSupported</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>31</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>32</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>488</internalId></specobject>
    <specobject>
      <id>dev.Mka.PointToPointOnly</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>51</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.MkaTransport.19</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>173</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.MkaTransport.20</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>175</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.19</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>215</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.45</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>251</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.63</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>276</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.69</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>282</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.Eapol.30</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>94</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.76</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>288</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>489</internalId></specobject>
    <specobject>
      <id>dev.MkaSuspensionNotSupported</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>70</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.45</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>251</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.MkaParticipantTimerValues.6</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>101</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>490</internalId></specobject>
    <specobject>
      <id>dev.TypeDefinitionChange</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>87</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_91027</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>372</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>491</internalId></specobject>
    <specobject>
      <id>dev.Mka.EapTlsNotSupported</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>106</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>195</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.14</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>210</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.MkaKeyHierarchy.2.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>107</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.MkaKeyHierarchy.19</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>139</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.MkaKeyHierarchy.20</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>141</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.MkaKeyHierarchy.21</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>142</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.MkaKeyHierarchy.22</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>143</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.MkaKeyHierarchy.24</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>145</internalId></provcov>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00016</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>327</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>492</internalId></specobject>
    <specobject>
      <id>dev.Mka.EapMkaOnlyVer3</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>130</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.9</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>51</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>493</internalId></specobject>
    <specobject>
      <id>dev.Mka.SakKdfGenerationNotSupported</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>146</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00007.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>306</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>494</internalId></specobject>
    <specobject>
      <id>dev.Mka.PassiveParticipantsNotSupported</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>162</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.MkaParticipantTimerValues.4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>99</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.MkaTransport.32</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>193</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>495</internalId></specobject>
    <specobject>
      <id>dev.Mka.InterfaceUpdate</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>191</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_91006</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>398</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>496</internalId></specobject>
    <specobject>
      <id>dev.KekDerivatedAfterFirstMkpduTransmission</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>208</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00006</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>303</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>497</internalId></specobject>
    <specobject>
      <id>doc/public/changelog/Deviations.xml_227</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>227</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.ECUC_Mka_00011</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>429</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>498</internalId></specobject>
    <specobject>
      <id>doc/public/changelog/Deviations.xml_228</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>228</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.ECUC_Mka_00037</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>411</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>499</internalId></specobject>
    <specobject>
      <id>dev.ReducedRange</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>229</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.ECUC_Mka_00053</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>417</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>500</internalId></specobject>
    <specobject>
      <id>dev.MkaConfigSet</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>246</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.ECUC_Mka_00001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>401</internalId></provcov>
        <provcov>
          <linksto>Mka.ECUC_Mka_00002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>402</internalId></provcov>
        <provcov>
          <linksto>Mka.ECUC_Mka_00033</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>409</internalId></provcov>
        <provcov>
          <linksto>Mka.ECUC_Mka_00021</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>416</internalId></provcov>
        <provcov>
          <linksto>Mka.ECUC_Mka_00003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>426</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>501</internalId></specobject>
    <specobject>
      <id>dev.PostBuild</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>282</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.ECUC_Mka_00003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>426</internalId></provcov>
        <provcov>
          <linksto>Mka.ECUC_Mka_00011</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>429</internalId></provcov>
        <provcov>
          <linksto>Mka.ECUC_Mka_00018</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>427</internalId></provcov>
        <provcov>
          <linksto>Mka.ECUC_Mka_00013</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>431</internalId></provcov>
        <provcov>
          <linksto>Mka.ECUC_Mka_00054</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>432</internalId></provcov>
        <provcov>
          <linksto>Mka.ECUC_Mka_00014</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>433</internalId></provcov>
        <provcov>
          <linksto>Mka.ECUC_Mka_00016</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>435</internalId></provcov>
        <provcov>
          <linksto>Mka.ECUC_Mka_00015</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>436</internalId></provcov>
        <provcov>
          <linksto>Mka.ECUC_Mka_00032</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>437</internalId></provcov>
        <provcov>
          <linksto>Mka.ECUC_Mka_00031</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>441</internalId></provcov>
        <provcov>
          <linksto>Mka.ECUC_Mka_00022</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>438</internalId></provcov>
        <provcov>
          <linksto>Mka.ECUC_Mka_00029</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>439</internalId></provcov>
        <provcov>
          <linksto>Mka.ECUC_Mka_00038</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>442</internalId></provcov>
        <provcov>
          <linksto>Mka.ECUC_Mka_00048</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>444</internalId></provcov>
        <provcov>
          <linksto>Mka.ECUC_Mka_00042</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>448</internalId></provcov>
        <provcov>
          <linksto>Mka.ECUC_Mka_00043</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>449</internalId></provcov>
        <provcov>
          <linksto>Mka.ECUC_Mka_00044</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>450</internalId></provcov>
        <provcov>
          <linksto>Mka.ECUC_Mka_00045</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>451</internalId></provcov>
        <provcov>
          <linksto>Mka.ECUC_Mka_00060</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>452</internalId></provcov>
        <provcov>
          <linksto>Mka.ECUC_Mka_00047</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>453</internalId></provcov>
        <provcov>
          <linksto>Mka.ECUC_Mka_00041</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>454</internalId></provcov>
        <provcov>
          <linksto>Mka.ECUC_Mka_00046</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>455</internalId></provcov>
        <provcov>
          <linksto>Mka.ECUC_Mka_00059</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>457</internalId></provcov>
        <provcov>
          <linksto>Mka.ECUC_Mka_00058</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>458</internalId></provcov>
        <provcov>
          <linksto>Mka.ECUC_Mka_00057</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>459</internalId></provcov>
        <provcov>
          <linksto>Mka.ECUC_Mka_00056</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>460</internalId></provcov>
        <provcov>
          <linksto>Mka.ECUC_Mka_00033</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>409</internalId></provcov>
        <provcov>
          <linksto>Mka.ECUC_Mka_00037</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>411</internalId></provcov>
        <provcov>
          <linksto>Mka.ECUC_Mka_00021</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>416</internalId></provcov>
        <provcov>
          <linksto>Mka.ECUC_Mka_00053</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>417</internalId></provcov>
        <provcov>
          <linksto>Mka.ECUC_Mka_00025</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>419</internalId></provcov>
        <provcov>
          <linksto>Mka.ECUC_Mka_00026</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>420</internalId></provcov>
        <provcov>
          <linksto>Mka.ECUC_Mka_00050</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>423</internalId></provcov>
        <provcov>
          <linksto>Mka.ECUC_Mka_00052</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>424</internalId></provcov>
        <provcov>
          <linksto>Mka.ECUC_Mka_00051</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>425</internalId></provcov>
        <provcov>
          <linksto>Mka.ECUC_Mka_00028</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>422</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>502</internalId></specobject>
    <specobject>
      <id>dev.CakCknSplit</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>312</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.ECUC_Mka_00040</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>445</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>503</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/include/Mka.h_19</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/include/Mka.h</sourcefile>
      <sourceline>19</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_91005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>361</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>504</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/Mka.h_76</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/include/Mka.h</sourcefile>
      <sourceline>76</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_91014</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>376</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>505</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/Mka.h_92</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/include/Mka.h</sourcefile>
      <sourceline>92</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_91031</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>393</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>506</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/Mka.h_98</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/include/Mka.h</sourcefile>
      <sourceline>98</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_91032</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>394</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>507</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/Mka.h_104</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/include/Mka.h</sourcefile>
      <sourceline>104</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_91033</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>395</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>508</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/include/Mka_Int.h_18</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/include/Mka_Int.h</sourcefile>
      <sourceline>18</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_91005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>361</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>509</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/Mka_Int.h_38</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/include/Mka_Int.h</sourcefile>
      <sourceline>38</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_91007</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>400</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>510</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/Mka_Int.h_357</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/include/Mka_Int.h</sourcefile>
      <sourceline>357</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.RunTimeEvent.TriggeredEventParticipant</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1479</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>511</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/Mka_Int.h_365</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/include/Mka_Int.h</sourcefile>
      <sourceline>365</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.RunTimeEvent.TriggeredEventPae</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1480</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>512</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/Mka_Int.h_373</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/include/Mka_Int.h</sourcefile>
      <sourceline>373</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.RunTimeEvent.BitFieldDefinition</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1478</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>513</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/include/Mka_Types.h_41</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/include/Mka_Types.h</sourcefile>
      <sourceline>41</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.MkaReportEventCallout_EventType</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1477</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>514</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/Mka_Types.h_71</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/include/Mka_Types.h</sourcefile>
      <sourceline>71</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_91004</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>363</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>515</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/Mka_Types.h_74</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/include/Mka_Types.h</sourcefile>
      <sourceline>74</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_91003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>364</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>516</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/Mka_Types.h_79</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/include/Mka_Types.h</sourcefile>
      <sourceline>79</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_91025</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>373</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>517</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/Mka_Types.h_82</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/include/Mka_Types.h</sourcefile>
      <sourceline>82</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_91002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>362</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>518</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/Mka_Types.h_98</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/include/Mka_Types.h</sourcefile>
      <sourceline>98</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_91008</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>365</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>519</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/Mka_Types.h_107</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/include/Mka_Types.h</sourcefile>
      <sourceline>107</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_91010</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>366</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>520</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/Mka_Types.h_120</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/include/Mka_Types.h</sourcefile>
      <sourceline>120</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_91009</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>367</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>521</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/Mka_Types.h_127</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/include/Mka_Types.h</sourcefile>
      <sourceline>127</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_91011</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>368</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>522</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/Mka_Types.h_145</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/include/Mka_Types.h</sourcefile>
      <sourceline>145</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_91028</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>371</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>523</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/Mka_Types.h_154</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/include/Mka_Types.h</sourcefile>
      <sourceline>154</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_91027</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>372</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>524</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/Mka_Types.h_167</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/include/Mka_Types.h</sourcefile>
      <sourceline>167</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.MkaReportEventCallout_EventType</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1477</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>525</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/Mka_Types.h_170</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/include/Mka_Types.h</sourcefile>
      <sourceline>170</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.MkaReportEventCallout_Prototype</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1476</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>526</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/src/EcuC_Timers.c_45</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/EcuC_Timers.c</sourcefile>
      <sourceline>45</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EcuC_Timers.dsn.Api.InitTimerHandler</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>7</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>527</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/EcuC_Timers.c_97</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/EcuC_Timers.c</sourcefile>
      <sourceline>97</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EcuC_Timers.dsn.Api.ProcessTimerTimeout</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>27</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>528</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/EcuC_Timers.c_173</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/EcuC_Timers.c</sourcefile>
      <sourceline>173</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EcuC_Timers.dsn.Api.StopTimer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>15</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>529</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/EcuC_Timers.c_199</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/EcuC_Timers.c</sourcefile>
      <sourceline>199</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EcuC_Timers.dsn.Api.PauseTimer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>18</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>530</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/EcuC_Timers.c_226</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/EcuC_Timers.c</sourcefile>
      <sourceline>226</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EcuC_Timers.dsn.Api.ResumeTimer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>21</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>531</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/EcuC_Timers.c_268</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/EcuC_Timers.c</sourcefile>
      <sourceline>268</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EcuC_Timers.dsn.Api.IsTimerStarted</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>24</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>532</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/src/EcuC_Timers.h_144</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/EcuC_Timers.h</sourcefile>
      <sourceline>144</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EcuC_Timers.dsn.Api.StartTimer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>9</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>533</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/EcuC_Timers.h_161</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/EcuC_Timers.h</sourcefile>
      <sourceline>161</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EcuC_Timers.dsn.Api.StartTimerAutorepeat</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>12</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>534</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/src/Mka_Cp.c_1038</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Cp.c</sourcefile>
      <sourceline>1038</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.Api.Init</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1010</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>535</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Cp.c_1061</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Cp.c</sourcefile>
      <sourceline>1061</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.Api.MainFunction</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1011</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>536</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Cp.c_1082</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Cp.c</sourcefile>
      <sourceline>1082</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.Api.NewSak</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1012</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>537</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Cp.c_1149</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Cp.c</sourcefile>
      <sourceline>1149</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.77</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>289</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>538</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Cp.c_1150</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Cp.c</sourcefile>
      <sourceline>1150</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.Api.FillSakUse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1015</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>539</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Cp.c_1253</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Cp.c</sourcefile>
      <sourceline>1253</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.Api.FillXpn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1016</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>540</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Cp.c_1298</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Cp.c</sourcefile>
      <sourceline>1298</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.Api.DisableMacSec</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1017</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>541</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Cp.c_1332</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Cp.c</sourcefile>
      <sourceline>1332</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.Api.LinkStateDown</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1018</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>542</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Cp.c_1398</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Cp.c</sourcefile>
      <sourceline>1398</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.Api.SetCipherSuite</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1019</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>543</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Cp.c_1443</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Cp.c</sourcefile>
      <sourceline>1443</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.41</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>244</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>544</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Cp.c_1444</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Cp.c</sourcefile>
      <sourceline>1444</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.42</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>245</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>545</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Cp.c_1445</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Cp.c</sourcefile>
      <sourceline>1445</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00014.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>324</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>546</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Cp.c_1446</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Cp.c</sourcefile>
      <sourceline>1446</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.Api.CheckAllReceivingServerTransmittingPlainText</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1014</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>547</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Cp.c_1469</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Cp.c</sourcefile>
      <sourceline>1469</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.KeyServerElection.46</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>256</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>548</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Cp.c_1525</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Cp.c</sourcefile>
      <sourceline>1525</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.Api.ProcessSakUse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1013</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>549</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Cp.c_1570</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Cp.c</sourcefile>
      <sourceline>1570</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.Retry.NotRequired</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1498</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>550</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Cp.c_1571</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Cp.c</sourcefile>
      <sourceline>1571</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.PacketNumber.UpdateLPn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1502</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>551</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Cp.c_1603</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Cp.c</sourcefile>
      <sourceline>1603</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.Api.MacSecUpdateSecYNotification</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1023</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>552</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Cp.c_1621</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Cp.c</sourcefile>
      <sourceline>1621</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.Api.MacSecAddTxSaNotification</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1024</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>553</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Cp.c_1643</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Cp.c</sourcefile>
      <sourceline>1643</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.Api.MacSecAddRxSaNotification</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1025</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>554</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Cp.c_1669</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Cp.c</sourcefile>
      <sourceline>1669</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.Api.TransmitWhen</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1020</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>555</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Cp.c_1691</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Cp.c</sourcefile>
      <sourceline>1691</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.Api.RetireWhen</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1021</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>556</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Cp.c_1713</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Cp.c</sourcefile>
      <sourceline>1713</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.Api.DelayMacSecOperational</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1022</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>557</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Cp.c_1738</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Cp.c</sourcefile>
      <sourceline>1738</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.ECUC_Mka_00027</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>421</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>558</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Cp.c_1739</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Cp.c</sourcefile>
      <sourceline>1739</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.ECUC_Mka_00028</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>422</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>559</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Cp.c_1893</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Cp.c</sourcefile>
      <sourceline>1893</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.ImmediatePeerResponse.EmptySakUse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1505</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>560</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Cp.c_1978</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Cp.c</sourcefile>
      <sourceline>1978</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.Net_Sec_2158</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1484</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>561</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Cp.c_2396</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Cp.c</sourcefile>
      <sourceline>2396</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.DisableSAsBeforeDelete</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1504</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>562</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Cp.c_2428</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Cp.c</sourcefile>
      <sourceline>2428</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.DisableSAsBeforeDelete</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1504</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>563</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Cp.c_2459</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Cp.c</sourcefile>
      <sourceline>2459</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.DisableSAsBeforeDelete</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1504</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>564</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Cp.c_2490</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Cp.c</sourcefile>
      <sourceline>2490</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.DisableSAsBeforeDelete</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1504</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>565</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Cp.c_2722</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Cp.c</sourcefile>
      <sourceline>2722</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.ExtendedPacketNumber.Salt</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1489</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>566</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Cp.c_2834</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Cp.c</sourcefile>
      <sourceline>2834</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.ExtendedPacketNumber.Salt.Calculation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1490</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>567</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Cp.c_2890</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Cp.c</sourcefile>
      <sourceline>2890</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.41</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>244</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>568</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Cp.c_2917</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Cp.c</sourcefile>
      <sourceline>2917</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.ExtendedPacketNumber.PnRecovery</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1492</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>569</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Cp.c_2918</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Cp.c</sourcefile>
      <sourceline>2918</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.ExtendedPacketNumber.XPN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1491</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>570</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/src/Mka_Crypto.c_149</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Crypto.c</sourcefile>
      <sourceline>149</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.Init</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1026</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>571</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Crypto.c_203</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Crypto.c</sourcefile>
      <sourceline>203</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.MainFunction</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1027</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>572</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Crypto.c_221</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Crypto.c</sourcefile>
      <sourceline>221</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.ValidateKeys.Retry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1560</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>573</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Crypto.c_329</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Crypto.c</sourcefile>
      <sourceline>329</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.Stop</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1028</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>574</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Crypto.c_344</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Crypto.c</sourcefile>
      <sourceline>344</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.FindParticipant</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1037</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>575</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Crypto.c_376</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Crypto.c</sourcefile>
      <sourceline>376</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.CopyCkn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1038</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>576</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Crypto.c_399</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Crypto.c</sourcefile>
      <sourceline>399</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.GetCknPtr</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1039</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>577</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Crypto.c_622</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Crypto.c</sourcefile>
      <sourceline>622</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00005.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>302</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>578</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Crypto.c_683</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Crypto.c</sourcefile>
      <sourceline>683</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.ValidateCAK</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1558</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>579</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Crypto.c_706</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Crypto.c</sourcefile>
      <sourceline>706</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.CacheCkn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1556</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>580</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Crypto.c_731</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Crypto.c</sourcefile>
      <sourceline>731</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.ValidatePresharedIckKek</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1557</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>581</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Crypto.c_740</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Crypto.c</sourcefile>
      <sourceline>740</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.ValidatePresharedIckKek</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1557</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>582</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Crypto.c_755</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Crypto.c</sourcefile>
      <sourceline>755</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.ValidateKeys.Retry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1560</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>583</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Crypto.c_778</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Crypto.c</sourcefile>
      <sourceline>778</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.ValidateKeys.RetryDisabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1561</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>584</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/src/Mka_Crypto_Icv.c_49</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Crypto_Icv.c</sourcefile>
      <sourceline>49</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.IcvVerifyAsync</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1034</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>585</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Crypto_Icv.c_82</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Crypto_Icv.c</sourcefile>
      <sourceline>82</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.IcvGenerateAsync</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1035</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>586</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Crypto_Icv.c_121</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Crypto_Icv.c</sourcefile>
      <sourceline>121</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Api.CsmIcvGenerateCallback</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>980</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>587</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Crypto_Icv.c_159</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Crypto_Icv.c</sourcefile>
      <sourceline>159</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Api.CsmIcvVerifyCallback</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>982</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>588</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/src/Mka_Crypto_KeyGen.c_120</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Crypto_KeyGen.c</sourcefile>
      <sourceline>120</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.IckGenerateAsync</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1030</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>589</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Crypto_KeyGen.c_145</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Crypto_KeyGen.c</sourcefile>
      <sourceline>145</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.KekGenerateAsync</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1031</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>590</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Crypto_KeyGen.c_189</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Crypto_KeyGen.c</sourcefile>
      <sourceline>189</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Api.CsmKeyGenerateCallback</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>979</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>591</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/src/Mka_Crypto_KeyWrap.c_108</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Crypto_KeyWrap.c</sourcefile>
      <sourceline>108</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.SakGenWrapAsync</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1032</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>592</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Crypto_KeyWrap.c_143</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Crypto_KeyWrap.c</sourcefile>
      <sourceline>143</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.SakUnwrapAsync</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1033</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>593</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Crypto_KeyWrap.c_189</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Crypto_KeyWrap.c</sourcefile>
      <sourceline>189</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Api.CsmKeyWrapCallback</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>983</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>594</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Crypto_KeyWrap.c_230</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Crypto_KeyWrap.c</sourcefile>
      <sourceline>230</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Api.CsmKeyUnwrapCallback</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>984</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>595</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Crypto_KeyWrap.c_271</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Crypto_KeyWrap.c</sourcefile>
      <sourceline>271</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Api.CsmHashGenerateCallback</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>981</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>596</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/src/Mka_Crypto_Rng.c_28</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Crypto_Rng.c</sourcefile>
      <sourceline>28</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.RandomGenerateAsync</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1036</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>597</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Crypto_Rng.c_96</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Crypto_Rng.c</sourcefile>
      <sourceline>96</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Api.CsmRandomCallback</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>978</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>598</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Crypto_Rng.c_143</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Crypto_Rng.c</sourcefile>
      <sourceline>143</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.RandomGenerate.CsmGranularity</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1537</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>599</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Crypto_Rng.c_310</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Crypto_Rng.c</sourcefile>
      <sourceline>310</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.RandomGenerate.CsmGranularity</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1537</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>600</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/src/Mka_Ext.c.m4_235</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Ext.c.m4</sourcefile>
      <sourceline>235</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Api.HandleEvents</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>988</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>601</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Ext.c.m4_306</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Ext.c.m4</sourcefile>
      <sourceline>306</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_91031</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>393</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>602</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Ext.c.m4_335</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Ext.c.m4</sourcefile>
      <sourceline>335</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_91032</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>394</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>603</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Ext.c.m4_367</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Ext.c.m4</sourcefile>
      <sourceline>367</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_91033</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>395</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>604</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Ext.c.m4_399</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Ext.c.m4</sourcefile>
      <sourceline>399</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_91015</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>377</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>605</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Ext.c.m4_440</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Ext.c.m4</sourcefile>
      <sourceline>440</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_91016</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>379</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>606</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Ext.c.m4_485</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Ext.c.m4</sourcefile>
      <sourceline>485</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_91020</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>380</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>607</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Ext.c.m4_516</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Ext.c.m4</sourcefile>
      <sourceline>516</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_91017</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>382</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>608</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Ext.c.m4_551</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Ext.c.m4</sourcefile>
      <sourceline>551</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_91018</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>383</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>609</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Ext.c.m4_587</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Ext.c.m4</sourcefile>
      <sourceline>587</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_91021</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>384</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>610</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Ext.c.m4_618</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Ext.c.m4</sourcefile>
      <sourceline>618</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_91022</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>386</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>611</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Ext.c.m4_679</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Ext.c.m4</sourcefile>
      <sourceline>679</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Mka.GetMacSecStatistics</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1455</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>612</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Ext.c.m4_683</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Ext.c.m4</sourcefile>
      <sourceline>683</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.CP_SWS_Mka_91006</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>399</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>613</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Ext.c.m4_754</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Ext.c.m4</sourcefile>
      <sourceline>754</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Mka.GetMacSecStatisticsNotification</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1456</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>614</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Ext.c.m4_799</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Ext.c.m4</sourcefile>
      <sourceline>799</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Api.EnableMacSec</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>985</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>615</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Ext.c.m4_813</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Ext.c.m4</sourcefile>
      <sourceline>813</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.MacSecEnabledStatus</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1590</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>616</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Ext.c.m4_820</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Ext.c.m4</sourcefile>
      <sourceline>820</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Api.DisableMacSec</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>986</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>617</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Ext.c.m4_834</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Ext.c.m4</sourcefile>
      <sourceline>834</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.MacSecEnabledStatus</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1590</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>618</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Ext.c.m4_841</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Ext.c.m4</sourcefile>
      <sourceline>841</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Api.GetMacSecEnabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>987</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>619</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_7</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>7</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.CP_SWS_Mka_91006</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>399</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>620</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_892</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>892</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.Api.Init</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>989</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>621</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_927</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>927</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.Api.CreateParticipant</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>990</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>622</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_959</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>959</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.Api.DeleteParticipant</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>991</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>623</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_975</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>975</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.Api.SetPrincipalActor</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>992</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>624</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_993</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>993</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.MacSecDisabled.NoKeysNoSc</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1592</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>625</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_996</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>996</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.65</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>278</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>626</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_1009</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>1009</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.Api.RandomGenerateFinished</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>996</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>627</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_1055</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>1055</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.Rekeying.KeyServerChangesMi</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1593</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>628</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_1079</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>1079</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.Api.KekGenerateFinished</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>999</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>629</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_1093</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>1093</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.65</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>278</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>630</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_1097</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>1097</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.12</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>208</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>631</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_1121</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>1121</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.Api.SakUnwrapFinished</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>997</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>632</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_1161</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>1161</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.Api.SakGenWrapFinished</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>998</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>633</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_1181</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>1181</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.KeyServerElection.60</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>273</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>634</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_1185</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>1185</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.38</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>241</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>635</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_1213</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>1213</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.Api.RxMkpdu</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1000</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>636</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_1231</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>1231</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.RestartPermissiveModeTimerOnFirstMkpdu</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1448</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>637</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_1243</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>1243</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.MkaTransport.15</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>167</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>638</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_1265</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>1265</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.Api.NewInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1001</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>639</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_1286</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>1286</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.Api.TimerCallback_TxMkpdu</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1002</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>640</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_1326</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>1326</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.Api.TimerCallback_PeerLifeTimeout</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1003</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>641</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_1347</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>1347</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.Api.TimerCallback_NewSakDelay</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1004</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>642</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_1371</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>1371</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.Api.TimerCallback_MkaSakRekeyTimeSpan</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1005</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>643</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_1372</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>1372</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00013</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>322</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>644</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_1393</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>1393</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.41</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>244</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>645</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_1394</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>1394</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.42</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>245</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>646</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_1395</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>1395</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00014.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>324</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>647</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_1396</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>1396</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.Api.PnExhausted</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1006</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>648</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_1418</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>1418</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.Api.AllReceiving</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1007</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>649</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_1440</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>1440</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.Api.PeerPlainText</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1009</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>650</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_1463</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>1463</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.Api.LinkStateActive</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>993</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>651</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_1487</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>1487</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.Api.GetConnectionStatus</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>994</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>652</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_1520</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>1520</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.Api.GetCknPeerSci</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>995</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>653</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_1540</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>1540</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.Api.SendQueuedMkpdus</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1008</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>654</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_1567</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>1567</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.MacSecDesired.Discard</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1591</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>655</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_1617</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>1617</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.28.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>78</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>656</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_1618</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>1618</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.KeyServerElection.27.2</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>227</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>657</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_1619</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>1619</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.KeyServerElection.27.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>225</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>658</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_1620</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>1620</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.4.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>199</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>659</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_1692</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>1692</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.28.3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>80</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>660</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_1723</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>1723</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.30</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>94</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>661</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_1724</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>1724</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.Eapol.30</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>95</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>662</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_1733</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>1733</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.28.4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>81</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>663</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_1749</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>1749</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.37</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>240</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>664</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_1750</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>1750</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.38</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>241</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>665</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_1751</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>1751</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.58.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>269</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>666</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_1752</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>1752</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.58.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>270</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>667</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_1753</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>1753</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.61</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>274</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>668</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_1754</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>1754</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.33.2</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>235</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>669</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_1768</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>1768</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.31</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>231</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>670</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_1827</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>1827</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_CONSTR_00019.5</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>334</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>671</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_1836</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>1836</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.FillCipherAnnouncement.KeyServerState</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1574</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>672</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_1860</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>1860</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00008.6</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>314</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>673</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_1876</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>1876</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00009</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>316</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>674</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_1883</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>1883</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00009.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>317</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>675</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_1911</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>1911</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.59</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>271</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>676</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_1926</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>1926</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.28.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>79</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>677</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_1934</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>1934</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.TxSakUse_PrincipalOnly</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1586</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>678</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_1942</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>1942</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.KeyServerElection.36</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>239</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>679</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_1958</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>1958</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.KeyServerElection.36</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>239</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>680</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_1999</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>1999</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.Retry.GetTxSaNextPn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1585</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>681</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_2056</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>2056</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.KeyServerElection.3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>197</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>682</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_2057</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>2057</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.KeyServerElection.5</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>202</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>683</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_2075</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>2075</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.7</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>204</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>684</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_2090</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>2090</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.29</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>229</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>685</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_2133</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>2133</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.CipherSuiteSelection.AnnouncementMissing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1575</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>686</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_2171</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>2171</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.4.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>200</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>687</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_2197</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>2197</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.Api.GetPrincipalActor</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1583</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>688</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_2219</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>2219</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.KeyServerElection.27.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>225</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>689</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_2312</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>2312</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.35</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>237</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>690</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_2417</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>2417</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.DistributedCipherSuite.NoMatch</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1577</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>691</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_2572</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>2572</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.KeyServerElection.27.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>225</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>692</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_2676</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>2676</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.KeyServerElection.27.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>225</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>693</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_2746</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>2746</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.CipherSuiteSelection.NoMatch</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1576</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>694</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_2789</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>2789</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.6</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>203</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>695</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_2802</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>2802</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.MacSecDisabled.NoKeysNoSc</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1592</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>696</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_2835</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>2835</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.50</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>260</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>697</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_2836</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>2836</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.51</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>261</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>698</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_2921</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>2921</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.PeerSM.KeyServerReset</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1594</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>699</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_3045</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>3045</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.37</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>240</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>700</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_3046</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>3046</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.55</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>265</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>701</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_3067</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>3067</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.KeyServerElection.45.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>253</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>702</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_3068</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>3068</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.KeyServerElection.45.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>254</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>703</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_3096</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>3096</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.ImmediatePeerResponse.SakGenerated</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1579</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>704</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_3232</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>3232</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.MkaTransport.16.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>169</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>705</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_3240</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>3240</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.MkaTransport.16.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>170</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>706</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_KaY.c_3241</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_KaY.c</sourcefile>
      <sourceline>3241</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.MkaTransport.17</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>171</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>707</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/src/Mka_Lib.c_157</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Lib.c</sourcefile>
      <sourceline>157</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Lib.Api.GetSciPtr</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1069</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>708</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Lib.c_172</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Lib.c</sourcefile>
      <sourceline>172</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Lib.Api.Init</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1068</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>709</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Lib.c_181</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Lib.c</sourcefile>
      <sourceline>181</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Lib.SciBuffer_Init</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1595</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>710</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Lib.c_187</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Lib.c</sourcefile>
      <sourceline>187</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_91007</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>400</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>711</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Lib.c_197</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Lib.c</sourcefile>
      <sourceline>197</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.27.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>70</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>712</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Lib.c_217</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Lib.c</sourcefile>
      <sourceline>217</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Lib.Api.TimerCallback_General</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1076</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>713</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/src/Mka_Lib_Int.h_202</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Lib_Int.h</sourcefile>
      <sourceline>202</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Lib.Api.StartTimer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1070</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>714</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Lib_Int.h_215</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Lib_Int.h</sourcefile>
      <sourceline>215</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Lib.Api.StartTimerAutorepeat</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1071</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>715</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Lib_Int.h_230</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Lib_Int.h</sourcefile>
      <sourceline>230</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Lib.Api.StopTimer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1072</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>716</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Lib_Int.h_242</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Lib_Int.h</sourcefile>
      <sourceline>242</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Lib.Api.PauseTimer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1073</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>717</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Lib_Int.h_257</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Lib_Int.h</sourcefile>
      <sourceline>257</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Lib.Api.ResumeTimer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1074</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>718</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Lib_Int.h_272</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Lib_Int.h</sourcefile>
      <sourceline>272</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Lib.Api.ProcessTimers</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1075</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>719</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Lib_Int.h_285</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Lib_Int.h</sourcefile>
      <sourceline>285</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Lib.Api.IsTimerStarted</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1077</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>720</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/src/Mka_Lib_ParSet.c_130</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Lib_ParSet.c</sourcefile>
      <sourceline>130</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.29.4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>93</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>721</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Lib_ParSet.c_131</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Lib_ParSet.c</sourcefile>
      <sourceline>131</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Lib.Api.ParSet_ValidateMkaPduData</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1078</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>722</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Lib_ParSet.c_164</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Lib_ParSet.c</sourcefile>
      <sourceline>164</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.29.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>84</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>723</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Lib_ParSet.c_181</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Lib_ParSet.c</sourcefile>
      <sourceline>181</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.29.3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>92</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>724</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Lib_ParSet.c_252</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Lib_ParSet.c</sourcefile>
      <sourceline>252</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.29.2.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>86</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>725</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Lib_ParSet.c_269</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Lib_ParSet.c</sourcefile>
      <sourceline>269</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.29.2.6</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>91</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>726</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Lib_ParSet.c_275</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Lib_ParSet.c</sourcefile>
      <sourceline>275</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.29.2.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>86</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>727</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Lib_ParSet.c_292</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Lib_ParSet.c</sourcefile>
      <sourceline>292</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.29.2.6</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>91</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>728</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Lib_ParSet.c_298</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Lib_ParSet.c</sourcefile>
      <sourceline>298</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.29.2.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>87</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>729</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Lib_ParSet.c_322</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Lib_ParSet.c</sourcefile>
      <sourceline>322</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.29.2.6</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>91</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>730</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Lib_ParSet.c_328</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Lib_ParSet.c</sourcefile>
      <sourceline>328</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.29.2.3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>88</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>731</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Lib_ParSet.c_366</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Lib_ParSet.c</sourcefile>
      <sourceline>366</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.29.2.6</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>91</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>732</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Lib_ParSet.c_372</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Lib_ParSet.c</sourcefile>
      <sourceline>372</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00008.6</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>314</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>733</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Lib_ParSet.c_385</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Lib_ParSet.c</sourcefile>
      <sourceline>385</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Lib.ParseMkpdu.Announcement.MinimumBodyLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1596</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>734</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Lib_ParSet.c_392</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Lib_ParSet.c</sourcefile>
      <sourceline>392</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00009</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>316</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>735</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Lib_ParSet.c_395</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Lib_ParSet.c</sourcefile>
      <sourceline>395</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Lib.ParseMkpdu.Announcement.TlvStringLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1597</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>736</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Lib_ParSet.c_408</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Lib_ParSet.c</sourcefile>
      <sourceline>408</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_CONSTR_00019.5</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>334</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>737</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Lib_ParSet.c_439</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Lib_ParSet.c</sourcefile>
      <sourceline>439</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.29.2.6</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>91</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>738</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Lib_ParSet.c_445</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Lib_ParSet.c</sourcefile>
      <sourceline>445</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00008.7</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>315</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>739</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Lib_ParSet.c_455</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Lib_ParSet.c</sourcefile>
      <sourceline>455</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Lib.ParseMkpdu.XPN.BodyLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1598</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>740</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Lib_ParSet.c_462</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Lib_ParSet.c</sourcefile>
      <sourceline>462</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.29.2.6</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>91</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>741</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/src/Mka_Logon.c_737</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Logon.c</sourcefile>
      <sourceline>737</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.Api.MainFunction</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1040</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>742</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Logon.c_760</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Logon.c</sourcefile>
      <sourceline>760</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.UpdateSecYDuringInit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1619</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>743</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Logon.c_777</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Logon.c</sourcefile>
      <sourceline>777</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.ParticipantsRestart</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1600</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>744</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Logon.c_786</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Logon.c</sourcefile>
      <sourceline>786</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.ReenableDisabledParticipants</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1607</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>745</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Logon.c_796</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Logon.c</sourcefile>
      <sourceline>796</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.Api.Init</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1041</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>746</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Logon.c_822</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Logon.c</sourcefile>
      <sourceline>822</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00027.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>344</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>747</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Logon.c_838</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Logon.c</sourcefile>
      <sourceline>838</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.Api.SetCknStatus</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1047</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>748</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Logon.c_863</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Logon.c</sourcefile>
      <sourceline>863</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.Api.GetCknStatus</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1048</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>749</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Logon.c_888</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Logon.c</sourcefile>
      <sourceline>888</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.Api.SetEnable</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1049</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>750</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Logon.c_900</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Logon.c</sourcefile>
      <sourceline>900</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.Api.GetEnable</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1050</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>751</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Logon.c_912</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Logon.c</sourcefile>
      <sourceline>912</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.Api.SetPaePermissiveMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1051</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>752</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Logon.c_918</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Logon.c</sourcefile>
      <sourceline>918</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_01003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>385</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>753</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Logon.c_925</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Logon.c</sourcefile>
      <sourceline>925</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.Api.StartPae</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1052</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>754</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Logon.c_933</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Logon.c</sourcefile>
      <sourceline>933</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_01004</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>387</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>755</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Logon.c_941</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Logon.c</sourcefile>
      <sourceline>941</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.ManualPaeStart</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1605</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>756</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Logon.c_944</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Logon.c</sourcefile>
      <sourceline>944</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.PermissiveMode.PaeAutoStart.Disabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1616</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>757</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Logon.c_962</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Logon.c</sourcefile>
      <sourceline>962</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.Api.GetPaeStatus</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1053</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>758</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Logon.c_1085</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Logon.c</sourcefile>
      <sourceline>1085</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.Net_Sec_2156</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1483</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>759</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Logon.c_1099</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Logon.c</sourcefile>
      <sourceline>1099</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.UpdateSecYDuringInit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1619</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>760</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Logon.c_1122</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Logon.c</sourcefile>
      <sourceline>1122</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.Api.TimerCallback_PermissiveMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1054</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>761</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Logon.c_1143</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Logon.c</sourcefile>
      <sourceline>1143</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00028</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>345</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>762</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Logon.c_1156</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Logon.c</sourcefile>
      <sourceline>1156</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00028.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>346</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>763</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Logon.c_1168</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Logon.c</sourcefile>
      <sourceline>1168</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.Api.ParticipantSuccessfulActor</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1042</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>764</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Logon.c_1214</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Logon.c</sourcefile>
      <sourceline>1214</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.Api.ParticipantDisabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1043</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>765</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Logon.c_1241</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Logon.c</sourcefile>
      <sourceline>1241</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.Api.ParticipantActor</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1044</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>766</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Logon.c_1268</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Logon.c</sourcefile>
      <sourceline>1268</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.Api.MkpduReceived</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1059</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>767</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Logon.c_1281</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Logon.c</sourcefile>
      <sourceline>1281</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.RestartPermissiveModeTimerOnFirstMkpdu</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1448</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>768</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Logon.c_1290</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Logon.c</sourcefile>
      <sourceline>1290</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.Api.IckGenerateFinished</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1046</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>769</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Logon.c_1334</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Logon.c</sourcefile>
      <sourceline>1334</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.Api.MacSecOperational</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1055</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>770</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Logon.c_1352</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Logon.c</sourcefile>
      <sourceline>1352</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.PermissiveMode.StopTimer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1615</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>771</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Logon.c_1369</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Logon.c</sourcefile>
      <sourceline>1369</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.Api.ReportEvent</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1056</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>772</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Logon.c_1444</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Logon.c</sourcefile>
      <sourceline>1444</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.Api.PaeRestart</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1057</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>773</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Logon.c_1457</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Logon.c</sourcefile>
      <sourceline>1457</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00028</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>345</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>774</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Logon.c_1486</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Logon.c</sourcefile>
      <sourceline>1486</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.MacSecEnabledStatus</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1590</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>775</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Logon.c_1487</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Logon.c</sourcefile>
      <sourceline>1487</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.Api.MacSecEnabledStatus</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1058</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>776</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Logon.c_1522</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Logon.c</sourcefile>
      <sourceline>1522</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.Nvm.WriteBlockImmediately</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1611</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>777</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Logon.c_1560</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Logon.c</sourcefile>
      <sourceline>1560</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.Nvm.ShadowNvMemoryBlock</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1612</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>778</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Logon.c_1613</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Logon.c</sourcefile>
      <sourceline>1613</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.PaeMkaAutoStart</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1602</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>779</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Logon.c_1630</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Logon.c</sourcefile>
      <sourceline>1630</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.PaeLastSuccessfulPrincipal</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1603</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>780</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Logon.c_1648</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Logon.c</sourcefile>
      <sourceline>1648</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.PaeLastSuccessfulPrincipalFailed</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1604</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>781</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Logon.c_1664</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Logon.c</sourcefile>
      <sourceline>1664</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.BypassMacSec.DisabledPort</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1617</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>782</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Logon.c_1681</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Logon.c</sourcefile>
      <sourceline>1681</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.Nvm.Start</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1608</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>783</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Logon.c_1695</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Logon.c</sourcefile>
      <sourceline>1695</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.Nvm.GetStatus</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1609</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>784</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Logon.c_1704</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Logon.c</sourcefile>
      <sourceline>1704</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.CP_SWS_Mka_91006</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>399</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>785</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Logon.c_1707</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Logon.c</sourcefile>
      <sourceline>1707</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.MkaPostBuildConfigurationHash_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1449</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>786</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Logon.c_1718</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Logon.c</sourcefile>
      <sourceline>1718</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.Nvm.SetChangedStatus</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1610</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>787</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Logon.c_1736</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Logon.c</sourcefile>
      <sourceline>1736</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.CP_SWS_Mka_91006</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>399</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>788</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Logon.c_1743</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Logon.c</sourcefile>
      <sourceline>1743</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00027</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>343</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>789</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Logon.c_1772</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Logon.c</sourcefile>
      <sourceline>1772</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.ECUC_Mka_00049</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>443</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>790</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Logon.c_1780</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Logon.c</sourcefile>
      <sourceline>1780</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.Nvm.MacSecDisabledByDefault</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1613</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>791</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Logon.c_1953</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Logon.c</sourcefile>
      <sourceline>1953</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_01002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>381</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>792</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Logon.c_1956</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Logon.c</sourcefile>
      <sourceline>1956</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.BypassMacSec.NoEnabledCakCkn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1618</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>793</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Logon.c_1996</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Logon.c</sourcefile>
      <sourceline>1996</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.ParticipantsRestartDisabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1601</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>794</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Logon.c_2037</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Logon.c</sourcefile>
      <sourceline>2037</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.PaeLastSuccessfulPrincipal</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1603</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>795</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Logon.c_2161</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Logon.c</sourcefile>
      <sourceline>2161</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_01001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>378</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>796</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Logon.c_2321</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Logon.c</sourcefile>
      <sourceline>2321</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.NextSuccessfulParticipantAsPrincipal</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1606</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>797</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_Logon.c_2529</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_Logon.c</sourcefile>
      <sourceline>2529</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.PermissiveMode.ResetTimer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1614</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>798</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/src/Mka_RxTx.c_136</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_RxTx.c</sourcefile>
      <sourceline>136</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.RxTx.Api.Mka_RxTx_Init</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1060</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>799</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_RxTx.c_159</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_RxTx.c</sourcefile>
      <sourceline>159</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>34</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>800</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_RxTx.c_177</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_RxTx.c</sourcefile>
      <sourceline>177</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.RxTx.Api.Mka_RxTx_GetTxBuffer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1061</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>801</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_RxTx.c_217</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_RxTx.c</sourcefile>
      <sourceline>217</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.CP_SWS_Mka_91006</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>399</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>802</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_RxTx.c_250</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_RxTx.c</sourcefile>
      <sourceline>250</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.RxTx.Api.Mka_RxTx_ReleaseTxBuffer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1062</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>803</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_RxTx.c_277</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_RxTx.c</sourcefile>
      <sourceline>277</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.RxTx.Api.Mka_RxTx_TxBufferReady</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1063</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>804</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_RxTx.c_302</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_RxTx.c</sourcefile>
      <sourceline>302</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.MkaTransport.6</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>156</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>805</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_RxTx.c_321</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_RxTx.c</sourcefile>
      <sourceline>321</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.RxTx.Api.Mka_RxTx_RxIndication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1064</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>806</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_RxTx.c_336</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_RxTx.c</sourcefile>
      <sourceline>336</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.5</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>35</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>807</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_RxTx.c_338</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_RxTx.c</sourcefile>
      <sourceline>338</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.27.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>71</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>808</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_RxTx.c_345</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_RxTx.c</sourcefile>
      <sourceline>345</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.7.3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>40</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>809</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_RxTx.c_348</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_RxTx.c</sourcefile>
      <sourceline>348</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.27.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>71</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>810</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_RxTx.c_351</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_RxTx.c</sourcefile>
      <sourceline>351</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.27.3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>72</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>811</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_RxTx.c_362</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_RxTx.c</sourcefile>
      <sourceline>362</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.27.4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>73</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>812</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_RxTx.c_368</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_RxTx.c</sourcefile>
      <sourceline>368</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.MkaKeyHierarchy.4.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>113</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>813</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_RxTx.c_374</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_RxTx.c</sourcefile>
      <sourceline>374</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.27.5</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>74</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>814</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_RxTx.c_377</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_RxTx.c</sourcefile>
      <sourceline>377</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.27.6</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>75</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>815</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_RxTx.c_414</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_RxTx.c</sourcefile>
      <sourceline>414</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.MkaTransport.6</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>156</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>816</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_RxTx.c_426</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_RxTx.c</sourcefile>
      <sourceline>426</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.27.7</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>76</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>817</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_RxTx.c_459</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_RxTx.c</sourcefile>
      <sourceline>459</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.RxTx.Api.Mka_RxTx_IcvVerifyFinished</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1065</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>818</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_RxTx.c_500</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_RxTx.c</sourcefile>
      <sourceline>500</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.RxTx.Api.Mka_RxTx_IcvGenerateFinished</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1066</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>819</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_RxTx.c_522</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_RxTx.c</sourcefile>
      <sourceline>522</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.CP_SWS_Mka_91006</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>399</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>820</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/Mka_RxTx.c_546</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/src/Mka_RxTx.c</sourcefile>
      <sourceline>546</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.RxTx.Api.Mka_RxTx_IsIcvErrorPresent</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1067</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>821</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_16</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>16</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.ECUC_Mka_00001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>401</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>822</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_64</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>64</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.ECUC_Mka_00001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>401</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>823</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_65</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>65</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.ECUC_Mka_00003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>426</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>824</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_66</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>66</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00026</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>342</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>825</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_93</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>93</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.ECUC_Mka_00011</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>430</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>826</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_118</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>118</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.ECUC_Mka_00018</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>427</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>827</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_157</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>157</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.ECUC_Mka_00019</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>428</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>828</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_186</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>186</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.ECUC_Mka_00013</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>431</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>829</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_211</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>211</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00002.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>297</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>830</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_219</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>219</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.ECUC_Mka_00054</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>432</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>831</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_245</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>245</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.ECUC_Mka_00014</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>433</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>832</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_277</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>277</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.MkaPortIdentifier_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1430</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>833</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_307</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>307</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.ECUC_Mka_00017</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>434</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>834</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_323</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>323</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.ECUC_Mka_00016</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>435</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>835</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_366</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>366</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.ECUC_Mka_00015</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>436</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>836</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_402</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>402</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.ECUC_Mka_00032</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>437</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>837</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_438</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>438</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.ECUC_Mka_00031</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>441</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>838</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_468</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>468</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.ECUC_Mka_00022</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>438</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>839</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_498</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>498</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.ECUC_Mka_00029</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>440</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>840</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_534</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>534</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.ECUC_Mka_00038</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>442</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>841</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_563</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>563</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.MkaParticipantIdx_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1434</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>842</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_588</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>588</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.ECUC_Mka_00049</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>443</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>843</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_616</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>616</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.ECUC_Mka_00048</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>444</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>844</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_643</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>643</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.ECUC_Mka_00040.Cak</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>446</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>845</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_644</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>644</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.MkaKeyHierarchy.2.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>108</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>846</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_645</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>645</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.MkaKeyHierarchy.3.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>111</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>847</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_683</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>683</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.ECUC_Mka_00040.Ckn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>447</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>848</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_718</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>718</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.ECUC_Mka_00042</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>448</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>849</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_755</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>755</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.ECUC_Mka_00043</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>449</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>850</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_793</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>793</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.ECUC_Mka_00044</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>450</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>851</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_831</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>831</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.ECUC_Mka_00045</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>451</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>852</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_870</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>870</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.ECUC_Mka_00060</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>452</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>853</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_907</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>907</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.ECUC_Mka_00047</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>453</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>854</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_944</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>944</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.ECUC_Mka_00041</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>454</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>855</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_977</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>977</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.ECUC_Mka_00046</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>455</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>856</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_1009</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>1009</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.MkaCryptoHashGenerateJobRef_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1444</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>857</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_1051</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>1051</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.MkaCryptoSak2KeyRef_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1446</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>858</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_1087</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>1087</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.MkaCryptoHashGenerateJob2Ref_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1445</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>859</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_1133</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>1133</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.ECUC_Mka_00055</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>456</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>860</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_1152</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>1152</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.ECUC_Mka_00059</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>457</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>861</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_1178</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>1178</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.MkaKayDemEventParameterRefs_InvalidReference</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1683</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>862</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_1181</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>1181</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.MkaKayDemEventParameterRefs_UniqueReference</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1684</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>863</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_1186</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>1186</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.ECUC_Mka_00058</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>458</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>864</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_1212</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>1212</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.MkaKayDemEventParameterRefs_InvalidReference</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1683</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>865</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_1215</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>1215</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.MkaKayDemEventParameterRefs_UniqueReference</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1684</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>866</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_1220</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>1220</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.ECUC_Mka_00057</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>459</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>867</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_1246</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>1246</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.MkaKayDemEventParameterRefs_InvalidReference</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1683</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>868</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_1249</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>1249</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.MkaKayDemEventParameterRefs_UniqueReference</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1684</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>869</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_1254</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>1254</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.ECUC_Mka_00056</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>460</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>870</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_1279</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>1279</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.MkaKayDemEventParameterRefs_InvalidReference</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1683</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>871</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_1282</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>1282</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.MkaKayDemEventParameterRefs_UniqueReference</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1684</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>872</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_1298</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>1298</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.ECUC_Mka_00001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>401</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>873</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_1299</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>1299</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.ECUC_Mka_00033</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>409</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>874</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_1318</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>1318</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.ECUC_Mka_00037</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>412</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>875</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_1343</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>1343</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.ECUC_Mka_00012</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>410</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>876</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_1373</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>1373</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.ECUC_Mka_00004</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>413</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>877</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_1405</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>1405</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.ECUC_Mka_00005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>414</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>878</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_1436</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>1436</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.ECUC_Mka_00024</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>415</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>879</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_1467</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>1467</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.ECUC_Mka_00001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>401</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>880</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_1475</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>1475</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.ECUC_Mka_00021</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>416</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>881</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_1494</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>1494</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.ECUC_Mka_00053</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>418</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>882</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_1519</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>1519</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.ECUC_Mka_00025</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>419</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>883</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_1553</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>1553</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.ECUC_Mka_00026</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>420</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>884</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_1590</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>1590</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.CryptoAlgoConfig.OffsetSetForXPN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1667</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>885</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_1599</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>1599</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.ECUC_Mka_00027</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>421</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>886</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_1625</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>1625</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.ECUC_Mka_00028</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>422</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>887</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_1655</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>1655</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.ECUC_Mka_00050</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>423</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>888</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_1657</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>1657</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_CONSTR_00020</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>335</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>889</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_1682</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>1682</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.ECUC_Mka_00052</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>424</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>890</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_1714</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>1714</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_CONSTR_00019.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>330</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>891</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_1716</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>1716</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_CONSTR_00019.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>331</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>892</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_1718</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>1718</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_CONSTR_00019.3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>332</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>893</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_1720</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>1720</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_CONSTR_00019.4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>333</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>894</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_1727</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>1727</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.ECUC_Mka_00051</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>425</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>895</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_1753</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>1753</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_CONSTR_00020</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>335</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>896</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_1770</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>1770</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.ECUC_Mka_00001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>401</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>897</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_1771</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>1771</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.ECUC_Mka_00002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>402</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>898</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_1787</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>1787</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.ECUC_Mka_00034</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>403</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>899</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_1809</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>1809</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.ECUC_Mka_00007</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>404</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>900</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_1835</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>1835</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.ECUC_Mka_00009</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>405</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>901</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_1865</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>1865</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.ECUC_Mka_00035</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>406</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>902</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_1891</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>1891</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.ECUC_Mka_00010</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>407</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>903</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_1917</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>1917</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.Net_Sec_2156</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1483</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>904</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_1948</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>1948</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.ECUC_Mka_00036</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>408</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>905</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_1970</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>1970</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.MkaMaxNumPaeInstances_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1431</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>906</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_2000</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>2000</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.MkaMaxNumParticipants_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1432</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>907</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_2030</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>2030</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.MkaMaxRxBufferSize_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1433</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>908</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_2031</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>2031</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.MkaMaxRxBufferSize.DefaultValue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1451</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>909</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_2061</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>2061</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.MkaDemReportingEnabled_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1441</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>910</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_2088</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>2088</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.MkaEmptyDistributedSakUseEnabled_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1482</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>911</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_2113</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>2113</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.MkaLatestKeyGetsOldAfterRetire_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1443</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>912</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_2144</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>2144</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.MkaRestartPermissiveModeTimerOnFirstMkpdu_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1447</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>913</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_2177</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>2177</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.MkaCryptoGeneral_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1435</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>914</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_2191</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>2191</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.MkaCsmProcessing_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1436</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>915</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_2222</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>2222</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.MkaCryptoKeyGenerateMaxBufferSize_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1437</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>916</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_2255</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>2255</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.MkaCryptoRandomGenerateMaxBufferSize_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1438</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>917</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_2286</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>2286</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.MkaCryptoKeyWrapMaxBufferSize_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1439</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>918</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_2318</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>2318</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.Mka.MkaNvmBlock_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1452</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>919</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_2348</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>2348</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.NvMNvBlockLength_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1454</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>920</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_2377</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>2377</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.Mka.MkaNvmBlockDescriptorRef_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1453</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>921</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_2413</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>2413</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.MkaNvmBlockDescriptorRef.ReadAll</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1674</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>922</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_2417</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>2417</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.MkaNvmBlockDescriptorRef.WriteAll</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1675</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>923</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_2421</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>2421</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.MkaNvmBlockDescriptorRef.RamAddress</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1676</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>924</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_2425</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>2425</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.MkaNvmBlockDescriptorRef.UserHeader</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1677</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>925</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_2429</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>2429</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.MkaNvmBlockDescriptorRef.MinimumMemorySize_Invalid</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1678</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>926</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_2440</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>2440</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.MkaHeaderFileInclusion_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1457</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>927</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_2463</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>2463</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.MkaCallbacks_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1458</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>928</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_2477</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>2477</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.MkaGetMacSecStatisticsCallback_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1459</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>929</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_2511</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>2511</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.MkaGetMacSecStatisticsCallback_EmptyReference</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1679</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>930</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_2518</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>2518</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.MkaSecYCallout_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1460</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>931</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_2546</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>2546</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.MkaSecYCallout_EmptyReference</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1680</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>932</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_2553</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>2553</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.MkaTaskCallout_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1461</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>933</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_2581</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>2581</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.MkaTaskCallout_EmptyReference</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1681</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>934</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_2588</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>2588</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.MkaReportEventCallout_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1462</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>935</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_2631</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>2631</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.MkaReportEventCallout_EmptyReference</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1682</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>936</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_2642</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>2642</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.MkaSecYAddTxSaSync_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1464</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>937</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_2670</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>2670</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.MkaSecYAddRxSaSync_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1465</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>938</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_2698</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>2698</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.MkaEnableImmediatePeerResponse_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1463</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>939</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_2724</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>2724</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.MkaUpdateSecYDuringInit_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1466</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>940</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_2754</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>2754</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.ParticipantsRestartDisabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1601</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>941</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_2786</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>2786</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.CipherSuiteSelection.AnnouncementMissing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1575</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>942</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_2819</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>2819</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.MkaStopTxAnnouncementAfterCipherSelected_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1469</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>943</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_2852</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>2852</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.MkaSecYRetryAttempts_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1442</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>944</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_2879</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>2879</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.MkaCryptoRetryAttempts_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1440</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>945</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_2907</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>2907</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.MkaHandleEventsApi_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1467</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>946</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/Mka.xdm.m4_2946</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/config/Mka.xdm.m4</sourcefile>
      <sourceline>2946</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.MkaUsePresharedIckKek_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1468</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>947</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/generate_var/xgen/Mka.xgen_77</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/generate_var/xgen/Mka.xgen</sourcefile>
      <sourceline>77</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_91026</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>374</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>948</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate_var/xgen/Mka.xgen_601</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/generate_var/xgen/Mka.xgen</sourcefile>
      <sourceline>601</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.MkaPostBuildConfigurationHash_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1449</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>949</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate_var/xgen/Mka.xgen_735</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/generate_var/xgen/Mka.xgen</sourcefile>
      <sourceline>735</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00011.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>319</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>950</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate_var/xgen/Mka.xgen_738</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/src/Autosar/generate_var/xgen/Mka.xgen</sourcefile>
      <sourceline>738</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00011.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>320</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>951</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs" title="Transmission and reception of MKPDUs">
    <specobject>
      <id>Mka.dsn.Func0100.MkaTransport</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>618</sourceline>
      <version>1</version>
      <description>
          Mka module shall provide a secure transport between the members of the same CA, by exchanging
          MKA protocol data units (MKPDUs), authenticated by CAK in possession of each CA member.
        </description>
      <furtherinfo>
          WRN.swurs.needscoverage.count - Linking all feature requirements to the single top-level
          requirement brings clear benefits and splitting them up would only increase complexity
          without any real improvements.
        </furtherinfo>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.8021X.Eapol.3</srcid><srcstatus/><internalId>32</internalId></linkedfrom><linkedfrom><srcid>Mka.EB.Eapol.3</srcid><srcstatus/><internalId>33</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.4</srcid><srcstatus/><internalId>34</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.5</srcid><srcstatus/><internalId>35</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.7</srcid><srcstatus/><internalId>37</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.7.1</srcid><srcstatus/><internalId>38</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.7.2</srcid><srcstatus/><internalId>39</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.7.3</srcid><srcstatus/><internalId>40</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.8</srcid><srcstatus/><internalId>42</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.8.1</srcid><srcstatus/><internalId>43</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.8.3</srcid><srcstatus/><internalId>45</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.8.4</srcid><srcstatus/><internalId>46</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.8.5</srcid><srcstatus/><internalId>47</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.8.6</srcid><srcstatus/><internalId>48</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.8.7</srcid><srcstatus/><internalId>49</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.8.8</srcid><srcstatus/><internalId>50</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.9</srcid><srcstatus/><internalId>51</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.11</srcid><srcstatus/><internalId>53</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.12</srcid><srcstatus/><internalId>54</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.15</srcid><srcstatus/><internalId>57</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.16</srcid><srcstatus/><internalId>58</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.22</srcid><srcstatus/><internalId>64</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.26</srcid><srcstatus/><internalId>68</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.27</srcid><srcstatus/><internalId>69</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.27.1</srcid><srcstatus/><internalId>70</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.27.2</srcid><srcstatus/><internalId>71</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.27.3</srcid><srcstatus/><internalId>72</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.27.4</srcid><srcstatus/><internalId>73</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.27.5</srcid><srcstatus/><internalId>74</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.27.6</srcid><srcstatus/><internalId>75</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.27.7</srcid><srcstatus/><internalId>76</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.28</srcid><srcstatus/><internalId>77</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.28.1</srcid><srcstatus/><internalId>78</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.28.2</srcid><srcstatus/><internalId>79</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.28.5</srcid><srcstatus/><internalId>82</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.29</srcid><srcstatus/><internalId>83</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.29.1</srcid><srcstatus/><internalId>84</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.29.2</srcid><srcstatus/><internalId>85</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.29.2.1</srcid><srcstatus/><internalId>86</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.29.2.2</srcid><srcstatus/><internalId>87</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.29.2.3</srcid><srcstatus/><internalId>88</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.29.2.4</srcid><srcstatus/><internalId>89</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.29.2.5</srcid><srcstatus/><internalId>90</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.29.2.6</srcid><srcstatus/><internalId>91</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.29.3</srcid><srcstatus/><internalId>92</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.29.4</srcid><srcstatus/><internalId>93</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.MkaTransport.2</srcid><srcstatus/><internalId>152</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.MkaTransport.4</srcid><srcstatus/><internalId>154</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.MkaTransport.6</srcid><srcstatus/><internalId>156</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.MkaTransport.8</srcid><srcstatus/><internalId>158</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.MkaTransport.9</srcid><srcstatus/><internalId>159</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.MkaTransport.10</srcid><srcstatus/><internalId>160</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.MkaTransport.10.1</srcid><srcstatus/><internalId>161</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.MkaTransport.11</srcid><srcstatus/><internalId>163</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.MkaTransport.13</srcid><srcstatus/><internalId>165</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.MkaTransport.15</srcid><srcstatus/><internalId>167</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.MkaTransport.16</srcid><srcstatus/><internalId>168</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.MkaTransport.16.1</srcid><srcstatus/><internalId>169</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.MkaTransport.16.2</srcid><srcstatus/><internalId>170</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.MkaTransport.17</srcid><srcstatus/><internalId>171</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.MkaTransport.25</srcid><srcstatus/><internalId>181</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.MkaTransport.25.1</srcid><srcstatus/><internalId>182</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.MkaTransport.25.2</srcid><srcstatus/><internalId>183</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.MkaTransport.25.3</srcid><srcstatus/><internalId>184</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.MkaTransport.29</srcid><srcstatus/><internalId>190</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.MkaTransport.31</srcid><srcstatus/><internalId>192</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.MkaTransport.32</srcid><srcstatus/><internalId>193</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.dsn.RxTx.TxSM</srcid><srcstatus/><internalId>1085</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.RxTx.RxSM</srcid><srcstatus/><internalId>1086</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>952</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs" title="Key derivation function">
    <specobject>
      <id>Mka.dsn.Func0101.KeyDerivation</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>640</sourceline>
      <version>1</version>
      <description>
          Mka module shall provide support for Key derivation to derive ICK and KEK from CAK.
        </description>
      <furtherinfo>
          WRN.swurs.needscoverage.count - Linking all feature requirements to the single top-level
          requirement brings clear benefits and splitting them up would only increase complexity
          without any real improvements.
        </furtherinfo>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.8021X.MkaKeyHierarchy.9</srcid><srcstatus/><internalId>123</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.MkaKeyHierarchy.9.1</srcid><srcstatus/><internalId>124</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.MkaKeyHierarchy.11</srcid><srcstatus/><internalId>127</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.MkaKeyHierarchy.11.1</srcid><srcstatus/><internalId>128</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.MkaKeyHierarchy.17</srcid><srcstatus/><internalId>135</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.MkaKeyHierarchy.17.1</srcid><srcstatus/><internalId>136</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.MkaKeyHierarchy.17.2</srcid><srcstatus/><internalId>137</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.MkaKeyHierarchy.18</srcid><srcstatus/><internalId>138</internalId></linkedfrom><linkedfrom><srcid>Mka.CP_SWS_Mka_CONSTR_00020.2</srcid><srcstatus/><internalId>337</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>953</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs" title="Random number generator">
    <specobject>
      <id>Mka.dsn.Func0102.RandomNumberGenerator</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>660</sourceline>
      <version>1</version>
      <description>
          Mka module shall provide support for use of strong random number generator (RNG) for
          SAK and Member Identifier generation.
        </description>
      <furtherinfo>
          WRN.swurs.needscoverage.count - Linking all feature requirements to the single top-level
          requirement brings clear benefits and splitting them up would only increase complexity
          without any real improvements.
        </furtherinfo>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.8021X.MkaKeyHierarchy.16.2</srcid><srcstatus/><internalId>134</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.MkaTransport.2</srcid><srcstatus/><internalId>152</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.MkaTransport.9</srcid><srcstatus/><internalId>159</internalId></linkedfrom><linkedfrom><srcid>Mka.CP_SWS_Mka_00007.2</srcid><srcstatus/><internalId>307</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>954</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs" title="Integrity check value">
    <specobject>
      <id>Mka.dsn.Func0103.IntegrityCheckValue</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>681</sourceline>
      <version>1</version>
      <description>
          Mka module shall provide support for use of AES CMAC with 128 bits, using ICK to generate and verify MKA message ICVs.
        </description>
      <furtherinfo>
          WRN.swurs.needscoverage.count - Linking all feature requirements to the single top-level
          requirement brings clear benefits and splitting them up would only increase complexity
          without any real improvements.
        </furtherinfo>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.8021X.Eapol.12</srcid><srcstatus/><internalId>54</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.28.5</srcid><srcstatus/><internalId>82</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.MkaTransport.6</srcid><srcstatus/><internalId>156</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>955</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs" title="Key wrap">
    <specobject>
      <id>Mka.dsn.Func0104.AesKeyWrap</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>701</sourceline>
      <version>1</version>
      <description>
          Mka module shall provide support AES key wrap and unwrap based on RFC 3394 for SAK transmission.
        </description>
      <furtherinfo>
          WRN.swurs.needscoverage.count - Linking all feature requirements to the single top-level
          requirement brings clear benefits and splitting them up would only increase complexity
          without any real improvements.
        </furtherinfo>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.8021X.MkaKeyHierarchy.10.1</srcid><srcstatus/><internalId>126</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.KeyServerElection.37</srcid><srcstatus/><internalId>240</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>956</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs" title="Potential and live peer lists">
    <specobject>
      <id>Mka.dsn.Func0105.PeerLists</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>721</sourceline>
      <version>1</version>
      <description>
          Mka module shall provide support for live and potential peer list parameter sets.
          The Live Peer List includes MI and MN tuple of a peer that have included participant's own MI and a
          recent MN in a recent MKPDU, thus proving liveness.
          Potential Peer List includes MI and MN tuple of a peer that have transmitted an MKPDU that has
          been directly received by the participant, but have not yet proved liveness.
        </description>
      <furtherinfo>
          WRN.swurs.needscoverage.count - Linking all feature requirements to the single top-level
          requirement brings clear benefits and splitting them up would only increase complexity
          without any real improvements.
        </furtherinfo>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.8021X.Eapol.28.3</srcid><srcstatus/><internalId>80</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.28.4</srcid><srcstatus/><internalId>81</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.Eapol.30</srcid><srcstatus/><internalId>94</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.MkaTransport.18</srcid><srcstatus/><internalId>172</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.MkaTransport.19</srcid><srcstatus/><internalId>173</internalId></linkedfrom><linkedfrom><srcid>Mka.EB.MkaTransport.19</srcid><srcstatus/><internalId>174</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.MkaTransport.20</srcid><srcstatus/><internalId>175</internalId></linkedfrom><linkedfrom><srcid>Mka.EB.MkaTransport.20</srcid><srcstatus/><internalId>176</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.MkaTransport.21</srcid><srcstatus/><internalId>177</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.MkaTransport.25.4</srcid><srcstatus/><internalId>185</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.MkaTransport.25.5</srcid><srcstatus/><internalId>186</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00008.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>310</internalId></provcov>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00008.3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>311</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>957</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs" title="Key server election">
    <specobject>
      <id>Mka.dsn.Func0106.KeyServerElection</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>753</sourceline>
      <version>1</version>
      <description>
          Mka shall support electing key server based on:
          &lt;ul&gt;
            &lt;li&gt;1) Statically configured roles in configuration parameter MkaRole - MKA_KEY_SERVER and MKA_PEER, and&lt;/li&gt;
            &lt;li&gt;2) Priority based (as defined in IEEE 802.1X) when MkaRole is set to MKA_KEY_SERVER_PRIORITY_BASED.&lt;/li&gt;
          &lt;/ul&gt;
        </description>
      <furtherinfo>
          WRN.swurs.needscoverage.count - Linking all feature requirements to the single top-level
          requirement brings clear benefits and splitting them up would only increase complexity
          without any real improvements.
        </furtherinfo>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.8021X.KeyServerElection.3</srcid><srcstatus/><internalId>196</internalId></linkedfrom><linkedfrom><srcid>Mka.EB.KeyServerElection.3</srcid><srcstatus/><internalId>197</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.KeyServerElection.4</srcid><srcstatus/><internalId>198</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.KeyServerElection.4.1</srcid><srcstatus/><internalId>199</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.KeyServerElection.4.2</srcid><srcstatus/><internalId>200</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.KeyServerElection.5</srcid><srcstatus/><internalId>201</internalId></linkedfrom><linkedfrom><srcid>Mka.EB.KeyServerElection.5</srcid><srcstatus/><internalId>202</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.KeyServerElection.6</srcid><srcstatus/><internalId>203</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.KeyServerElection.7</srcid><srcstatus/><internalId>204</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.KeyServerElection.10</srcid><srcstatus/><internalId>206</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>958</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs" title="Cipher suite selection">
    <specobject>
      <id>Mka.dsn.Func0107.CipherSuiteSelection</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>777</sourceline>
      <version>1</version>
      <description>
          Mka shall support configuring multiple cipher suites per participant. It shall also support Announcement parameter set,
          which distributes available cryptographic options (cipher suites and capability) to its partner.
          Key server shall be able to select cipher suite based on configured options at his side and available options at peer's side.
        </description>
      <furtherinfo>
          WRN.swurs.needscoverage.count - Linking all feature requirements to the single top-level
          requirement brings clear benefits and splitting them up would only increase complexity
          without any real improvements.
        </furtherinfo>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.8021X.KeyServerElection.18</srcid><srcstatus/><internalId>214</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.KeyServerElection.27.1</srcid><srcstatus/><internalId>224</internalId></linkedfrom><linkedfrom><srcid>Mka.EB.KeyServerElection.27.1</srcid><srcstatus/><internalId>225</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.KeyServerElection.27.2</srcid><srcstatus/><internalId>226</internalId></linkedfrom><linkedfrom><srcid>Mka.EB.KeyServerElection.27.2</srcid><srcstatus/><internalId>227</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.KeyServerElection.29</srcid><srcstatus/><internalId>229</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.KeyServerElection.34</srcid><srcstatus/><internalId>236</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.KeyServerElection.36</srcid><srcstatus/><internalId>238</internalId></linkedfrom><linkedfrom><srcid>Mka.EB.KeyServerElection.36</srcid><srcstatus/><internalId>239</internalId></linkedfrom><linkedfrom><srcid>Mka.CP_SWS_Mka_00008.6</srcid><srcstatus/><internalId>314</internalId></linkedfrom><linkedfrom><srcid>Mka.CP_SWS_Mka_00009</srcid><srcstatus/><internalId>316</internalId></linkedfrom><linkedfrom><srcid>Mka.CP_SWS_Mka_00009.1</srcid><srcstatus/><internalId>317</internalId></linkedfrom><linkedfrom><srcid>Mka.CP_SWS_Mka_CONSTR_00019.5</srcid><srcstatus/><internalId>334</internalId></linkedfrom><linkedfrom><srcid>Mka.CP_SWS_Mka_CONSTR_00020</srcid><srcstatus/><internalId>335</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.EB.MkaStopTxAnnouncementAfterCipherSelected_Conf</srcid><srcstatus/><internalId>1469</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.KaY.FillCipherAnnouncement.KeyServerState</srcid><srcstatus/><internalId>1574</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.KaY.CipherSuiteSelection.AnnouncementMissing</srcid><srcstatus/><internalId>1575</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.KaY.CipherSuiteSelection.NoMatch</srcid><srcstatus/><internalId>1576</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.KaY.DistributedCipherSuite.NoMatch</srcid><srcstatus/><internalId>1577</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Lib.ParseMkpdu.Announcement.MinimumBodyLength</srcid><srcstatus/><internalId>1596</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Lib.ParseMkpdu.Announcement.TlvStringLength</srcid><srcstatus/><internalId>1597</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Lib.ParseMkpdu.XPN.BodyLength</srcid><srcstatus/><internalId>1598</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>959</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs" title="Sak generation distribution and use">
    <specobject>
      <id>Mka.dsn.Func0108.SakGenerationDistributionUse</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>800</sourceline>
      <version>1</version>
      <description>
          MKA shall support functionality for each participant to:
          &lt;ul&gt;
            &lt;li&gt;1) Generate SAK when elected as key server.&lt;/li&gt;
            &lt;li&gt;2) Encrypt and distribute SAK to the peer.&lt;/li&gt;
            &lt;li&gt;3) Receive and decrypt SAK received from key server when elected not as a key server (peer).&lt;/li&gt;
            &lt;li&gt;4) Install SAK in SecY synchronously with a partner in order not to lose any traffic.&lt;/li&gt;
          &lt;/ul&gt;
        </description>
      <furtherinfo>
          WRN.swurs.needscoverage.count - Linking all feature requirements to the single top-level
          requirement brings clear benefits and splitting them up would only increase complexity
          without any real improvements.
        </furtherinfo>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.8021X.KeyServerElection.6</srcid><srcstatus/><internalId>203</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.KeyServerElection.12</srcid><srcstatus/><internalId>208</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.KeyServerElection.26</srcid><srcstatus/><internalId>222</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.KeyServerElection.33</srcid><srcstatus/><internalId>233</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.KeyServerElection.33.1</srcid><srcstatus/><internalId>234</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.KeyServerElection.33.2</srcid><srcstatus/><internalId>235</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.KeyServerElection.35</srcid><srcstatus/><internalId>237</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.KeyServerElection.37</srcid><srcstatus/><internalId>240</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.KeyServerElection.38</srcid><srcstatus/><internalId>241</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.KeyServerElection.44</srcid><srcstatus/><internalId>250</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.KeyServerElection.45</srcid><srcstatus/><internalId>251</internalId></linkedfrom><linkedfrom><srcid>Mka.EB.KeyServerElection.45</srcid><srcstatus/><internalId>252</internalId></linkedfrom><linkedfrom><srcid>Mka.EB.KeyServerElection.45.1</srcid><srcstatus/><internalId>253</internalId></linkedfrom><linkedfrom><srcid>Mka.EB.KeyServerElection.45.2</srcid><srcstatus/><internalId>254</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.KeyServerElection.46</srcid><srcstatus/><internalId>255</internalId></linkedfrom><linkedfrom><srcid>Mka.EB.KeyServerElection.46</srcid><srcstatus/><internalId>256</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.KeyServerElection.50</srcid><srcstatus/><internalId>260</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.KeyServerElection.51</srcid><srcstatus/><internalId>261</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.KeyServerElection.55</srcid><srcstatus/><internalId>265</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.KeyServerElection.58</srcid><srcstatus/><internalId>268</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.KeyServerElection.58.1</srcid><srcstatus/><internalId>269</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.KeyServerElection.58.2</srcid><srcstatus/><internalId>270</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.KeyServerElection.59</srcid><srcstatus/><internalId>271</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.KeyServerElection.60</srcid><srcstatus/><internalId>272</internalId></linkedfrom><linkedfrom><srcid>Mka.EB.KeyServerElection.60</srcid><srcstatus/><internalId>273</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.KeyServerElection.61</srcid><srcstatus/><internalId>274</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.KeyServerElection.64</srcid><srcstatus/><internalId>277</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.KeyServerElection.65</srcid><srcstatus/><internalId>278</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.KeyServerElection.66</srcid><srcstatus/><internalId>279</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.KeyServerElection.77</srcid><srcstatus/><internalId>289</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.dsn.KaY.TxSakUse_PrincipalOnly</srcid><srcstatus/><internalId>1586</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>960</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs" title="SAK re-keying">
    <specobject>
      <id>Mka.dsn.Func0109.SakRekeying</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>827</sourceline>
      <version>1</version>
      <description>
          Mka module shall provide support to re-key distributed SAK based on:
          &lt;ul&gt;
            &lt;li&gt;1) Configurable timer,&lt;/li&gt;
            &lt;li&gt;2) MACsec packet numbering and&lt;/li&gt;
            &lt;li&gt;3) Change of partner's MI.&lt;/li&gt;
            &lt;li&gt;4) Change of key server's MI.&lt;/li&gt;
          &lt;/ul&gt;
        </description>
      <furtherinfo>
          WRN.swurs.needscoverage.count - Linking all feature requirements to the single top-level
          requirement brings clear benefits and splitting them up would only increase complexity
          without any real improvements.
        </furtherinfo>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.8021X.KeyServerElection.41</srcid><srcstatus/><internalId>244</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.KeyServerElection.42</srcid><srcstatus/><internalId>245</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.KeyServerElection.43</srcid><srcstatus/><internalId>246</internalId></linkedfrom><linkedfrom><srcid>Mka.EB.KeyServerElection.43</srcid><srcstatus/><internalId>247</internalId></linkedfrom><linkedfrom><srcid>Mka.EB.KeyServerElection.43.1</srcid><srcstatus/><internalId>248</internalId></linkedfrom><linkedfrom><srcid>Mka.EB.KeyServerElection.43.2</srcid><srcstatus/><internalId>249</internalId></linkedfrom><linkedfrom><srcid>Mka.CP_SWS_Mka_00013</srcid><srcstatus/><internalId>322</internalId></linkedfrom><linkedfrom><srcid>Mka.CP_SWS_Mka_00014</srcid><srcstatus/><internalId>323</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.dsn.KaY.Rekeying.KeyServerChangesMi</srcid><srcstatus/><internalId>1593</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>961</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs" title="MACsec operational management">
    <specobject>
      <id>Mka.dsn.Func0110.MacSecOperational</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>854</sourceline>
      <version>1</version>
      <description>
          Mka shall inform EthIf about the status of MACsec protection for particular transceiver or port.
        </description>
      <furtherinfo>
          WRN.swurs.needscoverage.count - Linking all feature requirements to the single top-level
          requirement brings clear benefits and splitting them up would only increase complexity
          without any real improvements.
        </furtherinfo>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.8021X.KeyServerElection.26</srcid><srcstatus/><internalId>222</internalId></linkedfrom><linkedfrom><srcid>Mka.CP_SWS_Mka_00032</srcid><srcstatus/><internalId>350</internalId></linkedfrom><linkedfrom><srcid>Mka.CP_SWS_Mka_00032.1</srcid><srcstatus/><internalId>351</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.dsn.Cp.MacSecOperational.LinkStateDown</srcid><srcstatus/><internalId>1486</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Cp.MacSecOperational.Unsecured</srcid><srcstatus/><internalId>1487</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Logon.BypassMacSec.DisabledPort</srcid><srcstatus/><internalId>1617</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Logon.BypassMacSec.NoEnabledCakCkn</srcid><srcstatus/><internalId>1618</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>962</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs" title="Permissive mode on fail">
    <specobject>
      <id>Mka.dsn.Func0111.PermissiveMode</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>875</sourceline>
      <version>1</version>
      <description>
          MKA shall support permissive mode for Pae when no participant can find a successful peer.
          This option can be enabled via Mka configuration.
        </description>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.CP_SWS_Mka_00028</srcid><srcstatus/><internalId>345</internalId></linkedfrom><linkedfrom><srcid>Mka.CP_SWS_Mka_00029</srcid><srcstatus/><internalId>347</internalId></linkedfrom><linkedfrom><srcid>Mka.CP_SWS_Mka_00030</srcid><srcstatus/><internalId>348</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Logon.Api.MkpduReceived</srcid><srcstatus/><internalId>1059</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.EB.MkaRestartPermissiveModeTimerOnFirstMkpdu_Conf</srcid><srcstatus/><internalId>1447</internalId></linkedfrom><linkedfrom><srcid>Mka.EB.RestartPermissiveModeTimerOnFirstMkpdu</srcid><srcstatus/><internalId>1448</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Logon.PermissiveMode.ResetTimer</srcid><srcstatus/><internalId>1614</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Logon.PermissiveMode.StopTimer</srcid><srcstatus/><internalId>1615</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Logon.PermissiveMode.PaeAutoStart.Disabled</srcid><srcstatus/><internalId>1616</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>963</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs" title="Exponential startup Mka Hello Time">
    <specobject>
      <id>Mka.dsn.Func0112.ExponentialStartupMkaHelloTime</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>892</sourceline>
      <version>1</version>
      <description>
          Mka module shall support retry for the MKA sequence.
          If an MKA KaY participant (MkaKayParticipant) cannot successfully identify or successfully establish
          a SC with any participant in the Link, it shall retry the MKA sequence following a per configuration
          parametrized retry base delay with Exponential Back-off (MkaRetryBaseDelay) until a retry cyclic delay
          (MkaRetryCyclicDelay).
        </description>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.CP_SWS_Mka_00012</srcid><srcstatus/><internalId>321</internalId></linkedfrom><linkedfrom><srcid>Mka.ECUC_Mka_00004</srcid><srcstatus/><internalId>413</internalId></linkedfrom><linkedfrom><srcid>Mka.ECUC_Mka_00005</srcid><srcstatus/><internalId>414</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.dsn.KaY.Api.TimerCallbackTxMkpdu.LivePeerNotFound</srcid><srcstatus/><internalId>1572</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.KaY.Api.TimerCallbackTxMkpdu.LivePeerFound</srcid><srcstatus/><internalId>1573</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>964</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs" title="Extended packet numbering cipher suite support">
    <specobject>
      <id>Mka.dsn.Func0113.Xpn</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>912</sourceline>
      <version>1</version>
      <description>
          Mka shall support XPN cipher suites.
        </description>
      <furtherinfo>
          WRN.swurs.needscoverage.count - Linking all feature requirements to the single top-level
          requirement brings clear benefits and splitting them up would only increase complexity
          without any real improvements.
        </furtherinfo>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.8021X.KeyServerElection.68</srcid><srcstatus/><internalId>281</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.KeyServerElection.70</srcid><srcstatus/><internalId>283</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.KeyServerElection.72</srcid><srcstatus/><internalId>284</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.KeyServerElection.73</srcid><srcstatus/><internalId>285</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.KeyServerElection.75</srcid><srcstatus/><internalId>287</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.KeyServerElection.76</srcid><srcstatus/><internalId>288</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.KeyServerElection.80</srcid><srcstatus/><internalId>292</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.KeyServerElection.81</srcid><srcstatus/><internalId>293</internalId></linkedfrom><linkedfrom><srcid>Mka.CP_SWS_Mka_00008.7</srcid><srcstatus/><internalId>315</internalId></linkedfrom><linkedfrom><srcid>Mka.CP_SWS_Mka_00014.2</srcid><srcstatus/><internalId>325</internalId></linkedfrom><linkedfrom><srcid>Mka.CP_SWS_Mka_CONSTR_00019.3</srcid><srcstatus/><internalId>332</internalId></linkedfrom><linkedfrom><srcid>Mka.CP_SWS_Mka_CONSTR_00019.4</srcid><srcstatus/><internalId>333</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.dsn.Cp.ExtendedPacketNumber.Salt</srcid><srcstatus/><internalId>1489</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Cp.ExtendedPacketNumber.Salt.Calculation</srcid><srcstatus/><internalId>1490</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Cp.ExtendedPacketNumber.XPN</srcid><srcstatus/><internalId>1491</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Cp.ExtendedPacketNumber.PnRecovery</srcid><srcstatus/><internalId>1492</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Cp.BypassEtherType.Empty</srcid><srcstatus/><internalId>1493</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Cp.BypassVlan.Empty</srcid><srcstatus/><internalId>1494</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>965</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs" title="Packet Number (PN)">
    <specobject>
      <id>Mka.dsn.Func0114.PacketNumbering</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>933</sourceline>
      <version>1</version>
      <description>
          MKA shall support MACsec packet numbering, by communicating the lowest PN used for transmission
          with the SAK, allowing receivers to bound transmission delays.
        </description>
      <furtherinfo>
          WRN.swurs.needscoverage.count - Linking all feature requirements to the single top-level
          requirement brings clear benefits and splitting them up would only increase complexity
          without any real improvements.
        </furtherinfo>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.8021X.KeyServerElection.41</srcid><srcstatus/><internalId>244</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.KeyServerElection.66</srcid><srcstatus/><internalId>279</internalId></linkedfrom><linkedfrom><srcid>Mka.ECUC_Mka_00027</srcid><srcstatus/><internalId>421</internalId></linkedfrom><linkedfrom><srcid>Mka.ECUC_Mka_00028</srcid><srcstatus/><internalId>422</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.dsn.Cp.PacketNumber.SakUseLPn</srcid><srcstatus/><internalId>1485</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Cp.PacketNumber.UpdateLPn</srcid><srcstatus/><internalId>1502</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>966</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs" title="User callout function">
    <specobject>
      <id>Mka.dsn.Func0115.CallbackFunctions</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>955</sourceline>
      <version>1</version>
      <description>
          MKA shall support user callback functions.
          Supported user callback functions are:
            - Callback function for retrieving PAE statistics.
        </description>
      <furtherinfo>
          WRN.swdd.needscoverage.count - Linking all feature requirements to the single top-level
          requirement brings clear benefits and splitting them up would only increase complexity
          without any real improvements.
        </furtherinfo>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.EB.MkaHeaderFileInclusion_Conf</srcid><srcstatus/><internalId>1457</internalId></linkedfrom><linkedfrom><srcid>Mka.EB.MkaCallbacks_Conf</srcid><srcstatus/><internalId>1458</internalId></linkedfrom><linkedfrom><srcid>Mka.EB.MkaGetMacSecStatisticsCallback_Conf</srcid><srcstatus/><internalId>1459</internalId></linkedfrom><linkedfrom><srcid>Mka.EB.MkaSecYCallout_Conf</srcid><srcstatus/><internalId>1460</internalId></linkedfrom><linkedfrom><srcid>Mka.EB.MkaTaskCallout_Conf</srcid><srcstatus/><internalId>1461</internalId></linkedfrom><linkedfrom><srcid>Mka.EB.MkaReportEventCallout_Conf</srcid><srcstatus/><internalId>1462</internalId></linkedfrom><linkedfrom><srcid>Mka.EB.MkaSecYCallout</srcid><srcstatus/><internalId>1473</internalId></linkedfrom><linkedfrom><srcid>Mka.EB.MkaTaskCallout</srcid><srcstatus/><internalId>1474</internalId></linkedfrom><linkedfrom><srcid>Mka.EB.MkaReportEventCallout</srcid><srcstatus/><internalId>1475</internalId></linkedfrom><linkedfrom><srcid>Mka.EB.MkaReportEventCallout_Prototype</srcid><srcstatus/><internalId>1476</internalId></linkedfrom><linkedfrom><srcid>Mka.EB.MkaReportEventCallout_EventType</srcid><srcstatus/><internalId>1477</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.XDM.MkaSecYCallout_EmptyReference</srcid><srcstatus/><internalId>1680</internalId></linkedfrom><linkedfrom><srcid>Mka.XDM.MkaTaskCallout_EmptyReference</srcid><srcstatus/><internalId>1681</internalId></linkedfrom><linkedfrom><srcid>Mka.XDM.MkaReportEventCallout_EmptyReference</srcid><srcstatus/><internalId>1682</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>967</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs" title="MACsec bypass rules">
    <specobject>
      <id>Mka.dsn.Func0116.BypassRules</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>978</sourceline>
      <version>1</version>
      <description>
          MKA shall support MACsec bypass rules per PAE based on configured Ethertypes and VLAN IDs.
        </description>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.CP_SWS_Mka_00003</srcid><srcstatus/><internalId>298</internalId></linkedfrom><linkedfrom><srcid>Mka.CP_SWS_Mka_00004</srcid><srcstatus/><internalId>299</internalId></linkedfrom><linkedfrom><srcid>Mka.CP_SWS_Mka_91002</srcid><srcstatus/><internalId>362</internalId></linkedfrom><linkedfrom><srcid>Mka.ECUC_Mka_00016</srcid><srcstatus/><internalId>435</internalId></linkedfrom><linkedfrom><srcid>Mka.ECUC_Mka_00015</srcid><srcstatus/><internalId>436</internalId></linkedfrom><linkedfrom><srcid>Mka.XDM.KaY.MkaBypassEtherType_Repeating</srcid><srcstatus/><internalId>1636</internalId></linkedfrom><linkedfrom><srcid>Mka.XDM.KaY.MkaBypassVlan_Repeating</srcid><srcstatus/><internalId>1637</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.dsn.Cp.BypassEtherType.Empty</srcid><srcstatus/><internalId>1493</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Cp.BypassVlan.Empty</srcid><srcstatus/><internalId>1494</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>968</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs" title="Mka SecY retry">
    <specobject>
      <id>Mka.dsn.Func0117.SecYRetry</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>994</sourceline>
      <version>1</version>
      <description>
          MKA shall provide functionality to retry unsuccessful SecY API call for a specified number of times.
        </description>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.InterAct.Cp.SecYRetry_Exhausted</srcid><srcstatus/><internalId>1108</internalId></linkedfrom><linkedfrom><srcid>Mka.EB.MkaSecYRetryAttempts_Conf</srcid><srcstatus/><internalId>1442</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Cp.Retry</srcid><srcstatus/><internalId>1497</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Cp.Retry.NotRequired</srcid><srcstatus/><internalId>1498</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Cp.CpSM.Retry.CleanUp</srcid><srcstatus/><internalId>1499</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Cp.CpSM.Retry</srcid><srcstatus/><internalId>1500</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Cp.CpSM.NewSak</srcid><srcstatus/><internalId>1501</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.KaY.Retry.GetTxSaNextPn</srcid><srcstatus/><internalId>1585</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>969</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs" title="Mka extended production errors">
    <specobject>
      <id>Mka.dsn.Func0118.ProductionErrors</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>1009</sourceline>
      <version>1</version>
      <description>
          MKA shall support production errors.
        </description>
      <furtherinfo>
          WRN.swurs.needscoverage.count - Linking all feature requirements to the single top-level
          requirement brings clear benefits and splitting them up would only increase complexity
          without any real improvements.
        </furtherinfo>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.CP_SWS_Mka_00033</srcid><srcstatus/><internalId>352</internalId></linkedfrom><linkedfrom><srcid>Mka.CP_SWS_Mka_00034</srcid><srcstatus/><internalId>353</internalId></linkedfrom><linkedfrom><srcid>Mka.CP_SWS_Mka_00035</srcid><srcstatus/><internalId>354</internalId></linkedfrom><linkedfrom><srcid>Mka.CP_SWS_Mka_00036</srcid><srcstatus/><internalId>355</internalId></linkedfrom><linkedfrom><srcid>Mka.CP_SWS_Mka_00200</srcid><srcstatus/><internalId>357</internalId></linkedfrom><linkedfrom><srcid>Mka.CP_SWS_Mka_00201</srcid><srcstatus/><internalId>358</internalId></linkedfrom><linkedfrom><srcid>Mka.CP_SWS_Mka_00202</srcid><srcstatus/><internalId>359</internalId></linkedfrom><linkedfrom><srcid>Mka.CP_SWS_Mka_00203</srcid><srcstatus/><internalId>360</internalId></linkedfrom><linkedfrom><srcid>Mka.ECUC_Mka_00055</srcid><srcstatus/><internalId>456</internalId></linkedfrom><linkedfrom><srcid>Mka.ECUC_Mka_00059</srcid><srcstatus/><internalId>457</internalId></linkedfrom><linkedfrom><srcid>Mka.ECUC_Mka_00058</srcid><srcstatus/><internalId>458</internalId></linkedfrom><linkedfrom><srcid>Mka.ECUC_Mka_00057</srcid><srcstatus/><internalId>459</internalId></linkedfrom><linkedfrom><srcid>Mka.ECUC_Mka_00056</srcid><srcstatus/><internalId>460</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.EB.MkaReportEventCallout_Conf</srcid><srcstatus/><internalId>1462</internalId></linkedfrom><linkedfrom><srcid>Mka.EB.MkaReportEventCallout</srcid><srcstatus/><internalId>1475</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>970</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs" title="Mka run-time events">
    <specobject>
      <id>Mka.dsn.Func0119.RunTimeEvents</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>1030</sourceline>
      <version>1</version>
      <description>
          Mka module shall internally store events and errors that are relevant for module diagnostic and debugging.
          The events shall be stored in a compact form of a bit-fields.
        </description>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.EB.RunTimeEvent.BitFieldDefinition</srcid><srcstatus/><internalId>1478</internalId></linkedfrom><linkedfrom><srcid>Mka.EB.RunTimeEvent.TriggeredEventParticipant</srcid><srcstatus/><internalId>1479</internalId></linkedfrom><linkedfrom><srcid>Mka.EB.RunTimeEvent.TriggeredEventPae</srcid><srcstatus/><internalId>1480</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>971</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs" title="MACsec disabled">
    <specobject>
      <id>Mka.dsn.Func0120.MacSecDisabled</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>1046</sourceline>
      <version>1</version>
      <description>
          Mka module shall support the functionality to enable/disable MACsec protection on all configured PAEs.
          MACsec enable/disable status shall be changeable via external interface, stored in NvRam and
          processed in the next power-up cycle.
          MKA sequences shall be exchanged on all active participants even when MACsec is disabled.
        </description>
      <furtherinfo>
          WRN.swurs.needscoverage.count - Linking all feature requirements to the single top-level
          requirement brings clear benefits and splitting them up would only increase complexity
          without any real improvements.
        </furtherinfo>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.EB.KeyServerElection.27.2</srcid><srcstatus/><internalId>227</internalId></linkedfrom><linkedfrom><srcid>Mka.8021X.KeyServerElection.31</srcid><srcstatus/><internalId>231</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Api.EnableMacSec</srcid><srcstatus/><internalId>985</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Api.DisableMacSec</srcid><srcstatus/><internalId>986</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Api.GetMacSecEnabled</srcid><srcstatus/><internalId>987</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.InterAct.MkpduQueuing</srcid><srcstatus/><internalId>1079</internalId></linkedfrom><linkedfrom><srcid>Mka.InterAct.MacSecDisabled.EmptyParamSets</srcid><srcstatus/><internalId>1081</internalId></linkedfrom><linkedfrom><srcid>Mka.InterAct.MacSecDisabled.NoEmptyParamSets</srcid><srcstatus/><internalId>1082</internalId></linkedfrom><linkedfrom><srcid>Mka.InterAct.MacSecDisabled.EmptyParamSets.DelayTimer</srcid><srcstatus/><internalId>1083</internalId></linkedfrom><linkedfrom><srcid>Mka.EB.MkaEmptyDistributedSakUseEnabled_Conf</srcid><srcstatus/><internalId>1482</internalId></linkedfrom><linkedfrom><srcid>Mka.EB.Net_Sec_2158</srcid><srcstatus/><internalId>1484</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.KaY.MacSecEnabledStatus</srcid><srcstatus/><internalId>1590</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.KaY.MacSecDesired.Discard</srcid><srcstatus/><internalId>1591</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.KaY.MacSecDisabled.NoKeysNoSc</srcid><srcstatus/><internalId>1592</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>972</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs" title="Immediate MKPDU response">
    <specobject>
      <id>Mka.dsn.Func0121.ImmediateResponse</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>1070</sourceline>
      <version>1</version>
      <description>
          Mka module shall support the functionality to immediately respond on MKPDU received from a partner, in order to reduce
          start-up time.
        </description>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.EB.MkaEnableImmediatePeerResponse_Conf</srcid><srcstatus/><internalId>1463</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Cp.ImmediatePeerResponse.EmptySakUse</srcid><srcstatus/><internalId>1505</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.KaY.ImmediatePeerResponse.PeerSM</srcid><srcstatus/><internalId>1578</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.KaY.ImmediatePeerResponse.SakGenerated</srcid><srcstatus/><internalId>1579</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>973</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs" title="Disable non-principal participants">
    <specobject>
      <id>Mka.dsn.Func0122.DisableNonPrincipalParticipants</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>1086</sourceline>
      <version>1</version>
      <description>
          Mka module shall support the functionality to disable other active participants of a single PAE when the first successful
          participant is found.
        </description>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.dsn.Logon.ParticipantsRestartDisabled</srcid><srcstatus/><internalId>1601</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>974</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs" title="Caching the first successful participant and selected cipher">
    <specobject>
      <id>Mka.dsn.Func0123.CachingSuccessfulParticipant</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>1102</sourceline>
      <version>1</version>
      <description>
          Mka module shall support the functionality to cache the principal participant, selected cipher suite and confidentiality offset
          in order to speed up subsequent power-up cycles.
        </description>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.dsn.Logon.PaeLastSuccessfulPrincipal</srcid><srcstatus/><internalId>1603</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Logon.PaeLastSuccessfulPrincipalFailed</srcid><srcstatus/><internalId>1604</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>975</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs" title="Support for interrupt mode of operation">
    <specobject>
      <id>Mka.dsn.Func0124.InterruptMode</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>1118</sourceline>
      <version>1</version>
      <description>
          Mka module shall support working in interrupt mode, i.e. it shall enable external source to trigger Mka event processing outside
          of the context of scheduled Mka_MainFunction().
          This shall be achieved by providing optional external API, which triggers event processing.
        </description>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.EB.MkaSecYCallout_Conf</srcid><srcstatus/><internalId>1460</internalId></linkedfrom><linkedfrom><srcid>Mka.EB.MkaTaskCallout_Conf</srcid><srcstatus/><internalId>1461</internalId></linkedfrom><linkedfrom><srcid>Mka.EB.MkaHandleEventsApi_Conf</srcid><srcstatus/><internalId>1467</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.MkaExt.HandleEventsApi.MkaNotInitialized</srcid><srcstatus/><internalId>1471</internalId></linkedfrom><linkedfrom><srcid>Mka.EB.MkaSecYCallout</srcid><srcstatus/><internalId>1473</internalId></linkedfrom><linkedfrom><srcid>Mka.EB.MkaTaskCallout</srcid><srcstatus/><internalId>1474</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.dsn.Api.HandleEvents</srcid><srcstatus/><internalId>988</internalId></linkedfrom><linkedfrom><srcid>Mka.XDM.MkaSecYCallout_EmptyReference</srcid><srcstatus/><internalId>1680</internalId></linkedfrom><linkedfrom><srcid>Mka.XDM.MkaTaskCallout_EmptyReference</srcid><srcstatus/><internalId>1681</internalId></linkedfrom><linkedfrom><srcid>Mka.XDM.MkaReportEventCallout_EmptyReference</srcid><srcstatus/><internalId>1682</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>976</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs" title="Pre-shared ICK and KEK.">
    <specobject>
      <id>Mka.dsn.Func0124.PresharedIckKek</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>1136</sourceline>
      <version>1</version>
      <description>
          Mka module shall support use of pre-shared ICK and KEK, instead of deriving them from CAK.
        </description>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.EB.MkaUsePresharedIckKek_Conf</srcid><srcstatus/><internalId>1468</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Crypto.ValidatePresharedIckKek</srcid><srcstatus/><internalId>1557</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.CP_SWS_Mka_00022</srcid><srcstatus/><internalId>338</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>977</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs" title="Mka public interface requirements">
    <specobject>
      <id>Mka.dsn.Api.CsmRandomCallback</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>2663</sourceline>
      <version>1</version>
      <description>
              &lt;ul&gt;
                &lt;li&gt;Service Name:       Mka_CsmRandomCallback&lt;/li&gt;
                &lt;li&gt;
                  Syntax:             void Mka_CsmRandomCallback(
                                                                  const Crypto_JobType* job,
                                                                  Std_ReturnType        result
                                                                );
                &lt;/li&gt;
                &lt;li&gt;Service ID [hex]:   0x30&lt;/li&gt;
                &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
                &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
                &lt;li&gt;Parameters (in):    job             Holds a pointer to the job, which has finished.&lt;/li&gt;
                &lt;li&gt;Parameters (in):    result          Contains the result of the cryptographic operation.&lt;/li&gt;
                &lt;li&gt;Parameters (inout): None&lt;/li&gt;
                &lt;li&gt;Parameters (out):   None&lt;/li&gt;
                &lt;li&gt;Return value:       None&lt;/li&gt;
                &lt;li&gt;Description:        CSM notifies that a job for Random generation has finished (result of Mka_Crypto_RandomGenerateAsync).&lt;/li&gt;
                &lt;li&gt;Available via:      Mka_Crypto_Int.h&lt;/li&gt;
              &lt;/ul&gt;
            </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Crypto_Rng.c_96</srcid><srcstatus/><internalId>598</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>978</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Api.CsmKeyGenerateCallback</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>2694</sourceline>
      <version>1</version>
      <description>
              &lt;ul&gt;
                &lt;li&gt;Service Name:       Mka_CsmKeyGenerateCallback&lt;/li&gt;
                &lt;li&gt;
                  Syntax:             void Mka_CsmKeyGenerateCallback(
                                                                       const Crypto_JobType* job,
                                                                       Std_ReturnType        result
                                                                     );
                &lt;/li&gt;
                &lt;li&gt;Service ID [hex]:   0x31&lt;/li&gt;
                &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
                &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
                &lt;li&gt;Parameters (in):    job             Holds a pointer to the job, which has finished.&lt;/li&gt;
                &lt;li&gt;Parameters (in):    result          Contains the result of the cryptographic operation.&lt;/li&gt;
                &lt;li&gt;Parameters (inout): None&lt;/li&gt;
                &lt;li&gt;Parameters (out):   None&lt;/li&gt;
                &lt;li&gt;Return value:       None&lt;/li&gt;
                &lt;li&gt;Description:        CSM notifies that a job for Key generation has finished.&lt;/li&gt;
                &lt;li&gt;Available via:      Mka_Crypto_Int.h&lt;/li&gt;
              &lt;/ul&gt;
            </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Crypto_KeyGen.c_189</srcid><srcstatus/><internalId>591</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>979</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Api.CsmIcvGenerateCallback</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>2725</sourceline>
      <version>1</version>
      <description>
              &lt;ul&gt;
                &lt;li&gt;Service Name:       Mka_CsmIcvGenerateCallback&lt;/li&gt;
                &lt;li&gt;
                  Syntax:             void Mka_CsmIcvGenerateCallback(
                                                                       const Crypto_JobType* job,
                                                                       Std_ReturnType        result
                                                                     );
                &lt;/li&gt;
                &lt;li&gt;Service ID [hex]:   0x32&lt;/li&gt;
                &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
                &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
                &lt;li&gt;Parameters (in):    job             Holds a pointer to the job, which has finished.&lt;/li&gt;
                &lt;li&gt;Parameters (in):    result          Contains the result of the cryptographic operation.&lt;/li&gt;
                &lt;li&gt;Parameters (inout): None&lt;/li&gt;
                &lt;li&gt;Parameters (out):   None&lt;/li&gt;
                &lt;li&gt;Return value:       None&lt;/li&gt;
                &lt;li&gt;Description:        CSM notifies that a job for ICV generation has finished (result of Mka_Crypto_IcvGenerateAsync).&lt;/li&gt;
                &lt;li&gt;Available via:      Mka_Crypto_Int.h&lt;/li&gt;
              &lt;/ul&gt;
            </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Crypto_Icv.c_121</srcid><srcstatus/><internalId>587</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>980</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Api.CsmHashGenerateCallback</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>2756</sourceline>
      <version>1</version>
      <description>
              &lt;ul&gt;
                &lt;li&gt;Service Name:       Mka_CsmHashGenerateCallback&lt;/li&gt;
                &lt;li&gt;
                  Syntax:             void Mka_CsmHashGenerateCallback(
                                                                       const Crypto_JobType* job,
                                                                       Std_ReturnType        result
                                                                     );
                &lt;/li&gt;
                &lt;li&gt;Service ID [hex]:   0x33&lt;/li&gt;
                &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
                &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
                &lt;li&gt;Parameters (in):    job             Holds a pointer to the job, which has finished.&lt;/li&gt;
                &lt;li&gt;Parameters (in):    result          Contains the result of the cryptographic operation.&lt;/li&gt;
                &lt;li&gt;Parameters (inout): None&lt;/li&gt;
                &lt;li&gt;Parameters (out):   None&lt;/li&gt;
                &lt;li&gt;Return value:       None&lt;/li&gt;
                &lt;li&gt;Description:        CSM notifies that a job for Hash generation has finished (result of Crypto_GenerateHash).&lt;/li&gt;
                &lt;li&gt;Available via:      Mka_Crypto_Int.h&lt;/li&gt;
              &lt;/ul&gt;
            </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Crypto_KeyWrap.c_271</srcid><srcstatus/><internalId>596</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>981</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Api.CsmIcvVerifyCallback</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>2787</sourceline>
      <version>1</version>
      <description>
              &lt;ul&gt;
                &lt;li&gt;Service Name:       Mka_CsmIcvVerifyCallback&lt;/li&gt;
                &lt;li&gt;
                  Syntax:             void Mka_CsmIcvVerifyCallback(
                                                                     const Crypto_JobType* job,
                                                                     Std_ReturnType        result
                                                                   );
                &lt;/li&gt;
                &lt;li&gt;Service ID [hex]:   0x34&lt;/li&gt;
                &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
                &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
                &lt;li&gt;Parameters (in):    job             Holds a pointer to the job, which has finished.&lt;/li&gt;
                &lt;li&gt;Parameters (in):    result          Contains the result of the cryptographic operation.&lt;/li&gt;
                &lt;li&gt;Parameters (inout): None&lt;/li&gt;
                &lt;li&gt;Parameters (out):   None&lt;/li&gt;
                &lt;li&gt;Return value:       None&lt;/li&gt;
                &lt;li&gt;Description:        CSM notifies that a job for ICV verification has finished (result of Mka_Crypto_IcvVerifyAsync).&lt;/li&gt;
                &lt;li&gt;Available via:      Mka_Crypto_Int.h&lt;/li&gt;
              &lt;/ul&gt;
            </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Crypto_Icv.c_159</srcid><srcstatus/><internalId>588</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>982</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Api.CsmKeyWrapCallback</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>2818</sourceline>
      <version>1</version>
      <description>
              &lt;ul&gt;
                &lt;li&gt;Service Name:       Mka_CsmKeyWrapCallback&lt;/li&gt;
                &lt;li&gt;
                  Syntax:             void Mka_CsmKeyWrapCallback(
                                                                   const Crypto_JobType* job,
                                                                   Std_ReturnType        result
                                                                 );
                &lt;/li&gt;
                &lt;li&gt;Service ID [hex]:   0x35&lt;/li&gt;
                &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
                &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
                &lt;li&gt;Parameters (in):    job             Holds a pointer to the job, which has finished.&lt;/li&gt;
                &lt;li&gt;Parameters (in):    result          Contains the result of the cryptographic operation.&lt;/li&gt;
                &lt;li&gt;Parameters (inout): None&lt;/li&gt;
                &lt;li&gt;Parameters (out):   None&lt;/li&gt;
                &lt;li&gt;Return value:       None&lt;/li&gt;
                &lt;li&gt;Description:        CSM notifies that a job for Key wrap has finished (result of Mka_Crypto_SakGenWrapAsync).&lt;/li&gt;
                &lt;li&gt;Available via:      Mka_Crypto_Int.h&lt;/li&gt;
              &lt;/ul&gt;
            </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Crypto_KeyWrap.c_189</srcid><srcstatus/><internalId>594</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>983</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Api.CsmKeyUnwrapCallback</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>2849</sourceline>
      <version>1</version>
      <description>
              &lt;ul&gt;
                &lt;li&gt;Service Name:       Mka_CsmKeyUnwrapCallback&lt;/li&gt;
                &lt;li&gt;
                  Syntax:             void Mka_CsmKeyUnwrapCallback(
                                                                     const Crypto_JobType* job,
                                                                     Std_ReturnType        result
                                                                   );
                &lt;/li&gt;
                &lt;li&gt;Service ID [hex]:   0x36&lt;/li&gt;
                &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
                &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
                &lt;li&gt;Parameters (in):    job             Holds a pointer to the job, which has finished.&lt;/li&gt;
                &lt;li&gt;Parameters (in):    result          Contains the result of the cryptographic operation.&lt;/li&gt;
                &lt;li&gt;Parameters (inout): None&lt;/li&gt;
                &lt;li&gt;Parameters (out):   None&lt;/li&gt;
                &lt;li&gt;Return value:       None&lt;/li&gt;
                &lt;li&gt;Description:        CSM notifies that a job for Key unwrap has finished (result of Mka_Crypto_SakUnwrapAsync).&lt;/li&gt;
                &lt;li&gt;Available via:      Mka_Crypto_Int.h&lt;/li&gt;
              &lt;/ul&gt;
            </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Crypto_KeyWrap.c_230</srcid><srcstatus/><internalId>595</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>984</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Api.EnableMacSec</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>2880</sourceline>
      <version>1</version>
      <description>
              &lt;ul&gt;
                &lt;li&gt;Service Name:       Mka_EnableMacSec&lt;/li&gt;
                &lt;li&gt;Syntax:             void Mka_EnableMacSec(void);&lt;/li&gt;
                &lt;li&gt;Service ID [hex]:   0xA0&lt;/li&gt;
                &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
                &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
                &lt;li&gt;Parameters (in):    None&lt;/li&gt;
                &lt;li&gt;Parameters (inout): None&lt;/li&gt;
                &lt;li&gt;Parameters (out):   None&lt;/li&gt;
                &lt;li&gt;Return value:       None&lt;/li&gt;
                &lt;li&gt;
                  Description:        Enables MACsec for all configured PAEs. The status shall be stored in NvR and processed in the next
                                      power-up cycle.
                &lt;/li&gt;
                &lt;li&gt;Available via:      Mka.h&lt;/li&gt;
              &lt;/ul&gt;
            </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Ext.c.m4_799</srcid><srcstatus/><internalId>615</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01001_PeerList_TxPotentFirst</srcid><srcstatus/><internalId>1689</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0120.MacSecDisabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>972</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>985</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Api.DisableMacSec</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>2915</sourceline>
      <version>1</version>
      <description>
              &lt;ul&gt;
                &lt;li&gt;Service Name:       Mka_DisableMacSec&lt;/li&gt;
                &lt;li&gt;Syntax:             void Mka_DisableMacSec(void);&lt;/li&gt;
                &lt;li&gt;Service ID [hex]:   0xA1&lt;/li&gt;
                &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
                &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
                &lt;li&gt;Parameters (in):    None&lt;/li&gt;
                &lt;li&gt;Parameters (inout): None&lt;/li&gt;
                &lt;li&gt;Parameters (out):   None&lt;/li&gt;
                &lt;li&gt;Return value:       None&lt;/li&gt;
                &lt;li&gt;
                  Description:          Disables MACsec for all configured PAEs. The status shall be stored in NvR and processed in the next
                                        power-up cycle.
                &lt;/li&gt;
                &lt;li&gt;Available via:      Mka.h&lt;/li&gt;
              &lt;/ul&gt;
            </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Ext.c.m4_820</srcid><srcstatus/><internalId>617</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01028_PlainText_KeyServer</srcid><srcstatus/><internalId>1717</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0120.MacSecDisabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>972</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>986</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Api.GetMacSecEnabled</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>2950</sourceline>
      <version>1</version>
      <description>
              &lt;ul&gt;
                &lt;li&gt;Service Name:       Mka_GetMacSecEnabled&lt;/li&gt;
                &lt;li&gt;Syntax:             Std_ReturnType Mka_GetMacSecEnabled(boolean* StatusPtr);&lt;/li&gt;
                &lt;li&gt;Service ID [hex]:   0xA3&lt;/li&gt;
                &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
                &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
                &lt;li&gt;Parameters (in):    None&lt;/li&gt;
                &lt;li&gt;Parameters (inout): None&lt;/li&gt;
                &lt;li&gt;Parameters (out):   StatusPtr       TRUE      MacSec is enabled.
                                                        FALSE     MacSec is disabled.&lt;/li&gt;
                &lt;li&gt;Return value:
                  Return value:         Std_ReturnType  E_OK:     Request successful.
                                                        E_NOT_OK: Request failed.
                &lt;/li&gt;
                &lt;li&gt;
                  Description:          Gets the status of MacSecEnabled from the NvR.
                &lt;/li&gt;
                &lt;li&gt;Available via:      Mka.h&lt;/li&gt;
              &lt;/ul&gt;
            </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Ext.c.m4_841</srcid><srcstatus/><internalId>619</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01001_PeerList_TxPotentFirst</srcid><srcstatus/><internalId>1689</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0120.MacSecDisabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>972</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>987</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Api.HandleEvents</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>2988</sourceline>
      <version>1</version>
      <description>
              &lt;ul&gt;
                &lt;li&gt;Service Name:       Mka_HandleEvents&lt;/li&gt;
                &lt;li&gt;Syntax:             void Mka_HandleEvents(void);&lt;/li&gt;
                &lt;li&gt;Service ID [hex]:   0xA2&lt;/li&gt;
                &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
                &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
                &lt;li&gt;Parameters (in):    None&lt;/li&gt;
                &lt;li&gt;Parameters (inout): None&lt;/li&gt;
                &lt;li&gt;Parameters (out):   None&lt;/li&gt;
                &lt;li&gt;
                  Description:          This service requests Mka to process received external events, e.g. crypto stack notifications or SecY
                                        notifications.
                &lt;/li&gt;
                &lt;li&gt;Available via:      Mka.h when MkaHandleEventsApi configuration parameter is enabled.&lt;/li&gt;
              &lt;/ul&gt;
            </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Ext.c.m4_235</srcid><srcstatus/><internalId>601</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_UnitTest01053_HandleEvents_MkaNotInitialized</srcid><srcstatus/><internalId>2312</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0124.InterruptMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>976</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>988</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs" title="KaY unit interface requirements">
    <specobject>
      <id>Mka.dsn.KaY.Api.Init</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>3796</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_KaY_Init&lt;/li&gt;
              &lt;li&gt;Syntax:             void Mka_KaY_Init(void);&lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    None&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;Return value:       None&lt;/li&gt;
              &lt;li&gt;Description:        This service initializes all global variables and state machines of the KaY unit.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_KaY_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01001_Initialization</srcid><srcstatus/><internalId>2071</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_892</srcid><srcstatus/><internalId>621</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>989</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.Api.CreateParticipant</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>3821</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_KaY_CreateParticipant&lt;/li&gt;
              &lt;li&gt;
                  Syntax:             Std_ReturnType Mka_KaY_CreateParticipant(
                                                                                uint8 ParticipantIdx
                                                                              );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    ParticipantIdx      Mka instance handle.&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;
                Return value:       Std_ReturnType      E_OK:     Request successful.
                                                        E_NOT_OK: Request failed.
              &lt;/li&gt;
              &lt;li&gt;Description:        This service requests creation of a new MKA instance.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_KaY_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01002_CreateParticipant</srcid><srcstatus/><internalId>2072</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_927</srcid><srcstatus/><internalId>622</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>990</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.Api.DeleteParticipant</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>3853</sourceline>
      <version>2</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_KaY_DeleteParticipant&lt;/li&gt;
              &lt;li&gt;
                  Syntax:             void Mka_KaY_DeleteParticipant(
                                                                   uint8 ParticipantIdx
                                                                 );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    ParticipantIdx      Mka instance handle.&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;Return value:       None&lt;/li&gt;
              &lt;li&gt;
                Description:        This service requests MKA participant deletion. All related state machines are initialized and
                                    allocated resources freed (running timers and active crypto operations stopped).
              &lt;/li&gt;
              &lt;li&gt;Available via:      Mka_KaY_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01003_DeleteInstance</srcid><srcstatus/><internalId>2073</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01090_DeleteInstance_Potential</srcid><srcstatus/><internalId>2158</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_959</srcid><srcstatus/><internalId>623</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>991</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.Api.SetPrincipalActor</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>3885</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_KaY_SetPrincipalActor&lt;/li&gt;
              &lt;li&gt;
                  Syntax:             Std_ReturnType Mka_KaY_SetPrincipalActor(
                                                                                uint8 ParticipantIdx
                                                                              );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    ParticipantIdx      Participant handle.&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;
                Return value:       Std_ReturnType      E_OK:     Request successful.
                                                        E_NOT_OK: Request failed.
              &lt;/li&gt;
              &lt;li&gt;Description:        This service sets referenced instance as port principal actor.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_KaY_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01004_SetPrincipalActor</srcid><srcstatus/><internalId>2074</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_975</srcid><srcstatus/><internalId>624</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>992</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.Api.LinkStateActive</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>3917</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_KaY_LinkStateActive&lt;/li&gt;
              &lt;li&gt;
                  Syntax:             void Mka_KaY_LinkStateActive(
                                                                    uint8 ParticipantIdx
                                                                  );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    ParticipantIdx      Mka instance handle.&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;Return value:       None&lt;/li&gt;
              &lt;li&gt;Description:        This service indicates to KaY that link state is active for the given participant idx.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_KaY_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01017_InstSM_WaitFirstMemberId2Running</srcid><srcstatus/><internalId>2085</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_1463</srcid><srcstatus/><internalId>651</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>993</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.Api.GetConnectionStatus</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>3946</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_KaY_GetConnectionStatus&lt;/li&gt;
              &lt;li&gt;
                  Syntax:             Mka_MkaStatusType Mka_KaY_GetConnectionStatus(
                                                                                      uint8 ParticipantIdx
                                                                                    );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    ParticipantIdx      Mka instance handle.&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;Return value:       Mka_MkaStatusType   ConnectionStatus of selected ParticipantIdx.&lt;/li&gt;
              &lt;li&gt;Description:        This service returns the connection status of selected participant.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_KaY_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01085_GetParticipantStatus</srcid><srcstatus/><internalId>2153</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_1487</srcid><srcstatus/><internalId>652</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>994</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.Api.GetCknPeerSci</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>3975</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_KaY_GetCknPeerSci&lt;/li&gt;
              &lt;li&gt;
                  Syntax:             void Mka_KaY_GetCknPeerSci(
                                                                  uint8              ParticipantIdx,
                                                                  Mka_PaeStatusType* PaeStatusPtr
                                                                );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    ParticipantIdx      Mka instance handle.&lt;/li&gt;
              &lt;li&gt;Parameters (in):    PaeStatus           Pointer to PaeStatusType that KaY shall fill.&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;Return value:       void&lt;/li&gt;
              &lt;li&gt;Description:        This service fills PaeStatusPtr structure's Ckn and PeerSci for selected ParticipantIdx.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_KaY_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01085_GetParticipantStatus</srcid><srcstatus/><internalId>2153</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_1520</srcid><srcstatus/><internalId>653</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>995</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.Api.RandomGenerateFinished</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>4006</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_KaY_RandomGenerateFinished&lt;/li&gt;
              &lt;li&gt;
                  Syntax:             Std_ReturnType Mka_KaY_RandomGenerateFinished(
                                                                                     uint8          ParticipantIdx,
                                                                                     Std_ReturnType Result,
                                                                                     const uint8*   RandomDataPtr,
                                                                                     uint32         RandomDataLength
                                                                                   );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    ParticipantIdx      Mka instance handle.&lt;/li&gt;
              &lt;li&gt;
                  Parameters (in):    Result              E_OK       Random value successfully generated.
                                                          E_NOT_OK   Random generation failed.
              &lt;/li&gt;
              &lt;li&gt;Parameters (in):    RandomDataPtr       Pointer to the generated random value.&lt;/li&gt;
              &lt;li&gt;Parameters (in):    RandomDataLength    Random number length.&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;Return value:       None&lt;/li&gt;
              &lt;li&gt;Description:        This service reports that random generation has finished.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_KaY_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01005_RandomGenerateFinished_E_OK</srcid><srcstatus/><internalId>2075</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_1009</srcid><srcstatus/><internalId>627</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>996</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.Api.SakUnwrapFinished</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>4044</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_KaY_SakUnwrapFinished&lt;/li&gt;
              &lt;li&gt;
                  Syntax:             void Mka_KaY_SakUnwrapFinished(
                                                                      uint8          ParticipantIdx,
                                                                      Std_ReturnType Result,
                                                                      uint32         SakKeyId,
                                                                      uint8          SakLength
                                                                    );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    ParticipantIdx      Mka instance handle.&lt;/li&gt;
              &lt;li&gt;
                  Parameters (in):    Result              E_OK       SAK unwrap successfully done.
                                                          E_NOT_OK   SAK unwrapping failed.
              &lt;/li&gt;
              &lt;li&gt;Parameters (in):    SakKeyId            Csm key id where SAK is stored.&lt;/li&gt;
              &lt;li&gt;Parameters (in):    SakLength           SAK length.&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;Return value:       None&lt;/li&gt;
              &lt;li&gt;Description:        This service reports that the key unwrap is finished.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_KaY_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01043_KeySm_Disabled2WaitSakDistribution</srcid><srcstatus/><internalId>2111</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01116_KeySm_Disabled2WaitSakDistribution_PresharedKek</srcid><srcstatus/><internalId>2184</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_1121</srcid><srcstatus/><internalId>632</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>997</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.Api.SakGenWrapFinished</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>4082</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_KaY_SakGenWrapFinished&lt;/li&gt;
              &lt;li&gt;
                  Syntax:             void Mka_KaY_SakGenWrapFinished(
                                                                       uint8          ParticipantIdx,
                                                                       Std_ReturnType Result,
                                                                       const uint8*   WrapDataPtr,
                                                                       uint32         WrapDataLength,
                                                                       uint32         SakKeyId,
                                                                       uint8          SakLength
                                                                     );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    ParticipantIdx      Mka instance handle.&lt;/li&gt;
              &lt;li&gt;
                  Parameters (in):    Result              E_OK       SAK generated and wrapped successfully.
                                                          E_NOT_OK   SAK generation or wrapping failed.
              &lt;/li&gt;
              &lt;li&gt;Parameters (in):    WrapDataPtr         Pointer to the wrapped SAK.&lt;/li&gt;
              &lt;li&gt;Parameters (in):    WrapDataLength      Wrapped SAK length.&lt;/li&gt;
              &lt;li&gt;Parameters (in):    SakKeyId            Key id of generated SAK in Csm.&lt;/li&gt;
              &lt;li&gt;Parameters (in):    SakLength           SAK length.&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;Return value:       None&lt;/li&gt;
              &lt;li&gt;Description:        This service reports that SAK generation and its wrap is done (result of Mka_Crypto_KeyWrapAsync).&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_KaY_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01042_KeySm_Disabled2GenerateNewSak</srcid><srcstatus/><internalId>2110</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_1161</srcid><srcstatus/><internalId>633</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>998</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.Api.KekGenerateFinished</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>4124</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_KaY_KekGenerateFinished&lt;/li&gt;
              &lt;li&gt;
                  Syntax:             void Mka_KaY_KekGenerateFinished(
                                                                        uint8          ParticipantIdx,
                                                                        Std_ReturnType Result
                                                                      );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    ParticipantIdx      Mka instance handle.&lt;/li&gt;
              &lt;li&gt;
                  Parameters (in):    Result              E_OK       Random generation is successful.
                                                          E_NOT_OK   Random generation failed.
              &lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;Return value:       None&lt;/li&gt;
              &lt;li&gt;Description:        This service reports that Random generation of KEK is done (result of Mka_Crypto_KekGenerateAsync).&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_KaY_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_1079</srcid><srcstatus/><internalId>629</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>999</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.Api.RxMkpdu</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>4157</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_KaY_RxMkpdu&lt;/li&gt;
              &lt;li&gt;
                  Syntax:             void Mka_KaY_RxMkpdu(
                                                            uint8  ParticipantIdx,
                                                            uint8* MkpduPtr,
                                                            uint16 MkpduSize
                                                          );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    ParticipantIdx      Mka instance handle.&lt;/li&gt;
              &lt;li&gt;Parameters (in):    MkpduPtr            Pointer to location where MKPDU is stored (starting with Basic parameter set).&lt;/li&gt;
              &lt;li&gt;Parameters (in):    MkpduSize           MKPDU size (excluding ICV field).&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;Return value:       None&lt;/li&gt;
              &lt;li&gt;Description:        This service reports reports reception of validated MKPDU.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_KaY_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01018_InstSM_RunningSelfTransition</srcid><srcstatus/><internalId>2086</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01107_RxMkpdu_ElectedPartner_MacSecDisabled</srcid><srcstatus/><internalId>2175</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01108_RxMkpdu_CheckPeerListMN_Failure</srcid><srcstatus/><internalId>2176</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_1213</srcid><srcstatus/><internalId>636</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1000</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.Api.NewInfo</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>4190</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_KaY_NewInfo&lt;/li&gt;
              &lt;li&gt;
                  Syntax:             void Mka_KaY_NewInfo(
                                                            uint8 MkaPaeIdx
                                                          );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    MkaPaeIdx             Mka controlled port handle.&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;Description:        This service transmission of a new MKPDU for MKA instance in control of a specified port.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_KaY_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01098_KaY_NewInfo</srcid><srcstatus/><internalId>2166</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_1265</srcid><srcstatus/><internalId>639</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1001</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.Api.TimerCallback_TxMkpdu</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>4218</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_KaY_TimerCallback_TxMkpdu&lt;/li&gt;
              &lt;li&gt;
                  Syntax:             void Mka_KaY_TimerCallback_TxMkpdu(
                                                                          EcuC_Timers_GroupIdxType GroupIdx,
                                                                          EcuC_Timers_TimerIdxType TimerIdxInGroup
                                                                        );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    GroupIdx            Timer group index.&lt;/li&gt;
              &lt;li&gt;Parameters (in):    TimerIdxInGroup     Timer index in group (ParticipantIdx).&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;Return value:       None&lt;/li&gt;
              &lt;li&gt;Description:        This service indicates that periodic MKPDU transmission timer has expired.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_KaY_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01013_NoTransmit_InstanceDisabled</srcid><srcstatus/><internalId>2081</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_1286</srcid><srcstatus/><internalId>640</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1002</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.Api.TimerCallback_PeerLifeTimeout</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>4249</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_KaY_TimerCallback_PeerLifeTimeout&lt;/li&gt;
              &lt;li&gt;
                  Syntax:             void Mka_KaY_TimerCallback_PeerLifeTimeout(
                                                                                  EcuC_Timers_GroupIdxType GroupIdx,
                                                                                  EcuC_Timers_TimerIdxType TimerIdxInGroup
                                                                                );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    GroupIdx            Timer group index.&lt;/li&gt;
              &lt;li&gt;Parameters (in):    TimerIdxInGroup     Timer index in group (ParticipantIdx).&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;Return value:       None&lt;/li&gt;
              &lt;li&gt;Description:        This service indicates that peer life timer has expired.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_KaY_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01024_PeerSM_Init2Undetected2Potent2Live</srcid><srcstatus/><internalId>2092</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_1326</srcid><srcstatus/><internalId>641</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1003</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.Api.TimerCallback_NewSakDelay</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>4280</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_KaY_TimerCallback_NewSakDelay&lt;/li&gt;
              &lt;li&gt;
                  Syntax:             void Mka_KaY_TimerCallback_NewSakDelay(
                                                                              EcuC_Timers_GroupIdxType GroupIdx,
                                                                              EcuC_Timers_TimerIdxType TimerIdxInGroup
                                                                            );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    GroupIdx            Timer group index.&lt;/li&gt;
              &lt;li&gt;Parameters (in):    TimerIdxInGroup     Timer index in group (ParticipantIdx).&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;Return value:       None&lt;/li&gt;
              &lt;li&gt;Description:        This service indicates that timer for SAK generation delay has expired.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_KaY_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01066_SakReKey_LkPnExhaustion</srcid><srcstatus/><internalId>2134</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_1347</srcid><srcstatus/><internalId>642</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1004</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.Api.TimerCallback_MkaSakRekeyTimeSpan</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>4311</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_KaY_TimerCallback_MkaSakRekeyTimeSpan&lt;/li&gt;
              &lt;li&gt;
                  Syntax:             void Mka_KaY_TimerCallback_MkaSakRekeyTimeSpan(
                                                                                      EcuC_Timers_GroupIdxType GroupIdx,
                                                                                      EcuC_Timers_TimerIdxType TimerIdxInGroup
                                                                                    );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    GroupIdx            Timer group index.&lt;/li&gt;
              &lt;li&gt;Parameters (in):    TimerIdxInGroup     Timer index in group (ParticipantIdx).&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;Return value:       None&lt;/li&gt;
              &lt;li&gt;Description:        This service indicates that timer for generation of new SAK has expired.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_KaY_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01076_TimerSakRekey</srcid><srcstatus/><internalId>2144</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_1371</srcid><srcstatus/><internalId>643</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1005</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.Api.PnExhausted</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>4342</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_KaY_PnExhausted&lt;/li&gt;
              &lt;li&gt;
                  Syntax:             void Mka_KaY_PnExhausted(
                                                                uint8 MkaPaeIdx
                                                              );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    MkaPaeIdx           PAE index.&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;Return value:       None&lt;/li&gt;
              &lt;li&gt;Description:        Function call indicates that the PN has reached the PN_Exhaustion threshold.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_KaY_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_1396</srcid><srcstatus/><internalId>648</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Cp_UnitTest01028_PnExhausted</srcid><srcstatus/><internalId>1840</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01042_KeySm_Disabled2GenerateNewSak</srcid><srcstatus/><internalId>2110</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01115_KeySm_Disabled2GenerateNewSak_PresharedKek</srcid><srcstatus/><internalId>2183</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1006</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.Api.AllReceiving</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>4371</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_KaY_AllReceiving&lt;/li&gt;
              &lt;li&gt;
                  Syntax:             void Mka_KaY_AllReceiving(
                                                                 uint8 MkaPaeIdx
                                                               );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    MkaPaeIdx           PAE index.&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;Return value:       None&lt;/li&gt;
              &lt;li&gt;Description:        Function call indicates that the partner has installed the Sak and had set L_Rx in MacSec SakUse parameter set.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_KaY_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_1418</srcid><srcstatus/><internalId>649</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1007</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.Api.SendQueuedMkpdus</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>4399</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_KaY_SendQueuedMkpdus&lt;/li&gt;
              &lt;li&gt;Syntax:             void Mka_KaY_SendQueuedMkpdus(void);&lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    None&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;Return value:       None&lt;/li&gt;
              &lt;li&gt;Description:        This services process MKPDU transmission if global MKPDU parameter is set.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_KaY_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_1540</srcid><srcstatus/><internalId>654</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01103_SendQueuedMkpdus_EmptyQueue</srcid><srcstatus/><internalId>2171</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1008</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.Api.PeerPlainText</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>4424</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_KaY_PeerPlainText&lt;/li&gt;
              &lt;li&gt;
                  Syntax:             void Mka_KaY_PeerPlainText(
                                                                  uint8 MkaPaeIdx
                                                                );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    MkaPaeIdx           PAE index.&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;Return value:       None&lt;/li&gt;
              &lt;li&gt;Description:        Function call indicates that the peer is transmitting and receiving plain text.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_KaY_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_1440</srcid><srcstatus/><internalId>650</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01105_PeerPlainText_ParticipantIsNull</srcid><srcstatus/><internalId>2173</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01106_PeerPlainText_ParticipantNotKeyServer</srcid><srcstatus/><internalId>2174</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1009</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs" title="CP unit interface requirements">
    <specobject>
      <id>Mka.dsn.Cp.Api.Init</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>4457</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_Cp_Init&lt;/li&gt;
              &lt;li&gt;Syntax:             void Mka_Cp_Init(void);&lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    None&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;Return value:       None&lt;/li&gt;
              &lt;li&gt;Description:        This service initializes all global variables of the Cp unit.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_Cp_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Cp_UnitTest01001_CpSM_Uninit2Secured</srcid><srcstatus/><internalId>1813</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Cp.c_1038</srcid><srcstatus/><internalId>535</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1010</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Cp.Api.MainFunction</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>4482</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_Cp_MainFunction&lt;/li&gt;
              &lt;li&gt;Syntax:             void Mka_Cp_MainFunction(void);&lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    None&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;Return value:       None&lt;/li&gt;
              &lt;li&gt;Description:        This service executes Cp unit tasks periodically.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_Cp_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Cp_UnitTest01001_CpSM_Uninit2Secured</srcid><srcstatus/><internalId>1813</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Cp.c_1061</srcid><srcstatus/><internalId>536</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1011</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Cp.Api.NewSak</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>4507</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_Cp_NewSak&lt;/li&gt;
              &lt;li&gt;
                  Syntax:             void Mka_Cp_NewSak(
                                                          uint8        MkaPaeIdx,
                                                          KaY_SakType* DistributedSakPtr,
                                                          uint8        Ssci,
                                                          boolean      ElectedSelf
                                                        );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    MkaPaeIdx             Mka instance handle.&lt;/li&gt;
              &lt;li&gt;Parameters (in):    DistributedSakPtr     Pointer to a structure holding new SAK and related data.&lt;/li&gt;
              &lt;li&gt;Parameters (in):    Ssci                  Ssci value of participant, 0 if XPN is not enabled.&lt;/li&gt;
              &lt;li&gt;Parameters (in):    ElectedSelf           Indicates if Pae's principal actor has been elected as Key server.&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;Return value:       void&lt;/li&gt;
              &lt;li&gt;Description:        This service indicates that the new SAK is available.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_Cp_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Cp_UnitTest01002_CpSM_Secured2WaitAddTxSa</srcid><srcstatus/><internalId>1814</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Cp.c_1082</srcid><srcstatus/><internalId>537</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1012</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Cp.Api.ProcessSakUse</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>4542</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_Cp_ProcessSakUse&lt;/li&gt;
              &lt;li&gt;
                  Syntax:             void Mka_Cp_ProcessSakUse(
                                                                 uint8                MkaPaeIdx,
                                                                 const Mka_MkpduType* MkpduPtr
                                                               );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    MkaPaeIdx             Mka port instance handle.&lt;/li&gt;
              &lt;li&gt;Parameters (in):    MkpduPtr              Pointer to received Mkpdu.&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;Return value:       void&lt;/li&gt;
              &lt;li&gt;
                  Description:        This service checks if the Pn has been exhausted, does the XPN recovery, updates the RxSa PacketNumber in the SecY and updates
                                      the MacSecOperational status.
              &lt;/li&gt;
              &lt;li&gt;Available via:      Mka_Cp_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Cp_UnitTest01003_CpSM_Receiving2Transmitting</srcid><srcstatus/><internalId>1815</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01006_CpSM_Ready2Retire_2ndLoop</srcid><srcstatus/><internalId>1818</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Cp.c_1525</srcid><srcstatus/><internalId>549</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1013</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Cp.Api.CheckAllReceivingServerTransmittingPlainText</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>4576</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_Cp_CheckAllReceivingServerTransmittingPlainText&lt;/li&gt;
              &lt;li&gt;
                  Syntax:             void Mka_Cp_CheckAllReceivingServerTransmittingPlainText(
                                                                                                uint8                MkaPaeIdx,
                                                                                                const Mka_MkpduType* MkpduPtr
                                                                                              );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    MkaPaeIdx             Mka port instance handle.&lt;/li&gt;
              &lt;li&gt;Parameters (in):    MkpduPtr              Pointer to received Mkpdu.&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;Return value:       void&lt;/li&gt;
              &lt;li&gt;
                  Description:        This service checks if the peer is receiving and/or transmitting with the newest key or transmitting and
                                      receiving plain text.
              &lt;/li&gt;
              &lt;li&gt;Available via:      Mka_Cp_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Cp_UnitTest01003_CpSM_Receiving2Transmitting</srcid><srcstatus/><internalId>1815</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Cp.c_1446</srcid><srcstatus/><internalId>547</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1014</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Cp.Api.FillSakUse</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>4610</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_Cp_FillSakUse&lt;/li&gt;
              &lt;li&gt;
                  Syntax:             Std_ReturnType Mka_Cp_FillSakUse(
                                                                        uint8   MkaPaeIdx,
                                                                        uint8** BufPtrPtr,
                                                                        uint16* BufSizePtr
                                                                      );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    MkaPaeIdx             Controlled port handle for which SAK use parameter set shall be generated.&lt;/li&gt;
              &lt;li&gt;
                  Parameters (inout): BufPtrPtr             On call the pointer to the memory location where parameter set shall be stored.
                                                            On exit, it shall point to the location where the next parameter set shall be stored.
              &lt;/li&gt;
              &lt;li&gt;
                  Parameters (inout): BufSizePtr            On call, available buffer size.
                                                            On exit, the remaining size of the buffer after parameter set was copied.
              &lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;
                  Return value:       Std_ReturnType        E_OK:     Request successful.
                                                            E_NOT_OK: Request failed (call to EthIf API failed with E_NOT_OK).
              &lt;/li&gt;
              &lt;li&gt;Description:        This service generates SAK Use parameter set for a specified port and stores it into provided buffer.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_Cp_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Cp_UnitTest01027_FillSakUse</srcid><srcstatus/><internalId>1839</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01082_FillSakUse_ENotOk</srcid><srcstatus/><internalId>1891</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Cp.c_1150</srcid><srcstatus/><internalId>539</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1015</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Cp.Api.FillXpn</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>4651</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_Cp_FillXpn&lt;/li&gt;
              &lt;li&gt;
                  Syntax:             void Mka_Cp_FillXpn(
                                                           uint8   MkaPaeIdx,
                                                           uint8** BufPtrPtr,
                                                           uint16* BufSizePtr
                                                         );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    MkaPaeIdx             Controlled port handle for which XPN parameter set shall be generated.&lt;/li&gt;
              &lt;li&gt;
                  Parameters (inout): BufPtrPtr             On call the pointer to the memory location where parameter set shall be stored.
                                                            On exit, it shall point to the location where the next parameter set shall be stored.
              &lt;/li&gt;
              &lt;li&gt;
                  Parameters (inout): BufSizePtr            On call, available buffer size.
                                                            On exit, the remaining size of the buffer after parameter set was copied.
              &lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;Return value:       void&lt;/li&gt;
              &lt;li&gt;Description:        This service generates XPN parameter set for a specified port and stores it into provided buffer.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_Cp_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01018_XPN</srcid><srcstatus/><internalId>1707</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Cp.c_1253</srcid><srcstatus/><internalId>540</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1016</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Cp.Api.DisableMacSec</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>4689</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_Cp_DisableMacSec&lt;/li&gt;
              &lt;li&gt;
                  Syntax:             void Mka_Cp_DisableMacSec(
                                                                 uint8 MkaPaeIdx,
                                                                 uint8 Secure
                                                               );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    MkaPaeIdx             Controlled port handle.&lt;/li&gt;
              &lt;li&gt;Parameters (in):    Secure                Indicates if MACsec is enabled for a specified controlled port.&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;Return value:       void&lt;/li&gt;
              &lt;li&gt;Description:        This service indicates the change of Secure connect parameter to unsecured thus disabling MacSec.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_Cp_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Cp_UnitTest01011_CpSM_Uninit2Unsecured</srcid><srcstatus/><internalId>1823</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Cp.c_1298</srcid><srcstatus/><internalId>541</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1017</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Cp.Api.LinkStateDown</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>4720</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_Cp_LinkStateDown&lt;/li&gt;
              &lt;li&gt;
                  Syntax:             void Mka_Cp_LinkStateDown(
                                                                 uint8   MkaPaeIdx
                                                               );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    MkaPaeIdx             Controlled port handle.&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;Return value:       void&lt;/li&gt;
              &lt;li&gt;Description:        This service indicates the negative change of Link State for specified MkaPaeId.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_Cp_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Cp_UnitTest01023_CpSM_WaitAddTxSa2WaitRxSc_PortEnabled</srcid><srcstatus/><internalId>1835</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01024_CpSM_Transmitting2WaitRxSc_PortEnabled</srcid><srcstatus/><internalId>1836</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01026_CpSM_Ready2WaitRxSc_PortEnabled</srcid><srcstatus/><internalId>1838</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Cp.c_1332</srcid><srcstatus/><internalId>542</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1018</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Cp.Api.SetCipherSuite</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>4749</sourceline>
      <version>2</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_Cp_SetCipherSuite&lt;/li&gt;
              &lt;li&gt;
                  Syntax:             Std_ReturnType Mka_Cp_SetCipherSuite(
                                                                            uint8 MkaPaeIdx,
                                                                            uint8 CryptoAlgoConfigIdx,
                                                                            uint8 CipherSuiteIdx,
                                                                            uint8 ConfidentialityOffset
                                                                          );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    MkaPaeIdx               Controlled port handle.&lt;/li&gt;
              &lt;li&gt;Parameters (in):    CipherSuiteIdx          Index to selected Cipher suite in the PB configuration for.&lt;/li&gt;
              &lt;li&gt;Parameters (in):    CryptoAlgoConfigIdx     Index pointing to Crypto Algo Config in the PB configuration.&lt;/li&gt;
              &lt;li&gt;Parameters (in):    ConfidentialityOffset   Chosen confidentiality offset.&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;
                  Return value:       Std_ReturnType        E_OK:     Request successful.
                                                            E_NOT_OK: Request failed.
              &lt;/li&gt;
              &lt;li&gt;
                  Description:        This service indicates change of SecY cryptographic parameters (cipher suite, confidentiality offset, etc.)
                                      It is accepted only if Cp StateMachine is in CP_UNINIT, CP_WAIT_RX_SC and CP_INIT_RX_SC state.
              &lt;/li&gt;
              &lt;li&gt;Available via:      Mka_Cp_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Cp_UnitTest01001_CpSM_Uninit2Secured</srcid><srcstatus/><internalId>1813</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01018_CpSM_Retire2Unsecured</srcid><srcstatus/><internalId>1830</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Cp.c_1398</srcid><srcstatus/><internalId>543</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1019</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Cp.Api.TransmitWhen</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>4790</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_Cp_TimerCallback_TransmitWhen&lt;/li&gt;
              &lt;li&gt;
                  Syntax:             void Mka_Cp_TimerCallback_TransmitWhen(
                                                                              EcuC_Timers_GroupIdxType GroupIdx,
                                                                              EcuC_Timers_TimerIdxType TimerIdxInGroup
                                                                            );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    GroupIdx              Timer group index.&lt;/li&gt;
              &lt;li&gt;Parameters (in):    TimerIdxInGroup       Timer index in group.&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;Return value:       None&lt;/li&gt;
              &lt;li&gt;Description:        This service indicates that Pae timer TransmitWhen has expired.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_Cp_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Cp_UnitTest01009_CpSM_Receiving2Transmitting</srcid><srcstatus/><internalId>1821</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Cp.c_1669</srcid><srcstatus/><internalId>555</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1020</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Cp.Api.RetireWhen</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>4821</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_Cp_TimerCallback_RetireWhen&lt;/li&gt;
              &lt;li&gt;
                  Syntax:             void Mka_Cp_TimerCallback_RetireWhen(
                                                                            EcuC_Timers_GroupIdxType GroupIdx,
                                                                            EcuC_Timers_TimerIdxType TimerIdxInGroup
                                                                          );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    GroupIdx              Timer group index.&lt;/li&gt;
              &lt;li&gt;Parameters (in):    TimerIdxInGroup       Timer index in group.&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;Return value:       None&lt;/li&gt;
              &lt;li&gt;Description:        This service indicates that Pae timer Retire has expired.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_Cp_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Cp_UnitTest01007_CpSM_Receiving2Retire_2ndLoop</srcid><srcstatus/><internalId>1819</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Cp.c_1691</srcid><srcstatus/><internalId>556</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1021</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Cp.Api.DelayMacSecOperational</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>4852</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_Cp_TimerCallback_DelayMacSecOperational&lt;/li&gt;
              &lt;li&gt;
                  Syntax:             void Mka_Cp_TimerCallback_DelayMacSecOperational(
                                                                                        EcuC_Timers_GroupIdxType GroupIdx,
                                                                                        EcuC_Timers_TimerIdxType TimerIdxInGroup
                                                                                      );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    GroupIdx              Timer group index.&lt;/li&gt;
              &lt;li&gt;Parameters (in):    TimerIdxInGroup       Timer index in group.&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;Return value:       None&lt;/li&gt;
              &lt;li&gt;Description:        This service indicates that the delay timer to send MacSecOperational signal has expired.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_Cp_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01037_DelayMacSecOperation_EmptySak</srcid><srcstatus/><internalId>1726</internalId></linkedfrom><linkedfrom><srcid>Mka_ConTest01038_DelayMacSecOperation_NoPlainText</srcid><srcstatus/><internalId>1727</internalId></linkedfrom><linkedfrom><srcid>Mka_ConTest01039_DelayMacSecOperation_NoPlainText_2</srcid><srcstatus/><internalId>1728</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Cp.c_1713</srcid><srcstatus/><internalId>557</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1022</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Cp.Api.MacSecUpdateSecYNotification</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>4883</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_Cp_MacSecUpdateSecYNotification&lt;/li&gt;
              &lt;li&gt;
                  Syntax:             void Mka_Cp_MacSecUpdateSecYNotification(
                                                                                uint8 MkaPaeIdx
                                                                              );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    MkaPaeIdx           Controlled port handle.&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;Return value:       None&lt;/li&gt;
              &lt;li&gt;Description:        This service indicates that request to EthIf for UpdateSecYNotification has been processed.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_Cp_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Cp_UnitTest01001_CpSM_Uninit2Secured</srcid><srcstatus/><internalId>1813</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Cp.c_1603</srcid><srcstatus/><internalId>552</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1023</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Cp.Api.MacSecAddTxSaNotification</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>4912</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_Cp_MacSecAddTxSaNotification&lt;/li&gt;
              &lt;li&gt;
                  Syntax:             void Mka_Cp_MacSecAddTxSaNotification(
                                                                             uint8 MkaPaeIdx
                                                                           );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    MkaPaeIdx           Controlled port handle.&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;Return value:       None&lt;/li&gt;
              &lt;li&gt;Description:        This service indicates that request to EthIf for AddTxSaNotification has been processed.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_Cp_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Cp_UnitTest01003_CpSM_Receiving2Transmitting</srcid><srcstatus/><internalId>1815</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Cp.c_1621</srcid><srcstatus/><internalId>553</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1024</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Cp.Api.MacSecAddRxSaNotification</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>4941</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_Cp_MacSecAddRxSaNotification&lt;/li&gt;
              &lt;li&gt;
                  Syntax:             void Mka_Cp_MacSecAddRxSaNotification(
                                                                             uint8 MkaPaeIdx
                                                                           );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    MkaPaeIdx           Controlled port handle.&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;Return value:       None&lt;/li&gt;
              &lt;li&gt;Description:        This service indicates that request to EthIf for AddRxSaNotification has been processed&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_Cp_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Cp_UnitTest01002_CpSM_Secured2WaitAddTxSa</srcid><srcstatus/><internalId>1814</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01003_CpSM_Receiving2Transmitting</srcid><srcstatus/><internalId>1815</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Cp.c_1643</srcid><srcstatus/><internalId>554</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1025</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs" title="Crypto unit interface requirements">
    <specobject>
      <id>Mka.dsn.Crypto.Api.Init</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>4974</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_Crypto_Init&lt;/li&gt;
              &lt;li&gt;Syntax:             void Mka_Crypto_Init(void);&lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    None&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;Return value:       None&lt;/li&gt;
              &lt;li&gt;Description:        This service initializes all global variables of the Crypto unit.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_Crypto_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01008_RandomGen_Async128</srcid><srcstatus/><internalId>1912</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Crypto.c_149</srcid><srcstatus/><internalId>571</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1026</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.Api.MainFunction</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>4999</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_Crypto_MainFunction&lt;/li&gt;
              &lt;li&gt;Syntax:             void Mka_Crypto_MainFunction(void);&lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    None&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;Return value:       None&lt;/li&gt;
              &lt;li&gt;Description:        This service executes Crypto unit tasks periodically.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_Crypto_Init_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01008_RandomGen_Async128</srcid><srcstatus/><internalId>1912</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Crypto.c_203</srcid><srcstatus/><internalId>572</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1027</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.Api.Stop</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>5024</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_Crypto_Stop&lt;/li&gt;
              &lt;li&gt;
                  Syntax:             void Mka_Crypto_Stop(
                                                            uint8 ParticipantIdx
                                                          );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    ParticipantIdx      Mka participant instance handle.&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;Return value:       None&lt;/li&gt;
              &lt;li&gt;Description:        This service shall stop the crypto functionality and discard any results of ongoing (async) operations.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_Crypto_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01068_RandomGen_Stop_Async128</srcid><srcstatus/><internalId>1972</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Crypto.c_329</srcid><srcstatus/><internalId>574</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1028</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.Api.CakCknGenerateAsync</id>
      <status>rejected</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>5053</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_Crypto_CakCknGenerateAsync&lt;/li&gt;
              &lt;li&gt;
                  Syntax:             Std_ReturnType Mka_Crypto_CakCknGenerateAsync(
                                                                                     uint8        ParticipantIdx,
                                                                                     const uint8* TlsSessionId,
                                                                                     uint8        TlsSessionIdLength,
                                                                                     const uint8* Mac1,
                                                                                     const uint8* Mac2
                                                                                   );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Asynchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    ParticipantIdx        Mka participant instance handle.&lt;/li&gt;
              &lt;li&gt;Parameters (in):    TlsSessionId          Session ID used to generate CKN.&lt;/li&gt;
              &lt;li&gt;Parameters (in):    TlsSessionIdLength    Length of the session ID.&lt;/li&gt;
              &lt;li&gt;Parameters (in):    Mac1                  First MAC addresses.&lt;/li&gt;
              &lt;li&gt;Parameters (in):    Mac2                  Second MAC addresses.&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;
                  Return value:       Std_ReturnType        E_OK:     Request successful.
                                                            E_NOT_OK: Request failed.
              &lt;/li&gt;
              &lt;li&gt;Description:        This service shall generate CAK and CKN for the selected MKA.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_Crypto_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <comment>
            This requirement is not applicable.
          </comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1029</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.Api.IckGenerateAsync</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>5092</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_Crypto_IckGenerateAsync&lt;/li&gt;
              &lt;li&gt;
                  Syntax:             Std_ReturnType Mka_Crypto_IckGenerateAsync(
                                                                                  uint8 ParticipantIdx
                                                                                );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Asynchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    ParticipantIdx      Mka participant instance handle.&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;
                  Return value:       Std_ReturnType      E_OK:     Request successful.
                                                          E_NOT_OK: Request failed.
              &lt;/li&gt;
              &lt;li&gt;Description:        This service shall generate ICK for the selected MKA.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_Crypto_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01010_KekIckGen_Async128</srcid><srcstatus/><internalId>1914</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Crypto_KeyGen.c_120</srcid><srcstatus/><internalId>589</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1030</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.Api.KekGenerateAsync</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>5124</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_Crypto_KekGenerateAsync&lt;/li&gt;
              &lt;li&gt;
                  Syntax:             Std_ReturnType Mka_Crypto_KekGenerateAsync(
                                                                                  uint8 ParticipantIdx
                                                                                );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Asynchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    ParticipantIdx      Mka participant instance handle.&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;
                  Return value:       Std_ReturnType      E_OK:     Request successful.
                                                          E_NOT_OK: Request failed.
              &lt;/li&gt;
              &lt;li&gt;Description:        This service shall generate Kek for the selected MKA.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_Crypto_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01010_KekIckGen_Async128</srcid><srcstatus/><internalId>1914</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Crypto_KeyGen.c_145</srcid><srcstatus/><internalId>590</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1031</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.Api.SakGenWrapAsync</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>5156</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_Crypto_SakGenWrapAsync&lt;/li&gt;
              &lt;li&gt;
                  Syntax:             Std_ReturnType Mka_Crypto_SakGenWrapAsync(
                                                                                 uint8 ParticipantIdx,
                                                                                 uint8 SakLength
                                                                               );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Asynchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    ParticipantIdx      Mka participant instance handle.&lt;/li&gt;
              &lt;li&gt;Parameters (in):    SakLength           SAK length in bytes.&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;
                  Return value:       Std_ReturnType      E_OK:     Request successful.
                                                          E_NOT_OK: Request failed.
              &lt;/li&gt;
              &lt;li&gt;
                  Description:        This service shall start the generation of SAK, and key wrap.
                                      Note: This function is used by key server MKA instance, it will start SAK generation and key wrap
                                      since the server needs to send wrapped SAK to remote hosts.
                                      SAK length is defined by the selected cipher suite.
              &lt;/li&gt;
              &lt;li&gt;Available via:      Mka_Crypto_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <furtherinfo>
            WRN.swuts.needscoverage.count - Linking all tests to the single top-level requirement brings clear benefits and splitting
            them up would only increase complexity without any real improvements.
          </furtherinfo>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01050_SakGenWrap_Async128</srcid><srcstatus/><internalId>1954</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01051_SakGenWrap_Sync128</srcid><srcstatus/><internalId>1955</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01052_SakGenWrap_Async256</srcid><srcstatus/><internalId>1956</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01053_SakGenWrap_Sync256</srcid><srcstatus/><internalId>1957</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01055_SakGenWrap_Rfc3394_Async128</srcid><srcstatus/><internalId>1959</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01056_SakGenWrap_Rfc3394_Sync128</srcid><srcstatus/><internalId>1960</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01057_SakGenWrap_Rfc3394_Async256</srcid><srcstatus/><internalId>1961</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01058_SakGenWrap_Rfc3394_Sync256</srcid><srcstatus/><internalId>1962</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01060_SakUnwrap_Sync128</srcid><srcstatus/><internalId>1964</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01073_SakGenWrap_Stop_Async128</srcid><srcstatus/><internalId>1977</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01074_SakGenWrap_Stop_Sync128</srcid><srcstatus/><internalId>1978</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01104_Sak_StartGenFail_Sync</srcid><srcstatus/><internalId>1999</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01105_Sak_StartWrapFail_Async</srcid><srcstatus/><internalId>2000</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01159_SakWrapUnwrapAsync_Fail_PresharedIckKek</srcid><srcstatus/><internalId>2054</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01160_SakGenWrap_Stop_PresharedIckKek</srcid><srcstatus/><internalId>2055</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Crypto_KeyWrap.c_108</srcid><srcstatus/><internalId>592</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1032</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.Api.SakUnwrapAsync</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>5199</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_Crypto_SakUnwrapAsync&lt;/li&gt;
              &lt;li&gt;
                  Syntax:             Std_ReturnType Mka_Crypto_SakUnwrapAsync(
                                                                                uint8        ParticipantIdx,
                                                                                const uint8* WrappedSakPtr,
                                                                                uint32       WrapLength
                                                                              );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Asynchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    ParticipantIdx      Mka participant instance handle.&lt;/li&gt;
              &lt;li&gt;Parameters (in):    WrappedSakPtr       Pointer to the wrapped key.&lt;/li&gt;
              &lt;li&gt;Parameters (in):    WrapLength          Length of data.&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;
                  Return value:       Std_ReturnType      E_OK:     Request successful.
                                                          E_NOT_OK: Request failed.
              &lt;/li&gt;
              &lt;li&gt;
                  Description:        This service shall unwrap SAK.
                                      Note: This function is used by an instance that is not a key server to unwrap the SAK and save it for later use.
              &lt;/li&gt;
              &lt;li&gt;Available via:      Mka_Crypto_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01059_SakUnwrap_Async128</srcid><srcstatus/><internalId>1963</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01060_SakUnwrap_Sync128</srcid><srcstatus/><internalId>1964</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01061_SakUnwrap_Async256</srcid><srcstatus/><internalId>1965</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01062_SakUnwrap_Sync256</srcid><srcstatus/><internalId>1966</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01075_SakUnwrap_Stop_Async128</srcid><srcstatus/><internalId>1979</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01076_SakUnwrap_Stop_Sync128</srcid><srcstatus/><internalId>1980</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Crypto_KeyWrap.c_143</srcid><srcstatus/><internalId>593</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1033</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.Api.IcvVerifyAsync</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>5238</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_Crypto_IcvVerifyAsync&lt;/li&gt;
              &lt;li&gt;
                  Syntax:             Std_ReturnType Mka_Crypto_IcvVerifyAsync(
                                                                                uint8        ParticipantIdx,
                                                                                const uint8* DataPtr,
                                                                                uint32       DataLength
                                                                              );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Asynchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    ParticipantIdx      Mka participant instance handle.&lt;/li&gt;
              &lt;li&gt;Parameters (in):    DataPtr             Pointer to data for which the MAC shall be verified.&lt;/li&gt;
              &lt;li&gt;Parameters (in):    DataLength          Length of data.&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;
                  Return value:       Std_ReturnType      E_OK:     Request successful.
                                                          E_NOT_OK: Request failed.
              &lt;/li&gt;
              &lt;li&gt;Description:        This service will verify the received ICV.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_Crypto_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01039_IcvVerify_Async128</srcid><srcstatus/><internalId>1943</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Crypto_Icv.c_49</srcid><srcstatus/><internalId>585</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1034</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.Api.IcvGenerateAsync</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>5274</sourceline>
      <version>2</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_Crypto_IcvGenerateAsync&lt;/li&gt;
              &lt;li&gt;
                  Syntax:             Std_ReturnType Mka_Crypto_IcvGenerateAsync(
                                                                                  uint8        ParticipantIdx,
                                                                                  uint8* const DataPtr,
                                                                                  uint32       DataLength,
                                                                                  uint32       BufferLength,
                                                                                  const uint8* MPtr,
                                                                                  uint8        MLength
                                                                                );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Asynchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    ParticipantIdx      Mka participant instance handle.&lt;/li&gt;
              &lt;li&gt;Parameters (in):    DataPtr             Pointer to data for which the ICV shall be computed.&lt;/li&gt;
              &lt;li&gt;Parameters (in):    DataLength          Length of data for which the ICV shall be computed.&lt;/li&gt;
              &lt;li&gt;Parameters (in):    BufferLength        Length of the available buffer (ICV stored at the end of message).&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;
                  Return value:       Std_ReturnType      E_OK:     Request successful.
                                                          E_NOT_OK: Request failed.
              &lt;/li&gt;
              &lt;li&gt;Description:        This service will generate ICV for outgoing messages.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_Crypto_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01014_IcvGen_Async128</srcid><srcstatus/><internalId>1918</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Crypto_Icv.c_82</srcid><srcstatus/><internalId>586</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1035</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.Api.RandomGenerateAsync</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>5314</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_Crypto_RandomGenerateAsync&lt;/li&gt;
              &lt;li&gt;
                  Syntax:             Std_ReturnType Mka_Crypto_RandomGenerateAsync(
                                                                                     uint8 ParticipantIdx,
                                                                                     uint32 RandomLength
                                                                                   );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Asynchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    ParticipantIdx      Participant instance handle.&lt;/li&gt;
              &lt;li&gt;Parameters (in):    RandomLength        Length of the requested random value.&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;
                  Return value:       Std_ReturnType      E_OK:     Request successful.
                                                          E_NOT_OK: Request failed.
              &lt;/li&gt;
              &lt;li&gt;Description:        This service will generate Random value.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_Crypto_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01008_RandomGen_Async128</srcid><srcstatus/><internalId>1912</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01018_RandGen_Async_Fail</srcid><srcstatus/><internalId>1922</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Crypto_Rng.c_28</srcid><srcstatus/><internalId>597</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1036</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.Api.FindParticipant</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>5348</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_Crypto_FindParticipant&lt;/li&gt;
              &lt;li&gt;
                  Syntax:             uint8 Mka_Crypto_FindParticipant(
                                                                        uint8        MkaPaeIdx,
                                                                        const uint8* Ckn,
                                                                        uint8        CknLength
                                                                      );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Asynchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    MkaPaeIdx            Control port instance.&lt;/li&gt;
              &lt;li&gt;Parameters (in):    Ckn                  Secure Connectivity Association Key Name.&lt;/li&gt;
              &lt;li&gt;Parameters (in):    CknLength            Length of Secure Connectivity Association Key Name.&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;
                Return value:       uint8                MKA instance:        Instance has been found
                                                         MKA_INVALID_MKA_ID:  Instance has not been found
              &lt;/li&gt;
              &lt;li&gt;Description:        This service will try to find the MKA instance that the CKN belongs to.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_Crypto_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01048_FindMkaId_128</srcid><srcstatus/><internalId>1952</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01091_InvalidCkn</srcid><srcstatus/><internalId>1986</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Crypto.c_344</srcid><srcstatus/><internalId>575</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1037</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.Api.CopyCkn</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>5384</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_Crypto_CopyCkn&lt;/li&gt;
              &lt;li&gt;
                  Syntax:             void Mka_Crypto_CopyCkn (
                                                                uint8       ParticipantIdx,
                                                                uint8*      BufPtr,
                                                                uint8*      CknSizePtr
                                                              );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Asynchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    ParticipantIdx        Index of an participant.&lt;/li&gt;
              &lt;li&gt;Parameters (in):    BufPtr                Pointer where the CKN will be stored.&lt;/li&gt;
              &lt;li&gt;
                  Parameters (inout): CknSizePtr            IN: Length of available memory for CKN.
                                                        OUT: Length of CKN.
              &lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;Return value:       None&lt;/li&gt;
              &lt;li&gt;Description:        This service will copy data CKN from cache.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_Crypto_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <verifycrit>
            Testcase1:  Verify that when function is called with CknSize big enough to copy CKN, function will store in CknSizePtr actual
                        size of CKN.
            Testcase2:  Verify that when function is called with CknSize that is smaller than CKN, function will store in CknSizePtr
                        a value 0 which indicate that CKN isn't copied.
          </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01066_CopyCkn_128</srcid><srcstatus/><internalId>1970</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01092_InvalidCkn2</srcid><srcstatus/><internalId>1987</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Crypto.c_376</srcid><srcstatus/><internalId>576</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1038</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.Api.GetCknPtr</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>5425</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_Crypto_GetCknPtr&lt;/li&gt;
              &lt;li&gt;
                  Syntax:             Std_RetrunType Mka_Crypto_GetCknPtr (
                                                                            uint8                ParticipantIdx,
                                                                            Mka_DataPtrType*     BufPtrPtr,
                                                                            uint8*               CknSizePtr
                                                                          );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    ParticipantIdx        Index of an participant.&lt;/li&gt;
              &lt;li&gt;Parameters (in):    BufPtrPtr             Address where CKN is stored.&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   CknSizePtr            Length of CKN.&lt;/li&gt;
              &lt;li&gt;
                  Return value:       Std_ReturnType        E_OK:       CKN provided.
                                                            E_NOT_OK:   Request failed - CKN permanently unavailable.
                                                            E_MKA_BUSY  CKN retrieve process ongoing.
              &lt;/li&gt;
              &lt;li&gt;Description:        This service will return pointer of cached CKN.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_Crypto_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <verifycrit>
            Testcase1:  Verify that when function is called and successfully assigned pointer and size of CKN, function will return E_OK.
            Testcase2:
              1) Make a callout that for one participant CSM couldn't get CKN.
              2) Verify that when function is called for that participant, pointer of CKN isn't assigned and function will return E_NOT_OK
                  along with CknSizePtr equal 0.
          </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01038_GetCknPtr_E_OK</srcid><srcstatus/><internalId>1942</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01093_InvalidCkn3</srcid><srcstatus/><internalId>1988</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Crypto.c_399</srcid><srcstatus/><internalId>577</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1039</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs" title="Logon unit interface requirements">
    <specobject>
      <id>Mka.dsn.Logon.Api.MainFunction</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>5472</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_Logon_MainFunction&lt;/li&gt;
              &lt;li&gt;Syntax:             Std_ReturnType Mka_Logon_MainFunction(void);&lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    None&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;Return value:       None&lt;/li&gt;
              &lt;li&gt;
                  Description:        This function starts/restarts all participants that are in INIT state and enabled on all enabled
                                  and started Pae-s.
              &lt;/li&gt;
              &lt;li&gt;Available via:      Mka_Logon_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <verifycrit>
            Testcase 1:
            Start Logon unit, Participant shall be started (Mka_Crypto_IckGenerateAsync is called). Notify Logon that crypto
            failed to generate Ick with call Mka_Logon_IckGenerateFinished Participant shall be in Init state. After call to
            Mka_MainFunction varify that Mka_Logon_MainFuction is called and that Participant is started again.
            Also verify that after restarting Participant Logon does not call MKA_SET_DIRTY and therefore Mka_Logon_Main in not called any more.
            Testcase 2:
            MKA_DISABLE_NON_PRINCIPAL_PARTICIPANTS should be set to STD_ON
            Start Logon unit, bring participant to be a principal actor, after that call Mka_Logon_Participant_Disabled and disable
            principal participant. Verify that all participants on that Pae are restared after next call to Mka_Logon_MainFunction.
          </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01013_MainFunction_RestartParticipant</srcid><srcstatus/><internalId>2203</internalId></linkedfrom><linkedfrom><srcid>Mka_Logon_UnitTest01052_MainFunction_InternalInitFail</srcid><srcstatus/><internalId>2242</internalId></linkedfrom><linkedfrom><srcid>Mka_Logon_UnitTest01053_MainFunction_StartLastPrincipalInitFail</srcid><srcstatus/><internalId>2243</internalId></linkedfrom><linkedfrom><srcid>Mka_Logon_UnitTest01063_SetNextAsPrincipal_Failure</srcid><srcstatus/><internalId>2253</internalId></linkedfrom><linkedfrom><srcid>Mka_Logon_UnitTest01065_MainFunction_ParticipantTwoGetCknFail</srcid><srcstatus/><internalId>2254</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Logon.c_737</srcid><srcstatus/><internalId>742</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1040</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Logon.Api.Init</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>5511</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_Logon_Init&lt;/li&gt;
              &lt;li&gt;Syntax:             void Mka_Logon_Init(void);&lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    None&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;Return value:       None&lt;/li&gt;
              &lt;li&gt;Description:        This service initializes all global variables of the Logon unit.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_Logon_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01001_LogonInit</srcid><srcstatus/><internalId>2191</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Logon.c_796</srcid><srcstatus/><internalId>746</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1041</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Logon.Api.ParticipantSuccessfulActor</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>5536</sourceline>
      <version>2</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_Logon_Participant_SuccessfulActor&lt;/li&gt;
              &lt;li&gt;
                  Syntax:             void Mka_Logon_Participant_SuccessfulActor(
                                                                                  uint8 ParticipantIdx,
                                                                                  uint8 CipherSuiteId,
                                                                                  uint8 ConfidentialityOffset
                                                                                );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    ParticipantIdx          Index of Mka participant instance.&lt;/li&gt;
              &lt;li&gt;Parameters (in):    CipherSuiteId           Index of selected cipher suite.&lt;/li&gt;
              &lt;li&gt;Parameters (in):    ConfidentialityOffset   Chosen confidentiality offset.&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;Return value:       None&lt;/li&gt;
              &lt;li&gt;Description:        Notifies Logon unit that participant has become successful actor.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_Logon_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <verifycrit>
            Testcase1: Verify that when participant becomes successful actor and there is no previously selected principal participant
                       call to Mka_Logon_Participant_SuccessfulActor shall set participant as principal and store its index and cipher id
                       to Nv memory.
            Testcase2: Verify that when participant becomes successful actor and there is previously selected principal participant
                       call to Mka_Logon_Participant_SuccessfulActor shall do nothing.
          </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01041_ConfidentialityOffset</srcid><srcstatus/><internalId>1730</internalId></linkedfrom><linkedfrom><srcid>Mka_Logon_UnitTest01003_ParticipantSuccsessfulActor_DisableNonPrincipalParticipantsOn</srcid><srcstatus/><internalId>2193</internalId></linkedfrom><linkedfrom><srcid>Mka_Logon_UnitTest01004_ParticipantSuccsessfulActor_DisableNonPrincipalParticipantsOff</srcid><srcstatus/><internalId>2194</internalId></linkedfrom><linkedfrom><srcid>Mka_Logon_UnitTest01031_PermissiveMode_StartTimer</srcid><srcstatus/><internalId>2221</internalId></linkedfrom><linkedfrom><srcid>Mka_Logon_UnitTest01044_SuccessfulActor_Failure</srcid><srcstatus/><internalId>2234</internalId></linkedfrom><linkedfrom><srcid>Mka_Logon_UnitTest01059_NvSet_NoChange</srcid><srcstatus/><internalId>2249</internalId></linkedfrom><linkedfrom><srcid>Mka_Logon_UnitTest01062_SetAsPrincipal_SetCipherSuiteFail</srcid><srcstatus/><internalId>2252</internalId></linkedfrom><linkedfrom><srcid>Mka_Logon_UnitTest01067_ParticipantSuccessfulActor_NonPrincipalFailure</srcid><srcstatus/><internalId>2255</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Logon.c_1168</srcid><srcstatus/><internalId>764</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1042</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Logon.Api.ParticipantDisabled</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>5577</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_Logon_Participant_Disabled&lt;/li&gt;
              &lt;li&gt;
                  Syntax:             void Mka_Logon_Participant_Disabled(
                                                                           uint8 ParticipantIdx,
                                                                         );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    ParticipantIdx    Index of Mka participant instance.&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;Return value:       None&lt;/li&gt;
              &lt;li&gt;Description:        Notifies Logon that Participant shall be deleted (stopped).&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_Logon_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <verifycrit>
            Verify that when Mka_Logon_Participant_Disabled is called, Logon shall try to delete instance in Kay by calling
            Mka_KaY_DeleteParticipant, stop ongoing cyipto operations by calling Mka_Crypto_Stop and reset participant to INIT state.
          </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01006_ParticipantDisabled_ParticipantRestarted</srcid><srcstatus/><internalId>2196</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.dsn.Logon.NextSuccessfulParticipantAsPrincipal</srcid><srcstatus/><internalId>1606</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Logon.c_1214</srcid><srcstatus/><internalId>765</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1043</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Logon.Api.ParticipantActor</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>5611</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_Logon_Participant_Actor&lt;/li&gt;
              &lt;li&gt;
                  Syntax:             void Mka_Logon_Participant_Actor(
                                                                         uint8 ParticipantIdx,
                                                                      );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    ParticipantIdx    Index of Mka participant instance.&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;Return value:       None&lt;/li&gt;
              &lt;li&gt;Description:        Notifies Logon that participant has lost partner and is no longer a successful actor.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_Logon_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <verifycrit>
            Testcase1:
            Verify that when Mka_Logon_Participant_Actor is called for a principal participant, Logon shall try to set another successful
            actor as principal (in next main tick) if it exists on same Pae. Verify that Mka_Cp_SetCipherSuite is called with correct
            parameters for new principal actor.
            Testcase2:
            Verify that when Mka_Logon_Participant_Actor is called for a non principal actor, logon will only change internal
            state and not other calls shall be made.
          </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01039_ParticipantActor</srcid><srcstatus/><internalId>2229</internalId></linkedfrom><linkedfrom><srcid>Mka_Logon_UnitTest01045_ParticipantActor_NotPrincipal</srcid><srcstatus/><internalId>2235</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Logon.c_1241</srcid><srcstatus/><internalId>766</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1044</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Logon.Api.CakCknGenerateFinished</id>
      <status>rejected</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>5649</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_Logon_CakCknGenerateFinished&lt;/li&gt;
              &lt;li&gt;
                  Syntax:             void Mka_Logon_CakCknGenerateFinished(
                                                                             uint8          ParticipantIdx,
                                                                             Std_ReturnType Result
                                                                           );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    ParticipantIdx    Index of Mka participant instance.&lt;/li&gt;
              &lt;li&gt;
                  Parameters (in):    Result            E_OK     Generation done.
                                                        E_NOT_OK Error occurred.
              &lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;Return value:       None&lt;/li&gt;
              &lt;li&gt;Description:        Notifies Logon unit that CAK and CKN generation is finished.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_Logon_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <comment>
            This requirement is not applicable.
          </comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1045</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Logon.Api.IckGenerateFinished</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>5682</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_Logon_IckGenerateFinished&lt;/li&gt;
              &lt;li&gt;
                  Syntax:             void Mka_Logon_IckGenerateFinished(
                                                                             uint8          ParticipantIdx,
                                                                             Std_ReturnType Result
                                                                           );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    ParticipantIdx    Index of Mka participant instance.&lt;/li&gt;
              &lt;li&gt;
                  Parameters (in):    Result            E_OK     Generation done.
                                                        E_NOT_OK Error occurred.
              &lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;Return value:       None&lt;/li&gt;
              &lt;li&gt;Description:        Notifies Logon unit that ICK generation is finished and starts Paricipant in KaY unit.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_Logon_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01002_LogonIckGenerateFinished_Principal</srcid><srcstatus/><internalId>2192</internalId></linkedfrom><linkedfrom><srcid>Mka_Logon_UnitTest01005_LogonIckGenerateFinished_PrincipalFalse</srcid><srcstatus/><internalId>2195</internalId></linkedfrom><linkedfrom><srcid>Mka_Logon_UnitTest01050_IckGenerateFinished_ENotOkay</srcid><srcstatus/><internalId>2240</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Logon.c_1290</srcid><srcstatus/><internalId>769</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1046</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Logon.Api.SetCknStatus</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>5716</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_Logon_SetCknStatus&lt;/li&gt;
              &lt;li&gt;
                  Syntax:             Std_ReturnType Mka_Logon_SetCknStatus(
                                                                             uint8        MkaPaeIdx,
                                                                             const uint8* CknPtr,
                                                                             uint8        CknLength,
                                                                             boolean      Enable
                                                                           );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;
                  Reentrancy:         Reentrant for different MkaPaeIdx.
                                      Non-reentrant for the same MkaPaeIdx.
              &lt;/li&gt;
              &lt;li&gt;Parameters (in):    MkaPaeIdx           Index of the PAE within the context of the MKA module.&lt;/li&gt;
              &lt;li&gt;
                  Parameters (in):    Enable              True:  The MKA Participant exchanges MKPDUs.
                                                          False: The MKA Participant does not exchange MKPDUs.
              &lt;/li&gt;
              &lt;li&gt;Parameters (in):    CknPtr              Connectivity Association Key Name to identify the KaY participant.&lt;/li&gt;
              &lt;li&gt;Parameters (in):    CknLength           Length of the CKN parameter provided.&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;
                  Return value:       Std_ReturnType      E_OK:     Request successful.
                                                          E_NOT_OK: Request failed.
              &lt;/li&gt;
              &lt;li&gt;Description:        Set status of a CKN for a PAE in Nv memory.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_Logon_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <verifycrit>
            Verify that Mka_Logon_SetCknStatus shall set (Enabled - True/False) configuration value for given Ckn-Participant
            (Ckn maps to Participant on a given Pae) in Nv memory and mark Nv memory block for write.
          </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01007_LogonSetCknStatus</srcid><srcstatus/><internalId>2197</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Logon.c_838</srcid><srcstatus/><internalId>748</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1047</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Logon.Api.GetCknStatus</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>5764</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_Logon_GetCknStatus&lt;/li&gt;
              &lt;li&gt;
                  Syntax:             Std_ReturnType Mka_Logon_GetCknStatus(
                                                                             uint8        MkaPaeIdx,
                                                                             const uint8* CknPtr,
                                                                             uint8        CknLength,
                                                                             boolean*     EnablePtr
                                                                           );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;
                  Reentrancy:         Reentrant for different MkaPaeIdx.
                                      Non-reentrant for the same MkaPaeIdx.
              &lt;/li&gt;
              &lt;li&gt;Parameters (in):    MkaPaeIdx           Index of the PAE within the context of the MKA module.&lt;/li&gt;
              &lt;li&gt;Parameters (in):    CknPtr              Connectivity Association Key Name to identify the KaY participant.&lt;/li&gt;
              &lt;li&gt;Parameters (in):    CknLength           Length of the CKN parameter provided.&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   EnablePtr           Pointer to the Mka Participant activation status.&lt;/li&gt;
              &lt;li&gt;
                  Return value:       Std_ReturnType      E_OK:     Request successful.
                                                          E_NOT_OK: Request failed.
              &lt;/li&gt;
              &lt;li&gt;Description:        Get Status of a CKN from a PAE in Nv Memory.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_Logon_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <verifycrit>
            Verify that Mka_Logon_GetCknStatus shall get configuration value (Enabled - True/False) for given Ckn-Participant
            (Ckn maps to Participant on a given Pae) from Nv memory.
          </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01020_SetCknStatus_DisableParticipant</srcid><srcstatus/><internalId>2210</internalId></linkedfrom><linkedfrom><srcid>Mka_Logon_UnitTest01021_SetCknStatus_EnableParticipant</srcid><srcstatus/><internalId>2211</internalId></linkedfrom><linkedfrom><srcid>Mka_Logon_UnitTest01026_LogonGetCknStatus</srcid><srcstatus/><internalId>2216</internalId></linkedfrom><linkedfrom><srcid>Mka_Logon_UnitTest01042_GetCknStatus_ENotOk</srcid><srcstatus/><internalId>2232</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Logon.c_863</srcid><srcstatus/><internalId>749</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1048</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Logon.Api.SetEnable</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>5808</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_Logon_SetEnable&lt;/li&gt;
              &lt;li&gt;
                  Syntax:             Std_ReturnType Mka_Logon_SetEnable(
                                                                          uint8   MkaPaeIdx,
                                                                          boolean Enable
                                                                        );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;
                  Reentrancy:         Reentrant for different MkaPaeIdx.
                                      Non-reentrant for the same MkaPaeIdx.
              &lt;/li&gt;
              &lt;li&gt;Parameters (in):    MkaPaeIdx           Index of the PAE within the context of the MKA module.&lt;/li&gt;
              &lt;li&gt;Parameters (in):    Enable              Boolean to control the Mka activation of a PAE.&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;
                  Return value:       Std_ReturnType      E_OK:     Request successful.
                                                          E_NOT_OK: Request failed.
              &lt;/li&gt;
              &lt;li&gt;Description:        Set the MKA activation status of a PAE in Nv memory.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_Logon_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <verifycrit>
            Verify that Mka_Logon_SetEnable shall set configuration value (Enabled - True/False) for given MkaPaeIdx in Nv memory
            and mark Nv memory block for write.
          </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01027_LogonSetEnable</srcid><srcstatus/><internalId>2217</internalId></linkedfrom><linkedfrom><srcid>Mka_Logon_UnitTest01056_SetEnable_DisablePae_NoChange</srcid><srcstatus/><internalId>2246</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Logon.c_888</srcid><srcstatus/><internalId>750</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1049</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Logon.Api.GetEnable</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>5849</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_Logon_GetEnable&lt;/li&gt;
              &lt;li&gt;
                  Syntax:             Std_ReturnType Mka_Logon_GetEnable(
                                                                          uint8    MkaPaeIdx,
                                                                          boolean* EnablePtr
                                                                        );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;
                  Reentrancy:         Reentrant for different MkaPaeIdx.
                                      Non-reentrant for the same MkaPaeIdx.
              &lt;/li&gt;
              &lt;li&gt;Parameters (in):    MkaPaeIdx           Index of the PAE within the context of the MKA module.&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   EnablePtr           Pointer to the Mka activation status of a PAE.&lt;/li&gt;
              &lt;li&gt;
                  Return value:       Std_ReturnType      E_OK:     Request successful.
                                                          E_NOT_OK: Request failed.
              &lt;/li&gt;
              &lt;li&gt;Description:        Get the MKA activation status of a PAE.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_Logon_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <verifycrit>
            Verify that Mka_Logon_GetEnable shall get configuration value (Enabled - True/False) for given MkaPaeIdx from Nv memory.
          </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01022_SetEnable_DisablePae</srcid><srcstatus/><internalId>2212</internalId></linkedfrom><linkedfrom><srcid>Mka_Logon_UnitTest01023_SetEnable_EnablePae</srcid><srcstatus/><internalId>2213</internalId></linkedfrom><linkedfrom><srcid>Mka_Logon_UnitTest01028_LogonGetEnable</srcid><srcstatus/><internalId>2218</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Logon.c_900</srcid><srcstatus/><internalId>751</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1050</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Logon.Api.SetPaePermissiveMode</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>5888</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_Logon_SetPaePermissiveMode&lt;/li&gt;
              &lt;li&gt;
                  Syntax:             Std_ReturnType Mka_Logon_SetPaePermissiveMode(
                                                                                     uint8                 MkaPaeIdx,
                                                                                     Mka_PermisiveModeType PermissiveMode
                                                                                   );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;
                  Reentrancy:         Reentrant for different MkaPaeIdx.
                                      Non-reentrant for the same MkaPaeIdx.
              &lt;/li&gt;
              &lt;li&gt;Parameters (in):    MkaPaeIdx           Index of the PAE within the context of the MKA module.&lt;/li&gt;
              &lt;li&gt;Parameters (in):    PermissiveMode      Permissive mode to set in the PAE.&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;
                  Return value:       Std_ReturnType      E_OK:     Request successful.
                                                          E_NOT_OK: Request failed.
              &lt;/li&gt;
              &lt;li&gt;Description:        Set Permissive Mode of a KaY.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_Logon_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <verifycrit>
            Verify that Mka_SetPaePermissiveMode shall set permissive mode for given MkaPaeIdx in Nv memory and
            mark Nv memory block for write.
          </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01024_SetPaePermissiveMode</srcid><srcstatus/><internalId>2214</internalId></linkedfrom><linkedfrom><srcid>Mka_Logon_UnitTest01029_LogonSetPaePermissiveMode</srcid><srcstatus/><internalId>2219</internalId></linkedfrom><linkedfrom><srcid>Mka_Logon_UnitTest01060_NvConfig_PermissiveNoChange</srcid><srcstatus/><internalId>2250</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Logon.c_912</srcid><srcstatus/><internalId>752</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1051</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Logon.Api.StartPae</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>5929</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_Logon_StartPae&lt;/li&gt;
              &lt;li&gt;
                  Syntax:             Std_ReturnType Mka_Logon_StartPae(
                                                                         uint8 MkaPaeIdx
                                                                       );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;
                  Reentrancy:         Reentrant for different MkaPaeIdx.
                                      Non-reentrant for the same MkaPaeIdx.
              &lt;/li&gt;
              &lt;li&gt;Parameters (in):    MkaPaeIdx           Index of the PAE within the context of the MKA module.&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;
                  Return value:       Std_ReturnType      E_OK:     Request successful.
                                                          E_NOT_OK: Request failed.
              &lt;/li&gt;
              &lt;li&gt;
                  Description:        Manual start of the PAE.
                                      (In case MkaPaeConfiguration.Autostart = False and PAE is enabled this method starts the PAE operation).
              &lt;/li&gt;
              &lt;li&gt;Available via:      Mka_Logon_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <verifycrit>
            Shall be verified with Mka.CP_SWS_Mka_01004.
          </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01015_StartPae</srcid><srcstatus/><internalId>2205</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Logon.c_925</srcid><srcstatus/><internalId>754</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1052</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Logon.Api.GetPaeStatus</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>5970</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_Logon_GetPaeStatus&lt;/li&gt;
              &lt;li&gt;
                  Syntax:             void Mka_Logon_GetPaeStatus(
                                                                   uint8              MkaPaeIdx,
                                                                   Mka_PaeStatusType* PaeStatus
                                                                 );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;
                  Reentrancy:         Reentrant for different PaeIdx.
                                      Non-reentrant for the same PaeIdx.
              &lt;/li&gt;
              &lt;li&gt;Parameters (in):    MkaPaeIdx           Index of the PAE within the context of the MKA module.&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   PaeStatus           Pointer to Mka_PaeStatusType structure where detailed information about PAE will be put.&lt;/li&gt;
              &lt;li&gt;Return value:       None&lt;/li&gt;
              &lt;li&gt;Description:        Set detailed information of a PAE.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_Logon_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <verifycrit>
            Verify that correct PaeStatus is returned for corresponding, valid, PaeIdx.
          </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01030_GetPaeStatus</srcid><srcstatus/><internalId>2220</internalId></linkedfrom><linkedfrom><srcid>Mka_Logon_UnitTest01047_GetPaeStatus_DisabledParticipant</srcid><srcstatus/><internalId>2237</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Logon.c_962</srcid><srcstatus/><internalId>758</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1053</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Logon.Api.TimerCallback_PermissiveMode</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>6006</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_Logon_TimerCallback_PermissiveMode&lt;/li&gt;
              &lt;li&gt;
                  Syntax:             void Mka_Logon_TimerCallback_PermissiveMode(
                                                                                   EcuC_Timers_GroupIdxType GroupIdx,
                                                                                   EcuC_Timers_TimerIdxType TimerIdxInGroup
                                                                                 );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    GroupIdx            Timer group index.&lt;/li&gt;
              &lt;li&gt;Parameters (in):    TimerIdxInGroup     Timer index in group (ParticipantIdx).&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;Return value:       None&lt;/li&gt;
              &lt;li&gt;Description:        This service indicates that permissive mode timeout has been triggered.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_Logon_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01032_PermissiveMode_TimerExpires</srcid><srcstatus/><internalId>2222</internalId></linkedfrom><linkedfrom><srcid>Mka_Logon_UnitTest01043_TimerCallBack_PermissiveMode_Operational</srcid><srcstatus/><internalId>2233</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Logon.c_1122</srcid><srcstatus/><internalId>761</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1054</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Logon.Api.MacSecOperational</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>6037</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_Logon_MacSecOperational&lt;/li&gt;
              &lt;li&gt;
                  Syntax:             void Mka_Logon_MacSecOperational(
                                                                        uint8     MkaPaeIdx,
                                                                        boolean   Status
                                                                      );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    MkaPaeIdx           Index of the PAE within the context of the MKA module.&lt;/li&gt;
              &lt;li&gt;
                  Parameters (in):    Status              TRUE:   MacSec is Operational.
                                                          FALSE:  MacSec isn't achieved.
              &lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;Return value:       None&lt;/li&gt;
              &lt;li&gt;Description:        Function call indicates that there is a change in status of MacSecOperational.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_Logon_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <verifycrit>
            Call function with Status = TRUE, and verify next things:
              1) Verify that MacSecOperational is TRUE with function call Mka_Logon_GetPaeStatus() that
                 ConnectionStatus = MKA_STATUS_MACSEC_RUNNING.
              2) Verify that are called all previously reported errors with status DEM_EVENT_STATUS_PASSED, if DEM reporting is enabled.
          </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01030_GetPaeStatus</srcid><srcstatus/><internalId>2220</internalId></linkedfrom><linkedfrom><srcid>Mka_Logon_UnitTest01035_Dem_SetEventStatus</srcid><srcstatus/><internalId>2225</internalId></linkedfrom><linkedfrom><srcid>Mka_Logon_UnitTest01046_MacSecOperational_FalseInputs</srcid><srcstatus/><internalId>2236</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Logon.c_1334</srcid><srcstatus/><internalId>770</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1055</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Logon.Api.ReportEvent</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>6077</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_Logon_ReportEvent&lt;/li&gt;
              &lt;li&gt;
                Syntax:               void Mka_Logon_ReportEvent(
                                                                  uint8 MkaParticipantIdx,
                                                                  uint8 ReportEvent
                                                                );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    MkaParticipantIdx      Index of the Participant within the context of the MKA module.&lt;/li&gt;
              &lt;li&gt;Parameters (in):    ReportEvent            Reported error event.&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;Return value:       None&lt;/li&gt;
              &lt;li&gt;Description:        Reports error event to Dem and/or report event callout function, when respective report method is enabled.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_Logon_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <verifycrit>
            Test case 1:
              1) Verify that is called Dem_SetEventStatus() if Error is enabled.
            Test case 2:
              1) Call Mka_Logon_ReportEvent() with an invalid ReportEvent.
              2) Verify that Dem_SetEventStatus() is not called.
          </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01035_Dem_SetEventStatus</srcid><srcstatus/><internalId>2225</internalId></linkedfrom><linkedfrom><srcid>Mka_Logon_UnitTest01051_PaeReportError_PaeDisabled</srcid><srcstatus/><internalId>2241</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Logon.c_1369</srcid><srcstatus/><internalId>772</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1056</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Logon.Api.PaeRestart</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>6115</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_Logon_Pae_Restart&lt;/li&gt;
              &lt;li&gt;
                  Syntax:             void Mka_Logon_Pae_Restart(
                                                                   uint8   MkaPaeIdx
                                                                );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    MkaPaeIdx           Index of the PAE within the context of the MKA module.&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;Return value:       None&lt;/li&gt;
              &lt;li&gt;
                  Description:        Called to indicate that CP has encountered unrecoverable error (e.g. retry counter exceeded the limit).
                                      Logon shall update SecY, delete and restart(in next main tick) all participants on that PAE.
              &lt;/li&gt;
              &lt;li&gt;Available via:      Mka_Logon_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <verifycrit>
            Call Mka_Logon_Pae_Restart with valid PaeIdx. Verify that SecY is restarted by call to Mka_Cp_SetCipherSuite() and
            that all participants are destroyed and restarted.
          </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01054_PaeRestart_Successful</srcid><srcstatus/><internalId>2244</internalId></linkedfrom><linkedfrom><srcid>Mka_Logon_UnitTest01055_PaeRestart_Failure</srcid><srcstatus/><internalId>2245</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Logon.c_1444</srcid><srcstatus/><internalId>773</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1057</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Logon.Api.MacSecEnabledStatus</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>6151</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_Logon_NvConfig_MacSecEnabled&lt;/li&gt;
              &lt;li&gt;
                  Syntax:             boolean Mka_Logon_NvConfig_MacSecEnabled(
                                                                                const boolean * EnabledPtr
                                                                              );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;
                  Parameters (in):    EnabledPtr           NULL_PTR if retrieving currently active value or
                                                           pointer to boolean value to set in Nv Memory.
              &lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;
                  Return value:       boolean              TRUE  MacSec is Enabled.
                                                           FALSE  MacSec is Disabled.
              &lt;/li&gt;
              &lt;li&gt;
                  Description:        Called to set or get configuration status of MacSec (Is MacSec Enabled or Disabled in configuration
                                      stored in Non Volatile Memory. Returns currently active value.
                                      Value stored in configuration shall have effect and be returned upon Mka restart.
              &lt;/li&gt;
              &lt;li&gt;Available via:      Mka_Logon_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <verifycrit>
            1.)  Call Mka_Logon_NvConfig_MacSecEnabled with NULL_PTR. Verify that TRUE was returned (TRUE is default value when NvM is initialized)
            2.)  Call Mka_Logon_NvConfig_MacSecEnabled with address of boolean value set to FALSE. Verify that function still returns TRUE.
            3.)  Restart MKA without clearing Nv Memory. Verify that Mka_Logon_NvConfig_MacSecEnabled returns FALSE;
          </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01058_Logon_NvConfig_MacSecEnabled</srcid><srcstatus/><internalId>2248</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Logon.c_1487</srcid><srcstatus/><internalId>776</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1058</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Logon.Api.MkpduReceived</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>6195</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_Logon_Participant_MkpduReceived&lt;/li&gt;
              &lt;li&gt;
                  Syntax:             void Mka_Logon_Participant_MkpduReceived(
                                                                                uint8 ParticipantIdx
                                                                              );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    ParticipantIdx       Index of Mka participant instance.&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;
                  Return value:       None&lt;/li&gt;
              &lt;li&gt;
                  Description:        Called to notify Logon that MKPDU is received. Logon shall restart permissive timer when
                                      first MKPDU is received after link up according to Mka.EB.RestartPermissiveModeTimerOnFirstMkpdu.
              &lt;/li&gt;
              &lt;li&gt;Available via:      Mka_Logon_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <verifycrit>
            1.)  Test that Permissive mode timer is started. Verify that when first MKPDU is received with valid ICV,
                 permissive mode timer is restarted.
            2.)  Bring Mka to state that Link is Up and permissive mode timer started and restarted upon reception for first MKPDU
                 with valid ICV, then bring Link down and then up again. Verify that Permissive mode is started and restarted after first
                 MKPDU received on that PAE.
          </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01022_PermissiveMode_TimerResetOnMkpdu_2</srcid><srcstatus/><internalId>1711</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Logon.c_1268</srcid><srcstatus/><internalId>767</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0111.PermissiveMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>963</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1059</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs" title="RxTx unit interface requirements">
    <specobject>
      <id>Mka.dsn.RxTx.Api.Mka_RxTx_Init</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>6245</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_RxTx_Init&lt;/li&gt;
              &lt;li&gt;Syntax:             void Mka_RxTx_Init(void);&lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    None&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;Return value:       None&lt;/li&gt;
              &lt;li&gt;Description:        This service initializes all global variables of the RxTx unit.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_RxTx_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_RxTx_UnitTest01001_Initial_2_BufUnalloc_2_BufAlloc</srcid><srcstatus/><internalId>2315</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_RxTx.c_136</srcid><srcstatus/><internalId>799</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1060</internalId></specobject>
    <specobject>
      <id>Mka.dsn.RxTx.Api.Mka_RxTx_GetTxBuffer</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>6270</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_RxTx_GetTxBuffer&lt;/li&gt;
              &lt;li&gt;
                  Syntax:             Std_ReturnType Mka_RxTx_GetTxBuffer(
                                                                           uint8            ParticipantIdx,
                                                                           Mka_DataPtrType* BufPtrPtr,
                                                                           uint16*          BufSizePtr
                                                                         );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    ParticipantIdx      Index of an instance that will use the buffer (used for indications).&lt;/li&gt;
              &lt;li&gt;
                  Parameters (inout): BufSizePtr          On calling this function the size of required buffer in bytes.
                                                          On return the actual size of allocated buffer.
              &lt;/li&gt;
              &lt;li&gt;Parameters (out):   BufPtrPtr           Pointer to the pointer to the buffer.&lt;/li&gt;
              &lt;li&gt;
                  Return value:       Std_ReturnType      E_OK:     Buffer successfully acquired.
                                                          E_NOT_OK: Buffer acquire failed, e.g. required buffer size cannot be allocated.
              &lt;/li&gt;
              &lt;li&gt;Description:        This service acquires transmit buffer for a specified MKA instance.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_RxTx_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_RxTx_UnitTest01001_Initial_2_BufUnalloc_2_BufAlloc</srcid><srcstatus/><internalId>2315</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_RxTx.c_177</srcid><srcstatus/><internalId>801</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1061</internalId></specobject>
    <specobject>
      <id>Mka.dsn.RxTx.Api.Mka_RxTx_ReleaseTxBuffer</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>6307</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_RxTx_ReleaseTxBuffer&lt;/li&gt;
              &lt;li&gt;
                  Syntax:             Std_ReturnType Mka_RxTx_ReleaseTxBuffer(
                                                                               uint8 ParticipantIdx
                                                                             );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    ParticipantIdx      Index of a participant that will use the buffer (used for indications).&lt;/li&gt;
              &lt;li&gt;
                  Return value:       Std_ReturnType      E_OK:     Buffer successfully released.
                                                          E_NOT_OK: Buffer release failed.
              &lt;/li&gt;
              &lt;li&gt;Description:        This service releases previously allocated transmit buffer for a specified participant.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_RxTx_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_RxTx_UnitTest01026_BufAllocLocked_2_BufAllocUnlocked</srcid><srcstatus/><internalId>2339</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_RxTx.c_250</srcid><srcstatus/><internalId>803</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1062</internalId></specobject>
    <specobject>
      <id>Mka.dsn.RxTx.Api.Mka_RxTx_TxBufferReady</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>6337</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_RxTx_TxBufferReady&lt;/li&gt;
              &lt;li&gt;
                  Syntax:             Std_ReturnType Mka_RxTx_TxBufferReady(
                                                                             uint8  ParticipantIdx,
                                                                             uint16 DataSize
                                                                           );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    ParticipantIdx        Mka instance handle.&lt;/li&gt;
              &lt;li&gt;Parameters (in):    DataSize              The actual size of a message stored in a buffer.&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;Return value:       None&lt;/li&gt;
              &lt;li&gt;Description:        This service indicates that MKPDU is available in the buffer and it shall be transmitted after ICV is applied.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_RxTx_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_RxTx_UnitTest01002_BufAlloc_2_WaitIcvGenFin_2_BufUnalloc</srcid><srcstatus/><internalId>2316</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_RxTx.c_277</srcid><srcstatus/><internalId>804</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1063</internalId></specobject>
    <specobject>
      <id>Mka.dsn.RxTx.Api.Mka_RxTx_RxIndication</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>6368</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_RxTx_RxIndication&lt;/li&gt;
              &lt;li&gt;
                  Syntax:             void Mka_RxTx_RxIndication(
                                                                  uint8         MkaPaeIdx,
                                                                  Eth_FrameType FrameType,
                                                                  boolean       IsBroadcast,
                                                                  const uint8*  MacSrcAddr,
                                                                  uint8*        DataPtr,
                                                                  uint16        LenByte
                                                                );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    MkaPaeIdx             Index of a controlled port to which received message is related.&lt;/li&gt;
              &lt;li&gt;Parameters (in):    FrameType             Value of Ethernet header type-field.&lt;/li&gt;
              &lt;li&gt;Parameters (in):    IsBroadcast           Indicates if the target MAC address is a broadcast address.&lt;/li&gt;
              &lt;li&gt;Parameters (in):    MacSrcAddr            Points to MAC address of remote host (source MAC).&lt;/li&gt;
              &lt;li&gt;
                  Parameters (in):    DataPtr               Pointer to the received data. The data contains the payload of the Ethernet protocol
                                                            (which excludes the Ethernet header but includes headers of higher layers).
              &lt;/li&gt;
              &lt;li&gt;Parameters (in):    LenByte               Length of received data in units of bytes.&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;Return value:       None&lt;/li&gt;
              &lt;li&gt;Description:        This service indicates frame reception.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_RxTx_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_UnitTest01019_RxIndication</srcid><srcstatus/><internalId>2278</internalId></linkedfrom><linkedfrom><srcid>Mka_RxTx_UnitTest01004_Initial_2_RxBufFree_2_WaitIcvVerFin_2_RxBufFree</srcid><srcstatus/><internalId>2318</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_RxTx.c_321</srcid><srcstatus/><internalId>806</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1064</internalId></specobject>
    <specobject>
      <id>Mka.dsn.RxTx.Api.Mka_RxTx_IcvVerifyFinished</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>6410</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_RxTx_IcvVerifyFinished&lt;/li&gt;
              &lt;li&gt;
                Syntax:             void Mka_RxTx_IcvVerifyFinished(
                                                                     uint8          ParticipantIdx,
                                                                     Std_ReturnType Result
                                                                   );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    ParticipantIdx        Mka instance handle.&lt;/li&gt;
              &lt;li&gt;
                  Parameters (in):    Result                E_OK     - ICV verification succeeded.
                                                            E_NOT_OK - ICV verification failed.
              &lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;Return value:       None&lt;/li&gt;
              &lt;li&gt;Description:        This service indicates that ICV verification has finished.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_RxTx_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_RxTx_UnitTest01004_Initial_2_RxBufFree_2_WaitIcvVerFin_2_RxBufFree</srcid><srcstatus/><internalId>2318</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_RxTx.c_459</srcid><srcstatus/><internalId>818</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1065</internalId></specobject>
    <specobject>
      <id>Mka.dsn.RxTx.Api.Mka_RxTx_IcvGenerateFinished</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>6444</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_RxTx_IcvGenerateFinished&lt;/li&gt;
              &lt;li&gt;
                  Syntax:             void Mka_RxTx_IcvGenerateFinished(
                                                                         uint8          ParticipantIdx,
                                                                         Std_ReturnType Result
                                                                       );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    ParticipantIdx        Mka instance handle.&lt;/li&gt;
              &lt;li&gt;
                  Parameters (in):    Result                E_OK     - ICV calculation succeeded.
                                                            E_NOT_OK - ICV calculation failed.
              &lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;Return value:       None&lt;/li&gt;
              &lt;li&gt;Description:        This service indicates that ICV generation has finished.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_RxTx_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_RxTx_UnitTest01002_BufAlloc_2_WaitIcvGenFin_2_BufUnalloc</srcid><srcstatus/><internalId>2316</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_RxTx.c_500</srcid><srcstatus/><internalId>819</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1066</internalId></specobject>
    <specobject>
      <id>Mka.dsn.RxTx.Api.Mka_RxTx_IsIcvErrorPresent</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>6478</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_RxTx_IsIcvErrorPresent&lt;/li&gt;
              &lt;li&gt;
                  Syntax:             boolean Mka_RxTx_IsIcvErrorPresent(
                                                                          uint8 ParticipantIdx
                                                                        );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    ParticipantIdx        Mka instance handle.&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;
                  Return value:       boolean               TRUE if Icv verification error occured for given ParticipantIdx,
                                                            FALSE otherwise.
              &lt;/li&gt;
              &lt;li&gt;Description:        This service indicates if ICV verification for given ParticipantIdx was successful.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_RxTx_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_RxTx_UnitTest01015_ValidateMkpdu_IcvVerification</srcid><srcstatus/><internalId>2329</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_RxTx.c_546</srcid><srcstatus/><internalId>821</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1067</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs" title="Lib unit interface requirements">
    <specobject>
      <id>Mka.dsn.Lib.Api.Init</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>6514</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_Lib_Init&lt;/li&gt;
              &lt;li&gt;Syntax:             Std_ReturnType Mka_Lib_Init(void);&lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    None&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;
                  Return value:       Std_ReturnType      E_OK:     Lib Initialization successful.
                                                          E_NOT_OK: Lib Initialization failed.
              &lt;/li&gt;
              &lt;li&gt;Description:        This service initializes all global variables of the Lib unit.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_Lib_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Lib_UnitTest01001_CorrectlyCalledFunction</srcid><srcstatus/><internalId>2189</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Lib.c_172</srcid><srcstatus/><internalId>709</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1068</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Lib.Api.GetSciPtr</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>6542</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_Lib_GetSciPtr&lt;/li&gt;
              &lt;li&gt;Syntax:             const uint8* Mka_Lib_GetSciPtr(uint8 MkaPaeIdx);&lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    None&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;Return value:       None&lt;/li&gt;
              &lt;li&gt;Description:        This service returns the pointer to the Sci for the given MkaPaeIdx.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_Lib_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Lib_UnitTest01002_GetSciPtr</srcid><srcstatus/><internalId>2190</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Lib.c_157</srcid><srcstatus/><internalId>708</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1069</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Lib.Api.StartTimer</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>6567</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_Lib_StartTimer&lt;/li&gt;
              &lt;li&gt;Syntax:             void Mka_Lib_StartTimer(GroupIdx, TimerIdxInGroup, TimeoutValue);&lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    GroupIdx           Timer group index.&lt;/li&gt;
              &lt;li&gt;Parameters (in):    TimerIdxInGroup    Timer index in group.&lt;/li&gt;
              &lt;li&gt;Parameters (in):    TimeoutValue       Timer timeout value.&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;Return value:       None&lt;/li&gt;
              &lt;li&gt;Description:        Function like macro starts timer in specified group.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_Lib_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Lib_UnitTest01001_CorrectlyCalledFunction</srcid><srcstatus/><internalId>2189</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Lib_Int.h_202</srcid><srcstatus/><internalId>714</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1070</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Lib.Api.StartTimerAutorepeat</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>6594</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_Lib_StartTimerAutorepeat&lt;/li&gt;
              &lt;li&gt;Syntax:             void Mka_Lib_StartTimerAutorepeat(GroupIdx, TimerIdxInGroup);&lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    GroupIdx           Timer group index.&lt;/li&gt;
              &lt;li&gt;Parameters (in):    TimerIdxInGroup    Timer index in group.&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;Return value:       None&lt;/li&gt;
              &lt;li&gt;Description:        Function like macro starts timer in specified group with preconfigured timeout value.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_Lib_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Lib_UnitTest01001_CorrectlyCalledFunction</srcid><srcstatus/><internalId>2189</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Lib_Int.h_215</srcid><srcstatus/><internalId>715</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1071</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Lib.Api.StopTimer</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>6620</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_Lib_StopTimer&lt;/li&gt;
              &lt;li&gt;Syntax:             void Mka_Lib_StopTimer(GroupIdx, TimerIdxInGroup);&lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    GroupIdx           Timer group index.&lt;/li&gt;
              &lt;li&gt;Parameters (in):    TimerIdxInGroup    Timer index in group.&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;Return value:       None&lt;/li&gt;
              &lt;li&gt;Description:        Function like macro stops timer in specified group.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_Lib_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Lib_UnitTest01001_CorrectlyCalledFunction</srcid><srcstatus/><internalId>2189</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Lib_Int.h_230</srcid><srcstatus/><internalId>716</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1072</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Lib.Api.PauseTimer</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>6646</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_Lib_PauseTimer&lt;/li&gt;
              &lt;li&gt;Syntax:             void Mka_Lib_PauseTimer(GroupIdx, TimerIdxInGroup);&lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    GroupIdx           Timer group index.&lt;/li&gt;
              &lt;li&gt;Parameters (in):    TimerIdxInGroup    Timer index in group.&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;Return value:       None&lt;/li&gt;
              &lt;li&gt;Description:        Function like macro pauses timer in specified group.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_Lib_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Lib_UnitTest01001_CorrectlyCalledFunction</srcid><srcstatus/><internalId>2189</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Lib_Int.h_242</srcid><srcstatus/><internalId>717</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1073</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Lib.Api.ResumeTimer</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>6672</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_Lib_ResumeTimer&lt;/li&gt;
              &lt;li&gt;Syntax:             void Mka_Lib_ResumeTimer(GroupIdx, TimerIdxInGroup);&lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    GroupIdx           Timer group index.&lt;/li&gt;
              &lt;li&gt;Parameters (in):    TimerIdxInGroup    Timer index in group.&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;Return value:       None&lt;/li&gt;
              &lt;li&gt;Description:        Function like macro resumes timer in specified group.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_Lib_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Lib_UnitTest01001_CorrectlyCalledFunction</srcid><srcstatus/><internalId>2189</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Lib_Int.h_257</srcid><srcstatus/><internalId>718</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1074</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Lib.Api.ProcessTimers</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>6698</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_Lib_ProcessTimers&lt;/li&gt;
              &lt;li&gt;Syntax:             void Mka_Lib_ProcessTimers();&lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    None&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;Return value:       None&lt;/li&gt;
              &lt;li&gt;
                  Description:        Function like macro ticks global timer counter and check if it is time for timeout, call corresponding
                                      callbacks for timed out timers and set next timeout value.
              &lt;/li&gt;
              &lt;li&gt;Available via:      Mka_Lib_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Lib_UnitTest01000_FirstTest</srcid><srcstatus/><internalId>2188</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Lib_Int.h_272</srcid><srcstatus/><internalId>719</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1075</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Lib.Api.TimerCallback_General</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>6726</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_Lib_TimerCallback_General&lt;/li&gt;
              &lt;li&gt;
                  Syntax:             void Mka_Lib_TimerCallback_General(
                                                                          EcuC_Timers_GroupIdxType GroupIdx,
                                                                          EcuC_Timers_TimerIdxType TimerIdxInGroup
                                                                        );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    GroupIdx            Timer group index.&lt;/li&gt;
              &lt;li&gt;Parameters (in):    TimerIdxInGroup     Timer index in group (ParticipantIdx).&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;Return value:       None&lt;/li&gt;
              &lt;li&gt;Description:        This function will be called when general usage timers timeout.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_Lib_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Lib_UnitTest01000_FirstTest</srcid><srcstatus/><internalId>2188</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Lib.c_217</srcid><srcstatus/><internalId>713</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1076</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Lib.Api.IsTimerStarted</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>6757</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_Lib_IsTimerStarted&lt;/li&gt;
              &lt;li&gt;
                  Syntax:             Std_ReturnType Mka_Lib_IsTimerStarted(
                                                                             EcuC_Timers_GroupIdxType GroupIdx,
                                                                             EcuC_Timers_TimerIdxType TimerIdxInGroup
                                                                           );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    GroupIdx            Timer group index.&lt;/li&gt;
              &lt;li&gt;Parameters (in):    TimerIdxInGroup     Timer index in group (PaeIdx).&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   None&lt;/li&gt;
              &lt;li&gt;
                  Return value:       Std_ReturnType      E_OK:     Timer is started.
                                                          E_NOT_OK: Timer is not started.
              &lt;/li&gt;
              &lt;li&gt;Description:        Function like macro indicates if timer is started.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_Lib_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Lib_UnitTest01001_CorrectlyCalledFunction</srcid><srcstatus/><internalId>2189</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Lib_Int.h_285</srcid><srcstatus/><internalId>720</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1077</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Lib.Api.ParSet_ValidateMkaPduData</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>6791</sourceline>
      <version>1</version>
      <description>
            &lt;ul&gt;
              &lt;li&gt;Service Name:       Mka_Lib_ParSet_ValidateMkaPduData&lt;/li&gt;
              &lt;li&gt;
                  Syntax:             Std_ReturnType Mka_Lib_ParSet_ValidateMkaPduData(
                                                                                        const uint8*   MkpduDataPtr,
                                                                                        uint16         MkpduDataSize,
                                                                                        Mka_MkpduType* MkaPduPtr
                                                                                      );
              &lt;/li&gt;
              &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
              &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
              &lt;li&gt;Parameters (in):    MkpduDataPtr        Pointer to a buffer of a Mkpdu that needs to be parsed.&lt;/li&gt;
              &lt;li&gt;Parameters (in):    MkpduDataSize       Size of Mkpdu.&lt;/li&gt;
              &lt;li&gt;Parameters (inout): None&lt;/li&gt;
              &lt;li&gt;Parameters (out):   MkaPduPtr           Pointer to a result Mka_MkpduType after parsing the Mkpdu.&lt;/li&gt;
              &lt;li&gt;
                  Return value:       Std_ReturnType      E_OK:     Parsing of Mkpdu successful.
                                                          E_NOT_OK: Parsing of Mkpdu failed.
              &lt;/li&gt;
              &lt;li&gt;Description:        Function like macro indicates if timer is started.&lt;/li&gt;
              &lt;li&gt;Available via:      Mka_Lib_Int.h&lt;/li&gt;
            &lt;/ul&gt;
          </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01033_LivePeerList_29_2_1</srcid><srcstatus/><internalId>2101</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Lib_ParSet.c_131</srcid><srcstatus/><internalId>722</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1078</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd" title="MKPDU transmission queue system">
    <specobject>
      <id>Mka.InterAct.MkpduQueuing</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>7110</sourceline>
      <version>1</version>
      <description>
          Mkpdu queuing shall be performed according to the sequence diagram above.
        </description>
      <verifycrit>
          The requirement is fulfilled if the interaction presented in a sequence diagram above is implemented in a test case(s) with the
          exact steps and execution order.
        </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01005_RandomGenerateFinished_E_OK</srcid><srcstatus/><internalId>2075</internalId></linkedfrom><linkedfrom><srcid>Mka_UnitTest01018_Main</srcid><srcstatus/><internalId>2277</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0120.MacSecDisabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>972</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1079</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd" title="Link state change">
    <specobject>
      <id>Mka.InterAct.LinkStateChange</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>7158</sourceline>
      <version>1</version>
      <description>
          Link state change procedure shall be performed according to the sequence diagram above.
        </description>
      <verifycrit>
          The requirement is fulfilled if the interaction presented in a sequence diagram above is implemented in a test case(s) with the
          exact steps and execution order.
        </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01000_PeriodicMkpduTransmission</srcid><srcstatus/><internalId>1688</internalId></linkedfrom><linkedfrom><srcid>Mka_Logon_UnitTest01033_PermissiveMode_LinkStateUpAndDown</srcid><srcstatus/><internalId>2223</internalId></linkedfrom><linkedfrom><srcid>Mka_Logon_UnitTest01040_Created_2_Active</srcid><srcstatus/><internalId>2230</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1080</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd" title="MKA exchange sequence when MACsec is disabled with an empty parameter sets">
    <specobject>
      <id>Mka.InterAct.MacSecDisabled.EmptyParamSets</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>7354</sourceline>
      <version>1</version>
      <description>
            MKA exchange in case that MACsec is disabled and empty parameter sets Distributed SAK and SAK Use are enabled,
            shall be performed according to the sequence diagram above.
          </description>
      <verifycrit>
            The requirement is fulfilled if the interaction presented in a sequence diagram above is implemented in a test case(s) with the
            exact steps and execution order.
          </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01026_PlainText_Peer</srcid><srcstatus/><internalId>1715</internalId></linkedfrom><linkedfrom><srcid>Mka_ConTest01027_PlainText_Peer_Permissive</srcid><srcstatus/><internalId>1716</internalId></linkedfrom><linkedfrom><srcid>Mka_ConTest01028_PlainText_KeyServer</srcid><srcstatus/><internalId>1717</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0120.MacSecDisabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>972</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1081</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd" title="MKA exchange sequence when MACsec is disabled with no empty parameter sets">
    <specobject>
      <id>Mka.InterAct.MacSecDisabled.NoEmptyParamSets</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>7421</sourceline>
      <version>1</version>
      <description>
            MKA exchange in case that MACsec is disabled and empty parameter sets Distributed SAK and SAK Use are disabled,
            shall be performed according to the sequence diagram above.
          </description>
      <verifycrit>
            The requirement is fulfilled if the interaction presented in a sequence diagram above is implemented in a test case(s) with the
            exact steps and execution order.
          </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01029_MacSecDisabled_NoPlainText_Peer</srcid><srcstatus/><internalId>1718</internalId></linkedfrom><linkedfrom><srcid>Mka_ConTest01030_MacSecDisabled_NoPlainText_KeyServer</srcid><srcstatus/><internalId>1719</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0120.MacSecDisabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>972</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1082</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd" title="MKA exchange sequence when MACsec is disabled with empty parameter sets and configured MkaDelayMacSecOperationalTimer">
    <specobject>
      <id>Mka.InterAct.MacSecDisabled.EmptyParamSets.DelayTimer</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>7467</sourceline>
      <version>1</version>
      <description>
            MKA exchange in case when MACsec is disabled, timer to delay MacSecOperational is used and empty parameter sets Distributed SAK
            and SAK Use are disabled, shall be performed according to the sequence diagram above.
          </description>
      <verifycrit>
            The requirement is fulfilled if the interaction presented in a sequence diagram above is implemented in a test case(s) with the
            exact steps and execution order.
          </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01031_MacSecDisabled_PlainText_Peer</srcid><srcstatus/><internalId>1720</internalId></linkedfrom><linkedfrom><srcid>Mka_ConTest01032_MacSecDisabled_PlainText_KeyServer</srcid><srcstatus/><internalId>1721</internalId></linkedfrom><linkedfrom><srcid>Mka_ConTest01037_DelayMacSecOperation_EmptySak</srcid><srcstatus/><internalId>1726</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0120.MacSecDisabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>972</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1083</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd" title="MKA pre-compile parameter that defines position of new key to be either in LatestKey or OldKey">
    <specobject>
      <id>Mka.InterAct.MkaLatestKeyGetsOldAfterRetire</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>7517</sourceline>
      <version>1</version>
      <description>
            MKA exchange in case when MkaLatestKeyGetsOldAfterRetire is disabled, new key stays on the position of LatestKey, shall be performed according to the sequence diagram above.
            MKA exchange in case when MkaLatestKeyGetsOldAfterRetire is enabled, new key moves to the position of OldKey, shall be performed according to the sequence diagram above.
          </description>
      <verifycrit>
            The requirement is fulfilled if both interactions presented in a sequence diagram above are implemented in test cases with the
            exact steps and execution order.
          </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01004_KSPHigh_KSPartner</srcid><srcstatus/><internalId>1692</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.MkaLatestKeyGetsOldAfterRetire_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1443</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1084</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd" title="RxTx Unit Tx/Rx State TX Machine Top Level Requirements">
    <specobject>
      <id>Mka.dsn.RxTx.TxSM</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>7579</sourceline>
      <version>2</version>
      <description>
           TX state machine is implemented in RxTx unit and it manages Tx buffer allocation, ICV generation and frame transmission.
           Each Mka instance has single TX state machine, i.e. it can handle single MKPDU transmission at a time.
           Once buffer is successfully allocated it remains locked until frame is transmitted or released.
        </description>
      <furtherinfo>
          WRN.swdd.needscoverage.count - Linking transition requirements to state machine top-level
          requirement is beneficial, splitting them up would only increase complexity without any
          real advantages.
        </furtherinfo>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.dsn.RxTx.TxSM.TxBufAllocLocked_2_TxBufAllocUnlocked</srcid><srcstatus/><internalId>1405</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.RxTx.TxSM.TxBufAllocLocked_2_WaitIcvGenFin</srcid><srcstatus/><internalId>1406</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.RxTx.TxSM.TxBufUnalloc_2_TxBufAllocLocked</srcid><srcstatus/><internalId>1407</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.RxTx.TxSM.TxBufAllocUnlocked_2_TxBufAllocLocked</srcid><srcstatus/><internalId>1408</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.RxTx.TxSM.WaitIcvGenFin_2_TxBufUnalloc</srcid><srcstatus/><internalId>1409</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.RxTx.TxSM.Initial_2_TxBufUnalloc</srcid><srcstatus/><internalId>1410</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.RxTx.TxSM.WaitIcvGenFin_2_TxBufAllocUnlocked</srcid><srcstatus/><internalId>1411</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.RxTx.TxSM.IcvGenerateFinished.UnexpectedState</srcid><srcstatus/><internalId>1626</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.RxTx.TxSM.TxBufferReady.UnexpectedState</srcid><srcstatus/><internalId>1627</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.RxTx.TxSM.GetTxBuffer.UnexpectedState</srcid><srcstatus/><internalId>1628</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.RxTx.TxSM.ReleaseTxBuffer.UnexpectedState</srcid><srcstatus/><internalId>1629</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0100.MkaTransport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>952</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1085</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd" title="RxTx Unit Tx/Rx RX State Machine Top Level Requirements">
    <specobject>
      <id>Mka.dsn.RxTx.RxSM</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>7626</sourceline>
      <version>2</version>
      <description>
           RX state machine is implemented in RxTx unit and it manages RX buffer allocation and ICV verification.
           Each Mka instance has single Rx state machine, i.e. it can handle single MKPDU reception at a time.
           Once buffer is successfully allocated it remains locked until frame is verified and processed.
        </description>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.dsn.RxTx.RxSM.WaitIcvVer_2_RxBufFree_OK</srcid><srcstatus/><internalId>1401</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.RxTx.RxSM.WaitIcvVer_2_RxBufFree_NOT_OK</srcid><srcstatus/><internalId>1402</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.RxTx.RxSM.RxBufFree_2_WaitIcvVer</srcid><srcstatus/><internalId>1403</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.RxTx.RxSM.Initial_2_RxBufFree</srcid><srcstatus/><internalId>1404</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0100.MkaTransport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>952</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1086</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd" title="Crypto Unit State Machine Top Level Requirement">
    <specobject>
      <id>Mka.dsn.Crypto.CryptoSM</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>7667</sourceline>
      <version>3</version>
      <description>
          Crypto state machine is implemented in Crypto unit and it manages all Crypto primitive operations and interaction with Csm module.
        </description>
      <furtherinfo>
          WRN.swdd.needscoverage.count - Linking transition requirements to state machine top-level
          requirement is beneficial, splitting them up would only increase complexity without any
          real advantages.
        </furtherinfo>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.dsn.Crypto.CryptoSM.CakCkn_Ready_2_Ick_Ready</srcid><srcstatus/><internalId>1326</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Crypto.CryptoSM.Sak_Ready_2_CakCkn_Ready_Stop</srcid><srcstatus/><internalId>1327</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Crypto.CryptoSM.Sak_Ready_2_CakCkn_Ready</srcid><srcstatus/><internalId>1328</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Crypto.CryptoSM.Kek_Ready_2_CakCkn_Ready_Wrap</srcid><srcstatus/><internalId>1329</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Crypto.CryptoSM.ValidateKeys_CakCkn_Ready</srcid><srcstatus/><internalId>1330</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Crypto.CryptoSM.Kek_Ready_2_CakCkn_Ready_Stop</srcid><srcstatus/><internalId>1331</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Crypto.CryptoSM.Kek_Ready_2_CakCkn_Ready_Unwrap</srcid><srcstatus/><internalId>1332</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Crypto.CryptoSM.Ick_Ready_2_CakCkn_Ready</srcid><srcstatus/><internalId>1333</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Crypto.CryptoSM.Ick_Ready_2_CakCkn_Ready_Stop</srcid><srcstatus/><internalId>1334</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Crypto.CryptoSM.Ick_ready_2_Kek_Ready</srcid><srcstatus/><internalId>1335</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Crypto.CryptoSM.ValidateKeys_Idle</srcid><srcstatus/><internalId>1336</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Crypto.CryptoSM.Kek_Ready_2_Sak_Ready_Wrap</srcid><srcstatus/><internalId>1337</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Crypto.CryptoSM.Kek_Ready_2_Sak_Ready_Unwrap</srcid><srcstatus/><internalId>1338</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Crypto.CryptoSM.SelfTrans.Kek_Ready</srcid><srcstatus/><internalId>1339</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Crypto.CryptoSM.Sak_Ready_2_Kek_Ready_WrapUnwrapFail</srcid><srcstatus/><internalId>1340</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Crypto.CryptoSM.Sak_Ready_2_Kek_Ready_Rekey</srcid><srcstatus/><internalId>1341</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Crypto.CryptoSM.Sak_Ready_2_Kek_Ready_Stop</srcid><srcstatus/><internalId>1342</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Crypto.CryptoSM.ValidateKeys_KekReady</srcid><srcstatus/><internalId>1343</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.KaY.PeerSM.SelfTrans.ValidateKeys</srcid><srcstatus/><internalId>1344</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Crypto.CryptoSM.Initial_ValidateKeys</srcid><srcstatus/><internalId>1345</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1087</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd" title="Crypto Unit Random generate State Machine Top Level Requirement">
    <specobject>
      <id>Mka.dsn.Crypto.RandomGenSM</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>7707</sourceline>
      <version>2</version>
      <description>
           Random generate state machine is implemented in Crypto unit and it manages Random number generation.
        </description>
      <furtherinfo>
          WRN.swdd.needscoverage.count  - Linking all tests to the single top-level requirement brings clear benefits and splitting
          them up would only increase complexity without any real improvements.
        </furtherinfo>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.dsn.Crypto.RandomGenSM.GenMoreData_2_Notified</srcid><srcstatus/><internalId>1346</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Crypto.RandomGenSM.GenMoreData_Queue</srcid><srcstatus/><internalId>1347</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Crypto.RandomGenSM.GenMoreData</srcid><srcstatus/><internalId>1348</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Crypto.RandomGenSM.GenMoreData_Retry</srcid><srcstatus/><internalId>1349</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Crypto.RandomGenSM.Busy_2_GenMoreData</srcid><srcstatus/><internalId>1350</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Crypto.RandomGenSM.Notified</srcid><srcstatus/><internalId>1351</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Crypto.RandomGenSM.Notified_2_Busy</srcid><srcstatus/><internalId>1352</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Crypto.RandomGenSM.Notified_2_Idle</srcid><srcstatus/><internalId>1353</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Crypto.RandomGenSM.Busy_2_Notified</srcid><srcstatus/><internalId>1354</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Crypto.RandomGenSM.Initial_Initialization</srcid><srcstatus/><internalId>1355</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Crypto.RandomGenSM.Busy_Retry</srcid><srcstatus/><internalId>1356</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Crypto.RandomGenSM.Busy_Queue</srcid><srcstatus/><internalId>1357</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Crypto.RandomGenSM.Idle_2_Busy</srcid><srcstatus/><internalId>1358</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1088</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd" title="Crypto Unit key generate State Machine Top Level Requirement">
    <specobject>
      <id>Mka.dsn.Crypto.KeyGenSM</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>7746</sourceline>
      <version>1</version>
      <description>
           Key generate state machine is implemented in Crypto unit and it manages Ick and Kek generation.
        </description>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.dsn.Crypto.KeyGenSM.Requested_2_Busy</srcid><srcstatus/><internalId>1301</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Crypto.KeyGenSM.Preparing_2_Requested</srcid><srcstatus/><internalId>1302</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Crypto.KeyGenSM.Initial_Initialization</srcid><srcstatus/><internalId>1303</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Crypto.KeyGenSM.Preparing_2_Idle</srcid><srcstatus/><internalId>1304</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Crypto.KeyGenSM.Idle_2_Preparing_Kek</srcid><srcstatus/><internalId>1305</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Crypto.KeyGenSM.Idle_2_Preparing</srcid><srcstatus/><internalId>1306</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Crypto.KeyGenSM.Busy_2_Idle_Fail</srcid><srcstatus/><internalId>1307</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Crypto.KeyGenSM.Busy_2_Idle_Ick</srcid><srcstatus/><internalId>1308</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Crypto.KeyGenSM.Busy_2_Idle_Kek</srcid><srcstatus/><internalId>1309</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1089</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd" title="Crypto Unit Icv generate State Machine Top Level Requirement">
    <specobject>
      <id>Mka.dsn.Crypto.IcvGenSM</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>7781</sourceline>
      <version>2</version>
      <description>
           Icv generate state machine is implemented in Crypto unit and it manages icv generation.
        </description>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.dsn.Crypto.IcvGenSM.Requested_2_Busy</srcid><srcstatus/><internalId>1259</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Crypto.IcvGenSM.Requested_2_Notify</srcid><srcstatus/><internalId>1260</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Crypto.IcvGenSM.Requested_2_Idle</srcid><srcstatus/><internalId>1261</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Crypto.IcvGenSM.Idle_2_Requested</srcid><srcstatus/><internalId>1262</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Crypto.IcvGenSM.Busy_2_Idle</srcid><srcstatus/><internalId>1263</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Crypto.IcvGenSM.Notify_2_Idle</srcid><srcstatus/><internalId>1264</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Crypto.IcvGenSM.Initial_Initialization</srcid><srcstatus/><internalId>1265</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Crypto.IcvGenSM.Busy_2_Notify</srcid><srcstatus/><internalId>1266</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Crypto.IcvGenSM.Busy_SelfTransition</srcid><srcstatus/><internalId>1267</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1090</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd" title="Crypto Unit Icv verify State Machine Top Level Requirement">
    <specobject>
      <id>Mka.dsn.Crypto.IcvVerSM</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>7816</sourceline>
      <version>1</version>
      <description>
           Icv verify state machine is implemented in Crypto unit and it manages icv verification.
        </description>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.dsn.Crypto.IcvVerSM.Notified_2_Idle</srcid><srcstatus/><internalId>1268</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Crypto.IcvVerSM.Requested_2_Notified</srcid><srcstatus/><internalId>1269</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Crypto.IcvVerSM.Busy_2_Notified</srcid><srcstatus/><internalId>1270</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Crypto.IcvVerSM.Initial_Initialization</srcid><srcstatus/><internalId>1271</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Crypto.IcvVerSM.Busy_2_Idle_Fail</srcid><srcstatus/><internalId>1272</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Crypto.IcvVerSM.Busy</srcid><srcstatus/><internalId>1273</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Crypto.IcvVerSM.Requested_2_Busy</srcid><srcstatus/><internalId>1274</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Crypto.IcvVerSM.Idle_2_Requested</srcid><srcstatus/><internalId>1275</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Crypto.IcvVerSM.Requested_2_Idle</srcid><srcstatus/><internalId>1276</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1091</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd" title="Crypto Unit key wrap State Machine Top Level Requirement">
    <specobject>
      <id>Mka.dsn.Crypto.KeyWrapSM</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>7851</sourceline>
      <version>1</version>
      <description>
           Key wrap state machine is implemented in Crypto unit and it manages generation and wrapping of SAK.
        </description>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.dsn.Crypto.KeyWrapSM.Busy_2_Busy_SakGenerate</srcid><srcstatus/><internalId>1317</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Crypto.KeyWrapSM.Busy_2_Busy_Server</srcid><srcstatus/><internalId>1318</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Crypto.KeyWrapSM.Busy_2_Idle_Fail_Server</srcid><srcstatus/><internalId>1319</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Crypto.KeyWrapSM.Busy_2_Idle_Fail_Sak</srcid><srcstatus/><internalId>1320</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Crypto.KeyWrapSM.Busy_2_Hashgen_Server</srcid><srcstatus/><internalId>1321</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Crypto.KeyWrapSM.Requested_2_Busy_Server</srcid><srcstatus/><internalId>1322</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Crypto.KeyWrapSM.Idle_2_Requested_Server</srcid><srcstatus/><internalId>1323</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Crypto.KeyWrapSM.Hashgen_2_Idle_Server</srcid><srcstatus/><internalId>1324</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Crypto.KeyWrapSM.Initial_Initialization</srcid><srcstatus/><internalId>1325</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1092</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd" title="Crypto Unit key unwrap State Machine Top Level Requirement">
    <specobject>
      <id>Mka.dsn.Crypto.KeyUnwrapSM</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>7886</sourceline>
      <version>1</version>
      <description>
           Key unwrap state machine is implemented in Crypto unit and it manages unwrapping of SAK.
        </description>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.dsn.Crypto.KeyUnwrapSM.Hashgen_2_Idle</srcid><srcstatus/><internalId>1310</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Crypto.KeyUnwrapSM.Busy_2_Hashgen</srcid><srcstatus/><internalId>1311</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Crypto.KeyUnwrapSM.Initial_Initialization</srcid><srcstatus/><internalId>1312</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Crypto.KeyUnwrapSM.Busy_2_Busy</srcid><srcstatus/><internalId>1313</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Crypto.KeyUnwrapSM.Busy_2_Idle_Fail</srcid><srcstatus/><internalId>1314</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Crypto.KeyUnwrapSM.Requested_2_Busy</srcid><srcstatus/><internalId>1315</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Crypto.KeyUnwrapSM.Idle_2_Requested</srcid><srcstatus/><internalId>1316</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1093</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd" title="KaY Unit Instance State Machine Top Level Requirement">
    <specobject>
      <id>Mka.dsn.KaY.InstSM</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>7922</sourceline>
      <version>1</version>
      <description>
           Instance state machine is implemented in KaY unit and it manages Mka instances creation and deletion, including Member identifier
           generation and interface to Peer state machine.
        </description>
      <furtherinfo>
          WRN.swdd.needscoverage.count - Linking transition requirements to state machine top-level
          requirement is beneficial, splitting them up would only increase complexity without any
          real advantages.
        </furtherinfo>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.dsn.KaY.InstSM.Disabled_2_WaitFirstMemberId</srcid><srcstatus/><internalId>1277</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.KaY.InstSM.WaitFirstMemberId_2_Disabled_RetVal_NOT_OK</srcid><srcstatus/><internalId>1278</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.KaY.InstSM.ANY_2_Disabled_DeleteParticipant</srcid><srcstatus/><internalId>1279</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.KaY.InstSM.Initial_2_Disabled</srcid><srcstatus/><internalId>1280</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.KaY.InstSM.WaitNewMemberId_2_Disabled_Result_NOT_OK</srcid><srcstatus/><internalId>1281</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.KaY.InstSM.WaitFirstMemberId_2_Disabled_Result_NOT_OK</srcid><srcstatus/><internalId>1282</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.KaY.InstSM.WaitNewMemberId_2_Running</srcid><srcstatus/><internalId>1283</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.KaY.InstSM.Running_2_WaitNewMemberId</srcid><srcstatus/><internalId>1284</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.KaY.InstSM.WaitFirstMemberId</srcid><srcstatus/><internalId>1285</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.KaY.InstSM.WaitFirstMemberId_2_InstanceRunning</srcid><srcstatus/><internalId>1286</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.KaY.InstSM.WaitFirstMemberId_2_WaitLinkActive</srcid><srcstatus/><internalId>1287</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.KaY.InstSM.WaitLinkActive_2_InstanceRunning</srcid><srcstatus/><internalId>1288</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.KaY.InstSM.SelfTrans.NewMemberId</srcid><srcstatus/><internalId>1289</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1094</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd" title="KaY Unit Peer State Machine Top Level Requirement">
    <specobject>
      <id>Mka.dsn.KaY.PeerSM</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>7962</sourceline>
      <version>2</version>
      <description>
           Peer state machine is implemented in KaY unit and it manages partner's state as potential or live partner, based on received
           MKPDUs and peer lifetime timer.
        </description>
      <furtherinfo>
          WRN.swdd.needscoverage.count - Linking transition requirements to state machine top-level
          requirement is beneficial, splitting them up would only increase complexity without any
          real advantages.
        </furtherinfo>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.dsn.KaY.PeerSM.Any_2_Undetected</srcid><srcstatus/><internalId>1290</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.KaY.PeerSM.Undetected_2_Live</srcid><srcstatus/><internalId>1291</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.KaY.PeerSM.Undetected_2_Potential</srcid><srcstatus/><internalId>1292</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.KaY.PeerSM.Initial_2_Undetected</srcid><srcstatus/><internalId>1293</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.KaY.PeerSM.Live_2_LivePrincipal</srcid><srcstatus/><internalId>1294</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.KaY.PeerSM.SelfTrans.Live</srcid><srcstatus/><internalId>1295</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.KaY.PeerSM.Potential_2_Live</srcid><srcstatus/><internalId>1296</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.KaY.PeerSM.LivePrincipal_2_Live</srcid><srcstatus/><internalId>1297</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.KaY.PeerSM.SelfTrans.Potential</srcid><srcstatus/><internalId>1298</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.KaY.PeerSM.LivePrincipal_2_Potential</srcid><srcstatus/><internalId>1299</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.KaY.PeerSM.SelfTrans.LivePrincipal.RxMkpdu</srcid><srcstatus/><internalId>1300</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1095</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd" title="KaY Unit Key State Machine Top Level Requirement">
    <specobject>
      <id>Mka.dsn.KaY.KeySM</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>8002</sourceline>
      <version>2</version>
      <description>
           Key state machine is implemented in KaY unit and it manages SAK key generation and distribution.
        </description>
      <furtherinfo>
          WRN.swdd.needscoverage.count - Linking transition requirements to state machine top-level
          requirement is beneficial, splitting them up would only increase complexity without any
          real advantages.
        </furtherinfo>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.dsn.KaY.KeySM.DelayNewSak_2_WaitNewSakReq</srcid><srcstatus/><internalId>1412</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.KaY.KeySM.SelfTrans.DelayNewSak</srcid><srcstatus/><internalId>1413</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.KaY.KeySM.GenerateNewSak_2_DelayNewSak</srcid><srcstatus/><internalId>1414</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.KaY.KeySM.Initial_2_Disabled</srcid><srcstatus/><internalId>1415</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.KaY.KeySM.ANY_2_Disabled</srcid><srcstatus/><internalId>1416</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.KaY.KeySM.WaitSakDistribution_2_WaitSakUnwrap</srcid><srcstatus/><internalId>1417</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.KaY.KeySM.GenerateKek_2_WaitSakDistribution</srcid><srcstatus/><internalId>1418</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.KaY.KeySM.Disabled_2_WaitSakDistribution</srcid><srcstatus/><internalId>1419</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.KaY.KeySM.WaitSakUnwrap_2_WaitSakDistribution_CryptoOk</srcid><srcstatus/><internalId>1420</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.KaY.KeySM.WaitSakUnwrap_2_WaitSakDistribution_CryptoNotOk</srcid><srcstatus/><internalId>1421</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.KaY.KeySM.SelfTrans.GenerateKek</srcid><srcstatus/><internalId>1422</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.KaY.KeySM.GenerateKek_2_GenerateNewSak</srcid><srcstatus/><internalId>1423</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.KaY.KeySM.Disabled_2_GenerateKek</srcid><srcstatus/><internalId>1424</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.KaY.KeySM.Disabled_2_GenerateNewSak</srcid><srcstatus/><internalId>1425</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.KaY.KeySM.SelfTrans.GenerateNewSak</srcid><srcstatus/><internalId>1426</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.KaY.KeySM.WaitNewSakReq_2_GenerateNewSak</srcid><srcstatus/><internalId>1427</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.KaY.KeySM.SelfTrans.WaitNewSakReq</srcid><srcstatus/><internalId>1428</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.KaY.KeySM.SelfTrans.WaitSakUnwrap</srcid><srcstatus/><internalId>1429</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1096</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd" title="Cp Unit Cp State Machine Top Level Requirements">
    <specobject>
      <id>Mka.dsn.Cp.CpSM</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>8042</sourceline>
      <version>1</version>
      <description>
          Cp state machine is implemented in Cp unit and it manages creation, deletion and transitions
          from old SAs with old SAKs to new SAs with new SAKs. One Cp state machine is implemented per one port.
        </description>
      <furtherinfo>
          WRN.swdd.needscoverage.count - Linking transition requirements to state machine top-level
          requirement is beneficial, splitting them up would only increase complexity without any
          real advantages.
        </furtherinfo>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.dsn.Cp.CpSM.Secured_2_WaitAddRxSa</srcid><srcstatus/><internalId>1375</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Cp.CpSM.Secured_2_UpdateSecY</srcid><srcstatus/><internalId>1376</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Cp.CpSM.InitRxSc_2_Secured</srcid><srcstatus/><internalId>1377</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Cp.CpSM.Transmitting_2_Retire</srcid><srcstatus/><internalId>1378</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Cp.CpSM.Receiving_2_Transmitting</srcid><srcstatus/><internalId>1379</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Cp.CpSM.Receiving_2_Transmitting2</srcid><srcstatus/><internalId>1380</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Cp.CpSM.Ready_2_Transmitting</srcid><srcstatus/><internalId>1381</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Cp.CpSM.WaitRxSc_2_InitRxSc</srcid><srcstatus/><internalId>1382</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Cp.CpSM.WaitRxSc_2_UpdateSecY</srcid><srcstatus/><internalId>1383</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Cp.CpSM.UpdateSecY_2_WaitRxSc</srcid><srcstatus/><internalId>1384</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Cp.CpSM.Any_2_WaitRxSc</srcid><srcstatus/><internalId>1385</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Cp.CpSM.Uninit_2_UpdateSecY</srcid><srcstatus/><internalId>1386</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Cp.CpSM.Uninit</srcid><srcstatus/><internalId>1387</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Cp.CpSM.Restart_2_Uninit</srcid><srcstatus/><internalId>1388</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Cp.CpSM.WaitAddTxSa_2_Receiving</srcid><srcstatus/><internalId>1389</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Cp.CpSM.WaitAddRxSa_2_WaitAddTxSa</srcid><srcstatus/><internalId>1390</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Cp.CpSM.Receiving_2_Ready</srcid><srcstatus/><internalId>1391</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Cp.CpSM.Receiving_2_WaitAddRxSa</srcid><srcstatus/><internalId>1392</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Cp.CpSM.Delete_2_Restart</srcid><srcstatus/><internalId>1393</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Cp.CpSM.Unsecured</srcid><srcstatus/><internalId>1394</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Cp.CpSM.InitRxSc_2_UpdateSecY</srcid><srcstatus/><internalId>1395</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Cp.CpSM.Ready_2_WaitAddRxSa</srcid><srcstatus/><internalId>1396</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Cp.CpSM.Retire_2_WaitAddRxSa</srcid><srcstatus/><internalId>1397</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Cp.CpSM.Any_2_Uninit</srcid><srcstatus/><internalId>1503</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.64</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>277</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1097</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd" title="Logon Unit NVM State Machine Top Level Requirements">
    <specobject>
      <id>Mka.dsn.Func0122.DynamicControl</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>8089</sourceline>
      <version>1</version>
      <description>
          NVM state machine is implemented in Logon unit and it manages initialization and usage of
          non volatile memory that us used to store Mka module startup configuration.
        </description>
      <furtherinfo>
          WRN.swurs.needscoverage.count - Linking all feature requirements to the single top-level
          requirement brings clear benefits and splitting them up would only increase complexity
          without any real improvements.
        </furtherinfo>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.CP_SWS_Mka_00027</srcid><srcstatus/><internalId>343</internalId></linkedfrom><linkedfrom><srcid>Mka.CP_SWS_Mka_91015</srcid><srcstatus/><internalId>377</internalId></linkedfrom><linkedfrom><srcid>Mka.CP_SWS_Mka_01001</srcid><srcstatus/><internalId>378</internalId></linkedfrom><linkedfrom><srcid>Mka.CP_SWS_Mka_91016</srcid><srcstatus/><internalId>379</internalId></linkedfrom><linkedfrom><srcid>Mka.CP_SWS_Mka_91020</srcid><srcstatus/><internalId>380</internalId></linkedfrom><linkedfrom><srcid>Mka.CP_SWS_Mka_01002</srcid><srcstatus/><internalId>381</internalId></linkedfrom><linkedfrom><srcid>Mka.CP_SWS_Mka_91017</srcid><srcstatus/><internalId>382</internalId></linkedfrom><linkedfrom><srcid>Mka.CP_SWS_Mka_91018</srcid><srcstatus/><internalId>383</internalId></linkedfrom><linkedfrom><srcid>Mka.CP_SWS_Mka_91021</srcid><srcstatus/><internalId>384</internalId></linkedfrom><linkedfrom><srcid>Mka.CP_SWS_Mka_01003</srcid><srcstatus/><internalId>385</internalId></linkedfrom><linkedfrom><srcid>Mka.CP_SWS_Mka_91022</srcid><srcstatus/><internalId>386</internalId></linkedfrom><linkedfrom><srcid>Mka.CP_SWS_Mka_01004</srcid><srcstatus/><internalId>387</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.EB.MkaPostBuildConfigurationHash_Conf</srcid><srcstatus/><internalId>1449</internalId></linkedfrom><linkedfrom><srcid>Mka.EB.Mka.MkaNvmBlock_Conf</srcid><srcstatus/><internalId>1452</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Logon.ManualPaeStart</srcid><srcstatus/><internalId>1605</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Logon.Nvm.Start</srcid><srcstatus/><internalId>1608</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Logon.Nvm.GetStatus</srcid><srcstatus/><internalId>1609</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Logon.Nvm.SetChangedStatus</srcid><srcstatus/><internalId>1610</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Logon.Nvm.WriteBlockImmediately</srcid><srcstatus/><internalId>1611</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Logon.Nvm.ShadowNvMemoryBlock</srcid><srcstatus/><internalId>1612</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Logon.Nvm.MacSecDisabledByDefault</srcid><srcstatus/><internalId>1613</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1098</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd" title="Logon Unit Participant State Machine Top Level Requirements">
    <specobject>
      <id>Mka.dsn.Logon.ParticipantSM</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>8131</sourceline>
      <version>1</version>
      <description>
          Participant state machine is implemented in Logon unit and it manages initialization, startup, disabling and other processes
          of Mka Participant.
        </description>
      <furtherinfo>
          WRN.swdd.needscoverage.count - Linking all feature requirements to the single top-level
          requirement brings clear benefits and splitting them up would only increase complexity
          without any real improvements.
        </furtherinfo>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.dsn.Logon.ParticipantSM.Init_2_Created</srcid><srcstatus/><internalId>1359</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Logon.ParticipantSM.Init_2_GenerateIck_Auto</srcid><srcstatus/><internalId>1360</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Logon.ParticipantSM.Init_2_GenerateIck_Manual</srcid><srcstatus/><internalId>1361</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Logon.ParticipantSM.Init_2_Active</srcid><srcstatus/><internalId>1362</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Logon.ParticipantSM.LinkStateDown</srcid><srcstatus/><internalId>1363</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Logon.ParticipantSM.Initialization</srcid><srcstatus/><internalId>1364</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Logon.ParticipantSM.ParticipantDisabled</srcid><srcstatus/><internalId>1365</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Logon.ParticipantSM.ParticipantStop</srcid><srcstatus/><internalId>1366</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Logon.ParticipantSM.GenerateIck_2_Init</srcid><srcstatus/><internalId>1367</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Logon.ParticipantSM.SuccessfulActor_2_Init</srcid><srcstatus/><internalId>1368</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Logon.ParticipantSM.Active_2_SuccessfulActor</srcid><srcstatus/><internalId>1369</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Logon.ParticipantSM.Active_2_Disabled</srcid><srcstatus/><internalId>1370</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Logon.ParticipantSM.GenerateIck_2_Active</srcid><srcstatus/><internalId>1371</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Logon.ParticipantSM.Created_2_Active</srcid><srcstatus/><internalId>1372</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Logon.ParticipantSM.Any_2_Disabled</srcid><srcstatus/><internalId>1373</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Logon.ParticipantSM.GenerateIck_2_Created</srcid><srcstatus/><internalId>1374</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1099</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd" title="Mka initialization requirement">
    <specobject>
      <id>Mka.InterAct.Initialization</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>8184</sourceline>
      <version>1</version>
      <description>
            The initialization of Mka module together with initialization of module units shall be performed according to the
            sequence shown in the diagram above.
          </description>
      <verifycrit>
            The requirement is fulfilled if the interaction presented in a sequence diagram above is implemented in a test case(s) with the
            exact steps and execution order.
          </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_UnitTest01051_Init_Failed</srcid><srcstatus/><internalId>2310</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1100</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd" title="Mka main function requirement">
    <specobject>
      <id>Mka.InterAct.MainFunction</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>8218</sourceline>
      <version>1</version>
      <description>
            Execution of Mka main function, including timer processing and unit main function calls, shall be performed according to the
            sequence shown in the diagram above.
          </description>
      <verifycrit>
            The requirement is fulfilled if the interaction presented in a sequence diagram above is implemented in a test case(s) with the
            exact steps and execution order.
          </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_UnitTest01018_Main</srcid><srcstatus/><internalId>2277</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1101</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd" title="MKPDU reception requirement">
    <specobject>
      <id>Mka.InterAct.RxMkpdu</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>8256</sourceline>
      <version>1</version>
      <description>
            The process of receiving MKPDU packet from EthIf, its verification, buffering and ICV verification, shall be performed according
            to the sequence shown in the diagram above.
          </description>
      <verifycrit>
            The requirement is fulfilled if the interaction presented in a sequence diagram above is implemented in a test case(s) with the
            exact steps and execution order.
          </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_UnitTest01019_RxIndication</srcid><srcstatus/><internalId>2278</internalId></linkedfrom><linkedfrom><srcid>Mka_RxTx_UnitTest01004_Initial_2_RxBufFree_2_WaitIcvVerFin_2_RxBufFree</srcid><srcstatus/><internalId>2318</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1102</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd" title="MKPDU transmission requirement">
    <specobject>
      <id>Mka.InterAct.TxMkpdu</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>8290</sourceline>
      <version>1</version>
      <description>
            The process of transmitting MKPDU including buffer allocation, ICV generation and transmission by EthIf shall be performed
            according to the sequence shown in the diagram above.
          </description>
      <verifycrit>
            The requirement is fulfilled if the interaction presented in a sequence diagram above is implemented in a test case(s) with the
            exact steps and execution order.
          </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01005_RandomGenerateFinished_E_OK</srcid><srcstatus/><internalId>2075</internalId></linkedfrom><linkedfrom><srcid>Mka_RxTx_UnitTest01001_Initial_2_BufUnalloc_2_BufAlloc</srcid><srcstatus/><internalId>2315</internalId></linkedfrom><linkedfrom><srcid>Mka_RxTx_UnitTest01002_BufAlloc_2_WaitIcvGenFin_2_BufUnalloc</srcid><srcstatus/><internalId>2316</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1103</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd" title="New Sak received requirement">
    <specobject>
      <id>Mka.InterAct.Cp.NewSak</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>8328</sourceline>
      <version>1</version>
      <description>
            The process of receiving new SAK and steps in configuring new SA in SecY (through EthIf) shall be performed according to the
            sequence shown in the diagram above.
          </description>
      <verifycrit>
            The requirement is fulfilled if the interaction presented in a sequence diagram above is implemented in a test case(s) with the
            exact steps and execution order.
          </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Cp_UnitTest01003_CpSM_Receiving2Transmitting</srcid><srcstatus/><internalId>1815</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01004_CpSM_Ready2Retire</srcid><srcstatus/><internalId>1816</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1104</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd" title="New Sak received, rekeying requirement">
    <specobject>
      <id>Mka.InterAct.Cp.NewSak.Rekeying</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>8363</sourceline>
      <version>1</version>
      <description>
            The rekeying process after receiving new SAK and steps in configuring new SA in SecY (through EthIf) shall be performed according
            to the sequence shown in the diagram above.
          </description>
      <verifycrit>
            The requirement is fulfilled if the interaction presented in a sequence diagram above is implemented in a test case(s) with the
            exact steps and execution order.
          </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Cp_UnitTest01006_CpSM_Ready2Retire_2ndLoop</srcid><srcstatus/><internalId>1818</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1105</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd" title="MacSecOperational requirement">
    <specobject>
      <id>Mka.InterAct.Cp.MacSecOperational</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>8397</sourceline>
      <version>1</version>
      <description>
            It is assumed that MacSecOperational is False, i.e. this is the first SAK, not rekeying.
            The process of updating MacSecOperational status shall be performed according to the sequence shown in the diagram above.
          </description>
      <verifycrit>
            The requirement is fulfilled if the interaction presented in a sequence diagram above is implemented in a test case(s) with the
            exact steps and execution order.
          </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Cp_UnitTest01003_CpSM_Receiving2Transmitting</srcid><srcstatus/><internalId>1815</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01006_CpSM_Ready2Retire_2ndLoop</srcid><srcstatus/><internalId>1818</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1106</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd" title="MacSecDisabled requirement">
    <specobject>
      <id>Mka.InterAct.Cp.MacSecDisabled</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>8432</sourceline>
      <version>1</version>
      <description>
            The MacSecDisabled process shall be performed according to the sequence shown in the diagram above.
          </description>
      <verifycrit>
            The requirement is fulfilled if the interaction presented in a sequence diagram above is implemented in a test case(s) with the
            exact steps and execution order.
          </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Cp_UnitTest01016_CpSM_Ready2Unsecured</srcid><srcstatus/><internalId>1828</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1107</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd" title="SecY retry exhausted requirement">
    <specobject>
      <id>Mka.InterAct.Cp.SecYRetry_Exhausted</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>8466</sourceline>
      <version>1</version>
      <description>
            When Cp unit SecY call retries exceed the configured retry limit MkaSecYRetryAttempts, Cp unit deletes SAs and resets the port.
            The process after exceeding the configured MkaSecYRetryAttempts attempts shall be performed according to the sequence shown in
            the diagram above.
          </description>
      <verifycrit>
            The requirement is fulfilled if the interaction presented in a sequence diagram above is implemented in a test case(s) with the
            exact steps and execution order.
          </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Cp_UnitTest01063_SecYRetry_Fail_CpSmTransmitting_Step0</srcid><srcstatus/><internalId>1872</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0117.SecYRetry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>969</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1108</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd" title="Kay interactions requirement">
    <specobject>
      <id>Mka.InterAct.KayInteractions</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>8512</sourceline>
      <version>1</version>
      <description>
            Interaction of KaY unit with other units, including MKA instance creation, MKPDU reception and SAK generation / reception
            shall be performed according to the sequence shown in the diagram above.
          </description>
      <verifycrit>
            The requirement is fulfilled if the interaction presented in a sequence diagram above is implemented in a test case(s) with the
            exact steps and execution order.
          </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01005_RandomGenerateFinished_E_OK</srcid><srcstatus/><internalId>2075</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01042_KeySm_Disabled2GenerateNewSak</srcid><srcstatus/><internalId>2110</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01043_KeySm_Disabled2WaitSakDistribution</srcid><srcstatus/><internalId>2111</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1109</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd" title="Kay Peer life timeout interactions requirement">
    <specobject>
      <id>Mka.InterAct.KayInteractions.PeerLifeTimeout</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>8547</sourceline>
      <version>1</version>
      <description>
            Interaction of KaY unit with other units, when Peer Life Timeout occurs,
            shall be performed according to the sequence shown in the diagram above.
          </description>
      <verifycrit>
            The requirement is fulfilled if the interaction presented in a sequence diagram above is implemented in a test case(s) with the
            exact steps and execution order.
          </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01048_KeySm_GenerateNewSak2Disabled</srcid><srcstatus/><internalId>2116</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1110</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd" title="Logon Unit initialization requirement">
    <specobject>
      <id>Mka.InterAct.Logon.Init</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>8587</sourceline>
      <version>1</version>
      <description>
            The process of Logon unit initialization with an interaction with Crypto unit shall be performed according to the sequence shown
            in the diagram above.
          </description>
      <verifycrit>
            The requirement is fulfilled if the interaction presented in a sequence diagram above is implemented in a test case(s) with the
            exact steps and execution order.
          </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01001_LogonInit</srcid><srcstatus/><internalId>2191</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1111</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd" title="Logon Unit NvM initialization requirement">
    <specobject>
      <id>Mka.InterAct.Logon.NvM.Init</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>8622</sourceline>
      <version>1</version>
      <description>
            The process of Logon unit NvM initialization with an interaction with NvM module shall be performed according to the sequence shown
            in the diagram above.
          </description>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.dsn.Logon.Nvm.Start</srcid><srcstatus/><internalId>1608</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1112</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd" title="Logon Unit Participant API requirements">
    <specobject>
      <id>Mka.InterAct.Logon.Participant.Disabled</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>8653</sourceline>
      <version>1</version>
      <description>
            Logon unit Participant Disabled API and interaction with KaY module shall be performed according to the sequence shown
            in the diagram above.
          </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01006_ParticipantDisabled_ParticipantRestarted</srcid><srcstatus/><internalId>2196</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1113</internalId></specobject>
    <specobject>
      <id>Mka.InterAct.Logon.Participant.Active</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>8666</sourceline>
      <version>1</version>
      <description>
            Logon unit Participant Active API and interaction with KaY module shall be performed according to the sequence shown
            in the diagram above.
          </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01039_ParticipantActor</srcid><srcstatus/><internalId>2229</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1114</internalId></specobject>
    <specobject>
      <id>Mka.InterAct.Logon.Participant.Successful</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>8679</sourceline>
      <version>1</version>
      <description>
            Logon unit Participant Successful APIs and interaction with KaY module shall be performed according to the sequence shown
            in the diagram above.
          </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01004_ParticipantSuccsessfulActor_DisableNonPrincipalParticipantsOff</srcid><srcstatus/><internalId>2194</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1115</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd" title="Crypto Unit synchronous random number generation requirement">
    <specobject>
      <id>Mka.InterAct.Crypto.RandomGenerateSync</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>8716</sourceline>
      <version>1</version>
      <description>
            The process of Crypto unit synchronous random number generation with an interaction with KaY unit and Csm module shall be
            performed according to the sequence shown in the diagram above.
          </description>
      <verifycrit>
            The requirement is fulfilled if the interaction presented in a sequence diagram above is implemented in a test case(s) with the
            exact steps and execution order.
          </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01009_RandomGen_Sync128</srcid><srcstatus/><internalId>1913</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1116</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd" title="Crypto Unit asynchronous random number generation requirement">
    <specobject>
      <id>Mka.InterAct.Crypto.RandomGenerateAsync</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>8751</sourceline>
      <version>1</version>
      <description>
            The process of Crypto unit asynchronous random number generation with an interaction with KaY unit and Csm module shall be
            performed according to the sequence shown in the diagram above.
          </description>
      <verifycrit>
            The requirement is fulfilled if the interaction presented in a sequence diagram above is implemented in a test case(s) with the
            exact steps and execution order.
          </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01008_RandomGen_Async128</srcid><srcstatus/><internalId>1912</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1117</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd" title="Crypto Unit synchronous Icv generation requirement">
    <specobject>
      <id>Mka.InterAct.Crypto.IcvGenerateSync</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>8785</sourceline>
      <version>2</version>
      <description>
            The process of Crypto unit synchronous Icv generation with an interaction with RxTx unit and Csm module shall be
            performed according to the sequence shown in the diagram above.
          </description>
      <verifycrit>
            The requirement is fulfilled if the interaction presented in a sequence diagram above is implemented in a test case(s) with the
            exact steps and execution order.
          </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01015_IcvGen_Sync128</srcid><srcstatus/><internalId>1919</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1118</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd" title="Crypto Unit asynchronous Icv generation requirement">
    <specobject>
      <id>Mka.InterAct.Crypto.IcvGenerateAsync</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>8819</sourceline>
      <version>2</version>
      <description>
            The process of Crypto unit asynchronous Icv generation with an interaction with RxTx unit and Csm module shall be
            performed according to the sequence shown in the diagram above.
          </description>
      <verifycrit>
            The requirement is fulfilled if the interaction presented in a sequence diagram above is implemented in a test case(s) with the
            exact steps and execution order.
          </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01014_IcvGen_Async128</srcid><srcstatus/><internalId>1918</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1119</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd" title="Crypto Unit synchronous Icv verification requirement">
    <specobject>
      <id>Mka.InterAct.Crypto.IcvVerifySync</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>8853</sourceline>
      <version>1</version>
      <description>
            The process of Crypto unit synchronous Icv verification with an interaction with RxTx unit and Csm module shall be
            performed according to the sequence shown in the diagram above.
          </description>
      <verifycrit>
            The requirement is fulfilled if the interaction presented in a sequence diagram above is implemented in a test case(s) with the
            exact steps and execution order.
          </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01040_IcvVerify_Sync128</srcid><srcstatus/><internalId>1944</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1120</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd" title="Crypto Unit asynchronous Icv verification requirement">
    <specobject>
      <id>Mka.InterAct.Crypto.IcvVerifyAsync</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>8887</sourceline>
      <version>1</version>
      <description>
            The process of Crypto unit asynchronous Icv verification with an interaction with RxTx unit and Csm module shall be
            performed according to the sequence shown in the diagram above.
          </description>
      <verifycrit>
            The requirement is fulfilled if the interaction presented in a sequence diagram above is implemented in a test case(s) with the
            exact steps and execution order.
          </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01039_IcvVerify_Async128</srcid><srcstatus/><internalId>1943</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1121</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd" title="Crypto Unit synchronous Ick generation requirement">
    <specobject>
      <id>Mka.InterAct.Crypto.IckGenerateSync</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>8922</sourceline>
      <version>1</version>
      <description>
            The process of Crypto unit synchronous Ick generation with an interaction with Logon unit and Csm module shall be
            performed according to the sequence shown in the diagram above.
          </description>
      <verifycrit>
            The requirement is fulfilled if the interaction presented in a sequence diagram above is implemented in a test case(s) with the
            exact steps and execution order.
          </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01011_KekIckGen_Sync128</srcid><srcstatus/><internalId>1915</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01013_KekIckGen_Sync256</srcid><srcstatus/><internalId>1917</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01094_KekIckGen_Sync_128IckGenInput</srcid><srcstatus/><internalId>1989</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01095_KekIckGen_Sync_256IckGenInput</srcid><srcstatus/><internalId>1990</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01097_KekIckGen_Sync_256KekGenInput</srcid><srcstatus/><internalId>1992</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1122</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd" title="Crypto Unit asynchronous Ick generation requirement">
    <specobject>
      <id>Mka.InterAct.Crypto.IckGenerateAsync</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>8957</sourceline>
      <version>1</version>
      <description>
            The process of Crypto unit asynchronous Ick generation with an interaction with Logon unit and Csm module shall be
            performed according to the sequence shown in the diagram above.
          </description>
      <verifycrit>
            The requirement is fulfilled if the interaction presented in a sequence diagram above is implemented in a test case(s) with the
            exact steps and execution order.
          </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01010_KekIckGen_Async128</srcid><srcstatus/><internalId>1914</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01012_KekIckGen_Async256</srcid><srcstatus/><internalId>1916</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1123</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd" title="Crypto Unit synchronous Kek generation requirement">
    <specobject>
      <id>Mka.InterAct.Crypto.KekGenerateSync</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>8992</sourceline>
      <version>1</version>
      <description>
            The process of Crypto unit synchronous Kek generation with an interaction with Logon unit and Csm module shall be
            performed according to the sequence shown in the diagram above.
          </description>
      <verifycrit>
            The requirement is fulfilled if the interaction presented in a sequence diagram above is implemented in a test case(s) with the
            exact steps and execution order.
          </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01011_KekIckGen_Sync128</srcid><srcstatus/><internalId>1915</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01013_KekIckGen_Sync256</srcid><srcstatus/><internalId>1917</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01096_KekIckGen_Sync_128KekGenInput</srcid><srcstatus/><internalId>1991</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1124</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd" title="Crypto Unit asynchronous Kek generation requirement">
    <specobject>
      <id>Mka.InterAct.Crypto.KekGenerateAsync</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>9027</sourceline>
      <version>1</version>
      <description>
            The process of Crypto unit asynchronous Kek generation with an interaction with Logon unit and Csm module shall be
            performed according to the sequence shown in the diagram above.
          </description>
      <verifycrit>
            The requirement is fulfilled if the interaction presented in a sequence diagram above is implemented in a test case(s) with the
            exact steps and execution order.
          </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01010_KekIckGen_Async128</srcid><srcstatus/><internalId>1914</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01012_KekIckGen_Async256</srcid><srcstatus/><internalId>1916</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1125</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd" title="Crypto Unit synchronous Sak generation and wrap requirement">
    <specobject>
      <id>Mka.InterAct.Crypto.SakGenWrapSync</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>9062</sourceline>
      <version>1</version>
      <description>
            The process of Crypto unit synchronous Sak generation and wrap with an interaction with KaY unit and Csm module shall be
            performed according to the sequence shown in the diagram above.
          </description>
      <verifycrit>
            The requirement is fulfilled if the interaction presented in a sequence diagram above is implemented in a test case(s) with the
            exact steps and execution order.
          </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01051_SakGenWrap_Sync128</srcid><srcstatus/><internalId>1955</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01053_SakGenWrap_Sync256</srcid><srcstatus/><internalId>1957</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1126</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd" title="Crypto Unit asynchronous Sak generation and wrap requirement">
    <specobject>
      <id>Mka.InterAct.Crypto.SakGenWrapAsync</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>9097</sourceline>
      <version>1</version>
      <description>
            The process of Crypto unit asynchronous Sak generation and wrap with an interaction with KaY unit and Csm module shall be
            performed according to the sequence shown in the diagram above.
          </description>
      <verifycrit>
            The requirement is fulfilled if the interaction presented in a sequence diagram above is implemented in a test case(s) with the
            exact steps and execution order.
          </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01050_SakGenWrap_Async128</srcid><srcstatus/><internalId>1954</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01052_SakGenWrap_Async256</srcid><srcstatus/><internalId>1956</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1127</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd" title="Crypto Unit synchronous Sak unwrap requirement">
    <specobject>
      <id>Mka.InterAct.Crypto.SakUnwrapSync</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>9131</sourceline>
      <version>1</version>
      <description>
            The process of Crypto unit synchronous Sak unwrap with an interaction with KaY unit and Csm module shall be
            performed according to the sequence shown in the diagram above.
          </description>
      <verifycrit>
            The requirement is fulfilled if the interaction presented in a sequence diagram above is implemented in a test case(s) with the
            exact steps and execution order.
          </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01060_SakUnwrap_Sync128</srcid><srcstatus/><internalId>1964</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01062_SakUnwrap_Sync256</srcid><srcstatus/><internalId>1966</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1128</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd" title="Crypto Unit asynchronous Sak unwrap requirement">
    <specobject>
      <id>Mka.InterAct.Crypto.SakUnwrapAsync</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>9165</sourceline>
      <version>1</version>
      <description>
            The process of Crypto unit asynchronous Sak unwrap with an interaction with KaY unit and Csm module shall be
            performed according to the sequence shown in the diagram above.
          </description>
      <verifycrit>
            The requirement is fulfilled if the interaction presented in a sequence diagram above is implemented in a test case(s) with the
            exact steps and execution order.
          </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01059_SakUnwrap_Async128</srcid><srcstatus/><internalId>1963</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01061_SakUnwrap_Async256</srcid><srcstatus/><internalId>1965</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1129</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs" title="DET reporting requirements">
    <specobject>
      <id>Mka.Det.Init_CfgPtr_Invalid</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>15527</sourceline>
      <version>1</version>
      <description>
            If development error detection is enabled: The function shall check if the Mka_ConfigPtr
            is not a NULL_PTR. If the check fails the function shall raise the development error
            MKA_E_PARAM_POINTER and return E_NOT_OK.
          </description>
      <comment>&lt;comment/&gt;</comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_UnitTest01020_Init_Invalid_CfgPtr</srcid><srcstatus/><internalId>2279</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1130</internalId></specobject>
    <specobject>
      <id>Mka.Det.Init_Cfg_Invalid</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>15543</sourceline>
      <version>1</version>
      <description>
            If development error detection is enabled: Mka_Init() shall check if the configuration pointed by Mka_ConfigPtr is valid.
            If the check fails the function shall raise the development error MKA_E_INVALID_PARAMETER and return E_NOT_OK.
          </description>
      <comment>&lt;comment/&gt;</comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_UnitTest01021_Init_Invalid_Cfg</srcid><srcstatus/><internalId>2280</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1131</internalId></specobject>
    <specobject>
      <id>Mka.Det.GetVersionInfo_VersioninfoPtr_Invalid</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>15559</sourceline>
      <version>1</version>
      <description>
            If development error detection is enabled: The function shall check if the VersioninfoPtr
            is not a NULL_PTR. If the check fails the function shall raise the development error
            MKA_E_PARAM_POINTER and return E_NOT_OK.
          </description>
      <comment>&lt;comment/&gt;</comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_UnitTest01041_GetVersionInfo_VersionInfoPtr_Invalid_Params</srcid><srcstatus/><internalId>2300</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1132</internalId></specobject>
    <specobject>
      <id>Mka.Det.RxIndication_Uninit</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>15576</sourceline>
      <version>1</version>
      <description>
            If development error detection is enabled: Mka_RxIndication() shall check that the service Mka_Init() was previously called.
            If the check fails, the function shall raise the development error MKA_E_UNINIT.
          </description>
      <comment>&lt;comment/&gt;</comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_UnitTest01014_RxIndication_Uninit_Check</srcid><srcstatus/><internalId>2273</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1133</internalId></specobject>
    <specobject>
      <id>Mka.Det.RxIndication_EthIfCtrlIdx_Invalid</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>15590</sourceline>
      <version>1</version>
      <description>
            If development error detection is enabled: Mka_RxIndication() shall check if EthIfCtrlIdx matches configured number of
            EthIf controllers. If the check fails the function shall raise the development error MKA_E_INVALID_PARAMETER
            and return E_NOT_OK.
          </description>
      <comment>&lt;comment/&gt;</comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_UnitTest01022_RxIndication_Invalid_EthIfCtrlIdx</srcid><srcstatus/><internalId>2281</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1134</internalId></specobject>
    <specobject>
      <id>Mka.Det.RxIndication_MacSrcAddr_Invalid</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>15605</sourceline>
      <version>1</version>
      <description>
            If development error detection is enabled: Mka_RxIndication() shall check if MacSrcAddr is not a NULL_PTR.
            If the check fails the function shall raise the development error MKA_E_PARAM_POINTER and return E_NOT_OK.
          </description>
      <comment>&lt;comment/&gt;</comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_UnitTest01023_RxIndication_Invalid_MacSrcAddr</srcid><srcstatus/><internalId>2282</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1135</internalId></specobject>
    <specobject>
      <id>Mka.Det.RxIndication_DataPtr_Invalid</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>15619</sourceline>
      <version>1</version>
      <description>
            If development error detection is enabled: Mka_RxIndication() shall check if DataPtr is not a NULL_PTR.
            If the check fails the function shall raise the development error MKA_E_PARAM_POINTER and return E_NOT_OK.
          </description>
      <comment>&lt;comment/&gt;</comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_UnitTest01024_RxIndication_Invalid_DataPtr</srcid><srcstatus/><internalId>2283</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1136</internalId></specobject>
    <specobject>
      <id>Mka.Det.SetCknStatus_Uninit</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>15635</sourceline>
      <version>1</version>
      <description>
            If development error detection is enabled: Mka_SetCknStatus() shall check that the service Mka_Init() was previously called.
            If the check fails, the function shall raise the development error MKA_E_UNINIT.
          </description>
      <comment>&lt;comment/&gt;</comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_UnitTest01000_SetCknStatus_Uninit_Check</srcid><srcstatus/><internalId>2259</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1137</internalId></specobject>
    <specobject>
      <id>Mka.Det.SetCknStatus_MkaPaeIdx_Invalid</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>15649</sourceline>
      <version>1</version>
      <description>
            If development error detection is enabled: Mka_SetCknStatus() shall check if MkaPaeIdx matches configured number of
            Port Access Entities (PEAs). If the check fails the function shall raise the development error MKA_E_INVALID_PARAMETER
            and return E_NOT_OK.
          </description>
      <comment>&lt;comment/&gt;</comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_UnitTest01025_SetCknStatus_Invalid_Params</srcid><srcstatus/><internalId>2284</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1138</internalId></specobject>
    <specobject>
      <id>Mka.Det.SetCknStatus_CknPtr_Invalid</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>15664</sourceline>
      <version>1</version>
      <description>
            If development error detection is enabled: Mka_SetCknStatus() shall check if CknPtr is not a NULL_PTR.
            If the check fails the function shall raise the development error MKA_E_PARAM_POINTER and return E_NOT_OK.
          </description>
      <comment>&lt;comment/&gt;</comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_UnitTest01025_SetCknStatus_Invalid_Params</srcid><srcstatus/><internalId>2284</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1139</internalId></specobject>
    <specobject>
      <id>Mka.Det.SetCknStatus_CknLength_Invalid</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>15678</sourceline>
      <version>1</version>
      <description>
            If development error detection is enabled: Mka_SetCknStatus() shall check if CknLength is between values 0 and 32.
            If the check fails the function shall raise the development error MKA_E_INVALID_PARAMETER and return E_NOT_OK.
          </description>
      <comment>&lt;comment/&gt;</comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_UnitTest01025_SetCknStatus_Invalid_Params</srcid><srcstatus/><internalId>2284</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1140</internalId></specobject>
    <specobject>
      <id>Mka.Det.GetCknStatus_Uninit</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>15694</sourceline>
      <version>1</version>
      <description>
            If development error detection is enabled: Mka_GetCknStatus() shall check that the service Mka_Init() was previously called.
            If the check fails, the function shall raise the development error MKA_E_UNINIT.
          </description>
      <comment>&lt;comment/&gt;</comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_UnitTest01001_GetCknStatus_Uninit_Check</srcid><srcstatus/><internalId>2260</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1141</internalId></specobject>
    <specobject>
      <id>Mka.Det.GetCknStatus_MkaPaeIdx_Invalid</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>15708</sourceline>
      <version>1</version>
      <description>
            If development error detection is enabled: Mka_GetCknStatus() shall check if MkaPaeIdx matches configured number of
            Port Access Entities (PEAs). If the check fails the function shall raise the development error MKA_E_INVALID_PARAMETER
            and return E_NOT_OK.
          </description>
      <comment>&lt;comment/&gt;</comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_UnitTest01026_GetCknStatus_Invalid_Params</srcid><srcstatus/><internalId>2285</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1142</internalId></specobject>
    <specobject>
      <id>Mka.Det.GetCknStatus_CknPtr_Invalid</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>15723</sourceline>
      <version>1</version>
      <description>
            If development error detection is enabled: Mka_GetCknStatus() shall check if CknPtr is not a NULL_PTR.
            If the check fails the function shall raise the development error MKA_E_PARAM_POINTER and return E_NOT_OK.
          </description>
      <comment>&lt;comment/&gt;</comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_UnitTest01026_GetCknStatus_Invalid_Params</srcid><srcstatus/><internalId>2285</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1143</internalId></specobject>
    <specobject>
      <id>Mka.Det.GetCknStatus_CknLength_Invalid</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>15737</sourceline>
      <version>1</version>
      <description>
            If development error detection is enabled: Mka_GetCknStatus() shall check if CknLength is between values 1 and 32.
            If the check fails the function shall raise the development error MKA_E_INVALID_PARAMETER and return E_NOT_OK.
          </description>
      <comment>&lt;comment/&gt;</comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_UnitTest01026_GetCknStatus_Invalid_Params</srcid><srcstatus/><internalId>2285</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1144</internalId></specobject>
    <specobject>
      <id>Mka.Det.GetCknStatus_EnablePtr_Invalid</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>15751</sourceline>
      <version>1</version>
      <description>
            If development error detection is enabled: Mka_GetCknStatus() shall check if EnablePtr is not a NULL_PTR.
            If the check fails the function shall raise the development error MKA_E_PARAM_POINTER and return E_NOT_OK.
          </description>
      <comment>&lt;comment/&gt;</comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_UnitTest01026_GetCknStatus_Invalid_Params</srcid><srcstatus/><internalId>2285</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1145</internalId></specobject>
    <specobject>
      <id>Mka.Det.SetEnable_Uninit</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>15767</sourceline>
      <version>1</version>
      <description>
            If development error detection is enabled: Mka_SetEnable() shall check that the service Mka_Init() was previously called.
            If the check fails, the function shall raise the development error MKA_E_UNINIT.
          </description>
      <comment>&lt;comment/&gt;</comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_UnitTest01002_SetEnable_Uninit_Check</srcid><srcstatus/><internalId>2261</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1146</internalId></specobject>
    <specobject>
      <id>Mka.Det.SetEnable_MkaPaeIdx_Invalid</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>15781</sourceline>
      <version>1</version>
      <description>
            If development error detection is enabled: Mka_SetEnable() shall check if MkaPaeIdx matches configured number of
            Port Access Entities (PEAs). If the check fails the function shall raise the development error MKA_E_INVALID_PARAMETER
            and return E_NOT_OK.
          </description>
      <comment>&lt;comment/&gt;</comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_UnitTest01027_SetEnable_Invalid_Params</srcid><srcstatus/><internalId>2286</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1147</internalId></specobject>
    <specobject>
      <id>Mka.Det.GetEnable_Uninit</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>15798</sourceline>
      <version>1</version>
      <description>
            If development error detection is enabled: Mka_GetEnable() shall check that the service Mka_Init() was previously called.
            If the check fails, the function shall raise the development error MKA_E_UNINIT.
          </description>
      <comment>&lt;comment/&gt;</comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_UnitTest01003_GetEnable_Uninit_Check</srcid><srcstatus/><internalId>2262</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1148</internalId></specobject>
    <specobject>
      <id>Mka.Det.GetEnable_MkaPaeIdx_Invalid</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>15812</sourceline>
      <version>1</version>
      <description>
            If development error detection is enabled: Mka_GetEnable() shall check if MkaPaeIdx matches configured number of
            Port Access Entities (PEAs). If the check fails the function shall raise the development error MKA_E_INVALID_PARAMETER
            and return E_NOT_OK.
          </description>
      <comment>&lt;comment/&gt;</comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_UnitTest01028_GetEnable_Invalid_Params</srcid><srcstatus/><internalId>2287</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1149</internalId></specobject>
    <specobject>
      <id>Mka.Det.GetEnable_EnablePtr_Invalid</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>15827</sourceline>
      <version>1</version>
      <description>
            If development error detection is enabled: Mka_GetEnable() shall check if EnablePtr is not a NULL_PTR.
            If the check fails the function shall raise the development error MKA_E_PARAM_POINTER and return E_NOT_OK.
          </description>
      <comment>&lt;comment/&gt;</comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_UnitTest01028_GetEnable_Invalid_Params</srcid><srcstatus/><internalId>2287</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1150</internalId></specobject>
    <specobject>
      <id>Mka.Det.GetPaeStatus_Uninit</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>15843</sourceline>
      <version>1</version>
      <description>
            If development error detection is enabled: Mka_GetPaeStatus() shall check that the service Mka_Init() was previously called.
            If the check fails, the function shall raise the development error MKA_E_UNINIT.
          </description>
      <comment>&lt;comment/&gt;</comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_UnitTest01004_GetPaeStatus_Uninit_Check</srcid><srcstatus/><internalId>2263</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1151</internalId></specobject>
    <specobject>
      <id>Mka.Det.GetPaeStatus_MkaPaeIdx_Invalid</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>15857</sourceline>
      <version>1</version>
      <description>
            If development error detection is enabled: Mka_GetPaeStatus() shall check if MkaPaeIdx matches configured number of
            Port Access Entities (PEAs). If the check fails the function shall raise the development error MKA_E_INVALID_PARAMETER
            and return E_NOT_OK.
          </description>
      <comment>&lt;comment/&gt;</comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_UnitTest01029_GetPaeStatus_Invalid_Params</srcid><srcstatus/><internalId>2288</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1152</internalId></specobject>
    <specobject>
      <id>Mka.Det.GetPaeStatus_PaeStatusPtr_Invalid</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>15872</sourceline>
      <version>1</version>
      <description>
            If development error detection is enabled: Mka_GetPaeStatus() shall check if PaeStatusPtr is not a NULL_PTR.
            If the check fails the function shall raise the development error MKA_E_PARAM_POINTER and return E_NOT_OK.
          </description>
      <comment>&lt;comment/&gt;</comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_UnitTest01029_GetPaeStatus_Invalid_Params</srcid><srcstatus/><internalId>2288</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1153</internalId></specobject>
    <specobject>
      <id>Mka.Det.SetPaePermissiveMode_Uninit</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>15888</sourceline>
      <version>1</version>
      <description>
            If development error detection is enabled: Mka_SetPaePermissiveMode() shall check that the service Mka_Init() was previously called.
            If the check fails, the function shall raise the development error MKA_E_UNINIT.
          </description>
      <comment>&lt;comment/&gt;</comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_UnitTest01005_SetPaePermissiveMode_Uninit_Check</srcid><srcstatus/><internalId>2264</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1154</internalId></specobject>
    <specobject>
      <id>Mka.Det.SetPaePermissiveMode_MkaPaeIdx_Invalid</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>15902</sourceline>
      <version>1</version>
      <description>
            If development error detection is enabled: Mka_SetPaePermissiveMode() shall check if MkaPaeIdx matches configured number of
            Port Access Entities (PEAs). If the check fails the function shall raise the development error MKA_E_INVALID_PARAMETER
            and return E_NOT_OK.
          </description>
      <comment>&lt;comment/&gt;</comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_UnitTest01030_SetPaePermissiveMode_Invalid_Params</srcid><srcstatus/><internalId>2289</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1155</internalId></specobject>
    <specobject>
      <id>Mka.Det.StartPae_Uninit</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>15919</sourceline>
      <version>1</version>
      <description>
            If development error detection is enabled: Mka_StartPae() shall check that the service Mka_Init() was previously called.
            If the check fails, the function shall raise the development error MKA_E_UNINIT.
          </description>
      <comment>&lt;comment/&gt;</comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_UnitTest01006_StartPae_Uninit_Check</srcid><srcstatus/><internalId>2265</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1156</internalId></specobject>
    <specobject>
      <id>Mka.Det.StartPae_MkaPaeIdx_Invalid</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>15933</sourceline>
      <version>1</version>
      <description>
            If development error detection is enabled: Mka_StartPae() shall check if MkaPaeIdx matches configured number of
            Port Access Entities (PEAs). If the check fails the function shall raise the development error MKA_E_INVALID_PARAMETER
            and return E_NOT_OK.
          </description>
      <comment>&lt;comment/&gt;</comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_UnitTest01031_StartPae_Invalid_Params</srcid><srcstatus/><internalId>2290</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1157</internalId></specobject>
    <specobject>
      <id>Mka.Det.GetMacSecStatistics_Uninit</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>15950</sourceline>
      <version>1</version>
      <description>
            If development error detection is enabled: Mka_GetMacSecStatistics() shall check that the service Mka_Init() was previously called.
            If the check fails, the function shall raise the development error MKA_E_UNINIT.
          </description>
      <comment>&lt;comment/&gt;</comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_UnitTest01007_GetMacSecStatistics_Uninit_Check</srcid><srcstatus/><internalId>2266</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1158</internalId></specobject>
    <specobject>
      <id>Mka.Det.GetMacSecStatistics_MkaPaeIdx_Invalid</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>15964</sourceline>
      <version>1</version>
      <description>
            If development error detection is enabled: Mka_GetMacSecStatistics() shall check if MkaPaeIdx matches configured number of
            Port Access Entities (PEAs). If the check fails the function shall raise the development error MKA_E_INVALID_PARAMETER
            and return E_NOT_OK.
          </description>
      <comment>&lt;comment/&gt;</comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_UnitTest01032_GetMacSecStatistics_Invalid_Params</srcid><srcstatus/><internalId>2291</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1159</internalId></specobject>
    <specobject>
      <id>Mka.Det.GetMacSecStatistics_CknPtr_Invalid</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>15979</sourceline>
      <version>1</version>
      <description>
            If development error detection is enabled: Mka_GetMacSecStatistics() shall check if CknPtr is not a NULL_PTR.
            If the check fails the function shall raise the development error MKA_E_PARAM_POINTER and return E_NOT_OK.
          </description>
      <comment>&lt;comment/&gt;</comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_UnitTest01032_GetMacSecStatistics_Invalid_Params</srcid><srcstatus/><internalId>2291</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1160</internalId></specobject>
    <specobject>
      <id>Mka.Det.GetMacSecStatistics_CknLength_Invalid</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>15993</sourceline>
      <version>1</version>
      <description>
            If development error detection is enabled: Mka_GetMacSecStatistics() shall check if CknLength is between values 0 and 32.
            If the check fails the function shall raise the development error MKA_E_INVALID_PARAMETER and return E_NOT_OK.
          </description>
      <comment>&lt;comment/&gt;</comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_UnitTest01032_GetMacSecStatistics_Invalid_Params</srcid><srcstatus/><internalId>2291</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1161</internalId></specobject>
    <specobject>
      <id>Mka.Det.LinkStateChange_Uninit</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>16009</sourceline>
      <version>1</version>
      <description>
            If development error detection is enabled: Mka_LinkStateChange() shall check that the service Mka_Init() was previously called.
            If the check fails, the function shall raise the development error MKA_E_UNINIT.
          </description>
      <comment>&lt;comment/&gt;</comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_UnitTest01008_LinkStateChange_Uninit_Check</srcid><srcstatus/><internalId>2267</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1162</internalId></specobject>
    <specobject>
      <id>Mka.Det.LinkStateChange_MkaPaeIdx_Invalid</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>16023</sourceline>
      <version>1</version>
      <description>
            If development error detection is enabled: Mka_LinkStateChange() shall check if MkaPaeIdx matches configured number of
            Port Access Entities (PEAs). If the check fails the function shall raise the development error MKA_E_INVALID_PARAMETER
            and return E_NOT_OK.
          </description>
      <comment>&lt;comment/&gt;</comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_UnitTest01033_LinkStateChange_Invalid_PaeIdx</srcid><srcstatus/><internalId>2292</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1163</internalId></specobject>
    <specobject>
      <id>Mka.Det.LinkStateChange_TransceiverLinkState_Invalid</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>16038</sourceline>
      <version>1</version>
      <description>
            If development error detection is enabled: Mka_LinkStateChange() shall check if TransceiverLinkState matches configured
            number ETHTRCV_LINK_STATE_DOWN or ETHTRCV_LINK_STATE_ACTIVE. If the check fails the function shall raise the development error
            MKA_E_INVALID_PARAMETER and return E_NOT_OK.
          </description>
      <comment>&lt;comment/&gt;</comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_UnitTest01036_LinkStateChange_TransceiverLinkState_Invalid</srcid><srcstatus/><internalId>2295</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1164</internalId></specobject>
    <specobject>
      <id>Mka.Det.GetMacSecStatisticsNotification_Uninit</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>16055</sourceline>
      <version>1</version>
      <description>
            If development error detection is enabled: Mka_GetMacSecStatisticsNotification() shall check that the service Mka_Init() was
            previously called. If the check fails, the function shall raise the development error MKA_E_UNINIT.
          </description>
      <comment>&lt;comment/&gt;</comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_UnitTest01009_GetMacSecStatisticsNotification_Uninit_Check</srcid><srcstatus/><internalId>2268</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1165</internalId></specobject>
    <specobject>
      <id>Mka.Det.GetMacSecStatisticsNotification_MkaPaeIdx_Invalid</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>16069</sourceline>
      <version>1</version>
      <description>
            If development error detection is enabled: Mka_GetMacSecStatisticsNotification() shall check if MkaPaeIdx matches configured number of
            Port Access Entities (PEAs). If the check fails the function shall raise the development error MKA_E_INVALID_PARAMETER
            and return E_NOT_OK.
          </description>
      <comment>&lt;comment/&gt;</comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_UnitTest01034_GetMacSecStatisticsNotification_Invalid_Params</srcid><srcstatus/><internalId>2293</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1166</internalId></specobject>
    <specobject>
      <id>Mka.Det.GetMacSecStatisticsNotifications_MacSecStatsPtr_Invalid</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>16084</sourceline>
      <version>1</version>
      <description>
            If development error detection is enabled: Mka_GetMacSecStatisticsNotification() shall check if MacSecStatsPtr is not a NULL_PTR.
            If the check fails the function shall raise the development error MKA_E_PARAM_POINTER.
          </description>
      <comment>&lt;comment/&gt;</comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_UnitTest01034_GetMacSecStatisticsNotification_Invalid_Params</srcid><srcstatus/><internalId>2293</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1167</internalId></specobject>
    <specobject>
      <id>Mka.Det.TxConfirmation_Uninit</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>16100</sourceline>
      <version>1</version>
      <description>
            If development error detection is enabled: Mka_TxConfirmation() shall check that the service Mka_Init() was previously called.
            If the check fails, the function shall raise the development error MKA_E_UNINIT.
          </description>
      <comment>&lt;comment/&gt;</comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_UnitTest01010_TxConfirmation_Uninit_Check</srcid><srcstatus/><internalId>2269</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1168</internalId></specobject>
    <specobject>
      <id>Mka.Det.TxConfirmation_EthIfCtrlIdx_Invalid</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>16114</sourceline>
      <version>1</version>
      <description>
            If development error detection is enabled: Mka_TxConfirmation() shall check if EthIfCtrlIdx matches configured number of
            EthIf controllers. If the check fails the function shall raise the development error MKA_E_INVALID_PARAMETER.
          </description>
      <comment>&lt;comment/&gt;</comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_UnitTest01035_TxConfirmation_Invalid_Params</srcid><srcstatus/><internalId>2294</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1169</internalId></specobject>
    <specobject>
      <id>Mka.Det.MacSecUpdateSecYNotification_Uninit</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>16130</sourceline>
      <version>1</version>
      <description>
            If development error detection is enabled: Mka_MacSecUpdateSecYNotification() shall check that the service Mka_Init() was
            previously called. If the check fails, the function shall raise the development error MKA_E_UNINIT.
          </description>
      <comment>&lt;comment/&gt;</comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_UnitTest01011_MacSecUpdateSecYNotification_Uninit_Check</srcid><srcstatus/><internalId>2270</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1170</internalId></specobject>
    <specobject>
      <id>Mka.Det.MacSecUpdateSecYNotification_MkaPaeIdx_Invalid</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>16144</sourceline>
      <version>1</version>
      <description>
            If development error detection is enabled: Mka_MacSecUpdateSecYNotification() shall check if MkaPaeIdx matches configured number
            of Port Access Entities (PEAs). If the check fails the function shall raise the development error MKA_E_INVALID_PARAMETER
            and return E_NOT_OK.
          </description>
      <comment>&lt;comment/&gt;</comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_UnitTest01037_MacSecUpdateSecYNotification_MkaPaeIdx_Invalid_Params</srcid><srcstatus/><internalId>2296</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1171</internalId></specobject>
    <specobject>
      <id>Mka.Det.MacSecAddTxSaNotification_Uninit</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>16161</sourceline>
      <version>1</version>
      <description>
            If development error detection is enabled: Mka_MacSecAddTxSaNotification() shall check that the service Mka_Init() was
            previously called. If the check fails, the function shall raise the development error MKA_E_UNINIT.
          </description>
      <comment>&lt;comment/&gt;</comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_UnitTest01012_MacSecAddTxSaNotification_Uninit_Check</srcid><srcstatus/><internalId>2271</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1172</internalId></specobject>
    <specobject>
      <id>Mka.Det.MacSecAddTxSaNotification_MkaPaeIdx_Invalid</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>16175</sourceline>
      <version>1</version>
      <description>
            If development error detection is enabled: Mka_MacSecAddTxSaNotification() shall check if MkaPaeIdx matches configured number
            of Port Access Entities (PEAs). If the check fails the function shall raise the development error MKA_E_INVALID_PARAMETER
            and return E_NOT_OK.
          </description>
      <comment>&lt;comment/&gt;</comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_UnitTest01038_MacSecAddTxSaNotification_MkaPaeIdx_Invalid_Params</srcid><srcstatus/><internalId>2297</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1173</internalId></specobject>
    <specobject>
      <id>Mka.Det.MacSecAddRxSaNotification_Uninit</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>16192</sourceline>
      <version>1</version>
      <description>
            If development error detection is enabled: Mka_MacSecAddRxSaNotification() shall check that the service Mka_Init() was
            previously called. If the check fails, the function shall raise the development error MKA_E_UNINIT.
          </description>
      <comment>&lt;comment/&gt;</comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_UnitTest01013_MacSecAddRxSaNotification_Uninit_Check</srcid><srcstatus/><internalId>2272</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1174</internalId></specobject>
    <specobject>
      <id>Mka.Det.MacSecAddRxSaNotification_MkaPaeIdx_Invalid</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>16206</sourceline>
      <version>1</version>
      <description>
            If development error detection is enabled: Mka_MacSecAddRxSaNotification() shall check if MkaPaeIdx matches configured number
            of Port Access Entities (PEAs). If the check fails the function shall raise the development error MKA_E_INVALID_PARAMETER
            and return E_NOT_OK.
          </description>
      <comment>&lt;comment/&gt;</comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_UnitTest01039_MacSecAddRxSaNotification_MkaPaeIdx_Invalid_Params</srcid><srcstatus/><internalId>2298</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1175</internalId></specobject>
    <specobject>
      <id>Mka.Det.Crypto.Mka_CsmRandomCallback_Uninit</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>16223</sourceline>
      <version>1</version>
      <description>
            If development error detection is enabled: Mka_CsmRandomCallback() shall check that the service Mka_Init() was
            previously called. If the check fails, the function shall raise the development error MKA_E_UNINIT.
          </description>
      <comment>&lt;comment/&gt;</comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01001_CsmRandomCallback_Uninit_Check</srcid><srcstatus/><internalId>1905</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1176</internalId></specobject>
    <specobject>
      <id>Mka.Det.Crypto.Mka_CsmKeyGenerateCallback_Uninit</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>16239</sourceline>
      <version>1</version>
      <description>
            If development error detection is enabled: Mka_CsmKeyGenerateCallback() shall check that the service Mka_Init() was
            previously called. If the check fails, the function shall raise the development error MKA_E_UNINIT.
          </description>
      <comment>&lt;comment/&gt;</comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01002_CsmKeyGenerateCallback_Uninit_Check</srcid><srcstatus/><internalId>1906</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1177</internalId></specobject>
    <specobject>
      <id>Mka.Det.Crypto.Mka_CsmIcvGenerateCallback_Uninit</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>16255</sourceline>
      <version>1</version>
      <description>
            If development error detection is enabled: Mka_CsmIcvGenerateCallback() shall check that the service Mka_Init() was
            previously called. If the check fails, the function shall raise the development error MKA_E_UNINIT.
          </description>
      <comment>&lt;comment/&gt;</comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01003_CsmIcvGenerateCallback_Uninit_Check</srcid><srcstatus/><internalId>1907</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1178</internalId></specobject>
    <specobject>
      <id>Mka.Det.Crypto.Mka_CsmHashGenerateCallback_Uninit</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>16271</sourceline>
      <version>1</version>
      <description>
            If development error detection is enabled: Mka_CsmHashGenerateCallback() shall check that the service Mka_Init() was
            previously called. If the check fails, the function shall raise the development error MKA_E_UNINIT.
          </description>
      <comment>&lt;comment/&gt;</comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01004_CsmHashGenerateCallback_Uninit_Check</srcid><srcstatus/><internalId>1908</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1179</internalId></specobject>
    <specobject>
      <id>Mka.Crypto.HashGenerateCallback_NoMatch</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>16286</sourceline>
      <version>1</version>
      <description>
            If Mka_HashGenerateCallback is called with a jobId that does not match any Mka jobId the call shall be ignored.
          </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01152_HashGen_Retry_InvalidJob</srcid><srcstatus/><internalId>2047</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1180</internalId></specobject>
    <specobject>
      <id>Mka.Det.Crypto.Mka_CsmIcvVerifyCallback_Uninit</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>16303</sourceline>
      <version>1</version>
      <description>
            If development error detection is enabled: Mka_CsmIcvVerifyCallback() shall check that the service Mka_Init() was
            previously called. If the check fails, the function shall raise the development error MKA_E_UNINIT.
          </description>
      <comment>&lt;comment/&gt;</comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01005_CsmIcvVerifyCallback_Uninit_Check</srcid><srcstatus/><internalId>1909</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1181</internalId></specobject>
    <specobject>
      <id>Mka.Det.Crypto.Mka_CsmKeyWrapCallback_Uninit</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>16319</sourceline>
      <version>1</version>
      <description>
            If development error detection is enabled: Mka_CsmKeyWrapCallback() shall check that the service Mka_Init() was
            previously called. If the check fails, the function shall raise the development error MKA_E_UNINIT.
          </description>
      <comment>&lt;comment/&gt;</comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01006_CsmKeyWrapCallback_Uninit_Check</srcid><srcstatus/><internalId>1910</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1182</internalId></specobject>
    <specobject>
      <id>Mka.Det.Crypto.Mka_CsmKeyUnwrapCallback_Uninit</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>16335</sourceline>
      <version>1</version>
      <description>
            If development error detection is enabled: Mka_CsmKeyUnwrapCallback() shall check that the service Mka_Init() was
            previously called. If the check fails, the function shall raise the development error MKA_E_UNINIT.
          </description>
      <comment>&lt;comment/&gt;</comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01007_CsmKeyUnwrapCallback_Uninit_Check</srcid><srcstatus/><internalId>1911</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1183</internalId></specobject>
    <specobject>
      <id>Mka.Det.EnableMacSec_Uninit</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>16351</sourceline>
      <version>1</version>
      <description>
            If development error detection is enabled: Mka_EnableMacSec() shall check that the service Mka_Init() was previously called.
            If the check fails, the function shall raise the development error MKA_E_UNINIT.
          </description>
      <comment>&lt;comment/&gt;</comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_UnitTest01015_EnableMacSec_Uninit_Check</srcid><srcstatus/><internalId>2274</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1184</internalId></specobject>
    <specobject>
      <id>Mka.Det.DisableMacSec_Uninit</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>16367</sourceline>
      <version>1</version>
      <description>
            If development error detection is enabled: Mka_DisableMacSec() shall check that the service Mka_Init() was previously called.
            If the check fails, the function shall raise the development error MKA_E_UNINIT.
          </description>
      <comment>&lt;comment/&gt;</comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_UnitTest01016_DisableMacSec_Uninit_Check</srcid><srcstatus/><internalId>2275</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1185</internalId></specobject>
    <specobject>
      <id>Mka.Det.GetMacSecEnabled_Uninit</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>16383</sourceline>
      <version>1</version>
      <description>
            If development error detection is enabled: Mka_GetMacSecEnabled() shall check that the service Mka_Init() was previously called.
            If the check fails, the function shall raise the development error MKA_E_UNINIT.
          </description>
      <comment>&lt;comment/&gt;</comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_UnitTest01054_GetMacSecEnabled_Uninit_Check</srcid><srcstatus/><internalId>2313</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1186</internalId></specobject>
    <specobject>
      <id>Mka.Det.GetMacSecEnabled_StatusPtr_Invalid</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>16398</sourceline>
      <version>1</version>
      <description>
            If development error detection is enabled: Mka_GetMacSecEnabled() shall check that the parameter StatusPtr is not a NULL_PTR.
            If the check fails, the function shall raise the development error MKA_E_PARAM_POINTER.
          </description>
      <comment>&lt;comment/&gt;</comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_UnitTest01055_GetMacSecEnabled_StatusPtr_Invalid</srcid><srcstatus/><internalId>2314</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1187</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs" title="Crypto error handling requirements">
    <specobject>
      <id>Mka.Crypto.RandomCallback_NoMatch</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>16425</sourceline>
      <version>1</version>
      <description>
            If Mka_CsmRandomCallback is called with a jobId that does not match any Mka jobId the call shall be ignored.
          </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01019_CsmCallback_WrongJobID</srcid><srcstatus/><internalId>1923</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1188</internalId></specobject>
    <specobject>
      <id>Mka.Crypto.KeyGenerateCallback_NoMatch</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>16441</sourceline>
      <version>1</version>
      <description>
            If Mka_CsmKeyGenerateCallback is called with a jobId that does not match any Mka jobId the call shall be ignored.
          </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01019_CsmCallback_WrongJobID</srcid><srcstatus/><internalId>1923</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1189</internalId></specobject>
    <specobject>
      <id>Mka.Crypto.IcvGenerateCallback_NoMatch</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>16457</sourceline>
      <version>1</version>
      <description>
            If Mka_CsmIcvGenerateCallback is called with a jobId that does not match any Mka jobId the call shall be ignored.
          </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01019_CsmCallback_WrongJobID</srcid><srcstatus/><internalId>1923</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1190</internalId></specobject>
    <specobject>
      <id>Mka.Crypto.IcvVerifyCallback_NoMatch</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>16473</sourceline>
      <version>1</version>
      <description>
            If Mka_CsmIcvVerifyCallback is called with a jobId that does not match any Mka jobId the call shall be ignored.
          </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01041_IcvVerify_Async128_NoMatch</srcid><srcstatus/><internalId>1945</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1191</internalId></specobject>
    <specobject>
      <id>Mka.Crypto.KeyWrapCallback_NoMatch</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>16489</sourceline>
      <version>1</version>
      <description>
            If Mka_CsmKeyWrapCallback is called with a jobId that does not match any Mka jobId the call shall be ignored.
          </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01054_SakGenWrap_Async128_WrongJobId</srcid><srcstatus/><internalId>1958</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1192</internalId></specobject>
    <specobject>
      <id>Mka.Crypto.KeyUnwrapCallback_NoMatch</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>16505</sourceline>
      <version>1</version>
      <description>
            If Mka_CsmKeyUnwrapCallback is called with a jobId that does not match any Mka jobId the call shall be ignored.
          </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01107_SakUnwrap_Async128_WrongJobId</srcid><srcstatus/><internalId>2002</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1193</internalId></specobject>
    <specobject>
      <id>Mka.Crypto.RandomCallback_NotStarted</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>16521</sourceline>
      <version>1</version>
      <description>
            If Mka_CsmRandomCallback is called with a jobId that does not have an ongoing task the call shall be ignored.
          </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01016_CsmCallback_NoTaskFail</srcid><srcstatus/><internalId>1920</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1194</internalId></specobject>
    <specobject>
      <id>Mka.Crypto.KeyGenerateCallback_NotStarted</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>16537</sourceline>
      <version>1</version>
      <description>
            If Mka_CsmKeyGenerateCallback is called with a jobId that does not have an ongoing task the call shall be ignored.
          </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01016_CsmCallback_NoTaskFail</srcid><srcstatus/><internalId>1920</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1195</internalId></specobject>
    <specobject>
      <id>Mka.Crypto.IcvGenerateCallback_NotStarted</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>16553</sourceline>
      <version>1</version>
      <description>
            If Mka_CsmIcvGenerateCallback is called with a jobId that does not have an ongoing task the call shall be ignored.
          </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01016_CsmCallback_NoTaskFail</srcid><srcstatus/><internalId>1920</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1196</internalId></specobject>
    <specobject>
      <id>Mka.Crypto.IcvVerifyCallback_NotStarted</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>16569</sourceline>
      <version>1</version>
      <description>
            If Mka_CsmIcvVerifyCallback is called with a jobId that does not have an ongoing task the call shall be ignored.
          </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01039_IcvVerify_Async128</srcid><srcstatus/><internalId>1943</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1197</internalId></specobject>
    <specobject>
      <id>Mka.Crypto.KeyWrapCallback_NotStarted</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>16585</sourceline>
      <version>1</version>
      <description>
            If Mka_CsmKeyWrapCallback is called with a jobId that does not have an ongoing task the call shall be ignored.
          </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01054_SakGenWrap_Async128_WrongJobId</srcid><srcstatus/><internalId>1958</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1198</internalId></specobject>
    <specobject>
      <id>Mka.Crypto.KeyUnwrapCallback_NotStarted</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>16601</sourceline>
      <version>1</version>
      <description>
            If Mka_CsmKeyUnwrapCallback is called with a jobId that does not have an ongoing task the call shall be ignored.
          </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01108_SakUnwrap_Async128_NotStarted</srcid><srcstatus/><internalId>2003</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1199</internalId></specobject>
    <specobject>
      <id>Mka.Crypto.KeyGen_Ick_StartGenFail</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>16617</sourceline>
      <version>1</version>
      <description>
            If the Csm_MacGenerate call to start the key generation of ICK returns any result other than E_OK the Crypto unit shall
            stop any further key generation process and report to the caller that the key generation has failed.
          </description>
      <verifycrit>
            This requirement shall be tested for:
            * Synchronous processing
            * Asynchronous processing
          </verifycrit>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01028_KekIckGen_Async128_StartFail</srcid><srcstatus/><internalId>1932</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01029_KekIckGen_Sync128_StartFail</srcid><srcstatus/><internalId>1933</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01174_IckKekGen_KEY_NOT_PRESENT</srcid><srcstatus/><internalId>2069</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01175_IckKekGen_KEY_NOT_PRESENT_CsmCallback</srcid><srcstatus/><internalId>2070</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1200</internalId></specobject>
    <specobject>
      <id>Mka.Crypto.KeyGen_Kek_StartGenFail</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>16639</sourceline>
      <version>1</version>
      <description>
            If the Csm_MacGenerate call to start the key generation of KEK returns any result other than E_OK the Crypto unit shall
            stop any further key generation process and report to the caller that the key generation has failed.
          </description>
      <verifycrit>
            This requirement shall be tested for:
            * Synchronous processing
            * Asynchronous processing
          </verifycrit>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01028_KekIckGen_Async128_StartFail</srcid><srcstatus/><internalId>1932</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01029_KekIckGen_Sync128_StartFail</srcid><srcstatus/><internalId>1933</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01174_IckKekGen_KEY_NOT_PRESENT</srcid><srcstatus/><internalId>2069</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01175_IckKekGen_KEY_NOT_PRESENT_CsmCallback</srcid><srcstatus/><internalId>2070</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1201</internalId></specobject>
    <specobject>
      <id>Mka.Crypto.KeyGen_Ick_Async_KeyGenFail</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>16661</sourceline>
      <version>1</version>
      <description>
            If ICK key generation was started and Mka_CsmKeyGenerateCallback reports any result other than E_OK the Crypto unit shall
            stop any further key generation process and report to the caller that the key generation has failed.
          </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01023_KekIckGen_Async128_JobFail</srcid><srcstatus/><internalId>1927</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1202</internalId></specobject>
    <specobject>
      <id>Mka.Crypto.KeyGen_Kek_Async_KeyGenFail</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>16678</sourceline>
      <version>1</version>
      <description>
            If KEK key generation was started and Mka_CsmKeyGenerateCallback reports any result other than E_OK the Crypto unit shall
            stop any further key generation process and report to the caller that the key generation has failed.
          </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01023_KekIckGen_Async128_JobFail</srcid><srcstatus/><internalId>1927</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1203</internalId></specobject>
    <specobject>
      <id>Mka.Crypto.KeyGen_PrepareIck_GetCkn_Fail</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>16695</sourceline>
      <version>1</version>
      <description>
            If Csm_KeyElementGet used to get CKN for ICK generation return any result other than E_OK the Crypto unit shall
            return E_NOT_OK and no process will be started.
          </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01030_KekIckGen_Async128_PrepareFail</srcid><srcstatus/><internalId>1934</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01031_KekIckGen_Sync128_PrepareFail</srcid><srcstatus/><internalId>1935</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1204</internalId></specobject>
    <specobject>
      <id>Mka.Crypto.KeyGen_SetIck_Fail</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>16712</sourceline>
      <version>1</version>
      <description>
            If saving the generated ICK (Csm_KeyElementSet) fails the Crypto unit shall
            stop any further key generation process and report to the caller that the key generation has failed.
          </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01032_KekIckGen_Async128_SetFail</srcid><srcstatus/><internalId>1936</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01033_KekIckGen_Sync128_SetFail</srcid><srcstatus/><internalId>1937</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1205</internalId></specobject>
    <specobject>
      <id>Mka.Crypto.KeyGen_SetIckValid_Fail</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>16729</sourceline>
      <version>1</version>
      <description>
            If setting the state of the generated ICK to valid (Csm_KeySetValid) fails the Crypto unit shall
            stop any further key generation process and report to the caller that the key generation has failed.
          </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01034_KekIckGen_Async128_ValidFail</srcid><srcstatus/><internalId>1938</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01035_KekIckGen_Sync128_ValidFail</srcid><srcstatus/><internalId>1939</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1206</internalId></specobject>
    <specobject>
      <id>Mka.Crypto.KeyGen_SetKek_Fail</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>16746</sourceline>
      <version>1</version>
      <description>
            If saving the generated Kek (Csm_KeyElementSet) fails the Crypto unit shall
            stop any further key generation process and report to the caller that the key generation has failed.
          </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01032_KekIckGen_Async128_SetFail</srcid><srcstatus/><internalId>1936</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01033_KekIckGen_Sync128_SetFail</srcid><srcstatus/><internalId>1937</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1207</internalId></specobject>
    <specobject>
      <id>Mka.Crypto.KeyGen_SetKekValid_Fail</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>16763</sourceline>
      <version>1</version>
      <description>
            If setting the state of the generated KEK to valid (Csm_KeySetValid) fails the Crypto unit shall
            stop any further key generation process and report to the caller that the key generation has failed.
          </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01034_KekIckGen_Async128_ValidFail</srcid><srcstatus/><internalId>1938</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01035_KekIckGen_Sync128_ValidFail</srcid><srcstatus/><internalId>1939</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1208</internalId></specobject>
    <specobject>
      <id>Mka.Crypto.RandomGen_StartGenFail</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>16780</sourceline>
      <version>1</version>
      <description>
            If the Csm_RandomGenerate call to start the random value generation returns any result other than E_OK
            Mka_Crypto_RandomGenerateAsync shall return E_NOT_OK and the Crypto unit shall stop any further processing.
          </description>
      <verifycrit>
            This requirement shall be tested for:
            * Synchronous processing
            * Asynchronous processing
          </verifycrit>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01021_RandomGen_Async128_StartFail</srcid><srcstatus/><internalId>1925</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01022_RandomGen_Sync128_StartFail</srcid><srcstatus/><internalId>1926</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1209</internalId></specobject>
    <specobject>
      <id>Mka.Crypto.RandomGen_Async_RandomGenFail</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>16802</sourceline>
      <version>1</version>
      <description>
            If random value generation was started and Mka_CsmRandomCallback reports any result other than E_OK the Crypto unit shall
            stop any further processing and report to the caller that the random value generation has failed.
          </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01020_RandomGen_Async128_JobFail</srcid><srcstatus/><internalId>1924</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1210</internalId></specobject>
    <specobject>
      <id>Mka.Crypto.IcvGen_StartGenFail</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>16819</sourceline>
      <version>2</version>
      <description>
            If the Csm_MacGenerate call to perform ICV generation returns any result other than E_OK the Crypto unit shall
            stop any further processing and report to the caller that the ICV generation has failed.
          </description>
      <verifycrit>
            This requirement shall be tested for:
            * Synchronous processing
            * Asynchronous processing
            * Synchronous processing operation startstream
            * Synchronous processing operation update
            * Synchronous processing operation finish
          </verifycrit>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01025_IcvGen_Async128_StartFail</srcid><srcstatus/><internalId>1929</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01026_IcvGen_Sync128_StartFail</srcid><srcstatus/><internalId>1930</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1211</internalId></specobject>
    <specobject>
      <id>Mka.Crypto.IcvGen_Async_IcvGenFail</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>16844</sourceline>
      <version>1</version>
      <description>
            If ICV generation was started and Mka_CsmIcvGenerateCallback reports any result other than E_OK the Crypto unit shall
            stop any further processing and report to the caller that the ICV generation has failed.
          </description>
      <verifycrit>
          </verifycrit>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01024_IcvGen_Async128_JobFail</srcid><srcstatus/><internalId>1928</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01027_IcvGen_Async128_GenFail</srcid><srcstatus/><internalId>1931</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1212</internalId></specobject>
    <specobject>
      <id>Mka.Crypto.IcvVer_StartVerFail</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>16863</sourceline>
      <version>1</version>
      <description>
            If the Csm_MacVerify call to start the ICV verification returns any result other than E_OK the Crypto unit shall
            stop any further processing and report to the caller that the ICV generation has failed.
          </description>
      <verifycrit>
            This requirement shall be tested for:
            * Synchronous processing:
               * Return value != E_OK AND verifyPtr != E_OK
               * Return value == E_OK AND verifyPtr != E_OK
               * Return value != E_OK AND verifyPtr == E_OK
            * Asynchronous processing:
              * Return value != E_OK AND verifyPtr != E_OK
              * Return value != E_OK AND verifyPtr == E_OK
          </verifycrit>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01042_IcvVerify_Async128_StartVerFail</srcid><srcstatus/><internalId>1946</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01043_IcvVerify_Sync128_StartVerFail</srcid><srcstatus/><internalId>1947</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1213</internalId></specobject>
    <specobject>
      <id>Mka.Crypto.IcvVer_Async_IcvVerFail</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>16890</sourceline>
      <version>1</version>
      <description>
            If ICV verification was started and Mka_CsmIcvVerifyCallback reports any result other than E_OK the Crypto unit shall
            stop any further processing and report to the caller that the ICV verification has failed.
          </description>
      <verifycrit>
            This requirement shall be tested for:
            * Return value != E_OK
            * verifyPtr != E_OK
          </verifycrit>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01044_IcvVerify_Async128_IcvVerFail</srcid><srcstatus/><internalId>1948</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1214</internalId></specobject>
    <specobject>
      <id>Mka.Crypto.KeyGen_Ick_RequestInvalidState</id>
      <status>rejected</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>16912</sourceline>
      <version>1</version>
      <description>
            If Mka_Crypto_IckGenerateAsync is called while CAK and CKN are not ready the Crypto unit shall
            return E_NOT_OK and no process will be started.
          </description>
      <comment>
            This requirement is informational only.
          </comment>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1215</internalId></specobject>
    <specobject>
      <id>Mka.Crypto.KeyGen_Ick_RequestInvalidKeyGenState</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>16929</sourceline>
      <version>1</version>
      <description>
            If Mka_Crypto_IckGenerateAsync is called while key generation is ongoing the Crypto unit shall
            return E_NOT_OK and no process will be started.
          </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01036_IckGen_Async128_DoublesFail</srcid><srcstatus/><internalId>1940</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1216</internalId></specobject>
    <specobject>
      <id>Mka.Crypto.KeyGen_Kek_RequestInvalidState</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>16946</sourceline>
      <version>1</version>
      <description>
            If Mka_Crypto_KekGenerateAsync is called while ICK is not ready the Crypto unit shall
            return E_NOT_OK and no process will be started.
          </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01144_KekGen_DoubleCall_Async</srcid><srcstatus/><internalId>2039</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1217</internalId></specobject>
    <specobject>
      <id>Mka.Crypto.KeyGen_Kek_RequestInvalidKeyGenState</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>16963</sourceline>
      <version>1</version>
      <description>
            If Mka_Crypto_KekGenerateAsync is called while key generation is ongoing the Crypto unit shall
            return E_NOT_OK and no process will be started.
          </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01144_KekGen_DoubleCall_Async</srcid><srcstatus/><internalId>2039</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01150_Kek_InvalidKeyGenState</srcid><srcstatus/><internalId>2045</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1218</internalId></specobject>
    <specobject>
      <id>Mka.Crypto.IcvGen_RequestInvalidState</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>16980</sourceline>
      <version>1</version>
      <description>
            If Mka_Crypto_IcvGenerateAsync is called while ICK is not ready the Crypto unit shall
            return E_NOT_OK and no process will be started.
          </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01017_IcvGen_Async_Fail</srcid><srcstatus/><internalId>1921</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1219</internalId></specobject>
    <specobject>
      <id>Mka.Crypto.IcvGen_RequestInvalidIcvGenState</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>16997</sourceline>
      <version>1</version>
      <description>
            If Mka_Crypto_IcvGenerateAsync is called while ICV generation is ongoing the Crypto unit shall
            return E_NOT_OK and no process will be started.
          </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01017_IcvGen_Async_Fail</srcid><srcstatus/><internalId>1921</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1220</internalId></specobject>
    <specobject>
      <id>Mka.Crypto.IcvGen_RequestInvalidBuffLen</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>17014</sourceline>
      <version>1</version>
      <description>
            If Mka_Crypto_IcvGenerateAsync is called with invalid BufferLength value (not enough space to store ICV)
            the Crypto unit shall return E_NOT_OK and no process will be started.
          </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01017_IcvGen_Async_Fail</srcid><srcstatus/><internalId>1921</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1221</internalId></specobject>
    <specobject>
      <id>Mka.Crypto.IcvVer_RequestInvalidState</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>17031</sourceline>
      <version>1</version>
      <description>
            If Mka_Crypto_IcvVerifyAsync is called while ICK is not ready the Crypto unit shall
            return E_NOT_OK and no process will be started.
          </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01045_IcvVerify_RequestInvalidState</srcid><srcstatus/><internalId>1949</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1222</internalId></specobject>
    <specobject>
      <id>Mka.Crypto.IcvVer_RequestInvalidIcvVerState</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>17048</sourceline>
      <version>1</version>
      <description>
            If Mka_Crypto_IcvVerifyAsync is called while ICV verification is ongoing the Crypto unit shall
            return E_NOT_OK and no process will be started.
          </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01046_IcvVerify_Async128_RequestInvalidIcvVerState</srcid><srcstatus/><internalId>1950</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1223</internalId></specobject>
    <specobject>
      <id>Mka.Crypto.IcvVer_RequestInvalidDataLen</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>17065</sourceline>
      <version>1</version>
      <description>
            If Mka_Crypto_IcvVerifyAsync is called with invalid DataLength value (must be at least larger than ICV)
            the Crypto unit shall return E_NOT_OK and no process will be started.
          </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01047_IcvVerify_Async128_RequestInvalidDataLen</srcid><srcstatus/><internalId>1951</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1224</internalId></specobject>
    <specobject>
      <id>Mka.Crypto.KeyWrap_Sak_StartGenFail</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>17082</sourceline>
      <version>1</version>
      <description>
            If the Csm_RandomGenerate call to start the key generation of SAK returns any result other than E_OK the Crypto unit shall
            stop any further key generation process and report to the caller that the key generation has failed.
          </description>
      <verifycrit>
            This requirement shall be tested for:
            * Synchronous processing
            * Asynchronous processing
          </verifycrit>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01103_Sak_StartGenFail_Async</srcid><srcstatus/><internalId>1998</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1225</internalId></specobject>
    <specobject>
      <id>Mka.Crypto.KeyWrap_Sak_StartWrapFail</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>17104</sourceline>
      <version>1</version>
      <description>
            If the Csm_Encrypt call to start the key wrap of SAK returns any result other than E_OK the Crypto unit shall
            stop any further key wrap process and report to the caller that the key wrap has failed.
          </description>
      <verifycrit>
            This requirement shall be tested for:
            * Synchronous processing
            * Asynchronous processing
          </verifycrit>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01105_Sak_StartWrapFail_Async</srcid><srcstatus/><internalId>2000</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01106_Sak_StartWrapFail_Sync</srcid><srcstatus/><internalId>2001</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01159_SakWrapUnwrapAsync_Fail_PresharedIckKek</srcid><srcstatus/><internalId>2054</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01161_SakWrapAsync_Fail_PresharedIckKek</srcid><srcstatus/><internalId>2056</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1226</internalId></specobject>
    <specobject>
      <id>Mka.Crypto.KeyUnwrap_Sak_StartUnwrapFail</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>17126</sourceline>
      <version>1</version>
      <description>
            If the Csm_Decrypt call to start the key unwrap of SAK returns any result other than E_OK the Crypto unit shall
            stop any further key unwrap process and report to the caller that the key unwrap has failed.
          </description>
      <verifycrit>
            This requirement shall be tested for:
            * Synchronous processing
            * Asynchronous processing
          </verifycrit>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01112_SakUnwrap_StartFail</srcid><srcstatus/><internalId>2007</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01162_SakUnwrap_Fail_PresharedIckKek</srcid><srcstatus/><internalId>2057</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1227</internalId></specobject>
    <specobject>
      <id>Mka.Crypto.KeyWrap_Sak_Async_KeyGenFail</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>17148</sourceline>
      <version>1</version>
      <description>
            If SAK key generation was started and Mka_CsmRandomCallback reports any result other than E_OK the Crypto unit shall
            stop any further key generation process and report to the caller that the key generation has failed.
          </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01102_Sak_Async_KeyGen_Fail</srcid><srcstatus/><internalId>1997</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1228</internalId></specobject>
    <specobject>
      <id>Mka.Crypto.KeyWrap_Sak_Async_KeyWrapFail</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>17165</sourceline>
      <version>1</version>
      <description>
            If SAK key wrap was started and Mka_CsmKeyWrapCallback reports any result other than E_OK the Crypto unit shall
            stop any further key wrap process and report to the caller that the key wrap has failed.
          </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01101_Sak_Async_KeyWrap_Fail</srcid><srcstatus/><internalId>1996</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1229</internalId></specobject>
    <specobject>
      <id>Mka.Crypto.KeyUnwrap_Sak_Async_KeyUnwrapFail</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>17182</sourceline>
      <version>1</version>
      <description>
            If SAK key unwrap was started and Mka_CsmKeyUnwrapCallback reports any result other than E_OK the Crypto unit shall
            stop any further key unwrap process and report to the caller that the key unwrap has failed.
          </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01067_SakUnwrap_Async128_CC</srcid><srcstatus/><internalId>1971</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1230</internalId></specobject>
    <specobject>
      <id>Mka.Crypto.HashGenerate_Async_Fail</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>17199</sourceline>
      <version>1</version>
      <description>
            If Mka_CsmHashGenerateCallback reports any result other than E_OK the Crypto unit shall
            stop any further process and report to the caller that the operation has failed.
          </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01151_HashGen_CallbackFail</srcid><srcstatus/><internalId>2046</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1231</internalId></specobject>
    <specobject>
      <id>Mka.Crypto.HashGenerate_Sync_Fail</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>17216</sourceline>
      <version>1</version>
      <description>
            If Csm reports any result other than E_OK the Crypto unit shall
            stop any further process and report to the caller that the operation has failed.
          </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01153_HashGen_Retry_NotOk</srcid><srcstatus/><internalId>2048</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1232</internalId></specobject>
    <specobject>
      <id>Mka.Crypto.KeyWrap_SetSak_Fail</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>17233</sourceline>
      <version>1</version>
      <description>
            If saving the generated SAK (Csm_KeyElementSet) fails the Crypto unit shall
            stop any further key generation process and report to the caller that the key generation has failed.
          </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01100_KeyWrap_SetSak_Fail</srcid><srcstatus/><internalId>1995</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1233</internalId></specobject>
    <specobject>
      <id>Mka.Crypto.KeyWrap_SetSakValid_Fail</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>17250</sourceline>
      <version>1</version>
      <description>
            If setting the state of the generated SAK to valid (Csm_KeySetValid) fails the Crypto unit shall
            stop any further key generation process and report to the caller that the key generation has failed.
          </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01099_KeyWrap_SetSak_Valid_Fail</srcid><srcstatus/><internalId>1994</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1234</internalId></specobject>
    <specobject>
      <id>Mka.Crypto.KeyUnwrap_SetSak_Fail</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>17267</sourceline>
      <version>1</version>
      <description>
            If saving the unwrapped SAK (Csm_KeyElementSet) fails the Crypto unit shall
            stop any further key process and report to the caller that the key unwrap has failed.
          </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01109_SakUnwrap_Async128_SetFail</srcid><srcstatus/><internalId>2004</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1235</internalId></specobject>
    <specobject>
      <id>Mka.Crypto.KeyUnwrap_SetSakValid_Fail</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>17284</sourceline>
      <version>1</version>
      <description>
            If setting the state of the unwrapped SAK to valid (Csm_KeySetValid) fails the Crypto unit shall
            stop any further key process and report to the caller that the key unwrap has failed.
          </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01110_SakUnwrap_Async128_ValidFail</srcid><srcstatus/><internalId>2005</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1236</internalId></specobject>
    <specobject>
      <id>Mka.Crypto.KeyWrap_RequestInvalidState</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>17301</sourceline>
      <version>1</version>
      <description>
            If Mka_Crypto_SakGenWrapAsync is called while KEK is not ready the Crypto unit shall
            return E_NOT_OK and no process will be started.
          </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01065_SakGenWrap_128_CC</srcid><srcstatus/><internalId>1969</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1237</internalId></specobject>
    <specobject>
      <id>Mka.Crypto.KeyWrap_RequestInvalidKeyWrapState</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>17318</sourceline>
      <version>1</version>
      <description>
            If Mka_Crypto_SakGenWrapAsync is called while key generation and wrapping is ongoing the Crypto unit shall
            return E_NOT_OK and no process will be started.
          </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01098_KeyWrap_ReqInvalid_SM_State</srcid><srcstatus/><internalId>1993</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1238</internalId></specobject>
    <specobject>
      <id>Mka.Crypto.KeyUnwrap_RequestInvalidState</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>17335</sourceline>
      <version>1</version>
      <description>
            If Mka_Crypto_SakUnwrapAsync is called while KEK is not ready the Crypto unit shall
            return E_NOT_OK and no process will be started.
          </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01063_SakUnwrap_128_CC</srcid><srcstatus/><internalId>1967</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1239</internalId></specobject>
    <specobject>
      <id>Mka.Crypto.KeyUnwrap_RequestInvalidKeyUnwrapState</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>17352</sourceline>
      <version>1</version>
      <description>
            If Mka_Crypto_SakUnwrapAsync is called while unwrapping is ongoing the Crypto unit shall
            return E_NOT_OK and no process will be started.
          </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01111_SakUnwrap_Async128_DoubleFail</srcid><srcstatus/><internalId>2006</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1240</internalId></specobject>
    <specobject>
      <id>Mka.Crypto.RandomGen_Stop</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>17369</sourceline>
      <version>1</version>
      <description>
            If Mka_Crypto_Stop is called while random generation is ongoing the process shall be stopped and Mka_KaY_RandomGenerateFinished
            shall not be called.
          </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01069_RandomGen_Stop_Sync128</srcid><srcstatus/><internalId>1973</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1241</internalId></specobject>
    <specobject>
      <id>Mka.Crypto.RandomGen_Async_Stop</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>17386</sourceline>
      <version>1</version>
      <description>
            If Mka_Crypto_Stop is called while asynchronous random generation is ongoing Crypto unit shall call Csm_CancelJob
            for the ongoing random generate job.
          </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01068_RandomGen_Stop_Async128</srcid><srcstatus/><internalId>1972</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1242</internalId></specobject>
    <specobject>
      <id>Mka.Crypto.KeyGen_Ick_Stop</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>17403</sourceline>
      <version>1</version>
      <description>
            If Mka_Crypto_Stop is called while ICK generation is ongoing the process shall be stopped and
            Mka_Logon_IckGenerateFinished shall not be called.
          </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01123_IckGen_Stop_Sync256</srcid><srcstatus/><internalId>2018</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01155_KeyGenRequest_Stop_Async128</srcid><srcstatus/><internalId>2050</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1243</internalId></specobject>
    <specobject>
      <id>Mka.Crypto.KeyGen_Async_Ick_Stop</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>17420</sourceline>
      <version>1</version>
      <description>
            If Mka_Crypto_Stop is called while asynchronous ICK generation is ongoing Crypto unit shall call Csm_CancelJob
            for the ICK generate job.
          </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01070_KekIckGen_Stop_Async128</srcid><srcstatus/><internalId>1974</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1244</internalId></specobject>
    <specobject>
      <id>Mka.Crypto.KeyGen_Kek_Stop</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>17437</sourceline>
      <version>1</version>
      <description>
            If Mka_Crypto_Stop is called while KEK generation is ongoing the process shall be stopped and
            Mka_KaY_KekGenerateFinished shall not be called.
          </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01124_KekGen_Stop_Sync256</srcid><srcstatus/><internalId>2019</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1245</internalId></specobject>
    <specobject>
      <id>Mka.Crypto.KeyGen_Async_Kek_Stop</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>17454</sourceline>
      <version>1</version>
      <description>
            If Mka_Crypto_Stop is called while asynchronous KEK generation is ongoing Crypto unit shall call Csm_CancelJob
            for the KEK generate job.
          </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01125_KekGen_Stop_Async</srcid><srcstatus/><internalId>2020</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1246</internalId></specobject>
    <specobject>
      <id>Mka.Crypto.IcvGen_Stop</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>17471</sourceline>
      <version>1</version>
      <description>
            If Mka_Crypto_Stop is called while ICV generation is ongoing the process shall be stopped and
            Mka_RxTx_IcvGenerateFinished shall not be called.
          </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01071_IcvGen_Stop_Async128</srcid><srcstatus/><internalId>1975</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01156_IcvGenRequest_Stop_Async128</srcid><srcstatus/><internalId>2051</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1247</internalId></specobject>
    <specobject>
      <id>Mka.Crypto.IcvGen_Async_Stop</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>17488</sourceline>
      <version>1</version>
      <description>
            If Mka_Crypto_Stop is called while asynchronous ICV generation is ongoing Crypto unit shall call Csm_CancelJob
            for the ICV generate job.
          </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01071_IcvGen_Stop_Async128</srcid><srcstatus/><internalId>1975</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1248</internalId></specobject>
    <specobject>
      <id>Mka.Crypto.IcvVer_Stop</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>17505</sourceline>
      <version>1</version>
      <description>
            If Mka_Crypto_Stop is called while ICV verification is ongoing the process shall be stopped and
            Mka_RxTx_IcvVerifyFinished shall not be called.
          </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01072_IcvVer_Stop_Async128</srcid><srcstatus/><internalId>1976</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01157_IcvVerRequest_Stop_Async128</srcid><srcstatus/><internalId>2052</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1249</internalId></specobject>
    <specobject>
      <id>Mka.Crypto.IcvVer_Async_Stop</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>17522</sourceline>
      <version>1</version>
      <description>
            If Mka_Crypto_Stop is called while asynchronous ICV verification is ongoing Crypto unit shall call Csm_CancelJob
            for the ICV verify job.
          </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01072_IcvVer_Stop_Async128</srcid><srcstatus/><internalId>1976</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1250</internalId></specobject>
    <specobject>
      <id>Mka.Crypto.KeyWrap_Stop</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>17539</sourceline>
      <version>1</version>
      <description>
            If Mka_Crypto_Stop is called while SAK wrap is ongoing the process shall be stopped and
            Mka_KaY_SakGenWrapFinished shall not be called.
          </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01074_SakGenWrap_Stop_Sync128</srcid><srcstatus/><internalId>1978</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01158_KeyWrapRequest_Stop_Async128</srcid><srcstatus/><internalId>2053</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1251</internalId></specobject>
    <specobject>
      <id>Mka.Crypto.KeyWrap_Async_Stop</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>17556</sourceline>
      <version>1</version>
      <description>
            If Mka_Crypto_Stop is called while asynchronous SAK wrap is ongoing Crypto unit shall call Csm_CancelJob
            for the key wrap job.
          </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01073_SakGenWrap_Stop_Async128</srcid><srcstatus/><internalId>1977</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01154_SakHash_Stop_Async128</srcid><srcstatus/><internalId>2049</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01160_SakGenWrap_Stop_PresharedIckKek</srcid><srcstatus/><internalId>2055</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1252</internalId></specobject>
    <specobject>
      <id>Mka.Crypto.KeyUnwrap_Stop</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>17573</sourceline>
      <version>1</version>
      <description>
            If Mka_Crypto_Stop is called while SAK unwrap is ongoing the process shall be stopped and
            Mka_KaY_SakUnwrapFinished shall not be called.
          </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01075_SakUnwrap_Stop_Async128</srcid><srcstatus/><internalId>1979</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1253</internalId></specobject>
    <specobject>
      <id>Mka.Crypto.KeyUnwrap_Async_Stop</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>17590</sourceline>
      <version>1</version>
      <description>
            If Mka_Crypto_Stop is called while asynchronous SAK unwrap is ongoing Crypto unit shall call Csm_CancelJob
            for the key unwrap job.
          </description>
      <tags>
        <tag>Unit:Crypto</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01075_SakUnwrap_Stop_Async128</srcid><srcstatus/><internalId>1979</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01076_SakUnwrap_Stop_Sync128</srcid><srcstatus/><internalId>1980</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1254</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd">
    <specobject>
      <id>Mka.swdd.ROMConsumption</id>
      <status>approved</status>
      <source>Elektrobit Automotive GmbH</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>17678</sourceline>
      <version>1</version>
      <description>
                  The ROM consumption for the reference configuration for code and configuration
                  must not exceed 22000 bytes.
                </description>
      <rationale>
                  The defined ROM consumption is the result of all analyzed configuration
                  parameters of the reference configuration.
                  The number is based on the assumption of amount and size of analyzed configuration
                  parameters.
                </rationale>
      <needscoverage>
        <needscov><needsobj>man</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.EB.Manual.RAM_ROM_ConsumptionMonitoring</srcid><srcstatus/><internalId>461</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest0200_ResourceConsumption</srcid><srcstatus/><internalId>1736</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1255</internalId></specobject>
    <specobject>
      <id>Mka.swdd.ROMMonitoring</id>
      <status>approved</status>
      <source>Elektrobit Automotive GmbH</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>17699</sourceline>
      <version>1</version>
      <description>
                  The ROM consumption of Mka shall be monitored for each Mka external
                  release.
                </description>
      <verifycrit>
                  Analysis results and deviations from the calculated consumption shall be
                  analyzed and stored in
                  &lt;code&gt;asc_Mka\test\ts5\Manual\Mka_ManTest01_ResourceConsumption\ResourceConsumption.txt&lt;/code&gt;.
                  These numbers are calculated using the &lt;code&gt;asc_Mka\tools\GetMemoryUsage.sh&lt;/code&gt; script. Instructions 
                  on how to use this script can be found in the script itself and 
                  &lt;code&gt;asc_Mka\test\ts5\Manual\Mka_ManTest01_ResourceConsumption\readme.txt&lt;/code&gt;.
                </verifycrit>
      <needscoverage>
        <needscov><needsobj>man</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.EB.Manual.RAM_ROM_ConsumptionMonitoring</srcid><srcstatus/><internalId>461</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1256</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd">
    <specobject>
      <id>Mka.swdd.RAMConsumption</id>
      <status>approved</status>
      <source>Elektrobit Automotive GmbH</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>17733</sourceline>
      <version>1</version>
      <description>
                  The RAM consumption for the reference configuration must not exceed 1200 bytes.
                </description>
      <rationale>
                  The defined RAM consumption is the result of all analyzed configuration
                  parameters of the reference configuration.
                  The number is based on the assumption of amount and size of analyzed
                  configuration parameters.
                </rationale>
      <needscoverage>
        <needscov><needsobj>man</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.EB.Manual.RAM_ROM_ConsumptionMonitoring</srcid><srcstatus/><internalId>461</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest0200_ResourceConsumption</srcid><srcstatus/><internalId>1736</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1257</internalId></specobject>
    <specobject>
      <id>Mka.swdd.RAMMonitoring</id>
      <status>approved</status>
      <source>Elektrobit Automotive GmbH</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>17753</sourceline>
      <version>1</version>
      <description>
                  The RAM consumption of Mka shall be monitored for each Mka external
                  release.
                </description>
      <verifycrit>
                  Analysis results and deviations from the calculated consumption shall be
                  analyzed and stored in
                  &lt;code&gt;asc_Mka\test\ts5\Manual\Mka_ManTest01_ResourceConsumption\ResourceConsumption.txt&lt;/code&gt;.
                  These numbers are calculated using the &lt;code&gt;asc_Mka\tools\GetMemoryUsage.sh&lt;/code&gt; script. Instructions 
                  on how to use this script can be found in the script itself and 
                  &lt;code&gt;asc_Mka\test\ts5\Manual\Mka_ManTest01_ResourceConsumption\readme.txt&lt;/code&gt;.
                </verifycrit>
      <needscoverage>
        <needscov><needsobj>man</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.EB.Manual.RAM_ROM_ConsumptionMonitoring</srcid><srcstatus/><internalId>461</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1258</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd">
    <specobject>
      <id>Mka.dsn.Crypto.IcvGenSM.Requested_2_Busy</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>17868</sourceline>
      <version>2</version>
      <description>Transition from the state ICVGEN_REQUESTED  to the state ICVGEN_BUSY 
Csm_MacGenerate() returns E_BUSY, and retry feature is configured.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01119_IcvGen_Retry_Async</srcid><srcstatus/><internalId>2014</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.IcvGenSM</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1090</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1259</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.IcvGenSM.Requested_2_Notify</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>17885</sourceline>
      <version>2</version>
      <description>Transition from the state ICVGEN_REQUESTED to the state ICVGEN_NOTIFY happens when the notification Mka_CsmIcvGenerateCallback() is received.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01014_IcvGen_Async128</srcid><srcstatus/><internalId>1918</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.IcvGenSM</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1090</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1260</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.IcvGenSM.Requested_2_Idle</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>17901</sourceline>
      <version>2</version>
      <description>Transition from the state ICVGEN_REQUESTED to the state ICVGEN_IDLE happens when the first call of Csm_MacGenerate() returns E_NOT_OK.
RxTx unit is notified with Mka_RxTx_IcvGenerateFinished(E_NOT_OK), that the operation failed.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01024_IcvGen_Async128_JobFail</srcid><srcstatus/><internalId>1928</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01025_IcvGen_Async128_StartFail</srcid><srcstatus/><internalId>1929</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.IcvGenSM</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1090</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1261</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.IcvGenSM.Idle_2_Requested</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>17918</sourceline>
      <version>2</version>
      <description>Transition from the state ICVGEN_IDLE to the state ICVGEN_REQUESTED happens when ICV generation is requested with Mka_Crypto_IcvGenerateAsync().</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01014_IcvGen_Async128</srcid><srcstatus/><internalId>1918</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.IcvGenSM</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1090</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1262</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.IcvGenSM.Busy_2_Idle</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>17934</sourceline>
      <version>2</version>
      <description>Transition from the state ICVGEN_BUSY to the state ICVGEN_IDLE happens under the following circumstances:
1) When Csm_MacGenerate() called from Mka_Crypto_MainFunction() returns E_NOT_OK. Since this happens in the context of Mka main function, it is safe to immediately call  Mka_RxTx_IcvGenerateFinished(E_NOT_OK).
2) The maximum number of retries have been reached.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01121_IcvGen_Retry_Fail</srcid><srcstatus/><internalId>2016</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.IcvGenSM</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1090</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1263</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.IcvGenSM.Notify_2_Idle</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>17952</sourceline>
      <version>2</version>
      <description>Transition from the state ICVGEN_NOTIFY to the state ICVGEN_IDLE happens during Mka_Crypto_MainFunction() where Mka_RxTx_IcvGenerateFinished(Result) is called to inform about ICV generation result. This state is used to decouple Mka from the Crypto stack.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01014_IcvGen_Async128</srcid><srcstatus/><internalId>1918</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.IcvGenSM</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1090</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1264</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.IcvGenSM.Initial_Initialization</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>17968</sourceline>
      <version>2</version>
      <description>Transition from the state Initial to the state ICVGEN_IDLE happens during Crypto unit initialization - Mka_Crypto_Init().</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01014_IcvGen_Async128</srcid><srcstatus/><internalId>1918</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.IcvGenSM</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1090</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1265</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.IcvGenSM.Busy_2_Notify</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>17984</sourceline>
      <version>2</version>
      <description>Transition from the state ICVGEN_BUSY to the state ICVGEN_NOTIFY happens when the notification Mka_CsmIcvGenerateCallback() is received.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01119_IcvGen_Retry_Async</srcid><srcstatus/><internalId>2014</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.IcvGenSM</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1090</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1266</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.IcvGenSM.Busy_SelfTransition</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>18000</sourceline>
      <version>2</version>
      <description>Self-transition in the state ICVGEN_BUSY happens under the following circumstances:
1) When Csm_MacGenerate() returns E_BUSY and the number of retries did nor reach configured maximum.
2) When Csm_MacGenerate() returns E_OK, indicating that the request is accepted.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01119_IcvGen_Retry_Async</srcid><srcstatus/><internalId>2014</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01121_IcvGen_Retry_Fail</srcid><srcstatus/><internalId>2016</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.IcvGenSM</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1090</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1267</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.IcvVerSM.Notified_2_Idle</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>18018</sourceline>
      <version>1</version>
      <description>Transition from state ICVVER_NOTIFIED to ICVVER_IDLE occurs after Csm module calls Mka_CsmIcvVerifyCallback. Result is reported to the caller in the next MainFunction tick.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01039_IcvVerify_Async128</srcid><srcstatus/><internalId>1943</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.IcvVerSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1091</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1268</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.IcvVerSM.Requested_2_Notified</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>18034</sourceline>
      <version>1</version>
      <description>Transition from the state ICVVER_REQUESTED  to the state ICVVER_NOTIFIED happens when Icv Verification Csm operation callback is called - Mka_CsmIcvVerifyCallback().</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01039_IcvVerify_Async128</srcid><srcstatus/><internalId>1943</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.IcvVerSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1091</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1269</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.IcvVerSM.Busy_2_Notified</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>18050</sourceline>
      <version>1</version>
      <description>Transition from state ICVVER_BUSY to ICVVER_NOTIFIED happens when Csm module calls Mka_CsmIcvVerifyCallback().</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01040_IcvVerify_Sync128</srcid><srcstatus/><internalId>1944</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.IcvVerSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1091</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1270</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.IcvVerSM.Initial_Initialization</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>18066</sourceline>
      <version>1</version>
      <description>Transition from the state Initial to the state ICVVER_IDLE happens during Crypto unit initialization - Mka_Crypto_Init().</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01039_IcvVerify_Async128</srcid><srcstatus/><internalId>1943</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.IcvVerSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1091</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1271</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.IcvVerSM.Busy_2_Idle_Fail</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>18082</sourceline>
      <version>1</version>
      <description>Transition from the state ICVVER_BUSY to the state ICVVER_IDLE happens when a call to Csm API Csm_MacVerify returns E_NOT_OK or it returns E_BUSY for more times than the value of MAX_RETRY. Crypto unit shall call Mka_RxTx_IcvVerifyFinished with E_NOT_OK.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01117_IcvVerify_Retry_Fail</srcid><srcstatus/><internalId>2012</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.IcvVerSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1091</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1272</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.IcvVerSM.Busy</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>18098</sourceline>
      <version>1</version>
      <description>Self-transition in-to state ICVVER_BUSY occurs if call to Csm_MacVerify returns E_BUSY while the number of retries has not exceeded MAX_RETRY, or if Csm_MacVerify returned E_OK.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01116_IcvVerify_Retry</srcid><srcstatus/><internalId>2011</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.IcvVerSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1091</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1273</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.IcvVerSM.Requested_2_Busy</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>18114</sourceline>
      <version>1</version>
      <description>Transition from state ICVVER_REQUESTED to ICVVER_BUSY happens when a call to Csm_MacVerify returns E_BUSY.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01040_IcvVerify_Sync128</srcid><srcstatus/><internalId>1944</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.IcvVerSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1091</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1274</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.IcvVerSM.Idle_2_Requested</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>18130</sourceline>
      <version>1</version>
      <description>Transition from the state ICVVER_IDLE to the state MKA_CRYPTO_ICVVER_REQUESTED happens when Icv verification is requested - Mka_Crypto_IcvVerifyAsync.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01039_IcvVerify_Async128</srcid><srcstatus/><internalId>1943</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01040_IcvVerify_Sync128</srcid><srcstatus/><internalId>1944</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.IcvVerSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1091</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1275</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.IcvVerSM.Requested_2_Idle</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>18146</sourceline>
      <version>1</version>
      <description>Transition from state ICVVER_REQUESTED to ICVVER_IDLE happens if Csm_MacVerify returns E_NOT_OK. Result E_NOT_OK is reported to the caller.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01042_IcvVerify_Async128_StartVerFail</srcid><srcstatus/><internalId>1946</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01043_IcvVerify_Sync128_StartVerFail</srcid><srcstatus/><internalId>1947</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.IcvVerSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1091</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1276</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.InstSM.Disabled_2_WaitFirstMemberId</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>18162</sourceline>
      <version>1</version>
      <description>Transition from the state KAY_INSTANCE_DISABLED to the state KAY_INSTANCE_WAIT_FIRST_MEMBER_ID happens during instance creation - Mka_KaY_CreateParticipant().</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01014_InstSM_Disabled2WaitFirstMemberId</srcid><srcstatus/><internalId>2082</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.InstSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1094</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1277</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.InstSM.WaitFirstMemberId_2_Disabled_RetVal_NOT_OK</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>18178</sourceline>
      <version>1</version>
      <description>Transition from the state KAY_INSTANCE_WAIT_FIRST_MEMBER_ID  to the state KAY_INSTANCE_DISABLED happens if a call to Mka_Crypto_RandomGenerateAsync() returns E_NOT_OK. Mka_KaY_DeleteInstance() is called to delete instance and initialize downstream state machines.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01016_InstSM_WaitFirstMemberId2Disabled_RetVal_NOT_OK</srcid><srcstatus/><internalId>2084</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.InstSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1094</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1278</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.InstSM.ANY_2_Disabled_DeleteParticipant</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>18194</sourceline>
      <version>1</version>
      <description>Instance deletion (call of Mka_KaY_DeleteParticipant()) will cause transition to the state KAY_INSTANCE_DISABLED from any state.
</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01014_InstSM_Disabled2WaitFirstMemberId</srcid><srcstatus/><internalId>2082</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01017_InstSM_WaitFirstMemberId2Running</srcid><srcstatus/><internalId>2085</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01022_InstSM_DeleteWaitNewMemberId</srcid><srcstatus/><internalId>2090</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.InstSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1094</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1279</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.InstSM.Initial_2_Disabled</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>18211</sourceline>
      <version>1</version>
      <description>Transition from the state Initial to the state KAY_INSTANCE_DISABLED happens during KaY unit initialization - Mka_KaY_Init().</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01001_Initialization</srcid><srcstatus/><internalId>2071</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01014_InstSM_Disabled2WaitFirstMemberId</srcid><srcstatus/><internalId>2082</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.InstSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1094</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1280</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.InstSM.WaitNewMemberId_2_Disabled_Result_NOT_OK</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>18227</sourceline>
      <version>1</version>
      <description>Transition from the state KAY_INSTANCE_WAIT_NEW_MEMBER_ID  to the state KAY_INSTANCE_DISABLED happens if Crypto calls Mka_KaY_RandomGenerateFinished() with Result == E_NOT_OK or call to Mka_Crypto_RandomGenerateAsync() returned E_NOT_OK.
Mka_KaY_DeleteInstance() is called to delete instance and initialize downstream state machines.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01019_InstSM_Running2WaitNewMemberId_SameMi</srcid><srcstatus/><internalId>2087</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01021_InstSM_WaitNewMemberId2Disabled</srcid><srcstatus/><internalId>2089</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.InstSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1094</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1281</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.InstSM.WaitFirstMemberId_2_Disabled_Result_NOT_OK</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>18244</sourceline>
      <version>1</version>
      <description>Transition from the state KAY_INSTANCE_WAIT_FIRST_MEMBER_ID  to the state KAY_INSTANCE_DISABLED happens if Crypto calls Mka_KaY_RandomGenerateFinished() with Result == E_NOT_OK.
Logon unit is notified that the instance is disabled by calling Mka_Logon_InstanceStateChange(DISABLED).</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01015_InstSM_WaitFirstMemberId2Disabled_Result_NOT_OK</srcid><srcstatus/><internalId>2083</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.InstSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1094</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1282</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.InstSM.WaitNewMemberId_2_Running</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>18261</sourceline>
      <version>1</version>
      <description>Transition from the state KAY_INSTANCE_WAIT_NEW_MEMBER_ID to the state KAY_INSTANCE_RUNNING happens when Crypto indicates successful random number generation by calling Mka_KaY_RandomGenerateFinished() with Result == E_OK.
Additionally, for elected key server generation of new SAK is requested.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01023_InstSM_WaitNewMemberId2Running</srcid><srcstatus/><internalId>2091</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.InstSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1094</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1283</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.InstSM.Running_2_WaitNewMemberId</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>18278</sourceline>
      <version>1</version>
      <description>Transition from the state KAY_INSTANCE_RUNNING  to the state KAY_INSTANCE_WAIT_NEW_MEMBER_ID happens when new Member identifier is required due to following reasons:
1)  MKPDU is received (Mka_KaY_RxMkpdu() is called), and the received partners Member identifier is identical to the own Member identifier, i.e. is repeated).
2) Own Message number has reached threshold.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01019_InstSM_Running2WaitNewMemberId_SameMi</srcid><srcstatus/><internalId>2087</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01020_InstSM_Running2WaitNewMemberId_MnThreshold</srcid><srcstatus/><internalId>2088</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01023_InstSM_WaitNewMemberId2Running</srcid><srcstatus/><internalId>2091</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.InstSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1094</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1284</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.InstSM.WaitFirstMemberId</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>18296</sourceline>
      <version>1</version>
      <description>Self-transition from-to the state KAY_INSTANCE_WAIT_FIRST_MEMBER_ID happens if Logon called Mka_KaY_LinkStateActive (LinkStateTrigger == TRUE) before Mka_KaY_RandomGenerateFinished() call was received.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01005_RandomGenerateFinished_E_OK</srcid><srcstatus/><internalId>2075</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.InstSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1094</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1285</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.InstSM.WaitFirstMemberId_2_InstanceRunning</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>18312</sourceline>
      <version>1</version>
      <description>Transition from the state KAY_INSTANCE_WAIT_FIRST_MEMBER_ID to the state KAY_INSTANCE_RUNNING happens if Logon reported that link is active  with Mka_KaY_LinkStateActive() and Mka_KaY_RandomGenerateFinished() call was received after that, with Result == E_OK.
The first MKPDU is immediately transmitted and periodic TX MKPDU timer started.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01017_InstSM_WaitFirstMemberId2Running</srcid><srcstatus/><internalId>2085</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.InstSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1094</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1286</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.InstSM.WaitFirstMemberId_2_WaitLinkActive</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>18329</sourceline>
      <version>1</version>
      <description>Transition from the state KAY_INSTANCE_WAIT_FIRST_MEMBER_ID to the state KAY_INSTANCE_WAIT_LINK_ACTIVE happens when Crypto calls Mka_KaY_RandomGenerateFinished() with Result == E_OK and link is not active.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01084_InstSM_WaitFirstMemberId2WaitLinkActive</srcid><srcstatus/><internalId>2152</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.InstSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1094</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1287</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.InstSM.WaitLinkActive_2_InstanceRunning</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>18345</sourceline>
      <version>1</version>
      <description>Transition from the state KAY_INSTANCE_WAIT_LINK_ACTIVE to the state KAY_INSTANCE_RUNNING happens when Logon calls Mka_KaY_LinkStateActive.
The first MKPDU is immediately transmitted and periodic TX MKPDU timer started.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01084_InstSM_WaitFirstMemberId2WaitLinkActive</srcid><srcstatus/><internalId>2152</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.InstSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1094</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1288</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.InstSM.SelfTrans.NewMemberId</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>18362</sourceline>
      <version>1</version>
      <description>Self-transition in the state KAY_INSTANCE_RUNNING happens when new MKPDU is received (Mka_KaY_RxMkpdu() is called) and partner's Member identified is not repeated. In that case PeerSM is ticked.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01018_InstSM_RunningSelfTransition</srcid><srcstatus/><internalId>2086</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.InstSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1094</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1289</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.PeerSM.Any_2_Undetected</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>18378</sourceline>
      <version>1</version>
      <description>Transition from any state to the state KAY_PEER_UNDETECTED  happens when: 
1) Peer Life timer expires
2) State machine is initialized with a call to KaY_PeerSM_Init()
Consequently, active timers are canceled and downstream state (KeySM and CpSM) machines initialized.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01024_PeerSM_Init2Undetected2Potent2Live</srcid><srcstatus/><internalId>2092</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01025_PeerSM_Undetected2Potent2Undetected</srcid><srcstatus/><internalId>2093</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01026_PeerSM_Undetected2Live2Undetected</srcid><srcstatus/><internalId>2094</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01091_PeerSM_Live2Undetected</srcid><srcstatus/><internalId>2159</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01099_PeerSM_KaYPrincipalActor</srcid><srcstatus/><internalId>2167</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.PeerSM</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1095</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1290</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.PeerSM.Undetected_2_Live</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>18397</sourceline>
      <version>1</version>
      <description>Transition from the state KAY_PEER_UNDETECTED to the state KAY_PEER_LIVE  happens when MKPDU is received (Mka_KaY_RxMkpdu() called) and partner has proved aliveness. 
Consequently partner is registered, message number updated and peer Lifetime timer started.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01026_PeerSM_Undetected2Live2Undetected</srcid><srcstatus/><internalId>2094</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.PeerSM</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1095</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1291</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.PeerSM.Undetected_2_Potential</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>18414</sourceline>
      <version>1</version>
      <description>Transition from the state KAY_PEER_UNDETECTED to the state KAY_PEER_POTENTIAL  happens when MKPDU is received (Mka_KaY_RxMkpdu() called) and partner has NOT proved aliveness. 
Consequently partner is registered, message number updated and peer Lifetime timer started.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01024_PeerSM_Init2Undetected2Potent2Live</srcid><srcstatus/><internalId>2092</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.PeerSM</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1095</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1292</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.PeerSM.Initial_2_Undetected</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>18431</sourceline>
      <version>1</version>
      <description>Transition from the state Initial to the state KAY_PEER_UNDETECTED happens during KaY unit initialization - Mka_KaY_Init().</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01024_PeerSM_Init2Undetected2Potent2Live</srcid><srcstatus/><internalId>2092</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.PeerSM</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1095</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1293</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.PeerSM.Live_2_LivePrincipal</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>18447</sourceline>
      <version>1</version>
      <description>Transition from the state KAY_PEER_LIVE to the state KAY_PEER_LIVE_PRINCIPAL  happens when Mka_KaY_SetPrincipalActor() is called to indicate that actor has become principal actor.
Consequently, Mka_Cp_InitRxSc() is called to initialize receive security channel from Cp unit.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01099_PeerSM_KaYPrincipalActor</srcid><srcstatus/><internalId>2167</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.PeerSM</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1095</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1294</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.PeerSM.SelfTrans.Live</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>18464</sourceline>
      <version>1</version>
      <description>Self-transition in the state KAY_PEER_LIVE happens when MKPDU is received (Mka_KaY_RxMkpdu() called) from already registered and alive partner.
Consequently message number is updated and peer Lifetime timer re-started.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01026_PeerSM_Undetected2Live2Undetected</srcid><srcstatus/><internalId>2094</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.PeerSM</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1095</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1295</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.PeerSM.Potential_2_Live</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>18481</sourceline>
      <version>1</version>
      <description>Transition from the state KAY_PEER_POTENTIAL to the state KAY_PEER_LIVE  happens when MKPDU is received (Mka_KaY_RxMkpdu() called) and already registered partner has proved aliveness. 
Consequently message number is updated and peer lifetime timer re-started.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01024_PeerSM_Init2Undetected2Potent2Live</srcid><srcstatus/><internalId>2092</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.PeerSM</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1095</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1296</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.PeerSM.LivePrincipal_2_Live</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>18498</sourceline>
      <version>1</version>
      <description>Transition from the state KAY_PEER_LIVE_PRINCIPAL to the state KAY_PEER_LIVE happens when MKPDU is received (Mka_KaY_RxMkpdu() called) and alive partner stopped sending SakUse parameter set.
Consequently data for PeerSm and KeySM are initialized and afterwards are called Mka_Cp_LinkStateDown() and Mka_Logon_Participant_Actor() and it approves aliveness, it will transit into KAY_PEER_LIVE .</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01118_PeerSM_LivePrinciapl2Live</srcid><srcstatus/><internalId>2186</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.PeerSM</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1095</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1297</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.PeerSM.SelfTrans.Potential</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>18515</sourceline>
      <version>1</version>
      <description>Self-transition in the state KAY_PEER_POTENTIAL happens when MKPDU is received (Mka_KaY_RxMkpdu() called) and already registered partner has NOT proved aliveness. 
Consequently message number is updated and peer Lifetime timer re-started.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01024_PeerSM_Init2Undetected2Potent2Live</srcid><srcstatus/><internalId>2092</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.PeerSM</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1095</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1298</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.PeerSM.LivePrincipal_2_Potential</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>18532</sourceline>
      <version>1</version>
      <description>Transition from the state KAY_PEER_LIVE_PRINCIPAL to the state KAY_PEER_POTENTIAL happens when MKPDU is received (Mka_KaY_RxMkpdu() called) and alive partner stopped sending SakUse parameter set and didn't approved aliveness.
Consequently data for PeerSm and KeySM are initialized and afterwards are called Mka_Cp_LinkStateDown() and Mka_Logon_Participant_Actor()  and didn't approved aliveness, it will transit into KAY_PEER_LIVE .</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01117_PeerSM_LivePrincipal2Potential</srcid><srcstatus/><internalId>2185</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.PeerSM</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1095</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1299</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.PeerSM.SelfTrans.LivePrincipal.RxMkpdu</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>18549</sourceline>
      <version>1</version>
      <description>Self-transition in the state KAY_PEER_LIVE happens when MKPDU is received (Mka_KaY_RxMkpdu() called) from already registered and alive partner.
Consequently message number is updated and peer Lifetime timer re-started.
If SakUse param.set exists within received MKPDU, it shall be given to the Cp unit for analysis on whether to update the MacSecOperational, PN and do other operations.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01099_PeerSM_KaYPrincipalActor</srcid><srcstatus/><internalId>2167</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.PeerSM</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1095</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1300</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.KeyGenSM.Requested_2_Busy</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>18567</sourceline>
      <version>1</version>
      <description>Transition from the state KEYGEN_REQUESTED to the state KEYGEN_BUSY happens when key generation Csm operation is started- Mka_Crypto_MainFunction().
</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01010_KekIckGen_Async128</srcid><srcstatus/><internalId>1914</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.KeyGenSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1089</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1301</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.KeyGenSM.Preparing_2_Requested</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>18584</sourceline>
      <version>1</version>
      <description>Transition from the state KEYGEN_PREPARING to the state KEYGEN_REQUESTED happens when Ckn is extracted from Csm and data for key generation is prepared successfully .</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01010_KekIckGen_Async128</srcid><srcstatus/><internalId>1914</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.KeyGenSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1089</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1302</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.KeyGenSM.Initial_Initialization</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>18600</sourceline>
      <version>1</version>
      <description>Transition from the state Initial to the state KEYGEN_IDLE happens during Crypto unit initialization - Mka_Crypto_Init().</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01008_RandomGen_Async128</srcid><srcstatus/><internalId>1912</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.KeyGenSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1089</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1303</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.KeyGenSM.Preparing_2_Idle</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>18616</sourceline>
      <version>1</version>
      <description>Transition from the state KEYGEN_PREPARING to the state KEYGEN_IDLE happens when preparing data for Ick key generation fails  - Mka_Crypto_KekIckGenerateAsync().</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01030_KekIckGen_Async128_PrepareFail</srcid><srcstatus/><internalId>1934</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.KeyGenSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1089</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1304</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.KeyGenSM.Idle_2_Preparing_Kek</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>18632</sourceline>
      <version>1</version>
      <description>Transition from the state KEYGEN_IDLE to the state KEYGEN_PREPARING happens when a Kek generation is started - Mka_Crypto_KekGenerateAsync().
</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01010_KekIckGen_Async128</srcid><srcstatus/><internalId>1914</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.KeyGenSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1089</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1305</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.KeyGenSM.Idle_2_Preparing</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>18649</sourceline>
      <version>1</version>
      <description>Transition from the state KEYGEN_IDLE to the state KEYGEN_PREPARING happens when a Ick and Kek generation is started - Mka_Crypto_IckGenerateAsync().</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01010_KekIckGen_Async128</srcid><srcstatus/><internalId>1914</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.KeyGenSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1089</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1306</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.KeyGenSM.Busy_2_Idle_Fail</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>18665</sourceline>
      <version>1</version>
      <description>Transition from the state KEYGEN_BUSY to the state KEYGEN_IDLE happens when key generation for Ick or Kek fails.
</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01034_KekIckGen_Async128_ValidFail</srcid><srcstatus/><internalId>1938</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.KeyGenSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1089</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1307</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.KeyGenSM.Busy_2_Idle_Ick</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>18682</sourceline>
      <version>1</version>
      <description>Transition from the state KEYGEN_BUSY to the state KEYGEN_IDLE happens when a Ick and Kek are generated successfully.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01010_KekIckGen_Async128</srcid><srcstatus/><internalId>1914</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.KeyGenSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1089</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1308</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.KeyGenSM.Busy_2_Idle_Kek</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>18698</sourceline>
      <version>1</version>
      <description>Transition from the state KEYGEN_BUSY to the state KEYGEN_IDLE happens when key generation for Ick or Kek fails.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01010_KekIckGen_Async128</srcid><srcstatus/><internalId>1914</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01034_KekIckGen_Async128_ValidFail</srcid><srcstatus/><internalId>1938</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.KeyGenSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1089</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1309</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.KeyUnwrapSM.Hashgen_2_Idle</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>18714</sourceline>
      <version>1</version>
      <description>Transition from the state KEYWRAP_HASHGEN to the state KEYWRAP_IDLE happens when Hash key is generated and the Result is E_OK.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01059_SakUnwrap_Async128</srcid><srcstatus/><internalId>1963</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.KeyUnwrapSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1093</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1310</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.KeyUnwrapSM.Busy_2_Hashgen</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>18730</sourceline>
      <version>1</version>
      <description>Transition from the state KEYWRAP_BUSY to the state KEYWRAP_HASHGEN happens when Sak unwrap is finished and the Result is E_OK.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01059_SakUnwrap_Async128</srcid><srcstatus/><internalId>1963</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.KeyUnwrapSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1093</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1311</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.KeyUnwrapSM.Initial_Initialization</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>18746</sourceline>
      <version>1</version>
      <description>Transition from the state Initial to the state KEYWRAP_IDLE happens during Crypto unit initialization - Mka_Crypto_Init().</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01059_SakUnwrap_Async128</srcid><srcstatus/><internalId>1963</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.KeyUnwrapSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1093</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1312</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.KeyUnwrapSM.Busy_2_Busy</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>18762</sourceline>
      <version>1</version>
      <description>Transition from the state KEYWRAP_BUSY to the state KEYWRAP_BUSY happens when Sak unwrap step is finished and the Result is E_OK.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01059_SakUnwrap_Async128</srcid><srcstatus/><internalId>1963</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.KeyUnwrapSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1093</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1313</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.KeyUnwrapSM.Busy_2_Idle_Fail</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>18778</sourceline>
      <version>1</version>
      <description>Transition from the state KEYWRAP_BUSY to the state KEYWRAP_IDLE happens when Sak unwrap is finished and the Result is E_NOT_OK.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01067_SakUnwrap_Async128_CC</srcid><srcstatus/><internalId>1971</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.KeyUnwrapSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1093</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1314</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.KeyUnwrapSM.Requested_2_Busy</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>18794</sourceline>
      <version>2</version>
      <description>Transition from the state KEYWRAP_REQUESTED to the state KEYWRAP_BUSY happens when Sak unwrap is started and if we are not the key server.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01059_SakUnwrap_Async128</srcid><srcstatus/><internalId>1963</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.KeyUnwrapSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1093</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1315</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.KeyUnwrapSM.Idle_2_Requested</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>18810</sourceline>
      <version>1</version>
      <description>Transition from the state KEYWRAP_IDLE to the state KEYWRAP_REQUESTED happens when a Sak unwrap is started - Mka_Crypto_SakUnwrapAsync().

</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01059_SakUnwrap_Async128</srcid><srcstatus/><internalId>1963</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.KeyUnwrapSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1093</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1316</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.KeyWrapSM.Busy_2_Busy_SakGenerate</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>18828</sourceline>
      <version>1</version>
      <description>Transition from the state KEYWRAP_BUSY to the state KEYWRAP_BUSY happens when Sak generation is finished and the Result is E_OK.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01050_SakGenWrap_Async128</srcid><srcstatus/><internalId>1954</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.KeyWrapSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1092</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1317</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.KeyWrapSM.Busy_2_Busy_Server</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>18844</sourceline>
      <version>1</version>
      <description>Transition from the state KEYWRAP_BUSY to the state KEYWRAP_BUSY happens when Sak wrap step is finished and the Result is E_OK.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01050_SakGenWrap_Async128</srcid><srcstatus/><internalId>1954</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.KeyWrapSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1092</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1318</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.KeyWrapSM.Busy_2_Idle_Fail_Server</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>18860</sourceline>
      <version>1</version>
      <description>Transition from the state KEYWRAP_BUSY to the state KEYWRAP_IDLE happens when Sak Wrap  is finished and the Result is E_NOT_OK.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01088_KeyGenWrap_Busy_Trans_Async_Gen_Fail</srcid><srcstatus/><internalId>1985</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.KeyWrapSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1092</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1319</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.KeyWrapSM.Busy_2_Idle_Fail_Sak</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>18876</sourceline>
      <version>1</version>
      <description>Transition from the state KEYWRAP_BUSY to the state KEYWRAP_IDLE happens when Sak generation  is finished and the Result is E_NOT_OK.
</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01086_KeyGenWrap_Busy_Trans_Sync_Fail</srcid><srcstatus/><internalId>1983</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01087_KeyGenWrap_Busy_Trans_Async_Wrap_Fail</srcid><srcstatus/><internalId>1984</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.KeyWrapSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1092</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1320</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.KeyWrapSM.Busy_2_Hashgen_Server</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>18893</sourceline>
      <version>1</version>
      <description>Transition from the state KEYWRAP_BUSY to the state KEYWRAP_HASHGEN happens when Sak wrap is finished and the Result is E_OK.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01050_SakGenWrap_Async128</srcid><srcstatus/><internalId>1954</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.KeyWrapSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1092</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1321</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.KeyWrapSM.Requested_2_Busy_Server</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>18909</sourceline>
      <version>2</version>
      <description>Transition from the state KEYWRAP_REQUESTED to the state KEYWRAP_BUSY happens when Sak unwrap is started and when RandomGenSM is in state IDLE.
</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01050_SakGenWrap_Async128</srcid><srcstatus/><internalId>1954</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.KeyWrapSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1092</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1322</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.KeyWrapSM.Idle_2_Requested_Server</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>18926</sourceline>
      <version>1</version>
      <description>Transition from the state KEYWRAP_IDLE to the state KEYWRAP_REQUESTED happens when a Sak generation and wrap is started - Mka_Crypto_SakGenWrapAsync().
</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01050_SakGenWrap_Async128</srcid><srcstatus/><internalId>1954</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.KeyWrapSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1092</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1323</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.KeyWrapSM.Hashgen_2_Idle_Server</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>18943</sourceline>
      <version>1</version>
      <description>Transition from the state KEYWRAP_HASHGEN to the state KEYWRAP_IDLE happens when Hash key is generated and the Result is E_OK.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01050_SakGenWrap_Async128</srcid><srcstatus/><internalId>1954</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.KeyWrapSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1092</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1324</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.KeyWrapSM.Initial_Initialization</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>18959</sourceline>
      <version>1</version>
      <description>Transition from the state Initial to the state KEYWRAP_IDLE happens during Crypto unit initialization - Mka_Crypto_Init().</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01050_SakGenWrap_Async128</srcid><srcstatus/><internalId>1954</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.KeyWrapSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1092</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1325</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.CryptoSM.CakCkn_Ready_2_Ick_Ready</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>18975</sourceline>
      <version>1</version>
      <description>Transition from the state MKA_CRYPTO_CAKCKN_READY to the state MKA_CRYPTO_ICK_READY happens during Ick generation - Mka_Crypto_IckGenerateAsync().</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01010_KekIckGen_Async128</srcid><srcstatus/><internalId>1914</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.CryptoSM</linksto>
          <dstversion>3</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1087</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1326</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.CryptoSM.Sak_Ready_2_CakCkn_Ready_Stop</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>18991</sourceline>
      <version>1</version>
      <description>Transition from the state MKA_CRYPTO_SAK_READY to the state MKA_CRYPTO_CAKCKN_READY happens when connection is stopped - Mka_Crypto_Stop() and use of pre-shared ICK and KEK is disabled (MkaUsePresharedIckKek == FALSE).</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01146_SakReady_Stop</srcid><srcstatus/><internalId>2041</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.CryptoSM</linksto>
          <dstversion>3</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1087</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1327</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.CryptoSM.Sak_Ready_2_CakCkn_Ready</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>19007</sourceline>
      <version>1</version>
      <description>Transition from the state MKA_CRYPTO_SAK_READY to the state MKA_CRYPTO_CAKCKN_READY happens during Sak rekey and wrap - Mka_Crypto_SakGenWrapAsync() if any process returns Result != E_OK and use of pre-shared ICK and KEK is disabled (MkaUsePresharedIckKek == FALSE).
During Sak Wrap  the following operations might fail Csm_RandomGenerate, Csm_KeyElementSet, Csm_KeySetValid, Csm_Encrypt.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01147_SakRekey_Fail</srcid><srcstatus/><internalId>2042</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.CryptoSM</linksto>
          <dstversion>3</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1087</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1328</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.CryptoSM.Kek_Ready_2_CakCkn_Ready_Wrap</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>19024</sourceline>
      <version>1</version>
      <description>Transition from the state MKA_CRYPTO_KEK_READY to the state MKA_CRYPTO_CAKCKN_READY happens during Sak generation and wrap - Mka_Crypto_SakGenWrapAsync() if any process returns Result != E_OK.
During Sak Wrap  the following operations might fail  Csm_RandomGenerate, Csm_KeyElementSet, Csm_KeySetValid, Csm_Encrypt.
The precondition for this transition is that the use of pre-shared ICK and KEK is disabled (MkaUsePresharedIckKek == FALSE).</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01105_Sak_StartWrapFail_Async</srcid><srcstatus/><internalId>2000</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01106_Sak_StartWrapFail_Sync</srcid><srcstatus/><internalId>2001</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.CryptoSM</linksto>
          <dstversion>3</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1087</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1329</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.CryptoSM.ValidateKeys_CakCkn_Ready</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>19042</sourceline>
      <version>1</version>
      <description>Transition from the state VALIDATE_KEYS to the state CAKCKN_READY happens when CAK is validated and CKN is successfully red for the use case when use of pre-shared ICK and KEK are disabled.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01170_ValidateCakCkn_Retry</srcid><srcstatus/><internalId>2065</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.CryptoSM</linksto>
          <dstversion>3</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1087</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1330</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.CryptoSM.Kek_Ready_2_CakCkn_Ready_Stop</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>19058</sourceline>
      <version>1</version>
      <description>Transition from the state MKA_CRYPTO_KEK_READY to the state MKA_CRYPTO_CAKCKN_READY happens when connection is stopped with Mka_Crypto_Stop().
The precondition for this transition is that the use of pre-shared ICK and KEK is disabled (MkaUsePresharedIckKek == FALSE).</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01149_KekReady_Stop</srcid><srcstatus/><internalId>2044</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.CryptoSM</linksto>
          <dstversion>3</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1087</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1331</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.CryptoSM.Kek_Ready_2_CakCkn_Ready_Unwrap</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>19075</sourceline>
      <version>1</version>
      <description>Transition from the state MKA_CRYPTO_KEK_READY to the state MKA_CRYPTO_CAKCKN_READY happens during Sak unwrap - Mka_Crypto_SakUnwrapAsync() if any process returns Result != E_OK.
During Sak unwrap  the following operations might fail   Csm_Decrypt, Csm_KeyElementSet, Csm_KeySetValid.
The precondition for this transition is that the use of pre-shared ICK and KEK is disabled (MkaUsePresharedIckKek == FALSE).</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01112_SakUnwrap_StartFail</srcid><srcstatus/><internalId>2007</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.CryptoSM</linksto>
          <dstversion>3</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1087</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1332</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.CryptoSM.Ick_Ready_2_CakCkn_Ready</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>19093</sourceline>
      <version>1</version>
      <description>Transition from the state MKA_CRYPTO_ICK_READY to the state MKA_CRYPTO_CAKCKN_READY happens when Kek generation fails - Mka_Crypto_KekIckGenerateAsync() fails if any process returns Result != E_OK.
During Kek generation the following operations might fail  Csm_KeyElementSet, Csm_KeySetValid, Csm_MacGenerate, Csm_KeyElementGet.
The precondition for this transition is that the use of pre-shared ICK and KEK is disabled (MkaUsePresharedIckKek == FALSE).</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01029_KekIckGen_Sync128_StartFail</srcid><srcstatus/><internalId>1933</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.CryptoSM</linksto>
          <dstversion>3</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1087</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1333</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.CryptoSM.Ick_Ready_2_CakCkn_Ready_Stop</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>19111</sourceline>
      <version>1</version>
      <description>Transition from the state MKA_CRYPTO_ICK_READY to the state MKA_CRYPTO_CAKCKN_READY happens when connection is stopped with Mka_Crypto_Stop().
The precondition for this transition is that the use of pre-shared ICK and KEK is disabled (MkaUsePresharedIckKek == FALSE).</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01148_IckReady_Stop</srcid><srcstatus/><internalId>2043</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.CryptoSM</linksto>
          <dstversion>3</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1087</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1334</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.CryptoSM.Ick_ready_2_Kek_Ready</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>19128</sourceline>
      <version>1</version>
      <description>Transition from the state MKA_CRYPTO_ICK_READY to the state MKA_CRYPTO_KEK_READY happens during Kek generation - Mka_Crypto_KekGenerateAsync().</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01010_KekIckGen_Async128</srcid><srcstatus/><internalId>1914</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.CryptoSM</linksto>
          <dstversion>3</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1087</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1335</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.CryptoSM.ValidateKeys_Idle</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>19144</sourceline>
      <version>1</version>
      <description>Transition from the state VALIDATE_KEYS to the state IDLE happens when validation of keys fails or Csm returns E_BUSY for more then MkaCryptoRetryAttempts times.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01171_ValidateCakCkn_RetryFail</srcid><srcstatus/><internalId>2066</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.CryptoSM</linksto>
          <dstversion>3</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1087</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1336</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.CryptoSM.Kek_Ready_2_Sak_Ready_Wrap</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>19160</sourceline>
      <version>1</version>
      <description>Transition from the state MKA_CRYPTO_KEK_READY to the state MKA_CRYPTO_SAK_READY happens during Sak generation - Mka_Crypto_SakGenWrapAsync().</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01050_SakGenWrap_Async128</srcid><srcstatus/><internalId>1954</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01051_SakGenWrap_Sync128</srcid><srcstatus/><internalId>1955</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.CryptoSM</linksto>
          <dstversion>3</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1087</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1337</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.CryptoSM.Kek_Ready_2_Sak_Ready_Unwrap</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>19176</sourceline>
      <version>1</version>
      <description>Transition from the state MKA_CRYPTO_KEK_READY to the state MKA_CRYPTO_SAK_READY happens during Sak unwrap- &lt;b&gt;Mka_Crypto_SakUnwrapAsync&lt;/b&gt;().</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01059_SakUnwrap_Async128</srcid><srcstatus/><internalId>1963</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01060_SakUnwrap_Sync128</srcid><srcstatus/><internalId>1964</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.CryptoSM</linksto>
          <dstversion>3</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1087</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1338</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.CryptoSM.SelfTrans.Kek_Ready</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>19192</sourceline>
      <version>1</version>
      <description>Self-transition in the state MKA_CRYPTO_KEK_READY happens when use of pre-shared ICK and KEK is enabled (MkaUsePresharedIckKek == FALSE) 
and the following happens:
- SAK generation and wrap fails or
- SAK unwrap fails or
- Mka_Crypto_Stop is called.</description>
      <verifycrit>1</verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01159_SakWrapUnwrapAsync_Fail_PresharedIckKek</srcid><srcstatus/><internalId>2054</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.CryptoSM</linksto>
          <dstversion>3</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1087</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1339</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.CryptoSM.Sak_Ready_2_Kek_Ready_WrapUnwrapFail</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>19213</sourceline>
      <version>1</version>
      <description>Transition from the state MKA_CRYPTO_SAK_READY  to the state MKA_CRYPTO_KEK_READY happens if SAK wrap / unwrap operation fails and 
use of pre-shared ICK and KEK is enabled (MkaUsePresharedIckKek == TRUE).</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01161_SakWrapAsync_Fail_PresharedIckKek</srcid><srcstatus/><internalId>2056</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01162_SakUnwrap_Fail_PresharedIckKek</srcid><srcstatus/><internalId>2057</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.CryptoSM</linksto>
          <dstversion>3</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1087</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1340</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.CryptoSM.Sak_Ready_2_Kek_Ready_Rekey</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>19230</sourceline>
      <version>1</version>
      <description>Transition from the state MKA_CRYPTO_SAK_READY  to the state MKA_CRYPTO_KEK_READY happens during Sak rekey- Mka_Crypto_SakGenWrapAsync().</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01145_SakRekey</srcid><srcstatus/><internalId>2040</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.CryptoSM</linksto>
          <dstversion>3</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1087</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1341</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.CryptoSM.Sak_Ready_2_Kek_Ready_Stop</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>19246</sourceline>
      <version>1</version>
      <description>Transition from the state MKA_CRYPTO_SAK_READY to the state MKA_CRYPTO_KEK_READY happens when connection is stopped - Mka_Crypto_Stop() and use of pre-shared ICK and KEK is enabled (MkaUsePresharedIckKek == TRUE).</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01160_SakGenWrap_Stop_PresharedIckKek</srcid><srcstatus/><internalId>2055</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.CryptoSM</linksto>
          <dstversion>3</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1087</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1342</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.CryptoSM.ValidateKeys_KekReady</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>19262</sourceline>
      <version>1</version>
      <description>Transition from the state VALIDATE_KEYS to the state KEK_READY happens when ICK and KEK keys are successfully validated, CKN red for the use case when use of pre-shared ICK and KEK is enabled.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01172_ValidateIckKek_Retry</srcid><srcstatus/><internalId>2067</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.CryptoSM</linksto>
          <dstversion>3</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1087</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1343</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.PeerSM.SelfTrans.ValidateKeys</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>19278</sourceline>
      <version>1</version>
      <description>Self transition in the state VALIDATE_KEYS happens during Mka_Crypto_MainFunction() when validation of keys fails, i.e. Crypto_ValidateKeys() returns other then E_OK.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01170_ValidateCakCkn_Retry</srcid><srcstatus/><internalId>2065</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01172_ValidateIckKek_Retry</srcid><srcstatus/><internalId>2067</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.CryptoSM</linksto>
          <dstversion>3</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1087</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1344</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.CryptoSM.Initial_ValidateKeys</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>19294</sourceline>
      <version>1</version>
      <description>Transition from the state Initial to the state VALIDATE_KEYS happens during Crypto unit initialization - Mka_Crypto_Init().</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01045_ValidateCakCkn_Retry</srcid><srcstatus/><internalId>1733</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01170_ValidateCakCkn_Retry</srcid><srcstatus/><internalId>2065</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.CryptoSM</linksto>
          <dstversion>3</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1087</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1345</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.RandomGenSM.GenMoreData_2_Notified</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>19310</sourceline>
      <version>1</version>
      <description>Transition from state RNG_GENERATE_MORE_DATA to state RNG_NOTIFIED happens if Csm_RandomGenerate returns E_NOT_OK, or if the requeste RandomGenerate Length has been reached successfully, or if the MacRetry number has been exhausted.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01008_RandomGen_Async128</srcid><srcstatus/><internalId>1912</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01165_RandomGenGranular_Retry</srcid><srcstatus/><internalId>2060</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.RandomGenSM</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1088</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1346</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.RandomGenSM.GenMoreData_Queue</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>19326</sourceline>
      <version>1</version>
      <description>Self-transition in the state RNG_GENERATE_MORE_DATA occurs if new RandomGenerate operation is requested ( Mka_RandomGenerateAsync() is called) while Crypto unit is still in the process of another RandomGenerate operation. Newly requested op shall be queued. Note: only one op can be queued.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01165_RandomGenGranular_Retry</srcid><srcstatus/><internalId>2060</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.RandomGenSM</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1088</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1347</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.RandomGenSM.GenMoreData</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>19342</sourceline>
      <version>1</version>
      <description>Self-transition in the state RNG_GENERATE_MORE_DATA happens if the requested RandomGenerate Length has not been reached. Crypto unit will keep calling Csm_RandomGenerate to fill the requested Length.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01008_RandomGen_Async128</srcid><srcstatus/><internalId>1912</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01165_RandomGenGranular_Retry</srcid><srcstatus/><internalId>2060</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.RandomGenSM</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1088</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1348</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.RandomGenSM.GenMoreData_Retry</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>19358</sourceline>
      <version>1</version>
      <description>Self-transition in state RNG_GENERATE_MORE_DATA occurs if Csm_RandomGenerate() returns E_BUSY while the retry functionality is enabled (MAX_RETRY != 0) and the number of retries hasn't been exhausted.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01165_RandomGenGranular_Retry</srcid><srcstatus/><internalId>2060</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.RandomGenSM</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1088</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1349</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.RandomGenSM.Busy_2_GenMoreData</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>19374</sourceline>
      <version>1</version>
      <description>Transition from the state RNG_BUSY to the state RNG_GENERATE_MORE_DATA happens when Csm_RandomGenerate returns with E_OK, but the requested generated length is still not fulfilled.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01008_RandomGen_Async128</srcid><srcstatus/><internalId>1912</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.RandomGenSM</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1088</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1350</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.RandomGenSM.Notified</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>19390</sourceline>
      <version>1</version>
      <description>Self-transition of the state RNG_NOTIFIED occurs if another Crypto unit RandomGenerate operation is requested (Mka_RandomGenerateAsync() is called) before the active one has been finished. Newly requested RandGen op will be queued.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01166_SakGenWrap_RandomRequest</srcid><srcstatus/><internalId>2061</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01167_RandomGen_SakWrapRequest</srcid><srcstatus/><internalId>2062</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.RandomGenSM</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1088</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1351</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.RandomGenSM.Notified_2_Busy</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>19406</sourceline>
      <version>1</version>
      <description>Transition from state RNG_NOTIFIED to state RNG_BUSY happens if another RandomGen operation is queued (RNG_RandomGenLen_Queued != 0). Crypto unit will call back the notifcation API and then start with the new RandomGen process from queue.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01164_RandomGen_SelfTransit</srcid><srcstatus/><internalId>2059</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01165_RandomGenGranular_Retry</srcid><srcstatus/><internalId>2060</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01166_SakGenWrap_RandomRequest</srcid><srcstatus/><internalId>2061</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01167_RandomGen_SakWrapRequest</srcid><srcstatus/><internalId>2062</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01168_SakGenWrap_RandomRequestFail</srcid><srcstatus/><internalId>2063</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.RandomGenSM</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1088</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1352</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.RandomGenSM.Notified_2_Idle</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>19422</sourceline>
      <version>1</version>
      <description>Transition from state RNG_NOTIFIED to RNG_IDLE occurs after the Crypto unit RandomGenerate operation has been completed  and if there is no RandomGenerate queued operation. Crypto unit will call the notification API and return to RNG_IDLE.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01008_RandomGen_Async128</srcid><srcstatus/><internalId>1912</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01168_SakGenWrap_RandomRequestFail</srcid><srcstatus/><internalId>2063</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.RandomGenSM</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1088</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1353</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.RandomGenSM.Busy_2_Notified</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>19438</sourceline>
      <version>1</version>
      <description>Transition from the state RNG_BUSY to the state RNG_NOTIFIED happens when Random generation operation is finished and the Result is E_OK.
For synchronous operation Csm_RandomGenerate shall return Result == E_OK, for asynchronous operation Mka_CsmRandomCallback shall be called with Result == E_OK.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01020_RandomGen_Async128_JobFail</srcid><srcstatus/><internalId>1924</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.RandomGenSM</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1088</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1354</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.RandomGenSM.Initial_Initialization</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>19455</sourceline>
      <version>1</version>
      <description>Transition from the state Initial to the state RNG_IDLE happens during Crypto unit initialization - Mka_Crypto_Init().</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01008_RandomGen_Async128</srcid><srcstatus/><internalId>1912</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.RandomGenSM</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1088</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1355</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.RandomGenSM.Busy_Retry</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>19471</sourceline>
      <version>1</version>
      <description>Self-transition in state RNG_BUSY occurs if Csm_RandomGenerate() returns E_BUSY while the retry functionality is enabled (MAX_RETRY != 0) and the number of retries hasn't been exhausted.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01113_RandomGen_Retry</srcid><srcstatus/><internalId>2008</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.RandomGenSM</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1088</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1356</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.RandomGenSM.Busy_Queue</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>19487</sourceline>
      <version>1</version>
      <description>Self-transition in the state RNG_BUSY happens if Crypto unit receives a call to start another RandomGen operation (Mka_Crypto_RandomGenerateAsync), but is already in the process of another one. Crypto unit will put the newly requested operation in the queue. Note: only one op can be queued.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01164_RandomGen_SelfTransit</srcid><srcstatus/><internalId>2059</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01167_RandomGen_SakWrapRequest</srcid><srcstatus/><internalId>2062</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.RandomGenSM</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1088</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1357</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.RandomGenSM.Idle_2_Busy</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>19503</sourceline>
      <version>1</version>
      <description>Transition from the state RNG_IDLE to the state RNG_BUSY happens when a random number is requested - Mka_Crypto_RandomGenerateAsync().</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01008_RandomGen_Async128</srcid><srcstatus/><internalId>1912</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.RandomGenSM</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1088</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1358</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Logon.ParticipantSM.Init_2_Created</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>19519</sourceline>
      <version>1</version>
      <description>Transition from the state LOGON_PARTICIPANT_SM_INIT to the state LOGON_PARTICIPANT_SM_ACTIVE happens under the following circumstances:
- LinkState is still in state DOWN (LinkState == FALSE) and
- pre-shared ICK is used instead of derived one, i.e. MkaUsePresharedIckKek == TRUE.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01069_Init_2_Created</srcid><srcstatus/><internalId>2257</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.ParticipantSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1099</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1359</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Logon.ParticipantSM.Init_2_GenerateIck_Auto</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>19537</sourceline>
      <version>1</version>
      <description>The transition from state LOGON_PARTICIPANT_SM_INIT to LOGON_PARTICIPANT_SM_GENERATE_ICK happens if the AutoStart is enabled. If Logon couldn't get a PrincipalParticipant from NvM, it shall, for each Enabled (not disabled because of duplicated CKN on the same port) Participant on that Enabled Port (not disabled manually), call Mka_Crypto_IckGenerateAsync(). If Logon get a PrincipalParticipant from NvM, Mka_Crypto_IckGenerateAsync() shall be called only for PrincipalParticipant.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01001_LogonInit</srcid><srcstatus/><internalId>2191</internalId></linkedfrom><linkedfrom><srcid>Mka_Logon_UnitTest01009_LogonReinit_StartPreviouslyPrincipalActor</srcid><srcstatus/><internalId>2199</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.ParticipantSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1099</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1360</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Logon.ParticipantSM.Init_2_GenerateIck_Manual</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>19553</sourceline>
      <version>1</version>
      <description>The transition from state LOGON_PARTICIPANT_SM_INIT to LOGON_PARTICIPANT_SM_GENERATE_ICK happens if the AutoStart is disabled, but Mka_Logon_StartPae() was called for a Participant that is Enabled (not disabled because of duplicated CKN on the same port) and Port that is Enabled (not disabled manually). Mka_Crypto_IckGenerateAsync will be called.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01025_ManualPaeStart</srcid><srcstatus/><internalId>2215</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.ParticipantSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1099</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1361</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Logon.ParticipantSM.Init_2_Active</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>19569</sourceline>
      <version>1</version>
      <description>Transition from the state LOGON_PARTICIPANT_SM_INIT to the state LOGON_PARTICIPANT_SM_ACTIVE happens under the following circumstances:
- LinkState is already Active (LinkState == TRUE) and
- pre-shared ICK is used instead of derived one, i.e. MkaUsePresharedIckKek == TRUE.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01042_PreSharedKeys</srcid><srcstatus/><internalId>1731</internalId></linkedfrom><linkedfrom><srcid>Mka_Logon_UnitTest01070_Init_2_Active</srcid><srcstatus/><internalId>2258</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.ParticipantSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1099</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1362</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Logon.ParticipantSM.LinkStateDown</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>19587</sourceline>
      <version>1</version>
      <description>Transition from any state to LOGON_PARTICIPANT_SM_INIT occurs during the LinkStateChange to Down. The Participants will be deleted and reset, waiting for startup after the LinkStateChange to Active.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01033_PermissiveMode_LinkStateUpAndDown</srcid><srcstatus/><internalId>2223</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.ParticipantSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1099</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1363</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Logon.ParticipantSM.Initialization</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>19603</sourceline>
      <version>1</version>
      <description>Transition to state LOGON_PARTICIPANT_SM_INIT happens after first call of Mka_Logon_MainFunction after the MKA initialization phase. During this transition, if the MKA_NVM_CONFIG is enabled, the NvM state is checked. There is a NvM state machine that describes NvM related processes so it will not be shown here.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01009_LogonReinit_StartPreviouslyPrincipalActor</srcid><srcstatus/><internalId>2199</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.ParticipantSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1099</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1364</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Logon.ParticipantSM.ParticipantDisabled</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>19619</sourceline>
      <version>1</version>
      <description>Transition from any state to LOGON_PARTICIPANT_SM_INIT occurs when Mka_Logon_Participant_Disabled(Participant) is called.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01006_ParticipantDisabled_ParticipantRestarted</srcid><srcstatus/><internalId>2196</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.ParticipantSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1099</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1365</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Logon.ParticipantSM.ParticipantStop</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>19635</sourceline>
      <version>1</version>
      <description>Transition from any state to LOGON_PARTICIPANT_SM_INIT occurs when Logon_Participant_Stop(Participant) is called.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01006_ParticipantDisabled_ParticipantRestarted</srcid><srcstatus/><internalId>2196</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.ParticipantSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1099</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1366</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Logon.ParticipantSM.GenerateIck_2_Init</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>19651</sourceline>
      <version>1</version>
      <description>The transition from state LOGON_PARTICIPANT_SM_GENERATE_ICK to LOGON_PARTICIPANT_SM_INIT occurs if the callback Mka_Logon_IckGenerateFinished returned with negative result (Result == E_NOT_OK) or the call to Mka_Crypto_IckGenerateAsync was unsuccessful and returned E_NOT_OK. The process will be retried in the next tick.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01005_LogonIckGenerateFinished_PrincipalFalse</srcid><srcstatus/><internalId>2195</internalId></linkedfrom><linkedfrom><srcid>Mka_Logon_UnitTest01008_ParticipantsRestart_MainFunction</srcid><srcstatus/><internalId>2198</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.ParticipantSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1099</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1367</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Logon.ParticipantSM.SuccessfulActor_2_Init</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>19667</sourceline>
      <version>1</version>
      <description>Transition from state LOGON_PARTICIPANT_SM_SUCCESSFUL_ACTOR to LOGON_PARTICIPANT_SM_INIT occurs if the call to Mka_KaY_SetPrincipalActor or Mka_Cp_SetCipherSuite fail.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01010_LogonReinit_StartPreviouslyPrincipalActor_Failed</srcid><srcstatus/><internalId>2200</internalId></linkedfrom><linkedfrom><srcid>Mka_Logon_UnitTest01041_SetPrincipalActor_ENotOk</srcid><srcstatus/><internalId>2231</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.ParticipantSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1099</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1368</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Logon.ParticipantSM.Active_2_SuccessfulActor</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>19683</sourceline>
      <version>1</version>
      <description>The transition from state LOGON_PARTICIPANT_SM_ACTIVE to LOGON_PARTICIPANT_SM_SUCCESSFUL_ACTOR happens after the Logon gets call Mka_Logon_Participant_SuccessfulActor for a Participant that is Principal.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01003_ParticipantSuccsessfulActor_DisableNonPrincipalParticipantsOn</srcid><srcstatus/><internalId>2193</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.ParticipantSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1099</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1369</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Logon.ParticipantSM.Active_2_Disabled</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>19699</sourceline>
      <version>1</version>
      <description>The transition from state LOGON_PARTICIPANT_SM_ACTIVE to LOGON_PARTICIPANT_SM_DISABLED occurs if, when the MKA_DISABLE_NON_PRINCIPAL_PARTICIPANTS is STD_ON, the call Mka_Logon_Participant_SuccessfulActor() is received for another Participant that is Principal. Other Participants that are on this port will be disabled, Mka_KaY_DeleteInstance() and Mka_Crypto_Stop() will be called. </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01003_ParticipantSuccsessfulActor_DisableNonPrincipalParticipantsOn</srcid><srcstatus/><internalId>2193</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.ParticipantSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1099</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1370</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Logon.ParticipantSM.GenerateIck_2_Active</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>19715</sourceline>
      <version>1</version>
      <description>The transition from state LOGON_PARTICIPANT_SM_GENERATE_ICK to LOGON_PARTICIPANT_SM_ACTIVE occurs after the callback Mka_Logon_IckGenerateFinished is received with Result == E_OK, while the LinkState is already Active. Mka_KaY_CreateParticipant will be called to notify KaY unit that Ick is ready.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01003_ParticipantSuccsessfulActor_DisableNonPrincipalParticipantsOn</srcid><srcstatus/><internalId>2193</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.ParticipantSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1099</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1371</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Logon.ParticipantSM.Created_2_Active</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>19731</sourceline>
      <version>1</version>
      <description>The transition from state LOGON_PARTICIPANT_SM_CREATED to LOGON_PARTICIPANT_SM_ACTIVE happens when the signal LinkState becomes Active.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01040_Created_2_Active</srcid><srcstatus/><internalId>2230</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.ParticipantSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1099</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1372</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Logon.ParticipantSM.Any_2_Disabled</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>19747</sourceline>
      <version>1</version>
      <description>The transition from any state to LOGON_PARTICIPANT_SM_DISABLED occurs if the PermissiveMode is enabled and the Mka_Logon_TimerCallback_PermissiveMode() is called while MacSecOperational is False.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01032_PermissiveMode_TimerExpires</srcid><srcstatus/><internalId>2222</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.ParticipantSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1099</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1373</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Logon.ParticipantSM.GenerateIck_2_Created</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>19763</sourceline>
      <version>1</version>
      <description>The transition from state LOGON_PARTICIPANT_SM_GENERATE_ICK to LOGON_PARTICIPANT_SM_CREATED occurs when callback Mka_Logon_IckGenerateFinished() is received with Result == E_OK, while the LinkState is Down. Mka_KaY_CreateParticipant will be called to notify KaY unit that the Ick is ready.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01040_Created_2_Active</srcid><srcstatus/><internalId>2230</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.ParticipantSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1099</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1374</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Cp.CpSM.Secured_2_WaitAddRxSa</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>19779</sourceline>
      <version>1</version>
      <description>Transition from CP_SECURED to state CP_WAIT_ADD_RX_SA happens when new SAK becomes available (NewSak == TRUE), as a result of Mka_Cp_NewSak() call.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Cp_UnitTest01002_CpSM_Secured2WaitAddTxSa</srcid><srcstatus/><internalId>1814</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01003_CpSM_Receiving2Transmitting</srcid><srcstatus/><internalId>1815</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1097</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1375</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Cp.CpSM.Secured_2_UpdateSecY</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>19795</sourceline>
      <version>1</version>
      <description>Transition from CP_SECURED to CP_UPDATE_SECY state happens if the CipherSuite change has occurred (Mka_Cp_SetCipherSuite() API has been called). EthIf_MacSecUpdateSecY() shall be called to provide new info to SecY.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01040_ChangeCipher</srcid><srcstatus/><internalId>1729</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01095_CpSM_Secured2UpdateSecY</srcid><srcstatus/><internalId>1904</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1097</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1376</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Cp.CpSM.InitRxSc_2_Secured</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>19811</sourceline>
      <version>1</version>
      <description>Transition from CP_INIT_RX_SC to CP_SECURED occurs after a call to EthIf_MacSecInitRxSc() is successfully performed.
If API returns E_NOT_OK, the call is retried in the the next main function call until the maximum number of retries have been reached.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Cp_UnitTest01002_CpSM_Secured2WaitAddTxSa</srcid><srcstatus/><internalId>1814</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1097</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1377</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Cp.CpSM.Transmitting_2_Retire</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>19828</sourceline>
      <version>1</version>
      <description>Transition from state CP_TRANSMITTING to CP_RETIRE happens if the timer RetireWhen has encountered a timeout. Old SAs shall be deleted and afterwards replaced with the Latest ones. </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Cp_UnitTest01004_CpSM_Ready2Retire</srcid><srcstatus/><internalId>1816</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01005_CpSM_Receiving2Retire</srcid><srcstatus/><internalId>1817</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01006_CpSM_Ready2Retire_2ndLoop</srcid><srcstatus/><internalId>1818</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01007_CpSM_Receiving2Retire_2ndLoop</srcid><srcstatus/><internalId>1819</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01009_CpSM_Receiving2Transmitting</srcid><srcstatus/><internalId>1821</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1097</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1378</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Cp.CpSM.Receiving_2_Transmitting</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>19844</sourceline>
      <version>1</version>
      <description>Transition from state CP_RECEIVING to CP_TRANSMITTING happens if the actor is Key Server (ElectedSelf is True) while either peer is receiving with a new key (AllReceiving == True), ControlledPortEnabled is False or TransmitWhen timer ticks out | becomes 0. Actor shall start transmitting with a new SAKs after this transition.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Cp_UnitTest01005_CpSM_Receiving2Retire</srcid><srcstatus/><internalId>1817</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01007_CpSM_Receiving2Retire_2ndLoop</srcid><srcstatus/><internalId>1819</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01009_CpSM_Receiving2Transmitting</srcid><srcstatus/><internalId>1821</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1097</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1379</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Cp.CpSM.Receiving_2_Transmitting2</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>19860</sourceline>
      <version>1</version>
      <description>Transition from state CP_RECEIVING to CP_TRANSMITTING happens for the peer (ElectedSelf == FALSE) while server is already transmitting with a new key (ServerTransmitting == TRUE) or control port is disabled (ControlledPortEnabled == FALSE).</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Cp_UnitTest01003_CpSM_Receiving2Transmitting</srcid><srcstatus/><internalId>1815</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1097</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1380</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Cp.CpSM.Ready_2_Transmitting</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>19876</sourceline>
      <version>2</version>
      <description>Transition from state CP_READY to CP_TRANSMITTING happens when the peer (ElectedSelf == FALSE), receives notification that key server is transmitting with the new key, i.e. Mka_Cp_ServerTransmitting() is called.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Cp_UnitTest01006_CpSM_Ready2Retire_2ndLoop</srcid><srcstatus/><internalId>1818</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1097</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1381</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Cp.CpSM.WaitRxSc_2_InitRxSc</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>19892</sourceline>
      <version>1</version>
      <description>Transition from CP_WAIT_RX_SC to CP_WAIT_INIT_SC state occurs after a live peer is available and it's SCI is provided to CP unit by a call to Mka_Cp_InitRxSc().</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Cp_UnitTest01002_CpSM_Secured2WaitAddTxSa</srcid><srcstatus/><internalId>1814</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1097</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1382</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Cp.CpSM.WaitRxSc_2_UpdateSecY</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>19908</sourceline>
      <version>1</version>
      <description>Transition from CP_WAIT_RX_SC to CP_UPDATE_SECY state happens if the CipherSuite change has occurred (Mka_Cp_SetCipherSuite() API has been called). EthIf_MacSecUpdateSecY() shall be called to provide new info to SecY.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Cp_UnitTest01001_CpSM_Uninit2Secured</srcid><srcstatus/><internalId>1813</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1097</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1383</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Cp.CpSM.UpdateSecY_2_WaitRxSc</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>19924</sourceline>
      <version>1</version>
      <description>Transition from CP_UPDATE_SECY to CP_WAIT_RX_SC state occurs after a callback API Mka_MacSecUpdateSecYNotification() has been called.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Cp_UnitTest01001_CpSM_Uninit2Secured</srcid><srcstatus/><internalId>1813</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1097</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1384</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Cp.CpSM.Any_2_WaitRxSc</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>19940</sourceline>
      <version>1</version>
      <description>Transition from ANY state (accept CP_UNSECURED and CP_WAIT_RX_SC), to the state CP_WAIT_RX_SC occurs when Mka_Cp_LinkStateDown() is called. 

In this case active timers shall be canceled (TRANSMIT_WHEN and RETIRE_WHEN).

After that CP_DELETE state shall be used to notify EthIf that MacSec is not operational with EthIf_MacSecOperational(False) and controlled port disabled with EthIf_MacSecSetControlledPortEnabled(False).

The same state shall be used to delete all created SecY objects (receive security channel, Latest and Old Tx and Rx security associations). </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Cp_UnitTest01019_CpSM_Uninit2WaitRxSc_PortEnabled</srcid><srcstatus/><internalId>1831</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01020_CpSM_WaitRxSc2WaitRxSc_PortEnabled</srcid><srcstatus/><internalId>1832</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01021_CpSM_WaitAddRxSa2WaitRxSc_PortEnabled</srcid><srcstatus/><internalId>1833</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01022_CpSM_UpdateSecY2WaitRxSc_LinkStateDown</srcid><srcstatus/><internalId>1834</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01023_CpSM_WaitAddTxSa2WaitRxSc_PortEnabled</srcid><srcstatus/><internalId>1835</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01024_CpSM_Transmitting2WaitRxSc_PortEnabled</srcid><srcstatus/><internalId>1836</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01025_CpSM_Retire2WaitRxSc_PortEnabled</srcid><srcstatus/><internalId>1837</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01026_CpSM_Ready2WaitRxSc_PortEnabled</srcid><srcstatus/><internalId>1838</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01080_CpSM_Secured2WaitRxSc_LinkStateDown</srcid><srcstatus/><internalId>1889</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01081_CpSM_InitRxSc2WaitRxSc_LinkStateDown</srcid><srcstatus/><internalId>1890</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1097</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1385</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Cp.CpSM.Uninit_2_UpdateSecY</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>19962</sourceline>
      <version>1</version>
      <description>Transition from state CP_UNINIT to CP_UPDATE_SECY happens after API Mka_Cp_SetCipherSuite() has been called. This API contains the needed parameters to call EthIf_MacSecUpdateSecY(), such as CipherSuite and similar.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Cp_UnitTest01001_CpSM_Uninit2Secured</srcid><srcstatus/><internalId>1813</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1097</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1386</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Cp.CpSM.Uninit</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>19978</sourceline>
      <version>1</version>
      <description>Transition to state CP_UNINIT happens during CP unit initialization phase.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Cp_UnitTest01001_CpSM_Uninit2Secured</srcid><srcstatus/><internalId>1813</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1097</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1387</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Cp.CpSM.Restart_2_Uninit</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>19994</sourceline>
      <version>1</version>
      <description>Transition from state CP_RESTART  to CP_UNINIT occurs within the first main function tick.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Cp_UnitTest01066_SecYRetry_Fail_CpSmRetire_Step0</srcid><srcstatus/><internalId>1875</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1097</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1388</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Cp.CpSM.WaitAddTxSa_2_Receiving</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>20010</sourceline>
      <version>1</version>
      <description>Transition from state CP_WAIT_ADD_TX_SA to CP_RECEIVING happens when Mka_Cp_MacSecAddTxSaNotification() callback is made. </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Cp_UnitTest01003_CpSM_Receiving2Transmitting</srcid><srcstatus/><internalId>1815</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1097</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1389</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Cp.CpSM.WaitAddRxSa_2_WaitAddTxSa</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>20026</sourceline>
      <version>1</version>
      <description>Transition from state CP_WAIT_ADD_RX_SA to CP_WAIT_ADD_TX_SA happens when Mka_Cp_MacSecAddRxSaNotification() callback is made. </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Cp_UnitTest01002_CpSM_Secured2WaitAddTxSa</srcid><srcstatus/><internalId>1814</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01003_CpSM_Receiving2Transmitting</srcid><srcstatus/><internalId>1815</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1097</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1390</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Cp.CpSM.Receiving_2_Ready</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>20042</sourceline>
      <version>1</version>
      <description>Transition from CP_RECEIVING to CP_READY occurs if the actor is not the Key Server (ElectedSelf == FALSE), server is not yet transmitting with a new key (ServerTransmitting == FALSE) and controlled port was enabled (ControlledPortEnabled == TRUE).
</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Cp_UnitTest01006_CpSM_Ready2Retire_2ndLoop</srcid><srcstatus/><internalId>1818</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1097</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1391</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Cp.CpSM.Receiving_2_WaitAddRxSa</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>20059</sourceline>
      <version>1</version>
      <description>Transition from state CP_RECEIVING to CP_WAIT_ADD_RX_SA happens when there is a new SAK. Latest key Tx and Rx SA shall be deleted using CP_DELETE state before transition to CP_WAIT_ADD_RX_SA.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Cp_UnitTest01010_CpSM_Receiving2WaitAddRxSa</srcid><srcstatus/><internalId>1822</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1097</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1392</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Cp.CpSM.Delete_2_Restart</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>20075</sourceline>
      <version>1</version>
      <description>Transition from state CP_DELETE to CP_RESTART occurs when Delete operation fails (SecY function calls fail with E_NOT_OK too many times, exceeding MkaSecYRetryAttempts) or when the next transition shall be to the CP_UNINIT state.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Cp_UnitTest01066_SecYRetry_Fail_CpSmRetire_Step0</srcid><srcstatus/><internalId>1875</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1097</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1393</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Cp.CpSM.Unsecured</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>20091</sourceline>
      <version>1</version>
      <description>Transition to CP_UNSECURED from ANY other state occurs if the Mka_Cp_DisableMacSec() has been called (Connect != Secure). All created SecY objects shall be deleted (receive security channel, Latest and Old Tx and Rx security associations, by using CP_DELETE state. Additionally active timers shall be canceled (TRANSMIT_WHEN and RETIRE_WHEN).

As a result of this change MACsec shall be disabled and consequently traffic will flow without protection.</description>
      <verifycrit>Verify transition to CP_UNSECURED state from all other states: CP_UNINIT, CP_UPDATE_SECY, CP_WAIT_RX_SC, CP_INIT_RX_SC, CP_SECURED, CP_WAIT_ADD_RX_SA, CP_WAIT_ADD_TX_SA, CP_RECEIVING, CP_READY, CP_TRANSMITTING, CP_RETIRE.</verifycrit>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.dsn.Cp.CpSM.Unsecured.Testing</srcid><srcstatus/><internalId>1481</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1097</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1394</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Cp.CpSM.InitRxSc_2_UpdateSecY</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>20110</sourceline>
      <version>1</version>
      <description>Transition from CP_INIT_RX_SC to CP_UPDATE_SECY state happens if the CipherSuite change has occurred (Mka_Cp_SetCipherSuite() API has been called). EthIf_MacSecUpdateSecY() shall be called to provide new info to SecY.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Cp_UnitTest01094_CpSM_InitRxSc2UpdateSecY</srcid><srcstatus/><internalId>1903</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1097</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1395</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Cp.CpSM.Ready_2_WaitAddRxSa</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>20126</sourceline>
      <version>1</version>
      <description>Transition from state CP_READY to CP_WAIT_ADD_RX_SA occurs when there is a new SAK. Latest key Tx and Rx SA shall be deleted using CP_DELETE state transition before transition to CP_WAIT_ADD_RX_SA.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Cp_UnitTest01008_CpSM_Ready2WaitAddRxSa</srcid><srcstatus/><internalId>1820</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1097</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1396</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Cp.CpSM.Retire_2_WaitAddRxSa</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>20142</sourceline>
      <version>1</version>
      <description>Transition from state CP_RETIRE to CP_WAIT_ADD_RX_SA occurs happens when new SAK becomes available (NewSak == TRUE), as a result of Mka_Cp_NewSak() call.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Cp_UnitTest01004_CpSM_Ready2Retire</srcid><srcstatus/><internalId>1816</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01005_CpSM_Receiving2Retire</srcid><srcstatus/><internalId>1817</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1097</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1397</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Logon.NvmSM.Unknown_2_Valid_NOT_OK</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>20158</sourceline>
      <version>1</version>
      <description>Transition from the state LOGON_SM_NVM_UNKNOWN  to the state  LOGON_SM_NVM_VALID
happens during Mka_Logon_Init() if (Logon_Nvm_GetStatus() == E_NOT_OK) meaning that we do not have an already existing
valid data in non volatile memory block.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01019_NvmGetStatus_NvmReqNotOk</srcid><srcstatus/><internalId>2209</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1398</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Logon.NvmSM.Unknown_2_Valid_OK</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>20170</sourceline>
      <version>1</version>
      <description>Transition from the state LOGON_SM_NVM_UNKNOWN  to the state  LOGON_SM_NVM_VALID
happens during Mka_Logon_Init() if (Logon_Nvm_GetStatus() == E_OK) meaning that we already have 
valid data in non volatile memory block.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01017_NvmGetStatus_ValidMemoryBlock</srcid><srcstatus/><internalId>2207</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1399</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Logon.NvmSM.Init</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>20182</sourceline>
      <version>1</version>
      <description>State LOGON_SM_NVM_UNKNOWN is the starting state of NvM state machine.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01001_LogonInit</srcid><srcstatus/><internalId>2191</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1400</internalId></specobject>
    <specobject>
      <id>Mka.dsn.RxTx.RxSM.WaitIcvVer_2_RxBufFree_OK</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>20192</sourceline>
      <version>2</version>
      <description>Transition from the state RXTX_RX_WAIT_ICV_VERIFY_FINISHED to the state RXTX_RX_BUFFER_FREE happens when Cypto calls Mka_RxTx_IcvVerifyFinished() with Result == E_OK, to indicate that ICV verification was successful. KaY is notified about new verified MKPDU by calling Mka_KaY_RxMkpdu().</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_RxTx_UnitTest01004_Initial_2_RxBufFree_2_WaitIcvVerFin_2_RxBufFree</srcid><srcstatus/><internalId>2318</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.RxTx.RxSM</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1086</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1401</internalId></specobject>
    <specobject>
      <id>Mka.dsn.RxTx.RxSM.WaitIcvVer_2_RxBufFree_NOT_OK</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>20208</sourceline>
      <version>2</version>
      <description>Transition from the state RXTX_RX_WAIT_ICV_VERIFY_FINISHED to the state RXTX_RX_BUFFER_FREE happens when Cypto calls Mka_RxTx_IcvVerifyFinished() with Result == E_NOT_OK, indicating that ICV verification failed. MKPDU is simply dropped.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_RxTx_UnitTest01004_Initial_2_RxBufFree_2_WaitIcvVerFin_2_RxBufFree</srcid><srcstatus/><internalId>2318</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.RxTx.RxSM</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1086</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1402</internalId></specobject>
    <specobject>
      <id>Mka.dsn.RxTx.RxSM.RxBufFree_2_WaitIcvVer</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>20224</sourceline>
      <version>2</version>
      <description>Transition from the state RXTX_RX_BUFFER_FREE  to the state  RXTX_RX_WAIT_ICV_VERIFY_FINISHED 
happens during Mka_RxTx_RxIndication() processing when buffer is successfully allocated.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_RxTx_UnitTest01004_Initial_2_RxBufFree_2_WaitIcvVerFin_2_RxBufFree</srcid><srcstatus/><internalId>2318</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.RxTx.RxSM</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1086</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1403</internalId></specobject>
    <specobject>
      <id>Mka.dsn.RxTx.RxSM.Initial_2_RxBufFree</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>20241</sourceline>
      <version>2</version>
      <description>Transition from the state Initial to the state RXTX_RX_BUFFER_FREE happens during RxTx unit initialization - Mka_RxTx_Init().</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_RxTx_UnitTest01004_Initial_2_RxBufFree_2_WaitIcvVerFin_2_RxBufFree</srcid><srcstatus/><internalId>2318</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.RxTx.RxSM</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1086</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1404</internalId></specobject>
    <specobject>
      <id>Mka.dsn.RxTx.TxSM.TxBufAllocLocked_2_TxBufAllocUnlocked</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>20257</sourceline>
      <version>1</version>
      <description>Transition from the state RXTX_TX_BUFFER_ALLOCATED_LOCKED to the state RXTX_TX_BUFFER_ALLOCATED_UNLOCKED happens when Mka_RxTx_ReleaseTxBuffer() is called in order to release the buffer rather then transmit it.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_RxTx_UnitTest01026_BufAllocLocked_2_BufAllocUnlocked</srcid><srcstatus/><internalId>2339</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.RxTx.TxSM</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1085</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1405</internalId></specobject>
    <specobject>
      <id>Mka.dsn.RxTx.TxSM.TxBufAllocLocked_2_WaitIcvGenFin</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>20273</sourceline>
      <version>2</version>
      <description>Transition from the state RXTX_TX_BUFFER_ALLOCATED_LOCKED to the state RXTX_WAIT_ICV_GENERATE_FINISHED happens when Mka_RxTx_TxBufferReady() is called indicating that the buffer if filled and it is ready for ICV generation and subsequent transmission. 
Mka_Crypto_IcvGenerateAsync() is called to start ICV generation.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_RxTx_UnitTest01002_BufAlloc_2_WaitIcvGenFin_2_BufUnalloc</srcid><srcstatus/><internalId>2316</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.RxTx.TxSM</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1085</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1406</internalId></specobject>
    <specobject>
      <id>Mka.dsn.RxTx.TxSM.TxBufUnalloc_2_TxBufAllocLocked</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>20290</sourceline>
      <version>2</version>
      <description>Transition from the state RXTX_TX_BUFFER_UNALLOCATED to the state RXTX_TX_BUFFER_ALLOCATED_LOCKED happens when user requests buffer allocation by calling Mka_RxTx_GetTxBuffer() and buffer is successfully allocated from EthIf by calling EthIf_ProvideTxBuffer().

If buffer allocation was not successful, the state remains RXTX_TX_BUFFER_UNALLOCATED. </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_RxTx_UnitTest01001_Initial_2_BufUnalloc_2_BufAlloc</srcid><srcstatus/><internalId>2315</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.RxTx.TxSM</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1085</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1407</internalId></specobject>
    <specobject>
      <id>Mka.dsn.RxTx.TxSM.TxBufAllocUnlocked_2_TxBufAllocLocked</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>20308</sourceline>
      <version>2</version>
      <description>Transition from the state RXTX_TX_BUFFER_ALLOCATED_UNLOCKED to the state RXTX_TX_BUFFER_ALLOCATED_LOCKED happens when user requests buffer allocation by calling Mka_RxTx_GetTxBuffer() and the buffer is already allocated and ready for use.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_RxTx_UnitTest01003_BufAlloc_2_WaitIcvGenFin_2_BufAlloc</srcid><srcstatus/><internalId>2317</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.RxTx.TxSM</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1085</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1408</internalId></specobject>
    <specobject>
      <id>Mka.dsn.RxTx.TxSM.WaitIcvGenFin_2_TxBufUnalloc</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>20324</sourceline>
      <version>2</version>
      <description>Transition from the state RXTX_WAIT_ICV_GENERATE_FINISHED to the state RXTX_TX_BUFFER_UNALLOCATED happens when Crypto unit calls Mka_RxTx_IcvGenerateFinished() to indicate successful generation of ICV, i.e. Result == E_OK.

During this transition the complete MKPDU, including ICV field is forwarded to EthIf by calling EthIf_Transmit().</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_RxTx_UnitTest01002_BufAlloc_2_WaitIcvGenFin_2_BufUnalloc</srcid><srcstatus/><internalId>2316</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.RxTx.TxSM</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1085</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1409</internalId></specobject>
    <specobject>
      <id>Mka.dsn.RxTx.TxSM.Initial_2_TxBufUnalloc</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>20342</sourceline>
      <version>2</version>
      <description>Transition from the state Inital to the state RXTX_TX_BUFFER_UNALLOCATED happens during RxTx unit initialization - Mka_RxTx_Init().</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_RxTx_UnitTest01001_Initial_2_BufUnalloc_2_BufAlloc</srcid><srcstatus/><internalId>2315</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.RxTx.TxSM</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1085</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1410</internalId></specobject>
    <specobject>
      <id>Mka.dsn.RxTx.TxSM.WaitIcvGenFin_2_TxBufAllocUnlocked</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>20358</sourceline>
      <version>2</version>
      <description>Transition from the state RXTX_WAIT_ICV_GENERATE_FINISHED to the state RXTX_TX_BUFFER_ALLOCATED_UNLOCKED happens when Crypto unit calls Mka_RxTx_IcvGenerateFinished() to indicate that generation of ICV failed, i.e. Result == E_NOT_OK.

Since buffer allocated from EthIf can be released only during frame transmission, the allocated buffer remains allocated for the subsequent MKPDU transmission on this Mka instance.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_RxTx_UnitTest01003_BufAlloc_2_WaitIcvGenFin_2_BufAlloc</srcid><srcstatus/><internalId>2317</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.RxTx.TxSM</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1085</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1411</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.KeySM.DelayNewSak_2_WaitNewSakReq</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>20376</sourceline>
      <version>1</version>
      <description>Transition from the state KAY_KEYSM_DELAY_NEW_SAK to the state KAY_KEYSM_WAIT_NEW_SAK_REQ happens 
when Mka_KaY_TimerCallback_NewSakDelay() is called, indicating that NEW_SAK_DELAY timer has expired, i.e. new SAK can be installed / distributed.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01042_KeySm_Disabled2GenerateNewSak</srcid><srcstatus/><internalId>2110</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01115_KeySm_Disabled2GenerateNewSak_PresharedKek</srcid><srcstatus/><internalId>2183</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.KeySM</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1096</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1412</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.KeySM.SelfTrans.DelayNewSak</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>20393</sourceline>
      <version>1</version>
      <description>Self-transition in the state KAY_KEYSM_DELAY_NEW_SAK happens after a trigger KaY_KeySM_AllReceiving() indicating that partner is receiving with a new SAK.
Consequently distribution of a new SAK is stopped (DistributeSAK = FALSE).</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01046_KeySm_SelfTransit_DelayNewSak_WaitNewSakReq</srcid><srcstatus/><internalId>2114</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.KeySM</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1096</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1413</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.KeySM.GenerateNewSak_2_DelayNewSak</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>20410</sourceline>
      <version>1</version>
      <description>Transition from the state KAY_KEYSM_GENERATE_NEW_SAK to the state KAY_KEYSM_DELAY_NEW_SAK happens 
when Crypto calls Mka_KaY_SakGenWrapFinished() with Result == E_OK.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01042_KeySm_Disabled2GenerateNewSak</srcid><srcstatus/><internalId>2110</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01115_KeySm_Disabled2GenerateNewSak_PresharedKek</srcid><srcstatus/><internalId>2183</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.KeySM</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1096</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1414</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.KeySM.Initial_2_Disabled</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>20427</sourceline>
      <version>1</version>
      <description>Transition from the state Initial to the state KAY_KEYSM_DISABLED happens during KaY unit initialization - Mka_KaY_Init().</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01042_KeySm_Disabled2GenerateNewSak</srcid><srcstatus/><internalId>2110</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01043_KeySm_Disabled2WaitSakDistribution</srcid><srcstatus/><internalId>2111</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.KeySM</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1096</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1415</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.KeySM.ANY_2_Disabled</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>20443</sourceline>
      <version>2</version>
      <description>Call of KaY_KeySM_Init() triggers transition to the state KAY_KEYSM_DISABLED from any state (other then Initial or KAY_KEYSM_DISABLED).</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01048_KeySm_GenerateNewSak2Disabled</srcid><srcstatus/><internalId>2116</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01049_KeySm_DelayNewSak2Disabled</srcid><srcstatus/><internalId>2117</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01050_KeySm_WaitNewSakReq2Disabled</srcid><srcstatus/><internalId>2118</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01051_KeySm_WaitSakDistribution2Disabled</srcid><srcstatus/><internalId>2119</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01052_KeySm_WaitSakUnwrap2Disabled</srcid><srcstatus/><internalId>2120</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.KeySM</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1096</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1416</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.KeySM.WaitSakDistribution_2_WaitSakUnwrap</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>20459</sourceline>
      <version>1</version>
      <description>Transition from the state KAY_KEYSM_WAIT_SAK_DISTIRBUTION to the state KAY_KEYSM_WAIT_SAK_UNWRAP happens 
when Distributed SAK parameter set has been received with a new key.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01043_KeySm_Disabled2WaitSakDistribution</srcid><srcstatus/><internalId>2111</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01116_KeySm_Disabled2WaitSakDistribution_PresharedKek</srcid><srcstatus/><internalId>2184</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.KeySM</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1096</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1417</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.KeySM.GenerateKek_2_WaitSakDistribution</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>20476</sourceline>
      <version>1</version>
      <description>Transition from the state KAY_KEYSM_GENERATE_KEK to the state KAY_KEYSM_WAIT_SAK_DISTRIBUTION happens 
when a principal actor has elected partner as a key server and Distributed SAK parameter set has not been received yet.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01043_KeySm_Disabled2WaitSakDistribution</srcid><srcstatus/><internalId>2111</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.KeySM</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1096</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1418</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.KeySM.Disabled_2_WaitSakDistribution</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>20493</sourceline>
      <version>1</version>
      <description>Transition from the state KAY_KEYSM_DISABLED to the state WAIT_SAK_DISTRIBUTION happens under the following circumstances:
- Partner is NOT elected as a key server and
- Logon has chosen this participant as a principal actor, i.e. Mka_KaY_SetPrincipalActor() is called and
- pre-shared KEK is used instead of derived one, i.e. MkaUsePresharedIckKek == TRUE.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01116_KeySm_Disabled2WaitSakDistribution_PresharedKek</srcid><srcstatus/><internalId>2184</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.KeySM</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1096</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1419</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.KeySM.WaitSakUnwrap_2_WaitSakDistribution_CryptoOk</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>20512</sourceline>
      <version>1</version>
      <description>Transition from the state KAY_KEYSM_WAIT_SAK_UNWRAP to the state KAY_KEYSM_WAIT_SAK_DISTIRBUTION happens 
when  Crypto calls Mka_KaY_SakUnwrapFinished() with Result == E_OK, indicating successful key unwrap.  </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01043_KeySm_Disabled2WaitSakDistribution</srcid><srcstatus/><internalId>2111</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01116_KeySm_Disabled2WaitSakDistribution_PresharedKek</srcid><srcstatus/><internalId>2184</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.KeySM</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1096</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1420</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.KeySM.WaitSakUnwrap_2_WaitSakDistribution_CryptoNotOk</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>20529</sourceline>
      <version>1</version>
      <description>Transition from the state KAY_KEYSM_WAIT_SAK_UNWRAP to the state KAY_KEYSM_WAIT_SAK_DISTIRBUTION happens 
when:
1) Call of Mka_Crypto_SakUnwrapAsync() returned E_NOT_OK
2) Crypto calls Mka_KaY_SakUnwrapFinished() with Result == E_NOT_OK.
In both cases, Logon unit is informed about disabled MKA instance by calling Mka_Logon_InstanceStateChange(DISABLED);</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01044_KeySm_Disabled2WaitSakUnwrap</srcid><srcstatus/><internalId>2112</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01054_SakUnwrap_CC</srcid><srcstatus/><internalId>2122</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.KeySM</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1096</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1421</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.KeySM.SelfTrans.GenerateKek</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>20549</sourceline>
      <version>1</version>
      <description>Self-transition in the state KAY_KEYSM_GENERATE_KEK happens when: 
1) Call of Mka_Crypto_KekGenerateAsync() returned E_NOT_OK.
2) Crypto calls Mka_KaY_KekGenerateFinished() with Result == E_NOT_OK. 
In both cases, Logon unit is informed about disabled MKA instance by calling Mka_Logon_InstanceStateChange(DISABLED);</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01097_KeySm_SelfTransit_GenerateKek</srcid><srcstatus/><internalId>2165</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.KeySM</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1096</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1422</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.KeySM.GenerateKek_2_GenerateNewSak</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>20568</sourceline>
      <version>1</version>
      <description>Transition from the state KAY_KEYSM_GENERATE_KEK to the state KAY_KEYSM_GENERATE_NEW_SAK happens when KEK is successfully generated for a partner elected as key server.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01042_KeySm_Disabled2GenerateNewSak</srcid><srcstatus/><internalId>2110</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.KeySM</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1096</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1423</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.KeySM.Disabled_2_GenerateKek</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>20584</sourceline>
      <version>2</version>
      <description>Transition from the state KAY_KEYSM_DISABLED to the state KAY_KEYSM_GENERATE_KEK happens when Logon chooses the participant as principal actor (Mka_KaY_SetPrincipalActor() is called) and using pre-shared KEK is disabled (MkaUsePresharedIckKek == FALSE).</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01042_KeySm_Disabled2GenerateNewSak</srcid><srcstatus/><internalId>2110</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01043_KeySm_Disabled2WaitSakDistribution</srcid><srcstatus/><internalId>2111</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01051_KeySm_WaitSakDistribution2Disabled</srcid><srcstatus/><internalId>2119</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01097_KeySm_SelfTransit_GenerateKek</srcid><srcstatus/><internalId>2165</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.KeySM</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1096</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1424</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.KeySM.Disabled_2_GenerateNewSak</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>20600</sourceline>
      <version>1</version>
      <description>Transition from the state KAY_KEYSM_DISABLED to the state GENERATE_NEW_SAK happens under the following circumstances:
- Partner is elected as a key server and
- Logon has chosen this participant as a principal actor, i.e. Mka_KaY_SetPrincipalActor() is called and
- pre-shared KEK is used instead of derived one, i.e. MkaUsePresharedIckKek == TRUE.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01042_PreSharedKeys</srcid><srcstatus/><internalId>1731</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01115_KeySm_Disabled2GenerateNewSak_PresharedKek</srcid><srcstatus/><internalId>2183</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.KeySM</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1096</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1425</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.KeySM.SelfTrans.GenerateNewSak</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>20619</sourceline>
      <version>1</version>
      <description>Self-transition in the state KAY_KEYSM_GENERATE_NEW_SAK happens when 
1) Call of Mka_KaY_SakGenWrap() returned E_NOT_OK.
2) Crypto calls Mka_KaY_SakGenWrapFinished() with Result == E_NOT_OK. 
In both cases, Logon unit is informed about disabled MKA instance by calling Mka_Logon_InstanceStateChange(DISABLED);</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01045_KeySm_SelfTransit_GenerateNewSak</srcid><srcstatus/><internalId>2113</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01053_SakGenWrap_Fail_CC</srcid><srcstatus/><internalId>2121</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.KeySM</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1096</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1426</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.KeySM.WaitNewSakReq_2_GenerateNewSak</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>20638</sourceline>
      <version>1</version>
      <description>Transition from the state KAY_KEYSM_WAIT_NEW_SAK_REQ to the state KAY_KEYSM_GENERATE_NEW_SAK happens 
when trigger KaY_KeySM_GenerateNewSak() is received, indicating that new SAK shall be generated / distributed.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01042_KeySm_Disabled2GenerateNewSak</srcid><srcstatus/><internalId>2110</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01115_KeySm_Disabled2GenerateNewSak_PresharedKek</srcid><srcstatus/><internalId>2183</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.KeySM</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1096</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1427</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.KeySM.SelfTrans.WaitNewSakReq</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>20655</sourceline>
      <version>1</version>
      <description>Self-transition in the state KAY_KEYSM_WAIT_NEW_SAK_REQ happens after a trigger KaY_KeySM_AllReceiving() indicating that partner is receiving with a new SAK.
Consequently distribution of a new SAK is stopped (DistributeSAK = FALSE).</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01046_KeySm_SelfTransit_DelayNewSak_WaitNewSakReq</srcid><srcstatus/><internalId>2114</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.KeySM</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1096</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1428</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.KeySM.SelfTrans.WaitSakUnwrap</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>20672</sourceline>
      <version>1</version>
      <description>Self-transition in the state KAY_KEYSM_WAIT_SAK_UNWRAP happens when new 
Distributed SAK is received, while instance is waiting for the previous SAK to be unwrapped.</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01047_KeySm_SelfTransit_WaitSakUnwrap</srcid><srcstatus/><internalId>2115</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.KeySM</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1096</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1429</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd" title="MkaExt Unit - Functionality requirements">
    <specobject>
      <id>Mka.EB.MkaPortIdentifier_Conf</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>20695</sourceline>
      <version>1</version>
      <description>
        &lt;ul&gt;
          &lt;li&gt;Name:               MkaPortIdentifier&lt;/li&gt;
          &lt;li&gt;Parent Container:   MkaPaeInstance&lt;/li&gt;
          &lt;li&gt;
              Description:        A unique identifier within a system that forms SCI together with port MAC address.
                                  When this parameter is disabled MkaPaeIdx is used instead.
          &lt;/li&gt;
          &lt;li&gt;Multiplicity:       0..1&lt;/li&gt;
          &lt;li&gt;Type:               EcucIntegerParamDef&lt;/li&gt;
          &lt;li&gt;Range:              0 .. 65535&lt;/li&gt;
          &lt;li&gt;Default value:      None&lt;/li&gt;
          &lt;li&gt;
              Value Configuration Class:
              &lt;ul&gt;
                &lt;li&gt;Pre-compile time: X All Variants&lt;/li&gt;
                &lt;li&gt;Link time:        - -&lt;/li&gt;
                &lt;li&gt;Post-build time:  - -&lt;/li&gt;
              &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Scope / Dependency: scope: local&lt;/li&gt;
        &lt;/ul&gt;
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_277</srcid><srcstatus/><internalId>833</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1430</internalId></specobject>
    <specobject>
      <id>Mka.EB.MkaMaxNumPaeInstances_Conf</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>20731</sourceline>
      <version>1</version>
      <description>
        &lt;ul&gt;
          &lt;li&gt;Name:               MkaMaxNumPaeInstances&lt;/li&gt;
          &lt;li&gt;Parent Container:   MkaGeneral&lt;/li&gt;
          &lt;li&gt;Description:        Defines the maximum number PAE instances for which MACsec/MKA can be configured.&lt;/li&gt;
          &lt;li&gt;Multiplicity:       1&lt;/li&gt;
          &lt;li&gt;Type:               EcucIntegerParamDef&lt;/li&gt;
          &lt;li&gt;Range:              1 .. 255&lt;/li&gt;
          &lt;li&gt;Default value:      1&lt;/li&gt;
          &lt;li&gt;
              Value Configuration Class:
              &lt;ul&gt;
                &lt;li&gt;Pre-compile time: X All Variants&lt;/li&gt;
                &lt;li&gt;Link time:        - -&lt;/li&gt;
                &lt;li&gt;Post-build time:  - -&lt;/li&gt;
              &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Scope / Dependency: scope: local&lt;/li&gt;
        &lt;/ul&gt;
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_1970</srcid><srcstatus/><internalId>906</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1431</internalId></specobject>
    <specobject>
      <id>Mka.EB.MkaMaxNumParticipants_Conf</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>20764</sourceline>
      <version>1</version>
      <description>
        &lt;ul&gt;
          &lt;li&gt;Name:               MkaMaxNumParticipants&lt;/li&gt;
          &lt;li&gt;Parent Container:   MkaGeneral&lt;/li&gt;
          &lt;li&gt;Description:        Defines the maximum number of Mka participants for which MACsec/MKA can be configured.&lt;/li&gt;
          &lt;li&gt;Multiplicity:       1&lt;/li&gt;
          &lt;li&gt;Type:               EcucIntegerParamDef&lt;/li&gt;
          &lt;li&gt;Range:              1 .. 255&lt;/li&gt;
          &lt;li&gt;Default value:      1&lt;/li&gt;
          &lt;li&gt;
            Value Configuration Class:
            &lt;ul&gt;
              &lt;li&gt;Pre-compile time: X All Variants&lt;/li&gt;
              &lt;li&gt;Link time:        - -&lt;/li&gt;
              &lt;li&gt;Post-build time:  - -&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Scope / Dependency: scope: local&lt;/li&gt;
        &lt;/ul&gt;
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_2000</srcid><srcstatus/><internalId>907</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1432</internalId></specobject>
    <specobject>
      <id>Mka.EB.MkaMaxRxBufferSize_Conf</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>20797</sourceline>
      <version>1</version>
      <description>
        &lt;ul&gt;
          &lt;li&gt;Name:               MkaMaxRxBufferSize&lt;/li&gt;
          &lt;li&gt;Parent Container:   MkaGeneral&lt;/li&gt;
          &lt;li&gt;
              Description:        Defines the size of a buffer used for reception of MKPDUs.
                                  Note: The buffer shall be large enough to store the largest EAPOL-MKA packet and additionally MACsource (SA)
                                  and destination addresses (DA) and EtherType, i.e. 14 bytes.
          &lt;/li&gt;
          &lt;li&gt;Multiplicity:       1&lt;/li&gt;
          &lt;li&gt;Type:               EcucIntegerParamDef&lt;/li&gt;
          &lt;li&gt;Range:              276 .. 1500&lt;/li&gt;
          &lt;li&gt;Default value:      276&lt;/li&gt;
          &lt;li&gt;
              Value Configuration Class:
              &lt;ul&gt;
                &lt;li&gt;Pre-compile time: X All Variants&lt;/li&gt;
                &lt;li&gt;Link time:        - -&lt;/li&gt;
                &lt;li&gt;Post-build time:  - -&lt;/li&gt;
              &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Scope / Dependency: scope: local&lt;/li&gt;
        &lt;/ul&gt;
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_2030</srcid><srcstatus/><internalId>908</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1433</internalId></specobject>
    <specobject>
      <id>Mka.EB.MkaParticipantIdx_Conf</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>20834</sourceline>
      <version>1</version>
      <description>
        &lt;ul&gt;
          &lt;li&gt;Name:               MkaParticipantIdx&lt;/li&gt;
          &lt;li&gt;Parent Container:   MkaKayParticipant&lt;/li&gt;
          &lt;li&gt;Description:        Participant ID within KaY.&lt;/li&gt;
          &lt;li&gt;Multiplicity:       1&lt;/li&gt;
          &lt;li&gt;Type:               EcucIntegerParamDef&lt;/li&gt;
          &lt;li&gt;Range:              0 .. 254&lt;/li&gt;
          &lt;li&gt;Default value:      None&lt;/li&gt;
          &lt;li&gt;
              Value Configuration Class:
              &lt;ul&gt;
                &lt;li&gt;Pre-compile time: X All Variants&lt;/li&gt;
                &lt;li&gt;Link time:        - -&lt;/li&gt;
                &lt;li&gt;Post-build time:  - -&lt;/li&gt;
              &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Scope / Dependency: scope: local&lt;/li&gt;
        &lt;/ul&gt;
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_563</srcid><srcstatus/><internalId>842</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1434</internalId></specobject>
    <specobject>
      <id>Mka.EB.MkaCryptoGeneral_Conf</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>20867</sourceline>
      <version>1</version>
      <description>
        This container is a subcontainer of MkaGeneral and specifies the general configuration parameters of the Crypto configuration.
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_2177</srcid><srcstatus/><internalId>914</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1435</internalId></specobject>
    <specobject>
      <id>Mka.EB.MkaCsmProcessing_Conf</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>20886</sourceline>
      <version>1</version>
      <description>
        &lt;ul&gt;
          &lt;li&gt;Name:               MkaCsmProcessing&lt;/li&gt;
          &lt;li&gt;Parent Container:   MkaCryptoGeneral&lt;/li&gt;
          &lt;li&gt;Description:        Defines if Mka uses asynchronous or synchronous Csm processing.&lt;/li&gt;
          &lt;li&gt;Multiplicity:       1&lt;/li&gt;
          &lt;li&gt;Type:               EcucEnumerationParamDef&lt;/li&gt;
          &lt;li&gt;
              Range:
              &lt;ul&gt;
                &lt;li&gt;MKA_CSM_ASYNCHRONOUS&lt;/li&gt;
                &lt;li&gt;MKA_CSM_SYNCHRONOUS&lt;/li&gt;
              &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Default value:      MKA_CSM_ASYNCHRONOUS&lt;/li&gt;
          &lt;li&gt;
              Value Configuration Class:
              &lt;ul&gt;
                &lt;li&gt;Pre-compile time: X All Variants&lt;/li&gt;
                &lt;li&gt;Link time:        - -&lt;/li&gt;
                &lt;li&gt;Post-build time:  - -&lt;/li&gt;
              &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Scope / Dependency: scope: local&lt;/li&gt;
        &lt;/ul&gt;
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_2191</srcid><srcstatus/><internalId>915</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1436</internalId></specobject>
    <specobject>
      <id>Mka.EB.MkaCryptoKeyGenerateMaxBufferSize_Conf</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>20925</sourceline>
      <version>1</version>
      <description>
        &lt;ul&gt;
          &lt;li&gt;Name:               MkaCryptoKeyGenerateMaxBufferSize&lt;/li&gt;
          &lt;li&gt;Parent Container:   MkaCryptoGeneral&lt;/li&gt;
          &lt;li&gt;Description:        Defines the size of a buffer used for generating MKA crypto keys.&lt;/li&gt;
          &lt;li&gt;Multiplicity:       1&lt;/li&gt;
          &lt;li&gt;Type:               EcucIntegerParamDef&lt;/li&gt;
          &lt;li&gt;Range:              46 .. 300&lt;/li&gt;
          &lt;li&gt;Default value:      46&lt;/li&gt;
          &lt;li&gt;
              Value Configuration Class:
              &lt;ul&gt;
                &lt;li&gt;Pre-compile time: X All Variants&lt;/li&gt;
                &lt;li&gt;Link time:        - -&lt;/li&gt;
                &lt;li&gt;Post-build time:  - -&lt;/li&gt;
              &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Scope / Dependency: scope: local&lt;/li&gt;
        &lt;/ul&gt;
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_2222</srcid><srcstatus/><internalId>916</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1437</internalId></specobject>
    <specobject>
      <id>Mka.EB.MkaCryptoRandomGenerateMaxBufferSize_Conf</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>20958</sourceline>
      <version>1</version>
      <description>
        &lt;ul&gt;
          &lt;li&gt;Name:               MkaCryptoRandomGenerateMaxBufferSize&lt;/li&gt;
          &lt;li&gt;Parent Container:   MkaCryptoGeneral&lt;/li&gt;
          &lt;li&gt;Description:        Defines the size of a buffer used for generating random value.&lt;/li&gt;
          &lt;li&gt;Multiplicity:       1&lt;/li&gt;
          &lt;li&gt;Type:               EcucIntegerParamDef&lt;/li&gt;
          &lt;li&gt;Range:              16 .. 32&lt;/li&gt;
          &lt;li&gt;Default value:      16&lt;/li&gt;
          &lt;li&gt;
              Value Configuration Class:
              &lt;ul&gt;
                &lt;li&gt;Pre-compile time: X All Variants&lt;/li&gt;
                &lt;li&gt;Link time:        - -&lt;/li&gt;
                &lt;li&gt;Post-build time:  - -&lt;/li&gt;
              &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Scope / Dependency: scope: local&lt;/li&gt;
        &lt;/ul&gt;
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_2255</srcid><srcstatus/><internalId>917</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1438</internalId></specobject>
    <specobject>
      <id>Mka.EB.MkaCryptoKeyWrapMaxBufferSize_Conf</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>20991</sourceline>
      <version>1</version>
      <description>
        &lt;ul&gt;
          &lt;li&gt;Name:               MkaCryptoKeyWrapMaxBufferSize&lt;/li&gt;
          &lt;li&gt;Parent Container:   MkaCryptoGeneral&lt;/li&gt;
          &lt;li&gt;Description:        Defines the size of a buffer used for key wrap or unwrap.&lt;/li&gt;
          &lt;li&gt;Multiplicity:       1&lt;/li&gt;
          &lt;li&gt;Type:               EcucIntegerParamDef&lt;/li&gt;
          &lt;li&gt;Range:              24 .. 40&lt;/li&gt;
          &lt;li&gt;Default value:      24&lt;/li&gt;
          &lt;li&gt;
              Value Configuration Class:
              &lt;ul&gt;
                &lt;li&gt;Pre-compile time: X All Variants&lt;/li&gt;
                &lt;li&gt;Link time:        - -&lt;/li&gt;
                &lt;li&gt;Post-build time:  - -&lt;/li&gt;
              &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Scope / Dependency: scope: local&lt;/li&gt;
        &lt;/ul&gt;
      </description>
      <releases>
        <release>AUTOSAR R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_2286</srcid><srcstatus/><internalId>918</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1439</internalId></specobject>
    <specobject>
      <id>Mka.EB.MkaCryptoRetryAttempts_Conf</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>21024</sourceline>
      <version>1</version>
      <description>
        &lt;ul&gt;
          &lt;li&gt;Name:               MkaCryptoRetryAttempts&lt;/li&gt;
          &lt;li&gt;Parent Container:   MkaCryptoGeneral&lt;/li&gt;
          &lt;li&gt;Description:        Defines the number of times a cypto operation is retried if Csm returns BUSY.&lt;/li&gt;
          &lt;li&gt;Multiplicity:       1&lt;/li&gt;
          &lt;li&gt;Type:               EcucIntegerParamDef&lt;/li&gt;
          &lt;li&gt;Range:              0 .. 5&lt;/li&gt;
          &lt;li&gt;Default value:      3&lt;/li&gt;
          &lt;li&gt;
              Value Configuration Class:
              &lt;ul&gt;
                &lt;li&gt;Pre-compile time: X All Variants&lt;/li&gt;
                &lt;li&gt;Link time:        - -&lt;/li&gt;
                &lt;li&gt;Post-build time:  - -&lt;/li&gt;
              &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Scope / Dependency: scope: local&lt;/li&gt;
        &lt;/ul&gt;
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_2879</srcid><srcstatus/><internalId>945</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1440</internalId></specobject>
    <specobject>
      <id>Mka.EB.MkaDemReportingEnabled_Conf</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>21054</sourceline>
      <version>1</version>
      <description>
        &lt;ul&gt;
          &lt;li&gt;Name:               MkaDemReportingEnabled&lt;/li&gt;
          &lt;li&gt;Parent Container:   MkaGeneral&lt;/li&gt;
          &lt;li&gt;
              Description:        Enables interface to Dem module, which provides status of next errors:
                                  &lt;ul&gt;
                                    &lt;li&gt;MKA_E_ALGO_MISMATCH_INSTANCE,&lt;/li&gt;
                                    &lt;li&gt;MKA_E_KEY_MISMATCH_INSTANCE,&lt;/li&gt;
                                    &lt;li&gt;MKA_E_KEY_NOT_PRESENT_INSTANCE,&lt;/li&gt;
                                    &lt;li&gt;MKA_E_TIMEOUT_INSTANCE.&lt;/li&gt;
                                  &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Multiplicity:       1&lt;/li&gt;
          &lt;li&gt;Type:               EcucBooleanParamDef&lt;/li&gt;
          &lt;li&gt;Default value:      FALSE&lt;/li&gt;
          &lt;li&gt;
              Value Configuration Class:
              &lt;ul&gt;
                &lt;li&gt;Pre-compile time: X All Variants&lt;/li&gt;
                &lt;li&gt;Link time:        - -&lt;/li&gt;
                &lt;li&gt;Post-build time:  - -&lt;/li&gt;
              &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Scope / Dependency: scope: local&lt;/li&gt;
        &lt;/ul&gt;
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_2061</srcid><srcstatus/><internalId>910</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1441</internalId></specobject>
    <specobject>
      <id>Mka.EB.MkaSecYRetryAttempts_Conf</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>21091</sourceline>
      <version>1</version>
      <description>
        &lt;ul&gt;
          &lt;li&gt;Name:               MkaSecYRetryAttempts&lt;/li&gt;
          &lt;li&gt;Parent Container:   MkaGeneral&lt;/li&gt;
          &lt;li&gt;Description:        Defines the number of times a SecY operation is retried if EthIf returns E_NOT_OK.&lt;/li&gt;
          &lt;li&gt;Multiplicity:       1&lt;/li&gt;
          &lt;li&gt;Type:               EcucIntegerParamDef&lt;/li&gt;
          &lt;li&gt;Range:              0 .. 5&lt;/li&gt;
          &lt;li&gt;Default value:      5&lt;/li&gt;
          &lt;li&gt;
              Value Configuration Class:
              &lt;ul&gt;
                &lt;li&gt;Pre-compile time: X All Variants&lt;/li&gt;
                &lt;li&gt;Link time:        - -&lt;/li&gt;
                &lt;li&gt;Post-build time:  - -&lt;/li&gt;
              &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Scope / Dependency: scope: local&lt;/li&gt;
        &lt;/ul&gt;
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_2852</srcid><srcstatus/><internalId>944</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0117.SecYRetry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>969</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1442</internalId></specobject>
    <specobject>
      <id>Mka.EB.MkaLatestKeyGetsOldAfterRetire_Conf</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>21127</sourceline>
      <version>1</version>
      <description>
        &lt;ul&gt;
          &lt;li&gt;Name:               MkaLatestKeyGetsOldAfterRetire&lt;/li&gt;
          &lt;li&gt;Parent Container:   MkaGeneral&lt;/li&gt;
          &lt;li&gt;Description:        Defines if Mka will set the new LatestKey to LatestKey or to OldKey after reaching CP state CP_RETIRE.&lt;/li&gt;
          &lt;li&gt;Multiplicity:       1&lt;/li&gt;
          &lt;li&gt;Type:               EcucBooleanParamDef&lt;/li&gt;
          &lt;li&gt;Default value:      false&lt;/li&gt;
          &lt;li&gt;
              Value Configuration Class:
              &lt;ul&gt;
                &lt;li&gt;Pre-compile time: X All Variants&lt;/li&gt;
                &lt;li&gt;Link time:        - -&lt;/li&gt;
                &lt;li&gt;Post-build time:  - -&lt;/li&gt;
              &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Scope / Dependency: scope: local&lt;/li&gt;
        &lt;/ul&gt;
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_2113</srcid><srcstatus/><internalId>912</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.InterAct.MkaLatestKeyGetsOldAfterRetire</srcid><srcstatus/><internalId>1084</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1443</internalId></specobject>
    <specobject>
      <id>Mka.EB.MkaCryptoHashGenerateJobRef_Conf</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>21157</sourceline>
      <version>1</version>
      <description>
        &lt;ul&gt;
          &lt;li&gt;Name:               MkaCryptoHashGenerateJobRef&lt;/li&gt;
          &lt;li&gt;Parent Container:   MkaKayParticipant&lt;/li&gt;
          &lt;li&gt;Description:        Reference to a Csm job for SAK hash generation.&lt;/li&gt;
          &lt;li&gt;Multiplicity:       1&lt;/li&gt;
          &lt;li&gt;Type:               Symbolic name reference to CsmJob&lt;/li&gt;
          &lt;li&gt;Default value:      None&lt;/li&gt;
          &lt;li&gt;
              Value Configuration Class:
              &lt;ul&gt;
                &lt;li&gt;Pre-compile time: X All Variants&lt;/li&gt;
                &lt;li&gt;Link time:        - -&lt;/li&gt;
                &lt;li&gt;Post-build time:  - -&lt;/li&gt;
              &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Scope / Dependency: scope: local&lt;/li&gt;
        &lt;/ul&gt;
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_1009</srcid><srcstatus/><internalId>857</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1444</internalId></specobject>
    <specobject>
      <id>Mka.EB.MkaCryptoHashGenerateJob2Ref_Conf</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>21186</sourceline>
      <version>1</version>
      <description>
        &lt;ul&gt;
          &lt;li&gt;Name:               MkaCryptoHashGenerateJob2Ref&lt;/li&gt;
          &lt;li&gt;Parent Container:   MkaKayParticipant&lt;/li&gt;
          &lt;li&gt;Description:        Reference to a second Csm job for SAK hash generation.&lt;/li&gt;
          &lt;li&gt;Multiplicity:       1&lt;/li&gt;
          &lt;li&gt;Type:               Symbolic name reference to CsmJob&lt;/li&gt;
          &lt;li&gt;Default value:      None&lt;/li&gt;
          &lt;li&gt;
              Value Configuration Class:
              &lt;ul&gt;
                &lt;li&gt;Pre-compile time: X All Variants&lt;/li&gt;
                &lt;li&gt;Link time:        - -&lt;/li&gt;
                &lt;li&gt;Post-build time:  - -&lt;/li&gt;
              &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Scope:              scope: local&lt;/li&gt;
          &lt;li&gt;Dependency:         Enabled only if both cipher suite sizes (128 and 256) are configured in &lt;code&gt;MkaCryptoAlgoConfig&lt;/code&gt; referenced by &lt;code&gt;MkaCryptoAlgoRef&lt;/code&gt;.&lt;/li&gt;
        &lt;/ul&gt;
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_1087</srcid><srcstatus/><internalId>859</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1445</internalId></specobject>
    <specobject>
      <id>Mka.EB.MkaCryptoSak2KeyRef_Conf</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>21216</sourceline>
      <version>1</version>
      <description>
        &lt;ul&gt;
          &lt;li&gt;Name:               MkaCryptoSak2KeyRef&lt;/li&gt;
          &lt;li&gt;Parent Container:   MkaKayParticipant&lt;/li&gt;
          &lt;li&gt;Description:        Reference to a CSM key where the second SAK shall be stored.&lt;/li&gt;
          &lt;li&gt;Multiplicity:       1&lt;/li&gt;
          &lt;li&gt;Type:               Symbolic name reference to CsmKey&lt;/li&gt;
          &lt;li&gt;Default value:      None&lt;/li&gt;
          &lt;li&gt;
              Value Configuration Class:
              &lt;ul&gt;
                &lt;li&gt;Pre-compile time: X All Variants&lt;/li&gt;
                &lt;li&gt;Link time:        - -&lt;/li&gt;
                &lt;li&gt;Post-build time:  - -&lt;/li&gt;
              &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Scope:              scope: local&lt;/li&gt;
          &lt;li&gt;Dependency:         Enabled only if both cipher suites sizes (128 and 256) are configured in &lt;code&gt;MkaCryptoAlgoConfig&lt;/code&gt; referenced by &lt;code&gt;MkaCryptoAlgoRef&lt;/code&gt;.&lt;/li&gt;
        &lt;/ul&gt;
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_1051</srcid><srcstatus/><internalId>858</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1446</internalId></specobject>
    <specobject>
      <id>Mka.EB.MkaRestartPermissiveModeTimerOnFirstMkpdu_Conf</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>21246</sourceline>
      <version>1</version>
      <description>
        &lt;ul&gt;
          &lt;li&gt;Name:               MkaRestartPermissiveModeTimerOnFirstMkpdu&lt;/li&gt;
          &lt;li&gt;Parent Container:   MkaGeneral&lt;/li&gt;
          &lt;li&gt;Description:        Defines if permissive mode timer will be restarted when first valid MKPDU (ICV verified) is received from a partner.&lt;/li&gt;
          &lt;li&gt;Multiplicity:       1&lt;/li&gt;
          &lt;li&gt;Type:               EcucBooleanParamDef&lt;/li&gt;
          &lt;li&gt;Default value:      false&lt;/li&gt;
          &lt;li&gt;
              Value Configuration Class:
              &lt;ul&gt;
                &lt;li&gt;Pre-compile time: X All Variants&lt;/li&gt;
                &lt;li&gt;Link time:        - -&lt;/li&gt;
                &lt;li&gt;Post-build time:  - -&lt;/li&gt;
              &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Scope / Dependency: scope: local&lt;/li&gt;
        &lt;/ul&gt;
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_2144</srcid><srcstatus/><internalId>913</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0111.PermissiveMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>963</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1447</internalId></specobject>
    <specobject>
      <id>Mka.EB.RestartPermissiveModeTimerOnFirstMkpdu</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>21281</sourceline>
      <version>1</version>
      <description>
        If configuration parameter MkaRestartPermissiveModeTimerOnFirstMkpduPermissive is enabled, permissive timer shall be restarted
        when the first MKPDU with verified ICV is received from a partner.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_1231</srcid><srcstatus/><internalId>637</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Mka_Logon.c_1281</srcid><srcstatus/><internalId>768</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01021_PermissiveMode_TimerResetOnMkpdu_1</srcid><srcstatus/><internalId>1710</internalId></linkedfrom><linkedfrom><srcid>Mka_ConTest01022_PermissiveMode_TimerResetOnMkpdu_2</srcid><srcstatus/><internalId>1711</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0111.PermissiveMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>963</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1448</internalId></specobject>
    <specobject>
      <id>Mka.EB.MkaPostBuildConfigurationHash_Conf</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>21304</sourceline>
      <version>1</version>
      <description>
        PostBuild configuration shall contain PBcfgSignature variable that
        contains hash value of PostBuild configuration.This value shall be stored in NVRAM
        and compared with generated value of PBcfgSignature during MKA module initialization
        to verify if configuration has changed. In that case MKA shall not use NvRAM content,
        i.e. it shall act as NvRAM is empty. Consequently NVRAM shall be re-initialized.
      </description>
      <verifycrit>
        Verify that NvRam is reset to default values if hash value is changed.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01018_NvmGetStatus_InvalidMemoryBlock</srcid><srcstatus/><internalId>2208</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Logon.c_1707</srcid><srcstatus/><internalId>786</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/generate_var/xgen/Mka.xgen_601</srcid><srcstatus/><internalId>949</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0122.DynamicControl</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1098</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1449</internalId></specobject>
    <specobject>
      <id>Mka.EB.MkaMaxRxBufferSize.Calculation</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>21331</sourceline>
      <version>1</version>
      <description>
        Minimal required buffer size is 276 octets.
        Calculation:
        &lt;ul&gt;
          &lt;li&gt;EAPOL header = 4 octets.&lt;/li&gt;
          &lt;li&gt;
              Included parameter sets:
              &lt;ul&gt;
                &lt;li&gt;
                  Basic parameter set = 64 octets.
                  &lt;ul&gt;
                    &lt;li&gt;CKN length:   32 octet.&lt;/li&gt;
                    &lt;li&gt;NULL padding: 0  octets.&lt;/li&gt;
                  &lt;/ul&gt;
                &lt;/li&gt;
                &lt;li&gt;
                  Peer list parameter set = 20 octets.
                  &lt;ul&gt;
                    &lt;li&gt;Only have 1 participant.&lt;/li&gt;
                    &lt;li&gt;Can be only Live or Potential peer list, only one is transmitted in a single MKPDU.&lt;/li&gt;
                  &lt;/ul&gt;
                &lt;/li&gt;
                &lt;li&gt;SAK Use parameter set = 44 octets.&lt;/li&gt;
                &lt;li&gt;
                  Distributed SAK parameter set = 56 octets.
                  &lt;ul&gt;
                    &lt;li&gt;Default Cipher Suite is not used.&lt;/li&gt;
                    &lt;li&gt;Wrapped SAK is 256 bit long.&lt;/li&gt;
                  &lt;/ul&gt;
                &lt;/li&gt;
                &lt;li&gt;
                  Announcement parameter set = 46 octets.
                    &lt;ul&gt;&lt;li&gt;Contain all four Cipher Suite.&lt;/li&gt;&lt;/ul&gt;
                &lt;/li&gt;
                &lt;li&gt;XPN parameter set = 12 octets.&lt;/li&gt;
                &lt;li&gt;ICV = 16 octets.&lt;/li&gt;
              &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;
              Ethernet header
              &lt;ul&gt;
                &lt;li&gt;MAC address of source = 6 octets.&lt;/li&gt;
                &lt;li&gt;MAC address of destination = 6 octets.&lt;/li&gt;
                &lt;li&gt;EtherType = 2 octets.&lt;/li&gt;
              &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
        EAPOL-MKA is 262 octets long and Ethernet header is 14 octet long.
        Total sum is 276 octets.
      </description>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.EB.MkaMaxRxBufferSize.DefaultValue</srcid><srcstatus/><internalId>1451</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1450</internalId></specobject>
    <specobject>
      <id>Mka.EB.MkaMaxRxBufferSize.DefaultValue</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>21391</sourceline>
      <version>1</version>
      <description>
        The default value for MkaMaxRxBufferSize shall be 276 octets, which is the minimal value of the required buffer calculated
        in [Mka.EB.MkpduSize.Calculation].
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_2031</srcid><srcstatus/><internalId>909</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.MkaMaxRxBufferSize.Calculation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1450</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1451</internalId></specobject>
    <specobject>
      <id>Mka.EB.Mka.MkaNvmBlock_Conf</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>21411</sourceline>
      <version>1</version>
      <description>
        This container is a sub container of MkaGeneral and specifies the configuration non
        volatile memory in the Ecu to store runtime information (Pae and Participant configurations
        that shall be used on next initialization cycle).
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_2318</srcid><srcstatus/><internalId>919</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.EB.Mka.MkaNvmBlockDescriptorRef_Conf</srcid><srcstatus/><internalId>1453</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0122.DynamicControl</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1098</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1452</internalId></specobject>
    <specobject>
      <id>Mka.EB.Mka.MkaNvmBlockDescriptorRef_Conf</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>21433</sourceline>
      <version>1</version>
      <description>
        &lt;ul&gt;
          &lt;li&gt;Name:               MkaNvmBlockDescriptorRef&lt;/li&gt;
          &lt;li&gt;Parent Container:   MkaNvmBlock&lt;/li&gt;
          &lt;li&gt;Description:        Descriptor Reference to the Nvm block description in the Nvm module configuration.&lt;/li&gt;
          &lt;li&gt;Multiplicity:       1&lt;/li&gt;
          &lt;li&gt;Type:               Symbolic name reference to [ NvMBlockDescriptor ]&lt;/li&gt;
          &lt;li&gt;Default value:      None&lt;/li&gt;
          &lt;li&gt;
              Value Configuration Class:
              &lt;ul&gt;
                &lt;li&gt;Pre-compile time: X All Variants&lt;/li&gt;
                &lt;li&gt;Link time:        - -&lt;/li&gt;
                &lt;li&gt;Post-build time:  - -&lt;/li&gt;
              &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Scope / Dependency: scope: ECU&lt;/li&gt;
        &lt;/ul&gt;
      </description>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.XDM.MkaNvmBlockDescriptorRef.ReadAll</srcid><srcstatus/><internalId>1674</internalId></linkedfrom><linkedfrom><srcid>Mka.XDM.MkaNvmBlockDescriptorRef.WriteAll</srcid><srcstatus/><internalId>1675</internalId></linkedfrom><linkedfrom><srcid>Mka.XDM.MkaNvmBlockDescriptorRef.RamAddress</srcid><srcstatus/><internalId>1676</internalId></linkedfrom><linkedfrom><srcid>Mka.XDM.MkaNvmBlockDescriptorRef.UserHeader</srcid><srcstatus/><internalId>1677</internalId></linkedfrom><linkedfrom><srcid>Mka.XDM.MkaNvmBlockDescriptorRef.MinimumMemorySize_Invalid</srcid><srcstatus/><internalId>1678</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.XDM.NvMNvBlockLength_Conf</srcid><srcstatus/><internalId>1454</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_2377</srcid><srcstatus/><internalId>921</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.Mka.MkaNvmBlock_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1452</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1453</internalId></specobject>
    <specobject>
      <id>Mka.XDM.NvMNvBlockLength_Conf</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>21470</sourceline>
      <version>1</version>
      <description>
        This is placeholder for calculation of minimum size of Mka Nv memory.
        MkaNvRamBlockSize is calculated as:
        &lt;ul&gt;&lt;li&gt;sizeof(MkaNvRam_Memory)&lt;/li&gt;&lt;/ul&gt; or
        &lt;ul&gt;
          &lt;li&gt;1 *  uint32 (4 octets) +&lt;/li&gt;
          &lt;li&gt;3 * uint8(1 octet) times maximum number of PAEs +&lt;/li&gt;
          &lt;li&gt;for each Participant 1 bit aligned to octets, meaning minimum 1 octet&lt;/li&gt;
          &lt;li&gt;(largest integer value less than or equal to ((MaxNumParticipants + 7) / 8))&lt;/li&gt;
          &lt;li&gt;1 * uint8 for boolean values (flags)&lt;/li&gt;
        &lt;/ul&gt;
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_2348</srcid><srcstatus/><internalId>920</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.Mka.MkaNvmBlockDescriptorRef_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1453</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1454</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Mka.GetMacSecStatistics</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>21500</sourceline>
      <version>1</version>
      <description>
        When function Mka_GetMacSecStatistics() is called, function checks if participant exist on received PAE for given CKN.
        If participant exist, function will return value of EthIf_MacSecGetMacSecStats(), instead it returns E_NOT_OK.
      </description>
      <verifycrit>
        Test case 1:
          1) Configure stub EthIf_MacSecGetMacSecStats() to return E_OK.
          2) Call function Mka_GetMacSecStatistics() with valid CKN for given PAE.
          3) Check that Mka_GetMacSecStatistics() returns E_OK.
        Test case 2:
          1) Call function Mka_GetMacSecStatistics() with CKN that doesn't exist on given PAE.
          2) Check that Mka_GetMacSecStatistics() returns E_NOT_OK.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_UnitTest01049_GetMacSecStatistics</srcid><srcstatus/><internalId>2308</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Ext.c.m4_679</srcid><srcstatus/><internalId>612</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_91019</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>388</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1455</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Mka.GetMacSecStatisticsNotification</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>21530</sourceline>
      <version>1</version>
      <description>
        When function Mka_GetMacSecStatisticsNotification() is called if is defined user callback function, it will forward status message
        to user defined function.
      </description>
      <verifycrit>
        Test case 1:
          1) Call function Mka_GetMacSecStatisticsNotification().
          2) Check that nothing happens.
        Test case 2:
          1) Define User callback function and set it up in configuration.
          2) Call function Mka_GetMacSecStatisticsNotification().
          3) Check that user defined function is called.
          4) Verify that Mka_GetMacSecStatisticsNotification() properly forwarded messages to the user define function.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_UnitTest01050_GetMacSecStatisticsNotification</srcid><srcstatus/><internalId>2309</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Ext.c.m4_754</srcid><srcstatus/><internalId>614</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_91024</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>390</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1456</internalId></specobject>
    <specobject>
      <id>Mka.EB.MkaHeaderFileInclusion_Conf</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>21562</sourceline>
      <version>1</version>
      <description>
        &lt;ul&gt;
          &lt;li&gt;Name:               MkaHeaderFileInclusion&lt;/li&gt;
          &lt;li&gt;Parent Container:   MkaGeneral&lt;/li&gt;
          &lt;li&gt;
              Description:        Name of the header file(s) to be included by the Mka module
                                  containing the used C-callback declarations.
          &lt;/li&gt;
          &lt;li&gt;Multiplicity:       None&lt;/li&gt;
          &lt;li&gt;Type:               String&lt;/li&gt;
          &lt;li&gt;Default value:      None&lt;/li&gt;
          &lt;li&gt;
              Value Configuration Class:
              &lt;ul&gt;
                &lt;li&gt;Pre-compile time: X All Variants&lt;/li&gt;
                &lt;li&gt;Link time:        - -&lt;/li&gt;
                &lt;li&gt;Post-build time:  - -&lt;/li&gt;
              &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Scope / Dependency: scope: local&lt;/li&gt;
        &lt;/ul&gt;
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_2440</srcid><srcstatus/><internalId>927</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0115.CallbackFunctions</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>967</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1457</internalId></specobject>
    <specobject>
      <id>Mka.EB.MkaCallbacks_Conf</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>21600</sourceline>
      <version>1</version>
      <description>
        &lt;ul&gt;
          &lt;li&gt;Name:               MkaCallbacks&lt;/li&gt;
          &lt;li&gt;Parent Container:   MkaGeneral&lt;/li&gt;
          &lt;li&gt;Description:        Container that contains direct C Callback functions.&lt;/li&gt;
          &lt;li&gt;Multiplicity:       None&lt;/li&gt;
          &lt;li&gt;
              Value Configuration Class:
              &lt;ul&gt;
                &lt;li&gt;Pre-compile time: X All Variants&lt;/li&gt;
                &lt;li&gt;Link time:        - -&lt;/li&gt;
                &lt;li&gt;Post-build time:  - -&lt;/li&gt;
              &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Scope / Dependency: scope: local&lt;/li&gt;
        &lt;/ul&gt;
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_2463</srcid><srcstatus/><internalId>928</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0115.CallbackFunctions</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>967</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1458</internalId></specobject>
    <specobject>
      <id>Mka.EB.MkaGetMacSecStatisticsCallback_Conf</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>21633</sourceline>
      <version>1</version>
      <description>
        &lt;ul&gt;
          &lt;li&gt;Name:               MkaGetMacSecStatisticsCallback&lt;/li&gt;
          &lt;li&gt;Parent Container:   MkaCallbacks&lt;/li&gt;
          &lt;li&gt;
              Description:        User defined callback function to be called for every
                                  call of Mka_GetMacSecStatisticsNotification().
          &lt;/li&gt;
          &lt;li&gt;Multiplicity:       0 .. 1&lt;/li&gt;
          &lt;li&gt;Type:               Function-Name&lt;/li&gt;
          &lt;li&gt;Default value:      None&lt;/li&gt;
          &lt;li&gt;
              Value Configuration Class:
              &lt;ul&gt;
                &lt;li&gt;Pre-compile time: X All Variants&lt;/li&gt;
                &lt;li&gt;Link time:        - -&lt;/li&gt;
                &lt;li&gt;Post-build time:  - -&lt;/li&gt;
              &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Scope / Dependency: scope: local&lt;/li&gt;
        &lt;/ul&gt;
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_2477</srcid><srcstatus/><internalId>929</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.XDM.MkaGetMacSecStatisticsCallback_EmptyReference</srcid><srcstatus/><internalId>1679</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0115.CallbackFunctions</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>967</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1459</internalId></specobject>
    <specobject>
      <id>Mka.EB.MkaSecYCallout_Conf</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>21672</sourceline>
      <version>1</version>
      <description>
        &lt;ul&gt;
          &lt;li&gt;Name:               MkaSecYCallout&lt;/li&gt;
          &lt;li&gt;Parent Container:   MkaCallbacks&lt;/li&gt;
          &lt;li&gt;Description:        User defined callout function to be called for every asynchronous call of SecY API.&lt;/li&gt;
          &lt;li&gt;Multiplicity:       0 .. 1&lt;/li&gt;
          &lt;li&gt;Type:               Function-Name&lt;/li&gt;
          &lt;li&gt;Default value:      None&lt;/li&gt;
          &lt;li&gt;
              Value Configuration Class:
              &lt;ul&gt;
                &lt;li&gt;Pre-compile time: X All Variants&lt;/li&gt;
                &lt;li&gt;Link time:        - -&lt;/li&gt;
                &lt;li&gt;Post-build time:  - -&lt;/li&gt;
              &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Scope / Dependency: scope: local&lt;/li&gt;
        &lt;/ul&gt;
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_2518</srcid><srcstatus/><internalId>931</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0115.CallbackFunctions</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>967</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0124.InterruptMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>976</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1460</internalId></specobject>
    <specobject>
      <id>Mka.EB.MkaTaskCallout_Conf</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>21711</sourceline>
      <version>1</version>
      <description>
        &lt;ul&gt;
          &lt;li&gt;Name:               MkaTaskCallout&lt;/li&gt;
          &lt;li&gt;Parent Container:   MkaCallbacks&lt;/li&gt;
          &lt;li&gt;Description:        User defined callout function to be called when an event is received in Mka.&lt;/li&gt;
          &lt;li&gt;Multiplicity:       0 .. 1&lt;/li&gt;
          &lt;li&gt;Type:               Function-Name&lt;/li&gt;
          &lt;li&gt;Default value:      None&lt;/li&gt;
          &lt;li&gt;
              Value Configuration Class:
              &lt;ul&gt;
                &lt;li&gt;Pre-compile time: X All Variants&lt;/li&gt;
                &lt;li&gt;Link time:        - -&lt;/li&gt;
                &lt;li&gt;Post-build time:  - -&lt;/li&gt;
              &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Scope / Dependency: scope: local&lt;/li&gt;
        &lt;/ul&gt;
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_2553</srcid><srcstatus/><internalId>933</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0115.CallbackFunctions</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>967</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0124.InterruptMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>976</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1461</internalId></specobject>
    <specobject>
      <id>Mka.EB.MkaReportEventCallout_Conf</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>21750</sourceline>
      <version>1</version>
      <description>
        &lt;ul&gt;
          &lt;li&gt;Name:               MkaReportEventCallout&lt;/li&gt;
          &lt;li&gt;Parent Container:   MkaCallbacks&lt;/li&gt;
          &lt;li&gt;Description:        User defined callout function to be called when error event needs to be reported.&lt;/li&gt;
          &lt;li&gt;Multiplicity:       0 .. 1&lt;/li&gt;
          &lt;li&gt;Type:               Function-Name&lt;/li&gt;
          &lt;li&gt;Default value:      None&lt;/li&gt;
          &lt;li&gt;
              Value Configuration Class:
              &lt;ul&gt;
                &lt;li&gt;Pre-compile time: X All Variants&lt;/li&gt;
                &lt;li&gt;Link time:        - -&lt;/li&gt;
                &lt;li&gt;Post-build time:  - -&lt;/li&gt;
              &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Scope / Dependency: scope: local&lt;/li&gt;
        &lt;/ul&gt;
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_2588</srcid><srcstatus/><internalId>935</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0115.CallbackFunctions</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>967</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0118.ProductionErrors</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>970</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1462</internalId></specobject>
    <specobject>
      <id>Mka.EB.MkaEnableImmediatePeerResponse_Conf</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>21790</sourceline>
      <version>1</version>
      <description>
        &lt;ul&gt;
          &lt;li&gt;Name:               MkaEnableImmediatePeerResponse&lt;/li&gt;
          &lt;li&gt;Parent Container:   MkaGeneral&lt;/li&gt;
          &lt;li&gt;Description:        Enables optimization for immediate response for peer when received MKPDU and triggered some changes.&lt;/li&gt;
          &lt;li&gt;Multiplicity:       1&lt;/li&gt;
          &lt;li&gt;Type:               EcucBooleanParamDef&lt;/li&gt;
          &lt;li&gt;Default value:      FALSE&lt;/li&gt;
          &lt;li&gt;
              Value Configuration Class:
              &lt;ul&gt;
                &lt;li&gt;Pre-compile time: X All Variants&lt;/li&gt;
                &lt;li&gt;Link time:        - -&lt;/li&gt;
                &lt;li&gt;Post-build time:  - -&lt;/li&gt;
              &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Scope / Dependency: scope: local&lt;/li&gt;
        &lt;/ul&gt;
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_2698</srcid><srcstatus/><internalId>939</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0121.ImmediateResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>973</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1463</internalId></specobject>
    <specobject>
      <id>Mka.EB.MkaSecYAddTxSaSync_Conf</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>21825</sourceline>
      <version>1</version>
      <description>
        &lt;ul&gt;
          &lt;li&gt;Name:               MkaSecYAddTxSaSync&lt;/li&gt;
          &lt;li&gt;Parent Container:   MkaGeneral&lt;/li&gt;
          &lt;li&gt;Description:        Enables optimization when EthIf_MacSecAddTxSa work in synchronous mode.&lt;/li&gt;
          &lt;li&gt;Multiplicity:       1&lt;/li&gt;
          &lt;li&gt;Type:               EcucBooleanParamDef&lt;/li&gt;
          &lt;li&gt;Default value:      FALSE&lt;/li&gt;
          &lt;li&gt;
              Value Configuration Class:
              &lt;ul&gt;
                &lt;li&gt;Pre-compile time: X All Variants&lt;/li&gt;
                &lt;li&gt;Link time:        - -&lt;/li&gt;
                &lt;li&gt;Post-build time:  - -&lt;/li&gt;
              &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Scope / Dependency: scope: local&lt;/li&gt;
        &lt;/ul&gt;
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_2642</srcid><srcstatus/><internalId>937</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1464</internalId></specobject>
    <specobject>
      <id>Mka.EB.MkaSecYAddRxSaSync_Conf</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>21854</sourceline>
      <version>1</version>
      <description>
        &lt;ul&gt;
          &lt;li&gt;Name:               MkaSecYAddRxSaSync&lt;/li&gt;
          &lt;li&gt;Parent Container:   MkaGeneral&lt;/li&gt;
          &lt;li&gt;Description:        Enables optimization when EthIf_MacSecAddRxSa work in synchronous mode.&lt;/li&gt;
          &lt;li&gt;Multiplicity:       1&lt;/li&gt;
          &lt;li&gt;Type:               EcucBooleanParamDef&lt;/li&gt;
          &lt;li&gt;Default value:      FALSE&lt;/li&gt;
          &lt;li&gt;
              Value Configuration Class:
              &lt;ul&gt;
                &lt;li&gt;Pre-compile time: X All Variants&lt;/li&gt;
                &lt;li&gt;Link time:        - -&lt;/li&gt;
                &lt;li&gt;Post-build time:  - -&lt;/li&gt;
              &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Scope / Dependency: scope: local&lt;/li&gt;
        &lt;/ul&gt;
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_2670</srcid><srcstatus/><internalId>938</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1465</internalId></specobject>
    <specobject>
      <id>Mka.EB.MkaUpdateSecYDuringInit_Conf</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>21883</sourceline>
      <version>1</version>
      <description>
        &lt;ul&gt;
          &lt;li&gt;Name:               MkaUpdateSecYDuringInit&lt;/li&gt;
          &lt;li&gt;Parent Container:   MkaGeneral&lt;/li&gt;
          &lt;li&gt;Description:        When enabled SecY is initialized early during Mka initialization, otherwise when link-up is signalled.&lt;/li&gt;
          &lt;li&gt;Multiplicity:       1&lt;/li&gt;
          &lt;li&gt;Type:               EcucBooleanParamDef&lt;/li&gt;
          &lt;li&gt;Default value:      FALSE&lt;/li&gt;
          &lt;li&gt;
              Value Configuration Class:
              &lt;ul&gt;
                &lt;li&gt;Pre-compile time: X All Variants&lt;/li&gt;
                &lt;li&gt;Link time:        - -&lt;/li&gt;
                &lt;li&gt;Post-build time:  - -&lt;/li&gt;
              &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Scope / Dependency: scope: local&lt;/li&gt;
        &lt;/ul&gt;
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_2724</srcid><srcstatus/><internalId>940</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1466</internalId></specobject>
    <specobject>
      <id>Mka.EB.MkaHandleEventsApi_Conf</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>21912</sourceline>
      <version>1</version>
      <description>
        &lt;ul&gt;
          &lt;li&gt;Name:               MkaHandleEventsApi&lt;/li&gt;
          &lt;li&gt;Parent Container:   MkaGeneral&lt;/li&gt;
          &lt;li&gt;Description:        Enables Mka_HandleEvents() API which allows external source to request processing of received Mka events.&lt;/li&gt;
          &lt;li&gt;Multiplicity:       1&lt;/li&gt;
          &lt;li&gt;Type:               EcucBooleanParamDef&lt;/li&gt;
          &lt;li&gt;Default value:      FALSE&lt;/li&gt;
          &lt;li&gt;
              Value Configuration Class:
              &lt;ul&gt;
                &lt;li&gt;Pre-compile time: X All Variants&lt;/li&gt;
                &lt;li&gt;Link time:        - -&lt;/li&gt;
                &lt;li&gt;Post-build time:  - -&lt;/li&gt;
              &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Scope / Dependency: scope: local&lt;/li&gt;
        &lt;/ul&gt;
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_2907</srcid><srcstatus/><internalId>946</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0124.InterruptMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>976</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1467</internalId></specobject>
    <specobject>
      <id>Mka.EB.MkaUsePresharedIckKek_Conf</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>21947</sourceline>
      <version>1</version>
      <description>
        &lt;ul&gt;
          &lt;li&gt;Name:               MkaUsePresharedIckKek&lt;/li&gt;
          &lt;li&gt;Parent Container:   MkaGeneral&lt;/li&gt;
          &lt;li&gt;Description:        Enables use of pre-shared ICK and KEK instead of deriving it from CAK.&lt;/li&gt;
          &lt;li&gt;Multiplicity:       1&lt;/li&gt;
          &lt;li&gt;Type:               EcucBooleanParamDef&lt;/li&gt;
          &lt;li&gt;Default value:      FALSE&lt;/li&gt;
          &lt;li&gt;
              Value Configuration Class:
              &lt;ul&gt;
                &lt;li&gt;Pre-compile time: X All Variants&lt;/li&gt;
                &lt;li&gt;Link time:        - -&lt;/li&gt;
                &lt;li&gt;Post-build time:  - -&lt;/li&gt;
              &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Scope / Dependency: scope: local&lt;/li&gt;
        &lt;/ul&gt;
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_2946</srcid><srcstatus/><internalId>947</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0124.PresharedIckKek</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>977</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1468</internalId></specobject>
    <specobject>
      <id>Mka.EB.MkaStopTxAnnouncementAfterCipherSelected_Conf</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>21982</sourceline>
      <version>1</version>
      <description>
        &lt;ul&gt;
          &lt;li&gt;Name:               MkaStopTxAnnouncementAfterCipherSelected&lt;/li&gt;
          &lt;li&gt;Parent Container:   MkaGeneral&lt;/li&gt;
          &lt;li&gt;Description:        Stops transmission of Announcement parameter set, once cipher suite has been selected.&lt;/li&gt;
          &lt;li&gt;Multiplicity:       1&lt;/li&gt;
          &lt;li&gt;Type:               EcucBooleanParamDef&lt;/li&gt;
          &lt;li&gt;Default value:      FALSE&lt;/li&gt;
          &lt;li&gt;
              Value Configuration Class:
              &lt;ul&gt;
                &lt;li&gt;Pre-compile time: X All Variants&lt;/li&gt;
                &lt;li&gt;Link time:        - -&lt;/li&gt;
                &lt;li&gt;Post-build time:  - -&lt;/li&gt;
              &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Scope / Dependency: scope: local&lt;/li&gt;
        &lt;/ul&gt;
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_2819</srcid><srcstatus/><internalId>943</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0107.CipherSuiteSelection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>959</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1469</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Mka.Init_NotInitialized</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>22019</sourceline>
      <version>1</version>
      <description>
        During initialization of MKA, if Lib unit's function Mka_Lib_Init return E_NOT_OK, MKA is not initialized, and E_NOT_OK is returned.
      </description>
      <verifycrit>
        Test case:
          1) Set stub EthIf_UpdatePhysAddrFilter.Retval to return E_NOT_OK.
          2) Call Mka_Init().
          3) Verify that Mka_Lib_Init returned E_NOT_OK and call Mka_MainFunction.
          4) Verify that unit MainFunctions aren't called, and that DirtyFlag is still TRUE.
          5) Verify that Mka_Init() returned E_NOT_OK.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_UnitTest01051_Init_Failed</srcid><srcstatus/><internalId>2310</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1470</internalId></specobject>
    <specobject>
      <id>Mka.dsn.MkaExt.HandleEventsApi.MkaNotInitialized</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>22040</sourceline>
      <version>1</version>
      <description>
        When Mka_HandleEvents() API is enabled and called before MKA module is successfully initialized, the call shall be silently ignored.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_UnitTest01053_HandleEvents_MkaNotInitialized</srcid><srcstatus/><internalId>2312</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0124.InterruptMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>976</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1471</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Mka.IsValidConfig_NullPtr</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>22059</sourceline>
      <version>1</version>
      <description>
        When Mka_IsValidConfig receives ConfigPtr that is NULL_PTR, it shall return E_NOT_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_UnitTest01052_IsValidConfig_NullPtr</srcid><srcstatus/><internalId>2311</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1472</internalId></specobject>
    <specobject>
      <id>Mka.EB.MkaSecYCallout</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>22072</sourceline>
      <version>1</version>
      <description>
        When MkaSecYCallout is configured, Mka shall call as soon as possible configured callout function when
        requests asynchronous operation from SecY.
      </description>
      <verifycrit>
        Test case:
          1) Define User MkaSecYCallout callout function and set it up in configuration.
          2) Disable MkaSecYAddRxSaSync and MkaSecYAddTxSaSync.
          3) Go through CP state machine.
          4) Check that user defined MkaSecYCallout function is called after these function call:
              - EthIf_MacSecUpdateSecY
              - EthIf_MacSecAddRxSa
              - EthIf_MacSecAddTxSa
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Cp_UnitTest01004_CpSM_Ready2Retire</srcid><srcstatus/><internalId>1816</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01011_CpSM_Uninit2Unsecured</srcid><srcstatus/><internalId>1823</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0124.InterruptMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>976</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0115.CallbackFunctions</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>967</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1473</internalId></specobject>
    <specobject>
      <id>Mka.EB.MkaTaskCallout</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>22106</sourceline>
      <version>1</version>
      <description>
        When MkaTaskCallout is configured, Mka shall call as soon as possible configured callout function when
        MKA receives asynchronous notification from SecY or Csm.
      </description>
      <verifycrit>
        Test case 1 - SecY context:
          1) Define User MkaTaskCallout callout function and set it up in configuration.
          2) Disable MkaSecYAddRxSaSync and MkaSecYAddTxSaSync.
          3) Call any of these function Mka_MacSecUpdateSecYNotification, Mka_MacSecAddTxSaNotification and Mka_MacSecAddRxSaNotification.
          4) Verify that user defined MkaTaskCallout function is called as part of these function.
        Test case 2 - Csm context (ICV, ICK, KEK and Random):
          1) Define User MkaTaskCallout callout function and set it up in configuration.
          2) Configure Crypto as Asynchronous.
          3) Go through generation of these key: ICV, ICK or KEK, and random.
          4) Verify that user defined MkaTaskCallout function is called in the context of Callback function.
          5) Verify that user defined MkaTaskCallout function is called for random generation only if RandomGenerate was
             successful or failed, if needs to generate more data, then MkaTaskCallout function isn't called.
        Test case 3 - Csm context (SAK):
          1) Define User MkaTaskCallout callout function and set it up in configuration.
          2) Configure Crypto as Asynchronous.
          3) Go through generation of SAK key.
          4) Verify that user defined MkaTaskCallout function is called in the context of Hash Callback function.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01003_KSPLow_KSActor</srcid><srcstatus/><internalId>1691</internalId></linkedfrom><linkedfrom><srcid>Mka_ConTest01038_DelayMacSecOperation_NoPlainText</srcid><srcstatus/><internalId>1727</internalId></linkedfrom><linkedfrom><srcid>Mka_ConTest01039_DelayMacSecOperation_NoPlainText_2</srcid><srcstatus/><internalId>1728</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0124.InterruptMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>976</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0115.CallbackFunctions</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>967</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1474</internalId></specobject>
    <specobject>
      <id>Mka.EB.MkaReportEventCallout</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>22149</sourceline>
      <version>1</version>
      <description>
        When MkaReportEventCallout is configured and one of production errors defined in [CP_SWS_Mka_00200] .. [CP_SWS_Mka_00203] is
        detected, Mka shall call configured callout function to report an event.
      </description>
      <verifycrit>
        Configure ReportEvent callout function and create scenarios described in verification criteria of requirements
        [Mka.CP_SWS_Mka_00033] .. [CP_SWS_Mka_00036] and verify that the callout function is called with expected parameters.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01035_Dem_SetEventStatus</srcid><srcstatus/><internalId>2225</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0115.CallbackFunctions</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>967</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0118.ProductionErrors</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>970</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1475</internalId></specobject>
    <specobject>
      <id>Mka.EB.MkaReportEventCallout_Prototype</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>22177</sourceline>
      <version>1</version>
      <description>
        &lt;ul&gt;
          &lt;li&gt;Service Name:       User_MkaReportEventCallout&lt;/li&gt;
          &lt;li&gt;Syntax:             void User_ReportEvent(uint8 EventType, boolean EventStatus, uint8 MkaPaeIdx, uint16 MkaPortIdentifier, uint8 const * const Ckn, uint8 CknLength)&lt;/li&gt;
          &lt;li&gt;Sync/Async:         Synchronous&lt;/li&gt;
          &lt;li&gt;Reentrancy:         Non-reentrant&lt;/li&gt;
          &lt;li&gt;Parameters (in):    uint8 EventType - Event type as defined in [Mka.EB.MkaReportEventCallout_EventType]&lt;/li&gt;
          &lt;li&gt;Parameters (in):    boolean EventStatus - TRUE - event is present, FALSE - event is not present&lt;/li&gt;
          &lt;li&gt;Parameters (in):    uint8 MkaPaeIdx - Index of a PAE for which an event is reported&lt;/li&gt;
          &lt;li&gt;Parameters (in):    uint16 MkaPortIdentifier - A unique identifier within a system that forms SCI together with port MAC address&lt;/li&gt;
          &lt;li&gt;Parameters (in):    uint8 const * const Ckn - Pointer to Participant's CKN for which an event is reported, NULL_PTR if CKN is not available&lt;/li&gt;
          &lt;li&gt;Parameters (in):    uint8 CknLength - The size of CKN in bytes, 0 if CKN is not available&lt;/li&gt;
          &lt;li&gt;Parameters (inout): None&lt;/li&gt;
          &lt;li&gt;Parameters (out):   None&lt;/li&gt;
          &lt;li&gt;
            Description:          Configurable user callout used to report production errors (events).
          &lt;/li&gt;
          &lt;li&gt;Available via:      Mka.h when MkaReportEventCallout configuration parameter is enabled.&lt;/li&gt;
        &lt;/ul&gt;
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/Mka_Types.h_170</srcid><srcstatus/><internalId>526</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0115.CallbackFunctions</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>967</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1476</internalId></specobject>
    <specobject>
      <id>Mka.EB.MkaReportEventCallout_EventType</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>22213</sourceline>
      <version>1</version>
      <description>
        The following bit-flags shall be used as EventType parameter of user report event callout function. They can be used combined
        when clearing.

        |-----------------------------------------------------------------------------------------------------------------|
        |                 Type of error                              | Related error code               |   Error value   |
        |-----------------------------------------------------------------------------------------------------------------|
        | Event indicating that CAK or ICK or KEK are not present    | MKA_REPORT_EVENT_KEY_NOT_PRESENT |      0x01       |
        |-----------------------------------------------------------------------------------------------------------------|
        | Event indicating that ICV verification or key unwrap fails | MKA_REPORT_EVENT_KEY_MISMATCH    |      0x02       |
        |-----------------------------------------------------------------------------------------------------------------|
        | Event indicating that participant's partner only supports  | MKA_REPORT_EVENT_ALGO_MISMATCH   |      0x04       |
        | incompatible cipher suites                                 |                                  |                 |
        |-----------------------------------------------------------------------------------------------------------------|
        | Event indicating that permissive timer has expired         | MKA_REPORT_EVENT_TIMEOUT         |      0x08       |
        |-----------------------------------------------------------------------------------------------------------------|

        The values shall be available as macro constants in Mka_Types.h when User_MkaReportEventCallout is available.

      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/Mka_Types.h_41</srcid><srcstatus/><internalId>514</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/include/Mka_Types.h_167</srcid><srcstatus/><internalId>525</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01035_Dem_SetEventStatus</srcid><srcstatus/><internalId>2225</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0115.CallbackFunctions</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>967</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1477</internalId></specobject>
    <specobject>
      <id>Mka.EB.RunTimeEvent.BitFieldDefinition</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>22251</sourceline>
      <version>1</version>
      <description>
        Layout of bits for events that are participant base:
        &lt;ul&gt;
          &lt;li&gt;Bit  0 - ICK generation failed.&lt;/li&gt;
          &lt;li&gt;Bit  1 - Random generate failed.&lt;/li&gt;
          &lt;li&gt;Bit  2 - TxBuffer allocation failed.&lt;/li&gt;
          &lt;li&gt;Bit  3 - ICV generation failed.&lt;/li&gt;
          &lt;li&gt;Bit  4 - RxBuffer allocation failed.&lt;/li&gt;
          &lt;li&gt;Bit  5 - Received MKPDU has invalid format.&lt;/li&gt;
          &lt;li&gt;Bit  6 - ICV verification failed.&lt;/li&gt;
          &lt;li&gt;Bit  7 - Participant found Live peer.&lt;/li&gt;
          &lt;li&gt;Bit  8 - KEK generation failed.&lt;/li&gt;
          &lt;li&gt;Bit  9 - Participant became principal actor.&lt;/li&gt;
          &lt;li&gt;Bit 10 - SAK generation and wrapping failed.&lt;/li&gt;
          &lt;li&gt;Bit 11 - SAK unwrapping failed.&lt;/li&gt;
          &lt;li&gt;Bit 12 - Peer lifetime timer expired.&lt;/li&gt;
        &lt;/ul&gt;
        Layout of bits for events that are PAE based:
        &lt;ul&gt;
          &lt;li&gt;Bit 0 - Received MKPDU contain invalid CKN.&lt;/li&gt;
          &lt;li&gt;Bit 1 - SecY Api triggered retry.&lt;/li&gt;
          &lt;li&gt;Bit 2 - Retry counter maximum value has been exceeded.&lt;/li&gt;
          &lt;li&gt;Bit 3 - CP state machine has received new SAK.&lt;/li&gt;
          &lt;li&gt;Bit 4 - MacSec Operational set to TRUE for specific PAE.&lt;/li&gt;
          &lt;li&gt;Bit 5 - Link state down signal received for a port.&lt;/li&gt;
        &lt;/ul&gt;
      </description>
      <furtherinfo>
        WRN.swuts.needscoverage.count  - Linking all tests to the single top-level requirement brings clear benefits and splitting
        them up would only increase complexity without any real improvements.
      </furtherinfo>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/Mka_Int.h_373</srcid><srcstatus/><internalId>513</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01004_KSPHigh_KSPartner</srcid><srcstatus/><internalId>1692</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01003_CpSM_Receiving2Transmitting</srcid><srcstatus/><internalId>1815</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01013_CpSM_WaitAddRxSa2Unsecured</srcid><srcstatus/><internalId>1825</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01021_CpSM_WaitAddRxSa2WaitRxSc_PortEnabled</srcid><srcstatus/><internalId>1833</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01041_SecYRetry_CpSmUpdateSecY</srcid><srcstatus/><internalId>1850</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01059_SecYRetry_Fail_CpSmUpdateSecY</srcid><srcstatus/><internalId>1868</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01004_SetPrincipalActor</srcid><srcstatus/><internalId>2074</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01006_RandomGenerateFinished_E_NOT_OK</srcid><srcstatus/><internalId>2076</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01009_NoBuffer</srcid><srcstatus/><internalId>2078</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01018_InstSM_RunningSelfTransition</srcid><srcstatus/><internalId>2086</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01053_SakGenWrap_Fail_CC</srcid><srcstatus/><internalId>2121</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01054_SakUnwrap_CC</srcid><srcstatus/><internalId>2122</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01097_KeySm_SelfTransit_GenerateKek</srcid><srcstatus/><internalId>2165</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01099_PeerSM_KaYPrincipalActor</srcid><srcstatus/><internalId>2167</internalId></linkedfrom><linkedfrom><srcid>Mka_Logon_UnitTest01005_LogonIckGenerateFinished_PrincipalFalse</srcid><srcstatus/><internalId>2195</internalId></linkedfrom><linkedfrom><srcid>Mka_RxTx_UnitTest01013_ValidateMkpdu_InvalidCkn</srcid><srcstatus/><internalId>2327</internalId></linkedfrom><linkedfrom><srcid>Mka_RxTx_UnitTest01015_ValidateMkpdu_IcvVerification</srcid><srcstatus/><internalId>2329</internalId></linkedfrom><linkedfrom><srcid>Mka_RxTx_UnitTest01016_RxIndication_GetRxBufferFail</srcid><srcstatus/><internalId>2330</internalId></linkedfrom><linkedfrom><srcid>Mka_RxTx_UnitTest01019_GetTxBuffer_UnexpectedState</srcid><srcstatus/><internalId>2333</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0119.RunTimeEvents</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>971</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1478</internalId></specobject>
    <specobject>
      <id>Mka.EB.RunTimeEvent.TriggeredEventParticipant</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>22299</sourceline>
      <version>1</version>
      <description>
        Triggering of an event on a participant level shall be stored in a respective participant bit-field variable
        according to [Mka.EB.RunTimeEvent.BitFieldDefinition].
      </description>
      <furtherinfo>
        WRN.swuts.needscoverage.count  - Linking all tests to the single top-level requirement brings clear benefits and splitting
        them up would only increase complexity without any real improvements.
      </furtherinfo>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/Mka_Int.h_357</srcid><srcstatus/><internalId>511</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01004_SetPrincipalActor</srcid><srcstatus/><internalId>2074</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01006_RandomGenerateFinished_E_NOT_OK</srcid><srcstatus/><internalId>2076</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01009_NoBuffer</srcid><srcstatus/><internalId>2078</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01018_InstSM_RunningSelfTransition</srcid><srcstatus/><internalId>2086</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01053_SakGenWrap_Fail_CC</srcid><srcstatus/><internalId>2121</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01054_SakUnwrap_CC</srcid><srcstatus/><internalId>2122</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01097_KeySm_SelfTransit_GenerateKek</srcid><srcstatus/><internalId>2165</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01099_PeerSM_KaYPrincipalActor</srcid><srcstatus/><internalId>2167</internalId></linkedfrom><linkedfrom><srcid>Mka_Logon_UnitTest01005_LogonIckGenerateFinished_PrincipalFalse</srcid><srcstatus/><internalId>2195</internalId></linkedfrom><linkedfrom><srcid>Mka_RxTx_UnitTest01015_ValidateMkpdu_IcvVerification</srcid><srcstatus/><internalId>2329</internalId></linkedfrom><linkedfrom><srcid>Mka_RxTx_UnitTest01016_RxIndication_GetRxBufferFail</srcid><srcstatus/><internalId>2330</internalId></linkedfrom><linkedfrom><srcid>Mka_RxTx_UnitTest01019_GetTxBuffer_UnexpectedState</srcid><srcstatus/><internalId>2333</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0119.RunTimeEvents</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>971</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1479</internalId></specobject>
    <specobject>
      <id>Mka.EB.RunTimeEvent.TriggeredEventPae</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>22324</sourceline>
      <version>1</version>
      <description>
        Triggering of an event on a PAE level shall be stored in a respective PAE bit-field variable
        according to [Mka.EB.RunTimeEvent.BitFieldDefinition].
      </description>
      <furtherinfo>
        WRN.swuts.needscoverage.count  - Linking all tests to the single top-level requirement brings clear benefits and splitting
        them up would only increase complexity without any real improvements.
      </furtherinfo>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/Mka_Int.h_365</srcid><srcstatus/><internalId>512</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01004_KSPHigh_KSPartner</srcid><srcstatus/><internalId>1692</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01003_CpSM_Receiving2Transmitting</srcid><srcstatus/><internalId>1815</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01013_CpSM_WaitAddRxSa2Unsecured</srcid><srcstatus/><internalId>1825</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01021_CpSM_WaitAddRxSa2WaitRxSc_PortEnabled</srcid><srcstatus/><internalId>1833</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01041_SecYRetry_CpSmUpdateSecY</srcid><srcstatus/><internalId>1850</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01059_SecYRetry_Fail_CpSmUpdateSecY</srcid><srcstatus/><internalId>1868</internalId></linkedfrom><linkedfrom><srcid>Mka_RxTx_UnitTest01013_ValidateMkpdu_InvalidCkn</srcid><srcstatus/><internalId>2327</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0119.RunTimeEvents</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>971</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1480</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Cp.CpSM.Unsecured.Testing</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>22349</sourceline>
      <version>1</version>
      <description>
        Transition to CP_UNSECURED from ANY other state occurs as described in [Mka.dsn.Cp.CpSM.Unsecured].
      </description>
      <furtherinfo>
        WRN.swuts.needscoverage.count  - Linking all tests to the single top-level requirement brings clear benefits and splitting
        them up would only increase complexity without any real improvements.
      </furtherinfo>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Cp_UnitTest01011_CpSM_Uninit2Unsecured</srcid><srcstatus/><internalId>1823</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01012_CpSM_WaitRxSc2Unsecured</srcid><srcstatus/><internalId>1824</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01013_CpSM_WaitAddRxSa2Unsecured</srcid><srcstatus/><internalId>1825</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01014_CpSM_WaitAddTxSa2Unsecured</srcid><srcstatus/><internalId>1826</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01015_CpSM_Receiving2Unsecured</srcid><srcstatus/><internalId>1827</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01016_CpSM_Ready2Unsecured</srcid><srcstatus/><internalId>1828</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01017_CpSM_Transmitting2Unsecured</srcid><srcstatus/><internalId>1829</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01018_CpSM_Retire2Unsecured</srcid><srcstatus/><internalId>1830</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01077_CpSM_UpdateSecY2Unsecured</srcid><srcstatus/><internalId>1886</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01078_CpSM_InitRxSc2Unsecured</srcid><srcstatus/><internalId>1887</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01079_CpSM_Secured2Unsecured</srcid><srcstatus/><internalId>1888</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Unsecured</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1394</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1481</internalId></specobject>
    <specobject>
      <id>Mka.EB.MkaEmptyDistributedSakUseEnabled_Conf</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>22372</sourceline>
      <version>1</version>
      <description>
        &lt;ul&gt;
          &lt;li&gt;Name:               MkaEmptyDistributedSakUseEnabled&lt;/li&gt;
          &lt;li&gt;Parent Container:   MkaGeneral&lt;/li&gt;
          &lt;li&gt;Description:        Enables use of an empty Distributed SAK and SAK Use parameter sets when MACsec is disabled.&lt;/li&gt;
          &lt;li&gt;Multiplicity:       1&lt;/li&gt;
          &lt;li&gt;Type:               EcucBooleanParamDef&lt;/li&gt;
          &lt;li&gt;Default value:      FALSE&lt;/li&gt;
          &lt;li&gt;
              Value Configuration Class:
              &lt;ul&gt;
                &lt;li&gt;Pre-compile time: X All Variants&lt;/li&gt;
                &lt;li&gt;Link time:        - -&lt;/li&gt;
                &lt;li&gt;Post-build time:  - -&lt;/li&gt;
              &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Scope / Dependency: scope: local&lt;/li&gt;
        &lt;/ul&gt;
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_2088</srcid><srcstatus/><internalId>911</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0120.MacSecDisabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>972</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1482</internalId></specobject>
    <specobject>
      <id>Mka.EB.Net_Sec_2156</id>
      <status>approved</status>
      <source>LH10833648_Ethernet_Network_Security_v6</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>22407</sourceline>
      <version>1</version>
      <description>
        &lt;ul&gt;
          &lt;li&gt;Name:               MkaDelayMacSecOperationalTimer&lt;/li&gt;
          &lt;li&gt;Parent Container:   MkaGeneral&lt;/li&gt;
          &lt;li&gt;Description:        When MacSec is Disabled, a time [s] to send signal to UL that MacSec is Operational.&lt;/li&gt;
          &lt;li&gt;Multiplicity:       1&lt;/li&gt;
          &lt;li&gt;Type:               EcucFloatParamDef&lt;/li&gt;
          &lt;li&gt;Range:              [0 .. INF]&lt;/li&gt;
          &lt;li&gt;Default value:      0&lt;/li&gt;
          &lt;li&gt;
              Value Configuration Class:
              &lt;ul&gt;
                &lt;li&gt;Pre-compile time: X All Variants&lt;/li&gt;
                &lt;li&gt;Link time:        - -&lt;/li&gt;
                &lt;li&gt;Post-build time:  - -&lt;/li&gt;
              &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Scope / Dependency: scope: local&lt;/li&gt;
        &lt;/ul&gt;
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Logon.c_1085</srcid><srcstatus/><internalId>759</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_1917</srcid><srcstatus/><internalId>904</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.Net_Sec_2158</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1484</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1483</internalId></specobject>
    <specobject>
      <id>Mka.EB.Net_Sec_2158</id>
      <status>approved</status>
      <source>LH10833648_Ethernet_Network_Security_v6</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>22443</sourceline>
      <version>1</version>
      <description>
        When MacSec is disabled and MkaDelayMacSecOperationalTimer is configured to a value higher than 0, MacSec Operational
        signal shall be sent to UL after the timeout of MkaDelayMacSecOperationalTimer and a successful MKA exchange.
        The timer is started when the LinkState Active is signaled.
      </description>
      <verifycrit>
        Test cases:
          1. Verify that when MkaDelayMacSecOperationalTimer is zero, MacSec Operational is signaled as described in
             Mka.dsn.Func0120.MacSecDisabled.
          2. Verify that when MkaDelayMacSecOperationalTimer is not zero and no other participant (than our's) exists, MacSec Operational
             is not signaled after the timer ticks out. Then, receive a valid MKPDU from another peer and check that MacSecOperational is
             signaled to UL. For this test case, don't use EmptySak.
          3. Verify that when MkaDelayMacSecOperationalTimer is not zero, live peer exists and EmptySak is used, MacSec Operational
             is signaled only after timeout.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.EB.Net_Sec_2156</srcid><srcstatus/><internalId>1483</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Cp.c_1978</srcid><srcstatus/><internalId>561</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01037_DelayMacSecOperation_EmptySak</srcid><srcstatus/><internalId>1726</internalId></linkedfrom><linkedfrom><srcid>Mka_ConTest01038_DelayMacSecOperation_NoPlainText</srcid><srcstatus/><internalId>1727</internalId></linkedfrom><linkedfrom><srcid>Mka_ConTest01039_DelayMacSecOperation_NoPlainText_2</srcid><srcstatus/><internalId>1728</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01018_CpSM_Retire2Unsecured</srcid><srcstatus/><internalId>1830</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0120.MacSecDisabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>972</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1484</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd" title="Cp Unit - Functionality requirements">
    <specobject>
      <id>Mka.dsn.Cp.PacketNumber.SakUseLPn</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>22481</sourceline>
      <version>1</version>
      <description>
        When SakUse parameter set is being sent, LPn shall be calculated based on the value of NextPN and ReplayProtectionWindow.
      </description>
      <verifycrit>
        Verify that EthIf_MacSecGetTxSaNextPn is called during filling of SakUse param. set (call for API Mka_Cp_FillSakUse).
        Calculated LPn in SakUse param.set shall equal:
          - value of '1' if NextPn is lower than ReplayProtectionWindow
          - value of 'NextPn - ReplayProtectionWindow' if NextPN is higher than ReplayProtectionWindow
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Cp_UnitTest01027_FillSakUse</srcid><srcstatus/><internalId>1839</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0114.PacketNumbering</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>966</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1485</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Cp.MacSecOperational.LinkStateDown</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>22506</sourceline>
      <version>1</version>
      <description>
        When Mka_Cp_LinkStateDown is called, it shall call EthIf_MacSecOperational to notify EthIf that MacSec is not operational.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Cp_UnitTest01021_CpSM_WaitAddRxSa2WaitRxSc_PortEnabled</srcid><srcstatus/><internalId>1833</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0110.MacSecOperational</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>962</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1486</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Cp.MacSecOperational.Unsecured</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>22525</sourceline>
      <version>1</version>
      <description>
        When Cp SM enters the state CP_UNSECURED and after SecY is successfully updated to disable MACsec on a link,
        EthIf_MacSecOperational(TRUE) shall be called to signal upper communication layers to start communicating.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01026_PlainText_Peer</srcid><srcstatus/><internalId>1715</internalId></linkedfrom><linkedfrom><srcid>Mka_ConTest01027_PlainText_Peer_Permissive</srcid><srcstatus/><internalId>1716</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01011_CpSM_Uninit2Unsecured</srcid><srcstatus/><internalId>1823</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01013_CpSM_WaitAddRxSa2Unsecured</srcid><srcstatus/><internalId>1825</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01014_CpSM_WaitAddTxSa2Unsecured</srcid><srcstatus/><internalId>1826</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0110.MacSecOperational</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>962</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1487</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Cp.KeysReset</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>22545</sourceline>
      <version>1</version>
      <description>
        Cp unit shall reset Hash and SAK key to zero after it passes it to SecY in EthIf_MacSecAddTxSa API.
      </description>
      <verifycrit>
        Verify that keys are zero after function EthIf_MacSecAddTxSa() call.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Cp_UnitTest01034_CorrectKeys</srcid><srcstatus/><internalId>1846</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1488</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Cp.ExtendedPacketNumber.Salt</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>22561</sourceline>
      <version>1</version>
      <description>
        Cp unit shall calculate Salt and pass it to SecY in EthIf_MacSecAddTxSa and EthIf_MacSecAddRxSa APIs.
      </description>
      <verifycrit>
        Verify that correctly calculated Salt key is provided to EthIf_MacSecAddTxSa and EthIf_MacSecAddRxSa APIs.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Cp.c_2722</srcid><srcstatus/><internalId>566</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Cp_UnitTest01033_SaltKey</srcid><srcstatus/><internalId>1845</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.dsn.Cp.ExtendedPacketNumber.Salt.Calculation</srcid><srcstatus/><internalId>1490</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0113.Xpn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>965</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1489</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Cp.ExtendedPacketNumber.Salt.Calculation</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>22585</sourceline>
      <version>1</version>
      <description>
        Salt shall be calculated as following:
            The 64 least significant bits of the Salt are the 64 least significant bits of the MKA Key Servers
            Member Identifier (MI), the 16 next most significant bits of the Salt comprise the exclusive-or of the 16 next
            most significant bits of that MI with the 16 most significant bits of the 32-bit MKA Key Number (KN), and
            the 16 most significant bits of the Salt comprise the exclusive-or of the 16 most significant bits of that MI
            with the 16 least significant bits of the KN. This way of obtaining a Salt is not necessarily applicable to any
            other key agreement protocol.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Cp.c_2834</srcid><srcstatus/><internalId>567</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.ExtendedPacketNumber.Salt</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1489</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0113.Xpn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>965</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1490</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Cp.ExtendedPacketNumber.XPN</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>22614</sourceline>
      <version>1</version>
      <description>
        Cp unit shall acquire 32 most significant bits of extended packet number from received XPN parameter set if
        XPN cipher suite is used.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Cp.c_2918</srcid><srcstatus/><internalId>570</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Cp_UnitTest01092_L_XLPn_RxMkpdu</srcid><srcstatus/><internalId>1901</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01093_O_XLPn_RxMkpdu</srcid><srcstatus/><internalId>1902</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0113.Xpn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>965</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1491</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Cp.ExtendedPacketNumber.PnRecovery</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>22635</sourceline>
      <version>1</version>
      <description>
        Cp unit shall provide service via which an received extended LPn's 32 most significant bits will be recovered when
        XPN parameter set is not present in the received MKPDU, in a following way:
        The 32 most significant bits of the PN are recovered for each received frame by applying the assumption that
        they have remained unchanged since their use in the frame with the lowest acceptable PNunless the most
        significant of the 32 least significant bits of the lowest acceptable PN is set and the corresponding bit of the
        received PN is not set, in which case the value of the 32 most significant bits of the PN is one more than the
        value of the 32 most significant bits of the lowest acceptable PN.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Cp.c_2917</srcid><srcstatus/><internalId>569</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Cp_UnitTest01032_L_XLPn_Recovery</srcid><srcstatus/><internalId>1844</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01036_O_XLPn_Recovery</srcid><srcstatus/><internalId>1848</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0113.Xpn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>965</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1492</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Cp.BypassEtherType.Empty</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>22661</sourceline>
      <version>1</version>
      <description>
        In case that MkaBypassEtherType container is empty, i.e. no Ethernet type bypass rules are configured for a specific KaY instance,
        EthIf_MacSecUpdateSecY() shall be called with BypassedEtherTypesLength set to 0 and BypassedEtherTypesPtr set to NULL pointer.
      </description>
      <verifycrit>
        Create configuration where MkaBypassEtherType container is empty for ALL configured KaYs and verify that EthIf_MacSecUpdateSecY()
        is called as specified in aforementioned requirement.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Cp_UnitTest01037_NoBypass</srcid><srcstatus/><internalId>1849</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0113.Xpn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>965</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0116.BypassRules</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>968</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1493</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Cp.BypassVlan.Empty</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>22689</sourceline>
      <version>1</version>
      <description>
        In case that MkaBypassVlan container is empty, i.e. no VLAN bypass rules are configured for a specific KaY instance,
        EthIf_MacSecUpdateSecY() shall be called with BypassedVlansLength set to 0 and BypassedVlanPtrs set to NULL pointer.
      </description>
      <verifycrit>
        Create configuration where MkaBypassVlan container is empty for ALL configured KaYs and verify that EthIf_MacSecUpdateSecY()
        is called as specified in aforementioned requirement.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Cp_UnitTest01037_NoBypass</srcid><srcstatus/><internalId>1849</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0113.Xpn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>965</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0116.BypassRules</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>968</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1494</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Cp.FillSakUse.NoKeys</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>22717</sourceline>
      <version>1</version>
      <description>
        Cp unit shall ignore the call to Mka_Cp_FillSakUse when neither the Latest nor Old key is active.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Cp_UnitTest01035_NoKeys</srcid><srcstatus/><internalId>1847</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1495</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Cp.FillXpn.NoKeys</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>22730</sourceline>
      <version>1</version>
      <description>
        Cp unit shall ignore the call to Mka_Cp_FillXpn when neither the Latest nor Old key is active.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Cp_UnitTest01035_NoKeys</srcid><srcstatus/><internalId>1847</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1496</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Cp.Retry</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>22743</sourceline>
      <version>1</version>
      <description>
        When SecY API returns E_NOT_OK, Mka shall retry the call in the next Mka_MainFunction() tick. The maximum number of
        retries shall be defined in the configuration parameter MkaSecYRetryAttempts.
      </description>
      <furtherinfo>
        WRN.swuts.needscoverage.count  - Linking all tests to the single top-level requirement brings clear benefits and splitting
        them up would only increase complexity without any real improvements.
      </furtherinfo>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Cp_UnitTest01041_SecYRetry_CpSmUpdateSecY</srcid><srcstatus/><internalId>1850</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01042_SecYRetry_CpSmInitRxSc</srcid><srcstatus/><internalId>1851</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01043_SecYRetry_CpSmWaitAddRxSa</srcid><srcstatus/><internalId>1852</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01044_SecYRetry_CpSmWaitAddTxSa</srcid><srcstatus/><internalId>1853</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01045_SecYRetry_CpSmTransmitting_Step0</srcid><srcstatus/><internalId>1854</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01046_SecYRetry_CpSmTransmitting_Step1</srcid><srcstatus/><internalId>1855</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01047_SecYRetry_CpSmTransmitting_Step2</srcid><srcstatus/><internalId>1856</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01048_SecYRetry_CpSmRetire_Step0</srcid><srcstatus/><internalId>1857</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01049_SecYRetry_CpSmRetire_Step1</srcid><srcstatus/><internalId>1858</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01050_SecYRetry_CpSmUnsecured_Step0</srcid><srcstatus/><internalId>1859</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01051_SecYRetry_CpSmUnsecured_Step1</srcid><srcstatus/><internalId>1860</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01052_SecYRetry_CpSmDelete_Step0</srcid><srcstatus/><internalId>1861</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01053_SecYRetry_CpSmDelete_Step1</srcid><srcstatus/><internalId>1862</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01054_SecYRetry_CpSmDelete_Step2</srcid><srcstatus/><internalId>1863</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01055_SecYRetry_CpSmDelete_Step3</srcid><srcstatus/><internalId>1864</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01056_SecYRetry_CpSmDelete_Step4</srcid><srcstatus/><internalId>1865</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01057_SecYRetry_CpSmDelete_Step5</srcid><srcstatus/><internalId>1866</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01058_SecYRetry_CpSmDelete_Step6</srcid><srcstatus/><internalId>1867</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0117.SecYRetry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>969</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1497</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Cp.Retry.NotRequired</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>22767</sourceline>
      <version>1</version>
      <description>
        Retry functionality is not required for functions EthIf_MacSecUpdateRxSa() and EthIf_MacSecOperational().
        Rationale: These functions are called when new MKPDU is received from a partner. Since MKPDUs are periodically exchanged,
                   there is no need to implement retry calls since it will be anyway retried with the next received MKPDU.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Cp.c_1570</srcid><srcstatus/><internalId>550</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Cp_UnitTest01083_UpdateRxSa_Fail</srcid><srcstatus/><internalId>1892</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0117.SecYRetry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>969</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1498</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Cp.CpSM.Retry.CleanUp</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>22789</sourceline>
      <version>1</version>
      <description>
        When single SecY API fails for more then MkaSecYRetryAttempts times, the clean-up procedure shall be executed for that SecY:
        &lt;ul&gt;
          &lt;li&gt;MacSecOperational shall be reported FALSE.&lt;/li&gt;
          &lt;li&gt;Controlled port shall be disabled.&lt;/li&gt;
          &lt;li&gt;Receive security channel shall be deleted (if active).&lt;/li&gt;
          &lt;li&gt;Latest and Old security associations shall be deleted (if active).&lt;/li&gt;
          &lt;li&gt;Logon shall be notified by calling Mka_Logon_Pae_Restart() in order to restart participants.&lt;/li&gt;
        &lt;/ul&gt;
      </description>
      <furtherinfo>
        WRN.swuts.needscoverage.count  - Linking all tests to the single top-level requirement brings clear benefits and splitting
        them up would only increase complexity without any real improvements.
      </furtherinfo>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Cp_UnitTest01059_SecYRetry_Fail_CpSmUpdateSecY</srcid><srcstatus/><internalId>1868</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01060_SecYRetry_Fail_CpSmInitRxSc</srcid><srcstatus/><internalId>1869</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01061_SecYRetry_Fail_CpSmWaitAddRxSa</srcid><srcstatus/><internalId>1870</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01062_SecYRetry_Fail_CpSmWaitAddTxSa</srcid><srcstatus/><internalId>1871</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01063_SecYRetry_Fail_CpSmTransmitting_Step0</srcid><srcstatus/><internalId>1872</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01064_SecYRetry_Fail_CpSmTransmitting_Step1</srcid><srcstatus/><internalId>1873</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01065_SecYRetry_Fail_CpSmTransmitting_Step2</srcid><srcstatus/><internalId>1874</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01066_SecYRetry_Fail_CpSmRetire_Step0</srcid><srcstatus/><internalId>1875</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01067_SecYRetry_Fail_CpSmRetire_Step1</srcid><srcstatus/><internalId>1876</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01068_SecYRetry_Fail_CpSmUnsecured_Step0</srcid><srcstatus/><internalId>1877</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01069_SecYRetry_Fail_CpSmUnsecured_Step1</srcid><srcstatus/><internalId>1878</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01070_SecYRetry_Fail_CpSmDelete_Step0</srcid><srcstatus/><internalId>1879</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01071_SecYRetry_Fail_CpSmDelete_Step1</srcid><srcstatus/><internalId>1880</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01072_SecYRetry_Fail_CpSmDelete_Step2</srcid><srcstatus/><internalId>1881</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01073_SecYRetry_Fail_CpSmDelete_Step3</srcid><srcstatus/><internalId>1882</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01074_SecYRetry_Fail_CpSmDelete_Step4</srcid><srcstatus/><internalId>1883</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01075_SecYRetry_Fail_CpSmDelete_Step5</srcid><srcstatus/><internalId>1884</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01076_SecYRetry_Fail_CpSmDelete_Step6</srcid><srcstatus/><internalId>1885</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0117.SecYRetry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>969</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1499</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Cp.CpSM.Retry</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>22819</sourceline>
      <version>1</version>
      <description>
        Retry functionality shall be supported for all SecY API call in the following states of CP state machine:
        &lt;ul&gt;
          &lt;li&gt;CP_UPDATE_SECY&lt;/li&gt;
          &lt;li&gt;CP_INIT_RX_SC&lt;/li&gt;
          &lt;li&gt;CP_WAIT_ADD_RX_SA&lt;/li&gt;
          &lt;li&gt;CP_WAIT_ADD_TX_SA&lt;/li&gt;
          &lt;li&gt;CP_TRANSMITTING&lt;/li&gt;
          &lt;li&gt;CP_RETIRE&lt;/li&gt;
          &lt;li&gt;CP_UNSECURED&lt;/li&gt;
          &lt;li&gt;CP_DELETE&lt;/li&gt;
        &lt;/ul&gt;
      </description>
      <furtherinfo>
        WRN.swuts.needscoverage.count  - Linking all tests to the single top-level requirement brings clear benefits and splitting
        them up would only increase complexity without any real improvements.
      </furtherinfo>
      <verifycrit>
        Drive CpSM to enter each of aforementioned states. For each state check the list of SecY API calls as specified in CpSM
        (marked with step_xx).

        Test case 1: For each state configure stubs of all SecY APIs to return E_NOT_OK for the maximum configured number of retries and
                     E_OK afterwards.
                     Verify that API calls are correctly repeated and state transition is successfully completed at the end.
        Test case 2: For each state configure stubs of each SecY APIs to return E_NOT_OK for one above the maximum configured number of
                     retries.
                     Verify that clean-up procedure is executed according to [Mka.dsn.Cp.Retry.CleanUp] and CpSM has transitioned into
                     CP_UNINIT state.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Cp_UnitTest01041_SecYRetry_CpSmUpdateSecY</srcid><srcstatus/><internalId>1850</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01042_SecYRetry_CpSmInitRxSc</srcid><srcstatus/><internalId>1851</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01043_SecYRetry_CpSmWaitAddRxSa</srcid><srcstatus/><internalId>1852</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01044_SecYRetry_CpSmWaitAddTxSa</srcid><srcstatus/><internalId>1853</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01045_SecYRetry_CpSmTransmitting_Step0</srcid><srcstatus/><internalId>1854</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01046_SecYRetry_CpSmTransmitting_Step1</srcid><srcstatus/><internalId>1855</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01047_SecYRetry_CpSmTransmitting_Step2</srcid><srcstatus/><internalId>1856</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01048_SecYRetry_CpSmRetire_Step0</srcid><srcstatus/><internalId>1857</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01049_SecYRetry_CpSmRetire_Step1</srcid><srcstatus/><internalId>1858</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01050_SecYRetry_CpSmUnsecured_Step0</srcid><srcstatus/><internalId>1859</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01051_SecYRetry_CpSmUnsecured_Step1</srcid><srcstatus/><internalId>1860</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01052_SecYRetry_CpSmDelete_Step0</srcid><srcstatus/><internalId>1861</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01053_SecYRetry_CpSmDelete_Step1</srcid><srcstatus/><internalId>1862</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01054_SecYRetry_CpSmDelete_Step2</srcid><srcstatus/><internalId>1863</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01055_SecYRetry_CpSmDelete_Step3</srcid><srcstatus/><internalId>1864</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01056_SecYRetry_CpSmDelete_Step4</srcid><srcstatus/><internalId>1865</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01057_SecYRetry_CpSmDelete_Step5</srcid><srcstatus/><internalId>1866</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01058_SecYRetry_CpSmDelete_Step6</srcid><srcstatus/><internalId>1867</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01059_SecYRetry_Fail_CpSmUpdateSecY</srcid><srcstatus/><internalId>1868</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01060_SecYRetry_Fail_CpSmInitRxSc</srcid><srcstatus/><internalId>1869</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01061_SecYRetry_Fail_CpSmWaitAddRxSa</srcid><srcstatus/><internalId>1870</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01062_SecYRetry_Fail_CpSmWaitAddTxSa</srcid><srcstatus/><internalId>1871</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01063_SecYRetry_Fail_CpSmTransmitting_Step0</srcid><srcstatus/><internalId>1872</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01064_SecYRetry_Fail_CpSmTransmitting_Step1</srcid><srcstatus/><internalId>1873</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01065_SecYRetry_Fail_CpSmTransmitting_Step2</srcid><srcstatus/><internalId>1874</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01066_SecYRetry_Fail_CpSmRetire_Step0</srcid><srcstatus/><internalId>1875</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01067_SecYRetry_Fail_CpSmRetire_Step1</srcid><srcstatus/><internalId>1876</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01068_SecYRetry_Fail_CpSmUnsecured_Step0</srcid><srcstatus/><internalId>1877</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01069_SecYRetry_Fail_CpSmUnsecured_Step1</srcid><srcstatus/><internalId>1878</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01070_SecYRetry_Fail_CpSmDelete_Step0</srcid><srcstatus/><internalId>1879</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01071_SecYRetry_Fail_CpSmDelete_Step1</srcid><srcstatus/><internalId>1880</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01072_SecYRetry_Fail_CpSmDelete_Step2</srcid><srcstatus/><internalId>1881</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01073_SecYRetry_Fail_CpSmDelete_Step3</srcid><srcstatus/><internalId>1882</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01074_SecYRetry_Fail_CpSmDelete_Step4</srcid><srcstatus/><internalId>1883</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01075_SecYRetry_Fail_CpSmDelete_Step5</srcid><srcstatus/><internalId>1884</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01076_SecYRetry_Fail_CpSmDelete_Step6</srcid><srcstatus/><internalId>1885</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0117.SecYRetry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>969</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1500</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Cp.CpSM.NewSak</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>22864</sourceline>
      <version>1</version>
      <description>
        Mka_Cp_NewSak shall not make any Cp SM state transitions if called from any state other than:
        &lt;ul&gt;
          &lt;li&gt;CP_SECURED&lt;/li&gt;
          &lt;li&gt;CP_RETIRE&lt;/li&gt;
          &lt;li&gt;CP_READY&lt;/li&gt;
          &lt;li&gt;CP_RECEIVING&lt;/li&gt;
        &lt;/ul&gt;
      </description>
      <verifycrit>
        Test case: Call Mka_Cp_NewSak API from any other different state than the mentioned ones and verify that no state transitions
                   have been made.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Cp_UnitTest01002_CpSM_Secured2WaitAddTxSa</srcid><srcstatus/><internalId>1814</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0117.SecYRetry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>969</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1501</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Cp.PacketNumber.UpdateLPn</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>22894</sourceline>
      <version>1</version>
      <description>
        When SakUse parameter set is received from alive peer, Cp unit shall update SecY's LPn by calling API EthIf_MacSecUpdateRxSa if actor
        is receiving with that Sa.
      </description>
      <verifycrit>
        Verify that EthIf_MacSecUpdateRxSa is called with LPn from received SakUse param. set after SakUse was received from alive peer.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Cp_UnitTest01003_CpSM_Receiving2Transmitting</srcid><srcstatus/><internalId>1815</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Cp.c_1571</srcid><srcstatus/><internalId>551</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0114.PacketNumbering</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>966</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1502</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Cp.CpSM.Any_2_Uninit</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>22918</sourceline>
      <version>1</version>
      <description>
        When Retry functionality is disabled and SecY API returns E_NOT_OK, it shall transit into state CP_UNINIT.
      </description>
      <verifycrit>
        1) Configure parameter MkaSecYRetryAttempts that is zero.
        2) Configure SecY stub to return E_NOT_OK.
        3) From valid state call SecY API that is configured to return E_NOT_OK.
        4) Verify that CP  made transition into state CP_UNINIT.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Cp_UnitTest01084_SecYRetry_Disabled_CpSmUpdateSecY</srcid><srcstatus/><internalId>1893</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01085_SecYRetry_Disabled_CpSmInitRxSc</srcid><srcstatus/><internalId>1894</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01086_SecYRetry_Disabled_CpSmWaitAddRxSa</srcid><srcstatus/><internalId>1895</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01087_SecYRetry_Disabled_CpSmWaitAddTxSa</srcid><srcstatus/><internalId>1896</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01088_SecYRetry_Disabled_CpSmTransmitting</srcid><srcstatus/><internalId>1897</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01089_SecYRetry_Disabled_CpSmRetire</srcid><srcstatus/><internalId>1898</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01090_SecYRetry_Disabled_CpSmUnsecured</srcid><srcstatus/><internalId>1899</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01091_SecYRetry_Disabled_CpSmDelete</srcid><srcstatus/><internalId>1900</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1097</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1503</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Cp.DisableSAsBeforeDelete</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>22943</sourceline>
      <version>1</version>
      <description>
        Disable active TA and RX security associations before deleting.
        Rationale: During testing with different transceiver driver implementations it was noticed that some of them require security
                   associations (SAs) to be disabled before deleting, hence the requirement to improve interoperability.
      </description>
      <verifycrit>
        1) Configure parameter MkaSecYRetryAttempts that is zero.
        2) Configure SecY stub to return E_NOT_OK.
        3) From valid state call SecY API that is configured to return E_NOT_OK.
        4) Verify that CP  made transition into state CP_UNINIT.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Cp_UnitTest01006_CpSM_Ready2Retire_2ndLoop</srcid><srcstatus/><internalId>1818</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01008_CpSM_Ready2WaitAddRxSa</srcid><srcstatus/><internalId>1820</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01010_CpSM_Receiving2WaitAddRxSa</srcid><srcstatus/><internalId>1822</internalId></linkedfrom><linkedfrom><srcid>Mka_Cp_UnitTest01013_CpSM_WaitAddRxSa2Unsecured</srcid><srcstatus/><internalId>1825</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Cp.c_2396</srcid><srcstatus/><internalId>562</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Mka_Cp.c_2428</srcid><srcstatus/><internalId>563</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Mka_Cp.c_2459</srcid><srcstatus/><internalId>564</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Mka_Cp.c_2490</srcid><srcstatus/><internalId>565</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1504</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Cp.ImmediatePeerResponse.EmptySakUse</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>22965</sourceline>
      <version>1</version>
      <description>
        For the use case when MACsec is not desired and use of empty parameter sets is enabled (MkaEmptyDistributedSakUseEnabled = TRUE),
        Mka shall immediately transmit MKPDU in case SecY is successfully updated to bypass all traffic (MACsec is disabled).
        This feature is optionally enabled with MkaEnableImmediatePeerResponse.
      </description>
      <verifycrit>
        1) In configuration, enable parameter MkaEnableImmediatePeerResponse and MkaEmptyDistributedSakUseEnabled.
        2) Bring CP state machine into CP_UNSECURED state.
        3) After Mka_Cp_MacSecUpdateSecYNotification() is received, verify that MKPDU transmission is requested.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01031_MacSecDisabled_PlainText_Peer</srcid><srcstatus/><internalId>1720</internalId></linkedfrom><linkedfrom><srcid>Mka_ConTest01032_MacSecDisabled_PlainText_KeyServer</srcid><srcstatus/><internalId>1721</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Cp.c_1893</srcid><srcstatus/><internalId>560</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0121.ImmediateResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>973</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1505</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd" title="Crypto Unit - Functionality requirements">
    <specobject>
      <id>Mka.dsn.Crypto.Api.IckGenerateAsync.E_OK</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>22997</sourceline>
      <version>1</version>
      <description>
        When Mka_Crypto_IckGenerateAsync() is called for instance with CAK and CKN ready and key generate state is idle Crypto shall call
        Csm_KeyElementGet to get CKN and prepare input values for key generator, set the dirty flag and return E_OK.
      </description>
      <verifycrit>
        * It shall be verified that the CKN value extracted with Csm_KeyElementGet is used when preparing input values for key generation.
        * It shall be verified that the Csm_KeyElementGet is called with the correct keyId corresponding to the CKN configured keyId.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01010_KekIckGen_Async128</srcid><srcstatus/><internalId>1914</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1506</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.Api.IckGenerateAsync.SynDone</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>23015</sourceline>
      <version>1</version>
      <description>
        When Mka_Crypto_IckGenerateAsync() is called for synchronous processing with correct values the next Mka mainfunction shall
        finish the key generation and call Mka_Logon_IckGenerateFinished() with Result E_OK and corresponding MkaId.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01011_KekIckGen_Sync128</srcid><srcstatus/><internalId>1915</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1507</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.Api.IckGenerateAsync.AsynDone</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>23029</sourceline>
      <version>1</version>
      <description>
        When Mka_CsmKeyGenerateCallback() is called with result E_OK for asynchronous instance that has key generation ongoing
        Crypto shall call Mka_Logon_IckGenerateFinished() with Result E_OK and corresponding MkaId.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01010_KekIckGen_Async128</srcid><srcstatus/><internalId>1914</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1508</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.Api.IckGenerate.Retry</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>23043</sourceline>
      <version>1</version>
      <description>
        Csm_MacGenerate() shall be called again, if Csm module returns BUSY status and MkaCryptoRetryAttempts &amp;gt; 0.
        The crypto shall return E_OK and retry the key generation in the next call of Mka_Crypto_MainFunction().
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01126_IckGen_Retry</srcid><srcstatus/><internalId>2021</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1509</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.Api.IckGenerate.RetryDisabled</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>23057</sourceline>
      <version>1</version>
      <description>
        Csm_MacGenerate() shall not be called again, if Csm module returns BUSY status and MkaCryptoRetryAttempts = 0.
        The crypto shall return E_NOT_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01128_IckGen_Retry_Disabled</srcid><srcstatus/><internalId>2023</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1510</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.Api.IckGenerate.RetryAttempts</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>23071</sourceline>
      <version>1</version>
      <description>
        Crypto unit shall retry the key generation MkaCryptoRetryAttempts times before it calls
        the Mka_Logon_IckGenerateFinished() with result E_NOT_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01127_IckGen_Retry_Fail</srcid><srcstatus/><internalId>2022</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1511</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.Api.KekGenerateAsync.E_OK</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>23085</sourceline>
      <version>1</version>
      <description>
        When Mka_Crypto_KekGenerateAsync() is called for instance with ICK ready and key generate state is idle Crypto shall call
        Csm_KeyElementGet to get CKN and prepare input values for key generator, set the dirty flag and return E_OK.
      </description>
      <verifycrit>
        * It shall be verified that the CKN value extracted with Csm_KeyElementGet is used when preparing input values for key generation.
        * It shall be verified that the Csm_KeyElementGet is called with the correct keyId corresponding to the CKN configured keyId.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01010_KekIckGen_Async128</srcid><srcstatus/><internalId>1914</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1512</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.Api.KekGenerateAsync.SynDone</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>23103</sourceline>
      <version>1</version>
      <description>
        When Mka_Crypto_KekGenerateAsync() is called for synchronous processing with correct values the next Mka mainfunction shall
        finish the key generation and call Mka_KaY_KekGenerateFinished() with Result E_OK and corresponding MkaId.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01011_KekIckGen_Sync128</srcid><srcstatus/><internalId>1915</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1513</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.Api.KekGenerateAsync.AsynDone</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>23117</sourceline>
      <version>1</version>
      <description>
        When Mka_CsmKeyGenerateCallback() is called with result E_OK for asynchronous instance that has key generation ongoing
        Crypto shall call Mka_KaY_KekGenerateFinished() with Result E_OK and corresponding MkaId.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01010_KekIckGen_Async128</srcid><srcstatus/><internalId>1914</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1514</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.Api.KekGenerate.Retry</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>23131</sourceline>
      <version>1</version>
      <description>
        Csm_MacGenerate() shall be called again, if Csm module returns BUSY status and MkaCryptoRetryAttempts &amp;gt; 0.
        The crypto shall return E_OK and retry the key generation in the next call of Mka_Crypto_MainFunction().
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01129_KekGen_Retry</srcid><srcstatus/><internalId>2024</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1515</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.Api.KekGenerate.RetryDisabled</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>23145</sourceline>
      <version>1</version>
      <description>
        Csm_MacGenerate() shall not be called again, if Csm module returns BUSY status and MkaCryptoRetryAttempts = 0.
        The crypto shall return E_NOT_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01131_KekGen_Retry_Disabled</srcid><srcstatus/><internalId>2026</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1516</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.Api.KekGenerate.RetryAttempts</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>23159</sourceline>
      <version>1</version>
      <description>
        Crypto unit shall retry the key generation MkaCryptoRetryAttempts times before it calls
        the Mka_KaY_KekGenerateFinished() with result E_NOT_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01130_KekGen_Retry_Fail</srcid><srcstatus/><internalId>2025</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1517</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.Api.IcvVerifyAsync.E_OK</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>23173</sourceline>
      <version>1</version>
      <description>
        When Mka_Crypto_IcvVerifyAsync() is called with valid input parameters for instance that has ICK ready Crypto shall save
        the data pointer and data length set the dirty flag and return E_OK.
      </description>
      <verifycrit>
        * It shall be verified that the data and length passed to the Crypto unit is used to verify the ICV.
        * It shall be verified that Crypto correctly calculates the offset of ICV for verification.
        * It shall be verified that Crypto uses the correct Csm_MacVerify jobId that is configured (mainfunction triggers Csm_MacVerify).
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01039_IcvVerify_Async128</srcid><srcstatus/><internalId>1943</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1518</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.Api.IcvVerifyAsync.SynDone</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>23192</sourceline>
      <version>1</version>
      <description>
        When Mka_Crypto_IcvVerifyAsync() is called for synchronous processing with correct values the next Mka mainfunction shall
        finish the ICV verification and call Mka_RxTx_IcvVerifyFinished() with Result E_OK and corresponding MkaId.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01040_IcvVerify_Sync128</srcid><srcstatus/><internalId>1944</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1519</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.Api.IcvVerifyAsync.AsynDone</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>23206</sourceline>
      <version>1</version>
      <description>
        When Mka_CsmIcvVerifyCallback() is called with result E_OK for asynchronous instance that has ICV verification ongoing
        Crypto shall call Mka_RxTx_IcvVerifyFinished() with Result E_OK and corresponding MkaId.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01039_IcvVerify_Async128</srcid><srcstatus/><internalId>1943</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1520</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.Api.IcvVerify.Retry</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>23220</sourceline>
      <version>1</version>
      <description>
        Csm_MacVerify() shall be called again, if Csm module returns BUSY status and MkaCryptoRetryAttempts &amp;gt; 0.
        The crypto shall return E_OK and retry the ICV verification in the next call of Mka_Crypto_MainFunction().
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01116_IcvVerify_Retry</srcid><srcstatus/><internalId>2011</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1521</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.Api.IcvVerify.RetryDisabled</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>23234</sourceline>
      <version>1</version>
      <description>
        When Mka_Crypto_IcvVerifyAsync is called if Csm module returns busy and MkaCryptoRetryAttempts = 0
        the crypto shall return E_NOT_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01118_IcvVerify_Retry_Disabled</srcid><srcstatus/><internalId>2013</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1522</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.Api.IcvVerify.RetryAttempts</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>23248</sourceline>
      <version>1</version>
      <description>
        Crypto unit shall retry the ICV verification MkaCryptoRetryAttempts times before it calls
        the Mka_RxTx_IcvVerifyFinished() with result E_NOT_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01117_IcvVerify_Retry_Fail</srcid><srcstatus/><internalId>2012</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1523</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.Api.IcvGenerateAsync.ValidParam</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>23262</sourceline>
      <version>1</version>
      <description>
        When Mka_Crypto_IcvGenerateAsync() is called with valid input parameters for instance that has ICK ready, Crypto shall save
        the data pointer and data lengths and call Csm_MacGenerate().
      </description>
      <verifycrit>
        * It shall be verified that the data and length passed to the Crypto unit is used to generate the ICV.
        * It shall be verified that Crypto saves the generated ICV at the end of the data passed to the Crypto unit.
        * It shall be verified that Crypto uses correct Csm_MacGenerate jobId that is configured.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01015_IcvGen_Sync128</srcid><srcstatus/><internalId>1919</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1524</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.Api.IcvGenerateAsync.SynDone</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>23281</sourceline>
      <version>2</version>
      <description>
        When Mka_Crypto_IcvGenerateAsync() is called for synchronous processing with correct values, Mka_RxTx_IcvGenerateFinished() shall
        be called in the same context indicating the result of ICV generation.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01015_IcvGen_Sync128</srcid><srcstatus/><internalId>1919</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1525</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.Api.IcvGenerateAsync.AsynDone</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>23295</sourceline>
      <version>1</version>
      <description>
        When Mka_CsmIcvGenerateCallback() is called with result E_OK for asynchronous instance that has ICV generation ongoing
        Crypto shall call Mka_RxTx_IcvGenerateFinished() with Result E_OK and corresponding MkaId.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01119_IcvGen_Retry_Async</srcid><srcstatus/><internalId>2014</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1526</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.Api.IcvGenerateAsync.E_NOT_OK</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>23309</sourceline>
      <version>1</version>
      <description>
        When Mka_Crypto_IcvGenerateAsync() is called with valid input parameters for instance that has ICK ready Crypto, but there is not
        enough space in buffer to write ICV, Mka_Crypto_IcvGenerateAsync() shall return E_NOT_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01049_IcvGen_TooSmallBuffer</srcid><srcstatus/><internalId>1953</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1527</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.Api.IcvGenerate.Retry</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>23323</sourceline>
      <version>1</version>
      <description>
        Csm_MacGenerate() shall be called again, if Csm module returns BUSY status and MkaCryptoRetryAttempts &amp;gt; 0.
        The crypto shall return E_OK and retry the ICV generation in the next call of Mka_Crypto_MainFunction().
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01119_IcvGen_Retry_Async</srcid><srcstatus/><internalId>2014</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01120_IcvGen_Retry_Sync</srcid><srcstatus/><internalId>2015</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1528</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.Api.IcvGenerate.RetryDisabled</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>23337</sourceline>
      <version>1</version>
      <description>
        When Mka_Crypto_IcvGenerateAsync is called if Csm module returns busy and MkaCryptoRetryAttempts = 0
        the crypto shall return E_NOT_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01122_IcvGen_Retry_Disabled</srcid><srcstatus/><internalId>2017</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1529</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.Api.IcvGenerate.RetryAttempts</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>23351</sourceline>
      <version>1</version>
      <description>
        Crypto unit shall retry the ICV generation MkaCryptoRetryAttempts times before it calls
        the Mka_RxTx_IcvGenerateFinished() with result E_NOT_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01121_IcvGen_Retry_Fail</srcid><srcstatus/><internalId>2016</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1530</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.Api.RandomGenerateAsync.E_OK</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>23365</sourceline>
      <version>1</version>
      <description>
        When Mka_Crypto_RandomGenerateAsync() is called for instance with idle random generate state Crypto shall set the dirty flag and
        return E_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01009_RandomGen_Sync128</srcid><srcstatus/><internalId>1913</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1531</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.Api.RandomGenerateAsync.SynDone</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>23379</sourceline>
      <version>1</version>
      <description>
        When Mka_Crypto_RandomGenerateAsync() is called for synchronous processing with correct values the next Mka mainfunction shall
        finish the random value generation and call Mka_KaY_RandomGenerateFinished() with Result E_OK, corresponding MkaId and random value.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01009_RandomGen_Sync128</srcid><srcstatus/><internalId>1913</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1532</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.Api.RandomGenerateAsync.AsynDone</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>23393</sourceline>
      <version>1</version>
      <description>
        When Mka_CsmRandomCallback() is called with result E_OK for asynchronous instance that has random value generation ongoing
        Crypto shall call Mka_KaY_RandomGenerateFinished() with Result E_OK, corresponding MkaId and random value.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01008_RandomGen_Async128</srcid><srcstatus/><internalId>1912</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1533</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.Api.RandomGenerate.Retry</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>23407</sourceline>
      <version>1</version>
      <description>
        Csm_RandomGenerate() shall be called again, if Csm module returns BUSY status and MkaCryptoRetryAttempts &amp;gt; 0.
        The crypto shall return E_OK and retry the random generation in the next call of Mka_Crypto_MainFunction().
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01113_RandomGen_Retry</srcid><srcstatus/><internalId>2008</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01114_RandomGen_Retry_Fail</srcid><srcstatus/><internalId>2009</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1534</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.Api.RandomGenerate.RetryDisabled</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>23421</sourceline>
      <version>1</version>
      <description>
        Csm_RandomGenerate() shall not be called again, if Csm module returns BUSY status and MkaCryptoRetryAttempts = 0.
        The crypto shall return E_NOT_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01115_RandomGen_Retry_Disabled</srcid><srcstatus/><internalId>2010</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1535</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.Api.RandomGenerate.RetryAttempts</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>23435</sourceline>
      <version>1</version>
      <description>
        Crypto unit shall retry the random generation MkaCryptoRetryAttempts times before it calls
        the Mka_KaY_RandomGenerateFinished() with result E_NOT_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01114_RandomGen_Retry_Fail</srcid><srcstatus/><internalId>2009</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1536</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.Api.RandomGenerate.CsmGranularity</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>23449</sourceline>
      <version>1</version>
      <description>
        Crypto unit shall repeat the calling Csm_RandomGenerate until it gets requested amount of random data
        or number of attempts is greater than MkaCryptoRandomGenerateMaxBufferSize assuming minimum granularity of one byte.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Crypto_Rng.c_143</srcid><srcstatus/><internalId>599</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Mka_Crypto_Rng.c_310</srcid><srcstatus/><internalId>600</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01008_RandomGen_Async128</srcid><srcstatus/><internalId>1912</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01009_RandomGen_Sync128</srcid><srcstatus/><internalId>1913</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01052_SakGenWrap_Async256</srcid><srcstatus/><internalId>1956</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01053_SakGenWrap_Sync256</srcid><srcstatus/><internalId>1957</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1537</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.Api.GetCknPtr.E_OK</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>23464</sourceline>
      <version>1</version>
      <description>
        When Mka_Crypto_GetCknPtr() is called for a valid instance Crypto shall return the CKN pointer from cache, length and E_OK.
      </description>
      <verifycrit>
        * It shall be verified that Mka_Crypto_GetCknPtr() returned correct configured CKN.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01038_GetCknPtr_E_OK</srcid><srcstatus/><internalId>1942</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01093_InvalidCkn3</srcid><srcstatus/><internalId>1988</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1538</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.Api.GetCknPtr.E_NOT_OK</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>23480</sourceline>
      <version>1</version>
      <description>
        When Mka_Crypto_GetCknPtr() is called with valid Participant index, but CKN isn't stored in cache, because Csm_KeyElementGet()
        couldn't get CKN, Crypto shall return E_NOT_OK.
      </description>
      <verifycrit>
        It shall be verified that Mka_Crypto_GetCknPtr() return E_NOT_OK, if in cached CknSize equal zero for given ParticipantIdx.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01084_GetCkn_128_Fail</srcid><srcstatus/><internalId>1981</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1539</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.Api.CopyCkn.CknNotStored</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>23497</sourceline>
      <version>1</version>
      <description>
        When Mka_Crypto_CopyCkn() is called with valid Participant index, but CKN isn't stored in cache, because Csm_KeyElementGet()
        couldn't get CKN, Crypto shall store in CknSizePtr a value zero.
      </description>
      <verifycrit>
        Create a stub callout for Csm_KeyElementGet(), so that for one participant doesn't store CKN and store in CknSize zero.
        Verify that after function Mka_Crypto_CopyCkn() call for that participant return value of CknSizePtr equal zero.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01037_GetCknPtr_KeyNotAvailable</srcid><srcstatus/><internalId>1941</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1540</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.Api.SakGenWrap.SakGenRetry</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>23515</sourceline>
      <version>1</version>
      <description>
        Sak generate shall be attempted again, if Csm module returns BUSY status and MkaCryptoRetryAttempts &amp;gt; 0.
        The crypto shall return E_OK and retry the key generation in the next call of Mka_Crypto_MainFunction().
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01132_SakGenWrap_Retry</srcid><srcstatus/><internalId>2027</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01135_HashGen_Retry_Fail</srcid><srcstatus/><internalId>2030</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1541</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.Api.SakGenWrap.SakWrapRetry</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>23529</sourceline>
      <version>1</version>
      <description>
        Sak wrap shall attempt the same step again, if Csm module returns BUSY status and MkaCryptoRetryAttempts &amp;gt; 0.
        The crypto shall return E_OK and retry the same key wrapping step in the next call of Mka_Crypto_MainFunction().
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01132_SakGenWrap_Retry</srcid><srcstatus/><internalId>2027</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01135_HashGen_Retry_Fail</srcid><srcstatus/><internalId>2030</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1542</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.Api.SakGenWrap.HashRetry</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>23543</sourceline>
      <version>1</version>
      <description>
        Hash generation shall be attempted again, if Csm module returns BUSY status and MkaCryptoRetryAttempts &amp;gt; 0.
        The crypto shall return E_OK and retry the hash generation in the next call of Mka_Crypto_MainFunction().
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01132_SakGenWrap_Retry</srcid><srcstatus/><internalId>2027</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1543</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.Api.SakGenWrap.SakGenRetryDisabled</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>23557</sourceline>
      <version>1</version>
      <description>
        Sak generation shall not be attempted again, if Csm module returns BUSY status and MkaCryptoRetryAttempts = 0.
        The crypto shall return E_NOT_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01136_SakGen_Retry_Disabled</srcid><srcstatus/><internalId>2031</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1544</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.Api.SakGenWrap.SakWrapRetryDisabled</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>23571</sourceline>
      <version>1</version>
      <description>
        Sak wrap shall not be attempted again, if Csm module returns BUSY status and MkaCryptoRetryAttempts = 0.
        The crypto shall return E_NOT_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01137_SakWrap_Retry_Disabled</srcid><srcstatus/><internalId>2032</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1545</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.Api.SakGenWrap.HashRetryDisabled</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>23585</sourceline>
      <version>1</version>
      <description>
        Hash shall not be attempted again, if Csm module returns BUSY status and MkaCryptoRetryAttempts = 0.
        The crypto shall return E_NOT_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01138_HashGen_Retry_Disabled</srcid><srcstatus/><internalId>2033</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1546</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.Api.SakGenWrap.SakGenRetryAttempts</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>23599</sourceline>
      <version>1</version>
      <description>
        Crypto unit shall retry the key generation MkaCryptoRetryAttempts times before it calls
        the Mka_KaY_SakGenWrapFinished() with result E_NOT_OK.
      </description>
      <comment>
        Sak generation, wrapping and hash generate together have a total of MkaCryptoRetryAttempts number of attempts
        (e.g. if the Sak generation returns busy, wrap and hash will have fewer attempts
        in the event that busy is returned during those steps).
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01133_SakGen_Retry_Fail</srcid><srcstatus/><internalId>2028</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1547</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.Api.SakGenWrap.SakWrapRetryAttempts</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>23618</sourceline>
      <version>1</version>
      <description>
        Crypto unit shall retry the key wrap MkaCryptoRetryAttempts times before it calls
        the Mka_KaY_SakGenWrapFinished() with result E_NOT_OK.
      </description>
      <comment>
        Sak generation, wrapping and hash generate together have a total of MkaCryptoRetryAttempts number of attempts
        (e.g. if the Sak generation returns busy, wrap and hash will have fewer attempts
        in the event that busy is returned during those steps).
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01134_SakWrap_Retry_Fail</srcid><srcstatus/><internalId>2029</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1548</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.Api.SakGenWrap.HashRetryAttempts</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>23637</sourceline>
      <version>1</version>
      <description>
        Crypto unit shall retry the hash generation MkaCryptoRetryAttempts times before it calls
        the Mka_KaY_SakGenWrapFinished() with result E_NOT_OK.
      </description>
      <comment>
        Sak generation, wrapping and hash generate together have a total of MkaCryptoRetryAttempts number of attempts
        (e.g. if the Sak generation returns busy, wrap and hash will have fewer attempts
        in the event that busy is returned during those steps).
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01135_HashGen_Retry_Fail</srcid><srcstatus/><internalId>2030</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1549</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.Api.SakUnwrap.SakUnwrapRetry</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>23656</sourceline>
      <version>1</version>
      <description>
        Sak unwrap shall attempt the same step again, if Csm module returns BUSY status and MkaCryptoRetryAttempts &amp;gt; 0.
        The crypto shall return E_OK and retry the same key unwrapping step in the next call of Mka_Crypto_MainFunction().
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01139_SakUnwrapHash_Retry</srcid><srcstatus/><internalId>2034</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1550</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.Api.SakUnwrap.HashRetry</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>23670</sourceline>
      <version>1</version>
      <description>
        Hash generation shall be attempted again, if Csm module returns BUSY status and MkaCryptoRetryAttempts &amp;gt; 0.
        The crypto shall return E_OK and retry the hash generation in the next call of Mka_Crypto_MainFunction().
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01139_SakUnwrapHash_Retry</srcid><srcstatus/><internalId>2034</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1551</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.Api.SakUnwrap.SakUnwrapRetryDisabled</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>23684</sourceline>
      <version>1</version>
      <description>
        Sak unwrap shall not be attempted again, if Csm module returns BUSY status and MkaCryptoRetryAttempts = 0.
        The crypto shall return E_NOT_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01142_SakUnwrap_Retry_Disabled</srcid><srcstatus/><internalId>2037</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1552</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.Api.SakUnwrap.HashRetryDisabled</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>23698</sourceline>
      <version>1</version>
      <description>
        Hash shall not be attempted again, if Csm module returns BUSY status and MkaCryptoRetryAttempts = 0.
        The crypto shall return E_NOT_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01143_SakUnwrap_Hash_Retry_Disabled</srcid><srcstatus/><internalId>2038</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1553</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.Api.SakUnwrap.SakUnwrapRetryAttempts</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>23712</sourceline>
      <version>1</version>
      <description>
        Crypto unit shall retry the key unwrap MkaCryptoRetryAttempts times before it calls
        the Mka_KaY_SakUnwrapFinished() with result E_NOT_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01140_SakUnwrap_Retry_Fail</srcid><srcstatus/><internalId>2035</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1554</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.Api.SakUnwrap.HashRetryAttempts</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>23726</sourceline>
      <version>1</version>
      <description>
        Crypto unit shall retry the hash generation MkaCryptoRetryAttempts times before it calls
        the Mka_KaY_SakUnwrapFinished() with result E_NOT_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01141_SakUnwrap_Hash_Retry_Fail</srcid><srcstatus/><internalId>2036</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1555</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.CacheCkn</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>23740</sourceline>
      <version>1</version>
      <description>
        When Mka_Crypto_Init() is called, Crypto unit shall store CKNs for all participants into a cache.
      </description>
      <verifycrit>
        Check that after function call Mka_Crypto_Init(), Crypto unit shall call Csm_KeyElementGet() for
        number of participant (MKA_NUM_PARTICIPANTS).
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Crypto.c_706</srcid><srcstatus/><internalId>580</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01085_CacheCkn_128</srcid><srcstatus/><internalId>1982</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.ValidateKeys</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1559</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1556</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.ValidatePresharedIckKek</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>23764</sourceline>
      <version>1</version>
      <description>
        When pre-shared ICK and KEK are used (MkaUsePresharedIckKek == TRUE), Crypto shall validate both keys for each participant
        during initialization, by calling Csm_KeySetValid().
        If the check fails, it shall be reported to DEM with MKA_REPORT_EVENT_KEY_NOT_PRESENT event.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Crypto.c_731</srcid><srcstatus/><internalId>581</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Mka_Crypto.c_740</srcid><srcstatus/><internalId>582</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01163_ValidateIckKek_PresharedIckKek</srcid><srcstatus/><internalId>2058</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0124.PresharedIckKek</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>977</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.ValidateKeys</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1559</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1557</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.ValidateCAK</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>23790</sourceline>
      <version>1</version>
      <description>
        During the initialization of Crypto unit and in the case that the use of pre-shared ICK and KEK is disabled, CAK existence shall be
        verified by performing read access to it, i.e. Csm_KeyElementGet() shall be called.
        Key is available if Csm returns E_OK or CRYPTO_E_KEY_READ_FAIL (the former is retuned by HSM indicating that the key is available,
        but read is disabled).
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Crypto.c_683</srcid><srcstatus/><internalId>579</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01170_ValidateCakCkn_Retry</srcid><srcstatus/><internalId>2065</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.ValidateKeys</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1559</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1558</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.ValidateKeys</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>23813</sourceline>
      <version>1</version>
      <description>
        During the initialization of Crypto unit, MKA shall verify that the following keys are available and ready to use:
        1) CAK shall be validated as described in [Mka.dsn.Crypto.ValidateCAK].
        2) CKN shall be red and cached as described in [Mka.dsn.Crypto.CacheCkn].
        3) ICK and KEK shall be validated as described in [Mka.dsn.Crypto.ValidatePresharedIckKek].
        In case that key validation fails, i.e. Csm returns other then E_OK or E_BUSY, KEY_NOT_PRESENT event shall be raised.
      </description>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.dsn.Crypto.CacheCkn</srcid><srcstatus/><internalId>1556</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Crypto.ValidatePresharedIckKek</srcid><srcstatus/><internalId>1557</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Crypto.ValidateCAK</srcid><srcstatus/><internalId>1558</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1559</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.ValidateKeys.Retry</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>23830</sourceline>
      <version>1</version>
      <description>
        If during key validation as described in [Mka.dsn.Crypto.ValidateKeys] Csm returns E_BUSY, the call shall be retried in the next
        call of Mka_Crypto_MainFunction() if the number of retries did not exceed the threshold set in MkaCryptoRetryAttempts.
      </description>
      <verifycrit>
        Test case 1 (Precondition: MKA_USE_PRESHARED_ICK_KEK = STD_OFF)
          1) Configure Csm_KeyElementGet() to return CRYPTO_E_BUSY for CAK read for Participant_0 and Participant_2.
          2) Call Mka_Crypto_Init().
          3) Call Mka_Crypto_MainFunction().
          4) Verify that CAK and CKN access is repeated for Participant_0 and 2.
          5) Configure Csm_KeyElementGet() to return E_OK.
          6) Call Mka_Crypto_MainFunction() again.
          7) Verify that initialization of Participants 0 and 2 was successful.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Crypto.c_221</srcid><srcstatus/><internalId>573</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Mka_Crypto.c_755</srcid><srcstatus/><internalId>583</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01045_ValidateCakCkn_Retry</srcid><srcstatus/><internalId>1733</internalId></linkedfrom><linkedfrom><srcid>Mka_ConTest01047_ValidateCakCkn_Retry_CachedPrincipal</srcid><srcstatus/><internalId>1735</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01170_ValidateCakCkn_Retry</srcid><srcstatus/><internalId>2065</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01171_ValidateCakCkn_RetryFail</srcid><srcstatus/><internalId>2066</internalId></linkedfrom><linkedfrom><srcid>Mka_Crypto_UnitTest01172_ValidateIckKek_Retry</srcid><srcstatus/><internalId>2067</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1560</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Crypto.ValidateKeys.RetryDisabled</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>23855</sourceline>
      <version>1</version>
      <description>
        In case that number of retries performed according to [Mka.dsn.Crypto.ValidateKeys.Retry] exceeded the threshold, or retry feature
        is disabled (MkaCryptoRetryAttempts = 0), key validation shall not be retried and KEY_NOT_PRESENT event shall be raised.
      </description>
      <verifycrit>
        Test case 1 (Precondition: MKA_USE_PRESHARED_ICK_KEK = STD_OFF)
          1) Configure Csm_KeyElementGet() to return CRYPTO_E_BUSY for CAK read for Participant_0.
          2) Configure Csm_KeyElementGet() to return MKA_CRYPTO_IS_QUEUE_FULL for CKN read for Participant_1.
          3) Call Mka_Crypto_Init().
          4) Call Mka_Crypto_MainFunction() for MkaCryptoRetryAttempts - 1 times.
          5) Verify that Csm_KeyElementGet() is called again for Participant_0 and 1.
          6) Call Mka_Crypto_MainFunction() for one more time.
          7) Verify that KEY_NOT_PRESENT event is raised for both participants.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Crypto.c_778</srcid><srcstatus/><internalId>584</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01171_ValidateCakCkn_RetryFail</srcid><srcstatus/><internalId>2066</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1561</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd" title="KaY Unit - Functionality requirements">
    <specobject>
      <id>Mka.dsn.KaY.Api.CreateParticipant.E_NOT_OK</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>23885</sourceline>
      <version>1</version>
      <description>
        When Mka_KaY_CreateParticipant() is called for an instance that is not disabled, KaY shall return E_NOT_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01002_CreateParticipant</srcid><srcstatus/><internalId>2072</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1562</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.Api.CreateParticipant.E_OK</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>23898</sourceline>
      <version>1</version>
      <description>
        When Mka_KaY_CreateParticipant() is called for a disabled instance, KaY shall request generation of new random Member identifier
        by calling Mka_Crypto_RandomGenerateAsync() and return E_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01002_CreateParticipant</srcid><srcstatus/><internalId>2072</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1563</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.Api.SetPrincipalActor.E_OK</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>23912</sourceline>
      <version>1</version>
      <description>
        When Mka_KaY_SetPrincipalActor() is called for a participant that is not disabled, KaY shall trigger KeySM and return E_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01004_SetPrincipalActor</srcid><srcstatus/><internalId>2074</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1564</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.Api.SetPrincipalActor.E_NOT_OK</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>23925</sourceline>
      <version>1</version>
      <description>
        When Mka_KaY_SetPrincipalActor() is called for a participant that is not started (Mka_KaY_CreateParticipant() not yet called),
        KaY shall return E_NOT_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01004_SetPrincipalActor</srcid><srcstatus/><internalId>2074</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1565</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.Api.RandomGenerateFinished.Result_E_OK.MI</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>23939</sourceline>
      <version>1</version>
      <description>
        When Mka_KaY_RandomGenerateFinished() is called with Result == E_OK, KaY shall copy and use the number provided with RandomDataPtr
        as instance Member identifier (12 bytes long).
      </description>
      <verifycrit>
        It shall be verified that the number provided with Mka_KaY_RandomGenerateFinished() is used as Member identifier and present in
        transmitted MKPDUs.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01005_RandomGenerateFinished_E_OK</srcid><srcstatus/><internalId>2075</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1566</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.Api.RandomGenerateFinished.Result_E_OK.MN</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>23957</sourceline>
      <version>1</version>
      <description>
        When Mka_KaY_RandomGenerateFinished() is called with Result == E_OK, KaY shall reset Message number to 1 for specified instance.
      </description>
      <verifycrit>
        It shall be verified that the message number is set to 1 after Mka_KaY_RandomGenerateFinished() is called.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01005_RandomGenerateFinished_E_OK</srcid><srcstatus/><internalId>2075</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1567</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.Api.RandomGenerateFinished.Result_E_OK.FirstCall</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>23973</sourceline>
      <version>1</version>
      <description>
        When Mka_KaY_RandomGenerateFinished() is called with Result == E_OK, for the first time after instance was created, i.e. as a
        part of instance creation process, KaY shall immediately prepare and transmit the first MKPDU and start periodic TxMkpdu timer.
      </description>
      <verifycrit>
        - Test 1): It shall be verified that the first call of Mka_KaY_RandomGenerateFinished() after Mka_KaY_CreateParticipant() will
                   immediately transmit MKPDU and start periodic TxMkpdu timer.
        - Test 2): It shall be verified that subsequent calls of Mka_KaY_RandomGenerateFinished() will skip operations specified in this
                   requirement.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01005_RandomGenerateFinished_E_OK</srcid><srcstatus/><internalId>2075</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1568</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.Api.RandomGenerateFinished.Result_E_NOT_OK</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>23993</sourceline>
      <version>1</version>
      <description>
        When Mka_KaY_RandomGenerateFinished() is called with Result == E_NOT_OK, KaY shall disable the instance, stop timers and notify
        Logon unit with Mka_Logon_Participant_Disabled.
      </description>
      <comment>Not being able to obtain new Member identifier is unrecoverable MKA protocol error.</comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01006_RandomGenerateFinished_E_NOT_OK</srcid><srcstatus/><internalId>2076</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1569</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.TxMkpdu.GetTxBuffer.E_NOT_OK</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>24008</sourceline>
      <version>1</version>
      <description>
        When Mka_RxTx_GetTxBuffer() returns E_NOT_OK during new MKPDU assembly, KaY shall skip generating and sending MKPDU for that cycle, but
        shall retry it in the next MainFunction tick.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01009_NoBuffer</srcid><srcstatus/><internalId>2078</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1570</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.TxMkpdu.TxBufferReady.E_NOT_OK</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>24022</sourceline>
      <version>1</version>
      <description>
        When Mka_RxTx_TxBufferReady() returns E_NOT_OK during new MKPDU assembly, KaY shall skip generating and sending MKPDU for that cycle, but
        shall retry it in the next MainFunction tick.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01011_BufferNotReady</srcid><srcstatus/><internalId>2079</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1571</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.Api.TimerCallbackTxMkpdu.LivePeerNotFound</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>24036</sourceline>
      <version>1</version>
      <description>
        When Mka_KaY_TimerCallback_TxMkpdu() is called, the following should be done if Live peer isn't found:
        &lt;ul&gt;
          &lt;li&gt;Double the value of RetryBaseDelay, until it reaches the value of MkaRetryCyclicDelay.&lt;/li&gt;
          &lt;li&gt;Send MKPDU unless waiting for new MI to be generated. (please check below for this one).&lt;/li&gt;
          &lt;li&gt;Re-start timer with value of MkaRetryBaseDelay.&lt;/li&gt;
        &lt;/ul&gt;
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01000_PeriodicMkpduTransmission</srcid><srcstatus/><internalId>1688</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0112.ExponentialStartupMkaHelloTime</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>964</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1572</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.Api.TimerCallbackTxMkpdu.LivePeerFound</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>24060</sourceline>
      <version>1</version>
      <description>
        When Mka_KaY_TimerCallback_TxMkpdu() is called, the following should be done if Live peer is found:
        &lt;ul&gt;
          &lt;li&gt;Send MKPDU.&lt;/li&gt;
          &lt;li&gt;Re-start timer with value of MkaHelloTime.&lt;/li&gt;
        &lt;/ul&gt;
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01003_KSPLow_KSActor</srcid><srcstatus/><internalId>1691</internalId></linkedfrom><linkedfrom><srcid>Mka_ConTest01004_KSPHigh_KSPartner</srcid><srcstatus/><internalId>1692</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0112.ExponentialStartupMkaHelloTime</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>964</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1573</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.FillCipherAnnouncement.KeyServerState</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>24083</sourceline>
      <version>2</version>
      <description>
        When configuration parameter MkaStopTxAnnouncementAfterCipherSelected is disabled, Announcement parameter set shall be transmitted
        with each MKPDU.
        When this parameter is enabled, Mka shall stop transmission of Announcement parameter set, once cipher suite has been selected.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01031_MkpduCheckParameterSetTypeOrder</srcid><srcstatus/><internalId>2099</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01119_AnnouncementNotStopped</srcid><srcstatus/><internalId>2187</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_1836</srcid><srcstatus/><internalId>672</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0107.CipherSuiteSelection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>959</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1574</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.CipherSuiteSelection.AnnouncementMissing</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>24105</sourceline>
      <version>1</version>
      <description>
        If peer does not provide Announcement parameter set in MKPDU, cipher selection process shall fail,
        and instance shall be deleted unless optimization parameter MkaAllowMissingAnnouncementParameterSet is set to True
        in which case sequence shall proceed with configured cipher suite of highest priority.
      </description>
      <verifycrit>
        Implement the following test cases:
          1)  Set Optimization parameter MkaAllowMissingAnnouncementParameterSet to False.
              Receive MKPDUs from a peer that does not contain Announcement parameter set.
              Bring participant into a state that it is elected as a key server.
              Verify that participant shall be deleted.
          2)  Set Optimization parameter MkaAllowMissingAnnouncementParameterSet to True.
              Receive MKPDUs from a peer that does not contain Announcement parameter set.
              Bring participant into a state that it is elected as a key server.
              Sequence is continued with cipher suite of highest priority.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01069_DistributedSak_CipherSuite_1</srcid><srcstatus/><internalId>2137</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_2133</srcid><srcstatus/><internalId>686</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_2786</srcid><srcstatus/><internalId>942</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0107.CipherSuiteSelection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>959</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1575</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.CipherSuiteSelection.NoMatch</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>24138</sourceline>
      <version>2</version>
      <description>
        If cipher suite selection at key server side is not successful, i.e. no matching cipher suite is found or capability does not match,
        participant shall be disabled and MKA sequence repeated.
      </description>
      <verifycrit>
        Implement the following test case:
          1) Bring participant into a state that it is elected as a key server.
          2) All received MKPDUs from a peer shall contain Announcement parameter set, but with no match to any of the configured
          ones at key server side.
        Verify that key server participant is disabled.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01072_CipherSuiteSelection_NoMatch</srcid><srcstatus/><internalId>2140</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_2746</srcid><srcstatus/><internalId>694</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0107.CipherSuiteSelection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>959</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1576</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.DistributedCipherSuite.NoMatch</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>24166</sourceline>
      <version>1</version>
      <description>
        If MACsec cipher suite field in Distributed SAK parameter set contains invalid cipher suite or not supported by a peer, it shall be disabled.
      </description>
      <verifycrit>
        Test case 1:
          1) Bring participant into a state that it is elected as a peer.
          2) Receive MKPDU that contains Distributed SAK parameter set with cipher suite not supported by that peer.
          3) Verify that peer participant is disabled.
        Test case 2:
          1) Bring participant into a state that it is elected as a peer.
          2) Receive MKPDU that contains Distributed SAK parameter set with invalid cipher suite.
          3) Verify that peer participant is disabled.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01086_DistributedSak_NoMatch</srcid><srcstatus/><internalId>2154</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_2417</srcid><srcstatus/><internalId>691</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0107.CipherSuiteSelection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>959</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1577</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.ImmediatePeerResponse.PeerSM</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>24196</sourceline>
      <version>1</version>
      <description>
        When valid MKPDU is received and participant's PeerSM enters PEER_LIVE or PEER_POTENTIAL state, participant will immediately send a
        new MKPDU with function call KaY_SendMkpdu(). Immediate respond will not happen in case of any self transit of PeerSM.
        This feature is optionally enabled with MkaEnableImmediatePeerResponse.
      </description>
      <verifycrit>
        1) In configuration, enable parameter MkaEnableImmediatePeerResponse.
        2) Send MKPDU that is valid and verify that participant respond with new MKPDU if enters in PEER_LIVE or PEER_POTENTIAL state.
        3) Verify that self transition of PEER_POTENTIAL or PEER_LIVE will not trigger immediate respond.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01031_MacSecDisabled_PlainText_Peer</srcid><srcstatus/><internalId>1720</internalId></linkedfrom><linkedfrom><srcid>Mka_ConTest01032_MacSecDisabled_PlainText_KeyServer</srcid><srcstatus/><internalId>1721</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01024_PeerSM_Init2Undetected2Potent2Live</srcid><srcstatus/><internalId>2092</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01025_PeerSM_Undetected2Potent2Undetected</srcid><srcstatus/><internalId>2093</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01077_ParticipantRefreshedMi</srcid><srcstatus/><internalId>2145</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0121.ImmediateResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>973</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1578</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.ImmediatePeerResponse.SakGenerated</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>24222</sourceline>
      <version>1</version>
      <description>
        When participant receives new SAK from Crypto and notify CP unit, it will distribute SAK to peer.
        This feature is optionally enabled with MkaEnableImmediatePeerResponse.
      </description>
      <verifycrit>
        1) In configuration, enable parameter MkaEnableImmediatePeerResponse.
        2) Bring peer into Live peer and that participant is Key server.
        3) Call Mka_KaY_SakGenWrapFinished().
        4) Verify that new MKPDU is sent within call of Mka_KaY_SakGenWrapFinished().
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01082_ImmediateResponse_SakGenerated</srcid><srcstatus/><internalId>2150</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_3096</srcid><srcstatus/><internalId>704</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0121.ImmediateResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>973</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1579</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.Api.PeerSM.Live2Undetected.EthIf_E_NOT_OK</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>24249</sourceline>
      <version>1</version>
      <description>
        During transition from Peer_Live to Peer_Undetected, when EthIf_MacSecResetRxSc() returns Result == E_NOT_OK, KaY shall disable the instance.
      </description>
      <comment>Not being able to reset Rx secure connection is unrecoverable MKA protocol error.</comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01092_PeerSm_Live2Undetected_ResetRxSc_E_NOT_OK</srcid><srcstatus/><internalId>2160</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1580</internalId></specobject>
    <specobject>
      <id>Mka.KaY.KeyWrap_Invalid</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>24263</sourceline>
      <version>1</version>
      <description>
        If Mka_KaY_SakGenWrapFinished is called before SAK gen and wrap process was started (KaY SM is not in state 'KAY_KEYSM_GENERATE_NEW_SAK'),
        the call shall be ignored.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01012_KeySM_Invalid_WrapUnwrap</srcid><srcstatus/><internalId>2080</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1581</internalId></specobject>
    <specobject>
      <id>Mka.KaY.KeyUnwrap_Invalid</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>24277</sourceline>
      <version>1</version>
      <description>
        If Mka_KaY_SakUnwrapFinished is called before SAK unwrap process was started (KaY SM is not in state 'KAY_KEYSM_WAIT_SAK_UNWRAP'),
        the call shall be ignored.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01012_KeySM_Invalid_WrapUnwrap</srcid><srcstatus/><internalId>2080</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1582</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.Api.GetPrincipalActor</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>24291</sourceline>
      <version>1</version>
      <description>
        When KaY_GetPrincipalActor() is called for a PAE with existing principal actor, a pointer to that participant run-time data shall be returned.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_2197</srcid><srcstatus/><internalId>688</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01076_TimerSakRekey</srcid><srcstatus/><internalId>2144</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1583</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.Api.GetPrincipalActor.InvalidParticipant</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>24305</sourceline>
      <version>1</version>
      <description>
        When KaY_GetPrincipalActor() is called for a PAE without existing principal actor, NULL_PTR shall be returned.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01074_PnExhausted</srcid><srcstatus/><internalId>2142</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1584</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.Retry.GetTxSaNextPn</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>24318</sourceline>
      <version>1</version>
      <description>
        EthIf_MacSecGetTxSaNextPn() API is called during preparation of MKPDU with SAK Use parameter set, in order to fetch TX SA next PN
        value. In case that the API returns E_NOT_OK, MKPDU transmission shall be aborted, and new transmission scheduled for the next
        Mka_MainFunction tick.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_1999</srcid><srcstatus/><internalId>681</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01100_GetTxSaNextPn_Fail</srcid><srcstatus/><internalId>2168</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0117.SecYRetry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>969</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1585</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.TxSakUse_PrincipalOnly</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>24340</sourceline>
      <version>1</version>
      <description>
        SAK Use parameter set is transmitted only for principal participants.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_1934</srcid><srcstatus/><internalId>678</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01113_TxSakUse_PrincipalOnly</srcid><srcstatus/><internalId>2181</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0108.SakGenerationDistributionUse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>960</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1586</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.KeySM.KekGenerateFinished.UnexpectedState</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>24360</sourceline>
      <version>1</version>
      <description>
        If Mka_KaY_KekGenerateFinished() is called in unexpected state of KeySM,
        i.e. other than KAY_KEYSM_GENERATE_KEK, it shall ignore the request.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01101_KekGenerateFinished_Ignored</srcid><srcstatus/><internalId>2169</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1587</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.PeerSM.SelfTrans.Live.PeerNotRegistered</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>24374</sourceline>
      <version>1</version>
      <description>
        When PeerSM is in the state that indicates that the partner's peer is
        already registered (state other then KAY_PEER_UNDETECTED), and it
        receives MKPDU from another (non-registered) partner, that MKPDU shall
        be silently discarded.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01102_PeerLive_IgnoredMkpdu</srcid><srcstatus/><internalId>2170</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1588</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.Api.AllReceiving.UnexpectedState</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>24390</sourceline>
      <version>1</version>
      <description>
        If Mka_KaY_AllReceiving() is called in unexpected state of KeySM,
        i.e. other than KAY_KEYSM_DELAY_NEW_SAK or KAY_KEYSM_WAIT_NEW_SAK_REQ,
        or without a principal actor, it shall ignore the request.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01104_AllReceiving_Unexpected</srcid><srcstatus/><internalId>2172</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1589</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.MacSecEnabledStatus</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>24405</sourceline>
      <version>1</version>
      <description>
        Mka shall maintain status if MACsec is enabled or disabled for the complete instance of MKA module (ECU), i.e. this status shall
        apply to all enabled configured PAEs. It can be changed externally by APIs Mka_EnableMacSec() and Mka_DisableMacSec().
        The status shall be stored in NvRam and the change shall apply only on the next power-up cycle.
      </description>
      <verifycrit>
        Test case:
          1) Configure NvR stub for MacSecDisabled flag to true.
          2) Initialize MKA module and verify that MACsec is enabled by e.g. verifying that SAK is generated during MKA exchange.
          3) Call Mka_DisableMacSec() to disable MACsec
          4) Verify that the sequence of MKA exchange did not change.
          5) Initialize MKA module again.
          6) Verify that MACsec is disabled, e.g. by verifying that SecY is initialized with MACsec disabled parameters.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Ext.c.m4_813</srcid><srcstatus/><internalId>616</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Mka_Ext.c.m4_834</srcid><srcstatus/><internalId>618</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Mka_Logon.c_1486</srcid><srcstatus/><internalId>775</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01058_Logon_NvConfig_MacSecEnabled</srcid><srcstatus/><internalId>2248</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0120.MacSecDisabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>972</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1590</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.MacSecDesired.Discard</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>24436</sourceline>
      <version>1</version>
      <description>
        When MKPDU is received from a peer with MACsec Desired field value that does not match MACsec enabled statues field of Mka module
        instance [Mka.dsn.KaY.MacSecEnabledStatus], the received MKPDU shall be silently discarded.
        Note: When both partners have MACsec enabled set to 0 (not desired), the capability shall not be regarded.
      </description>
      <verifycrit>
        Test case 1:
          1) Receive MKPDU with MACsec Desired enabled while MACsec is disabled for MKA module instance.
          2) Receive MKPDU with MACsec Desired disabled while MACsec is enabled for MKA module instance.
          Verify that MKPDU is silently discarded.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_1567</srcid><srcstatus/><internalId>655</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01012_SakDistribution_WrongMi</srcid><srcstatus/><internalId>1701</internalId></linkedfrom><linkedfrom><srcid>Mka_ConTest01029_MacSecDisabled_NoPlainText_Peer</srcid><srcstatus/><internalId>1718</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01112_MacSecDesired_Capability_0</srcid><srcstatus/><internalId>2180</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0120.MacSecDisabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>972</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1591</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.MacSecDisabled.NoKeysNoSc</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>24464</sourceline>
      <version>1</version>
      <description>
        When MACsec is disabled, no keys other then ICK shall be generated (KEK, SAK).
        Also receive security channels shall not be added upon finding live partner.
      </description>
      <verifycrit>
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_993</srcid><srcstatus/><internalId>625</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_2802</srcid><srcstatus/><internalId>696</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01026_PlainText_Peer</srcid><srcstatus/><internalId>1715</internalId></linkedfrom><linkedfrom><srcid>Mka_ConTest01027_PlainText_Peer_Permissive</srcid><srcstatus/><internalId>1716</internalId></linkedfrom><linkedfrom><srcid>Mka_ConTest01029_MacSecDisabled_NoPlainText_Peer</srcid><srcstatus/><internalId>1718</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0120.MacSecDisabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>972</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1592</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.Rekeying.KeyServerChangesMi</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>24487</sourceline>
      <version>1</version>
      <description>
        Subject to conditions [Mka.8021X.KeyServerElection.45] that limit the frequency of SAK changes, the Key Server shall
        distribute a fresh SAK if it changes its own Member identifier (MI).

        Rationale: When MI changes during SAK distribution, Key Identifier value at Peer side (consisting of a Key server's MI and a
        key number) could be different, based on a timing, from KI at key server side. Consequently, SAK Use parameter sets would not match
        which would prevent SAK installation and led to MACsec traffic disruption.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_1055</srcid><srcstatus/><internalId>628</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01114_Rekeying_KeyServerChangesMi</srcid><srcstatus/><internalId>2182</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0109.SakRekeying</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>961</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1593</internalId></specobject>
    <specobject>
      <id>Mka.dsn.KaY.PeerSM.KeyServerReset</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>24512</sourceline>
      <version>1</version>
      <description>
        If elected PEER has received at least one SAK from key server and it receives MKPDU without SAK Use parameter set,
        this is an indication that key server got reset and PEER shall remove last PEER from Peer live list and restart
        procedure for finding new PEER.
      </description>
      <verifycrit>
        Test case:
          1) Configure Participant as Peer.
          2) Find Live peer that is key server.
          3) Key server generate and send Distributed Sak.
          4) Key server sends at least one MKPDU with SAK Use parameter set.
          5) Restart key server, it has new MI and MN starts from 1, but same SCI.
          6) Verify that participant removed old key server from Live peer list and started with procedure to register new Peer.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_KaY.c_2921</srcid><srcstatus/><internalId>699</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01117_PeerSM_LivePrincipal2Potential</srcid><srcstatus/><internalId>2185</internalId></linkedfrom><linkedfrom><srcid>Mka_KaY_UnitTest01118_PeerSM_LivePrinciapl2Live</srcid><srcstatus/><internalId>2186</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1594</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd" title="Lib Unit - Functionality requirements">
    <specobject>
      <id>Mka.dsn.Lib.SciBuffer_Init</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>24542</sourceline>
      <version>1</version>
      <description>
        During Mka initialization, Lib unit shall set SCIs for each port to the static buffer,
        that will be used later on to return SciPtr to the caller for the given MkaPaeIdx.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Lib.c_181</srcid><srcstatus/><internalId>710</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Lib_UnitTest01001_CorrectlyCalledFunction</srcid><srcstatus/><internalId>2189</internalId></linkedfrom><linkedfrom><srcid>Mka_UnitTest01017_Init</srcid><srcstatus/><internalId>2276</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.MkaProtocolRequirements.ScIdentification</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>104</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1595</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Lib.ParseMkpdu.Announcement.MinimumBodyLength</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>24563</sourceline>
      <version>1</version>
      <description>
        Announcement parameter set shall be accepted only if parameter set body length is equal or greater than size of Tlv header
        + one cipher info (12 octets in total).
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01063_AnnouncementParSet_9_6_Invalid</srcid><srcstatus/><internalId>2131</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Lib_ParSet.c_385</srcid><srcstatus/><internalId>734</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0107.CipherSuiteSelection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>959</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1596</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Lib.ParseMkpdu.Announcement.TlvStringLength</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>24584</sourceline>
      <version>1</version>
      <description>
        Tlv string length in Announcement parameter set shall be multiple of 10 and greater than 0.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01063_AnnouncementParSet_9_6_Invalid</srcid><srcstatus/><internalId>2131</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Lib_ParSet.c_395</srcid><srcstatus/><internalId>736</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0107.CipherSuiteSelection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>959</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1597</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Lib.ParseMkpdu.XPN.BodyLength</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>24604</sourceline>
      <version>1</version>
      <description>
        Parameter set body length in XPN parameter set shall be 8 octets.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_KaY_UnitTest01064_XPNParSet_9_7</srcid><srcstatus/><internalId>2132</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Lib_ParSet.c_455</srcid><srcstatus/><internalId>740</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0107.CipherSuiteSelection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>959</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1598</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd" title="Logon Unit - Functionality requirements">
    <specobject>
      <id>Mka.dsn.Logon.SinglePrincipalActorPerKaY</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>24629</sourceline>
      <version>1</version>
      <description>
        If several participants are configured for a single KaY, then only one of them can be allowed to be principal actor, i.e.
        to generate and distribute SAK and control SecY.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01019_TwoSaks_1</srcid><srcstatus/><internalId>1708</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1599</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Logon.ParticipantsRestart</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>24643</sourceline>
      <version>1</version>
      <description>
        Each enabled participant shall be restarted every time it is stopped.
      </description>
      <verifycrit>
        Testcase1: Verify that if enabled participant on started PAE is set to INIT state it shall be restarted in next main function call.
        Testcase2: Verify that if enabled participant is stopped with Mka_Logon_Participant_Disabled api,
                   it shall be restarted within the same function call.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.dsn.Logon.ParticipantsRestartDisabled</srcid><srcstatus/><internalId>1601</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Logon.ReenableDisabledParticipants</srcid><srcstatus/><internalId>1607</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01006_ParticipantDisabled_ParticipantRestarted</srcid><srcstatus/><internalId>2196</internalId></linkedfrom><linkedfrom><srcid>Mka_Logon_UnitTest01008_ParticipantsRestart_MainFunction</srcid><srcstatus/><internalId>2198</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Logon.c_777</srcid><srcstatus/><internalId>744</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1600</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Logon.ParticipantsRestartDisabled</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>24663</sourceline>
      <version>1</version>
      <description>
        Each configured and enabled participant shall be stopped and remain stopped if MKA_DISABLE_NON_PRINCIPAL_PARTICIPANTS is set to
        Enabled (STD_ON) and one participant on PAE reaches principal participant state.
      </description>
      <verifycrit>
        This requirement shall be tested for:
        * MKA_DISABLE_NON_PRINCIPAL_PARTICIPANTS STD_ON
        Verify that after participant reaches principal actor status, other participants on same PAE shall be and remain stopped.
        * MKA_DISABLE_NON_PRINCIPAL_PARTICIPANTS STD_OFF
        Verify that after participant reaches principal actor status, other participants on same PAE shall continue to work as before
        e.g. if participant reaches successful actor status it shall remain in that status.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01003_ParticipantSuccsessfulActor_DisableNonPrincipalParticipantsOn</srcid><srcstatus/><internalId>2193</internalId></linkedfrom><linkedfrom><srcid>Mka_Logon_UnitTest01004_ParticipantSuccsessfulActor_DisableNonPrincipalParticipantsOff</srcid><srcstatus/><internalId>2194</internalId></linkedfrom><linkedfrom><srcid>Mka_Logon_UnitTest01040_Created_2_Active</srcid><srcstatus/><internalId>2230</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Logon.c_1996</srcid><srcstatus/><internalId>794</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_2754</srcid><srcstatus/><internalId>941</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.ParticipantsRestart</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1600</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0122.DisableNonPrincipalParticipants</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>974</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1601</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Logon.PaeMkaAutoStart</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>24694</sourceline>
      <version>1</version>
      <description>
        For each PAE that has MkaAutoStart configured as TRUE, Logon module shall start all enabled participants of
        that PAE in Mka_Logon_Init.
      </description>
      <verifycrit>
        No previously successful principal actor stored in NvMemory.
        Testcase1: Verify that if MkaAutoStart for PAE is configured as TRUE, Participants of that
                   PAE shall be started after Mka_Logon_Init.
        Testcase2: Verify that if MkaAutoStart for PAE is configured as FALSE, Participants of that
                   PAE shall NOT be started after Mka_Logon_Init.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01014_AutoStart</srcid><srcstatus/><internalId>2204</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Logon.c_1613</srcid><srcstatus/><internalId>779</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1602</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Logon.PaeLastSuccessfulPrincipal</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>24716</sourceline>
      <version>1</version>
      <description>
        For each PAE that has MkaAutoStart configured as TRUE, and there is previously successful principal actor stored in
        Nv memory. Logon shall start that principal actor first for that PAE, and configure SecY with last successful crypto cipher id.
      </description>
      <verifycrit>
        There is previously successful principal actor stored in NvMemory.
        Verify that if MkaAutoStart for PAE is configured as TRUE, Participant that is stored in NvMemory is started first
        and Mka_Cp_SetCipherSuite is called for that PAE with cipher suite that is last used by that participant.
        Verify that rest of participants shall be started after next main.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01009_LogonReinit_StartPreviouslyPrincipalActor</srcid><srcstatus/><internalId>2199</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Logon.c_1630</srcid><srcstatus/><internalId>780</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Mka_Logon.c_2037</srcid><srcstatus/><internalId>795</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0123.CachingSuccessfulParticipant</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>975</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1603</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Logon.PaeLastSuccessfulPrincipalFailed</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>24742</sourceline>
      <version>1</version>
      <description>
        When previously successful principal actor stored in Nv memory is not successfully started,
        all enabled Participants shall be started for that PAE.
      </description>
      <verifycrit>
        Precondition: There is previously successful principal actor stored in NvMemory.
        Verify that if Mka_Crypto_IckGenerateAsync or Mka_Cp_SetCipherSuite fails when participant that is stored in NvMemory
        is started first, PAE will be started as if there was no last principal participant stored in Nv memory.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01010_LogonReinit_StartPreviouslyPrincipalActor_Failed</srcid><srcstatus/><internalId>2200</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Logon.c_1648</srcid><srcstatus/><internalId>781</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0123.CachingSuccessfulParticipant</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>975</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1604</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Logon.ManualPaeStart</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>24767</sourceline>
      <version>1</version>
      <description>
        If manual PAE start is requested with Mka_StartPae() it shall be successful only if PAE activation status is set to
        Enabled=TRUE (activations status is changed by calling Mka_SetEnable()) otherwise Mka_Logon_StartPae shall have no effect
        on that PAE.
      </description>
      <verifycrit>
        Testcase1: Verify that when Mka_Logon_StartPae is called for PAE that has Auto start disabled and has activation status in
                   Nv memory set as disabled, PAE shall not be started.
        Testcase2: Verify that when Mka_Logon_StartPae is called for PAE that has Auto start disabled and has activation status in
                   Nv memory set as enabled, PAE shall be started.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01025_ManualPaeStart</srcid><srcstatus/><internalId>2215</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Logon.c_941</srcid><srcstatus/><internalId>756</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_91022</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>386</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0122.DynamicControl</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1098</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1605</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Logon.NextSuccessfulParticipantAsPrincipal</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>24797</sourceline>
      <version>1</version>
      <description>
        When Mka_Logon_Participant_Disabled is called and given participant is principal, participant shall be stopped and if there is
        other successful actor on that PAE, that one shall be set as principal actor.
      </description>
      <verifycrit>
        Verify that when principal participant is disabled, and there is another participant that is successful actor on PAE
        that participant shall be set as principal.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01011_NextSuccessfulParticipantAsPrincipal</srcid><srcstatus/><internalId>2201</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Logon.c_2321</srcid><srcstatus/><internalId>797</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.Api.ParticipantDisabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1043</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1606</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Logon.ReenableDisabledParticipants</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>24821</sourceline>
      <version>1</version>
      <description>
        When setting of principal actor fails, and there is no other successful actors all participants on that PAE shall be
        enabled and restarted in next main call.
      </description>
      <verifycrit>
        Verify that when principal participant is disabled, and there is no other participant that is successful actor on PAE
        all disabled participants on that PAE are set to INIT state and are restarted in next Mka_Logon_MainFunction call.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01012_ReenableDisabledParticipants</srcid><srcstatus/><internalId>2202</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Logon.c_786</srcid><srcstatus/><internalId>745</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.ParticipantsRestart</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1600</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1607</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Logon.Nvm.Start</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>24845</sourceline>
      <version>1</version>
      <description>
        If Nv memory is enabled Mka shall check status of configured memory block that contains runtime configuration. If Nv memory block
        is valid Mka shall use that configuration. If configuration is not valid it shall be reset to default values and
        written to Nv memory.
      </description>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.dsn.Logon.Nvm.GetStatus</srcid><srcstatus/><internalId>1609</internalId></linkedfrom><linkedfrom><srcid>Mka.dsn.Logon.Nvm.SetChangedStatus</srcid><srcstatus/><internalId>1610</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Logon.c_1681</srcid><srcstatus/><internalId>783</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0122.DynamicControl</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1098</internalId></provcov>
        <provcov>
          <linksto>Mka.InterAct.Logon.NvM.Init</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1112</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1608</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Logon.Nvm.GetStatus</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>24869</sourceline>
      <version>1</version>
      <description>
        For status of Nv memory block to be valid, result of NvM_GetErrorStatus function of Nvm module shall be NVM_REQ_OK and
        post build  signature written in memory block (PBcfgSignature) shall match post build config signature of post build configuration.
      </description>
      <verifycrit>
        Testcase1: Configure Valid Nv memory block. That configuration shall be read during Mka_Init and used until next Mka restart.
        Testcase2: Configure Nv memory block so that PBcfgSignature does not match post build config. Mka shall reset configuration to
                   default values, mark block for writing and use that configuration.
        Testcase3: Configure Valid Nv memory block. configure NvM_GetErrorStatus to return NVM_REQ_NOT_OK status, Mka shall reset
                   configuration to default values, mark block for writing and use that configuration.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01017_NvmGetStatus_ValidMemoryBlock</srcid><srcstatus/><internalId>2207</internalId></linkedfrom><linkedfrom><srcid>Mka_Logon_UnitTest01018_NvmGetStatus_InvalidMemoryBlock</srcid><srcstatus/><internalId>2208</internalId></linkedfrom><linkedfrom><srcid>Mka_Logon_UnitTest01019_NvmGetStatus_NvmReqNotOk</srcid><srcstatus/><internalId>2209</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Logon.c_1695</srcid><srcstatus/><internalId>784</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.Nvm.Start</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1608</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0122.DynamicControl</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1098</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1609</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Logon.Nvm.SetChangedStatus</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>24899</sourceline>
      <version>1</version>
      <description>
        For any change in Mka Nv memory Mka shall mark memory block as changed with NvM_SetRamBlockStatus.
      </description>
      <verifycrit>
        Configure Nv memory block so that PBcfgSignature does not match post build config. Mka shall reset configuration to
        default values and mark block for writing. Verify that NvM_SetRamBlockStatus is called with correct
        block ID (MKA_NVM_BLOCK_ID) and status set to true.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01003_ParticipantSuccsessfulActor_DisableNonPrincipalParticipantsOn</srcid><srcstatus/><internalId>2193</internalId></linkedfrom><linkedfrom><srcid>Mka_Logon_UnitTest01004_ParticipantSuccsessfulActor_DisableNonPrincipalParticipantsOff</srcid><srcstatus/><internalId>2194</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Logon.c_1718</srcid><srcstatus/><internalId>787</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.Nvm.Start</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1608</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0122.DynamicControl</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1098</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1610</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Logon.Nvm.WriteBlockImmediately</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>24926</sourceline>
      <version>1</version>
      <description>
        Any change in Mka Nv memory shall be queued with NvM_WriteBlock for a write in next main tick.
        If during queuing of write, write is already in progress or there was error during previous write,
        block shall be queued in next main tick.
      </description>
      <verifycrit>
        1.) Introduce change in Mk Nv Memory block. Verify that Mka shall try to write block in next main tick.
        2.) Verify that subsequent calls to Mka_Logon_Nvm_WriteBlockIfChanged shall not queue block again until previous request is finished.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01043_NvM_ImmediateWriteBlock</srcid><srcstatus/><internalId>1732</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Logon.c_1522</srcid><srcstatus/><internalId>777</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0122.DynamicControl</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1098</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1611</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Logon.Nvm.ShadowNvMemoryBlock</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>24951</sourceline>
      <version>1</version>
      <description>
        During queuing of MkaNvRam_Memory for a write to NvM, Mka shall copy contents of MkaNvRam_Memory to internal shadow
        (duplicate) memory block that shall be used as parameter to NvM_WriteBlock. Copying of block shall be done in
        exclusive area so that no outside process can change MkaNvRam_Memory during copying of block.
        Contents of shadow memory block are unchanged until write to NvM is finished.
      </description>
      <verifycrit>
        1.) Verify that latest data that was written to NvM is equal to MkaNvRam_Memory. Change MkaNvRam_Memory.
            Verify that change MkaNvRam_Memory has not influenced data that was passed to NvM_WriteBlock;
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01043_NvM_ImmediateWriteBlock</srcid><srcstatus/><internalId>1732</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Logon.c_1560</srcid><srcstatus/><internalId>778</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0122.DynamicControl</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1098</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1612</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Logon.Nvm.MacSecDisabledByDefault</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>24977</sourceline>
      <version>1</version>
      <description>
        Initial (default) value for MacSec functionality in NvM is DISABLED, meaning that unless enabled by external interface MacSec
        shall be disabled.
      </description>
      <verifycrit>
        1.) Clear MkaNvRam_Memory and Initialize Mka. Verify Tha MacSec is Disabled.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01043_NvM_ImmediateWriteBlock</srcid><srcstatus/><internalId>1732</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Logon.c_1780</srcid><srcstatus/><internalId>791</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0122.DynamicControl</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1098</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1613</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Logon.PermissiveMode.ResetTimer</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>25000</sourceline>
      <version>1</version>
      <description>
        If a successful principal participant, for any reason, gets disabled, Logon shall reset the timer for PermissiveMode
        if PermissiveMode is enabled on that port.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01031_PermissiveMode_StartTimer</srcid><srcstatus/><internalId>2221</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Logon.c_2529</srcid><srcstatus/><internalId>798</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0111.PermissiveMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>963</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1614</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Logon.PermissiveMode.StopTimer</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>25020</sourceline>
      <version>1</version>
      <description>
        If MacSec is operational on a PAE, Permissive mode timer shall be stopped.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01027_PlainText_Peer_Permissive</srcid><srcstatus/><internalId>1716</internalId></linkedfrom><linkedfrom><srcid>Mka_Logon_UnitTest01043_TimerCallBack_PermissiveMode_Operational</srcid><srcstatus/><internalId>2233</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Logon.c_1352</srcid><srcstatus/><internalId>771</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0111.PermissiveMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>963</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1615</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Logon.PermissiveMode.PaeAutoStart.Disabled</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>25039</sourceline>
      <version>1</version>
      <description>
        For a PAE configured for a manual start (MkaAutoStart configuration field is disabled), permissive timer shall be started when
        both following conditions are fulfilled:
        1) PAE is manually started with Mka_StartPae(),
        2) referenced link is active.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_ConTest01020_PermissiveMode_TimerExpires</srcid><srcstatus/><internalId>1709</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Logon.c_944</srcid><srcstatus/><internalId>757</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0111.PermissiveMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>963</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1616</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Logon.BypassMacSec.DisabledPort</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>25061</sourceline>
      <version>2</version>
      <description>
        If a port has been disabled, MacSec on that port shall be bypassed when MacSec is disabled. This can be done by setting MacSec Entity
        parameters so as to bypass MacSec checks and verification, then let the communication flow by calling EthIf_MacSecOperational(True).
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Logon.c_1664</srcid><srcstatus/><internalId>782</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01037_Pae_DisabledPort</srcid><srcstatus/><internalId>2227</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0110.MacSecOperational</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>962</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1617</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Logon.BypassMacSec.NoEnabledCakCkn</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>25081</sourceline>
      <version>1</version>
      <description>
        If a port has no enabled CAKs or CKNs, the MACsec on this port shall be bypassed if MacSec is disabled. This shall be done in the same way as described
        in Mka.dsn.Logon.BypassMacSec.DisabledPort.
        The key verification is done by calling Csm_KeyElementGet(), whose return parameter can take the following values:
          - E_OK                       -&amp;gt; Request successful
          - E_NOT_OK                   -&amp;gt; Request failed
          - CRYPTO_E_KEY_READ_FAIL     -&amp;gt; Key exists, but read access was denied
          - CRYPTO_E_KEY_NOT_AVAILABLE -&amp;gt; Key is not available.
        If the return value is E_OK, it means that the key is available and valid.
        If the return value is CRYPTO_E_KEY_READ_FAIL for CAK, it means that the key is valid but we are not allowed to read it, which is expected behavior for HSM.
        Other two return values indicate that the key is not valid / does not exist.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Logon.c_1956</srcid><srcstatus/><internalId>793</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Crypto_UnitTest01169_InvalidCak</srcid><srcstatus/><internalId>2064</internalId></linkedfrom><linkedfrom><srcid>Mka_Logon_UnitTest01038_Pae_DisabledParticipants</srcid><srcstatus/><internalId>2228</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0110.MacSecOperational</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>962</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1618</internalId></specobject>
    <specobject>
      <id>Mka.dsn.Logon.UpdateSecYDuringInit</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>25109</sourceline>
      <version>1</version>
      <description>
        When configuration parameter MkaUpdateSecYDuringInit is enabled, Logon shall call EthIf_MacSecUpdateSecY() during the first
        Mka_MainFunction() tick. Otherwise it shall update SecY when corresponding link becomes ACTIVE.
      </description>
      <verifycrit>
        Testcase1: Set a configuration with MkaUpdateSecYDuringInit = FALSE and verify that EthIf_MacSecUpdateSecY() is NOT called during
                   the first Mka_MainFunction() call but when the corresponding link becomes ACTIVE.
        Testcase2: Set a configuration with MkaUpdateSecYDuringInit = TRUE and verify that EthIf_MacSecUpdateSecY() is called during the
                   first Mka_MainFunction() call and not repeated when the corresponding link becomes ACTIVE.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/Mka_Logon.c_760</srcid><srcstatus/><internalId>743</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/Mka_Logon.c_1099</srcid><srcstatus/><internalId>760</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_Logon_UnitTest01068_UpdateSecYDuringInit</srcid><srcstatus/><internalId>2256</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1619</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd" title="RxTx Unit - Functionality requirements">
    <specobject>
      <id>Mka.dsn.RxTx.Api.Mka_RxTx_RxIndication.LenByte</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>25136</sourceline>
      <version>1</version>
      <description>
        When Mka_RxTx_RxIndication() is called with parameter LenByte less than (32U + MKA_EAPOL_SIZE_HEADER), EAPOL PDU shall be dropped.
      </description>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka.8021X.Eapol.27.2</srcid><srcstatus/><internalId>71</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1620</internalId></specobject>
    <specobject>
      <id>Mka.dsn.RxTx.Api.Mka_RxTx_RxIndication.EAPoLPacketType</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>25149</sourceline>
      <version>1</version>
      <description>
        When Mka_RxTx_RxIndication() is called and EAPOL PDU type is not EAPOL-MKA, EAPOL PDU shall be dropped.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_RxTx_UnitTest01005_RxBufFree_2_WaitIcvVerFin_Fail</srcid><srcstatus/><internalId>2319</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1621</internalId></specobject>
    <specobject>
      <id>Mka.dsn.RxTx.Api.Mka_RxTx_RxIndication.LenByteEAPoLBodyPacketLength</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>25162</sourceline>
      <version>1</version>
      <description>
        When Mka_RxTx_RxIndication() is called and (EAPoL Packet Body Length + MKA_EAPOL_SIZE_HEADER) is less then LenByte parameter,
        EAPOL PDU shall be dropped.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_RxTx_UnitTest01005_RxBufFree_2_WaitIcvVerFin_Fail</srcid><srcstatus/><internalId>2319</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1622</internalId></specobject>
    <specobject>
      <id>Mka.dsn.RxTx.Api.Mka_RxTx_RxIndication.GetRxBuffer.Fail</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>25176</sourceline>
      <version>2</version>
      <description>
        When Mka_RxTx_RxIndication() is called and allocation of Rx buffer fails because it is already in use, EAPOL PDU shall be dropped.
      </description>
      <verifycrit>
        Test this requirement by calling Mka_RxTx_RxIndication() when RxSM is in the state RXTX_RX_WAIT_ICV_VERIFY_FINISHED, i.e.
        before Mka_RxTx_IcvVerifyFinished() is called.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_RxTx_UnitTest01016_RxIndication_GetRxBufferFail</srcid><srcstatus/><internalId>2330</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1623</internalId></specobject>
    <specobject>
      <id>Mka.dsn.RxTx.Api.Mka_RxTx_RxIndication.DataSize.Oversized</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>25193</sourceline>
      <version>1</version>
      <description>
        When Mka_RxTx_RxIndication() is called and buffer size is smaller then required (2 * Mac address size (6) + Ethernet type size +
        EAPOL header size (4) + received MKPDU size) the frame shall be silently dropped.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_RxTx_UnitTest01017_RxIndication_DataSizeOversized</srcid><srcstatus/><internalId>2331</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1624</internalId></specobject>
    <specobject>
      <id>Mka.dsn.RxTx.Api.Mka_RxTx_GetTxBuffer.ProvideTxBuffer.Fail</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>25207</sourceline>
      <version>1</version>
      <description>
        When Mka_RxTx_GetTxBuffer() is called and call to allocate buffer in EthIf fails - EthIf_ProvideTxBuffer() returns other then
        BUFREQ_OK, MKA shall return E_NOT_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_RxTx_UnitTest01018_GetTxBuffer_ProvideTxBufferFail</srcid><srcstatus/><internalId>2332</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1625</internalId></specobject>
    <specobject>
      <id>Mka.dsn.RxTx.TxSM.IcvGenerateFinished.UnexpectedState</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>25221</sourceline>
      <version>2</version>
      <description>
        If Mka_RxTx_IcvGenerateFinished() is called in unexpected state of TxSM, i.e. other then RXTX_WAIT_ICV_GENERATE_FINISHED,
        MKA shall silently ignore this call.
      </description>
      <verifycrit>
        Test this requirement for the use case when TxSM is in the following states: RXTX_TX_BUFFER_UNALLOCATED,
        RXTX_TX_BUFFER_ALLOCATED_LOCKED and RXTX_TX_BUFFER_ALLOCATED_UNLOCKED.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_RxTx_UnitTest01021_IcvGenerateFinished_UnexpectedState</srcid><srcstatus/><internalId>2334</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.RxTx.TxSM</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1085</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1626</internalId></specobject>
    <specobject>
      <id>Mka.dsn.RxTx.TxSM.TxBufferReady.UnexpectedState</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>25245</sourceline>
      <version>2</version>
      <description>
        If Mka_RxTx_TxBufferReady() is called in unexpected state of TxSM, i.e. other then  RXTX_TX_BUFFER_ALLOCATED_LOCKED,
        MKA shall ignore the request and return E_NOT_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_RxTx_UnitTest01022_TxBufferReady_UnexpectedState</srcid><srcstatus/><internalId>2335</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.RxTx.TxSM</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1085</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1627</internalId></specobject>
    <specobject>
      <id>Mka.dsn.RxTx.TxSM.GetTxBuffer.UnexpectedState</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>25265</sourceline>
      <version>1</version>
      <description>
        If Mka_RxTx_GetTxBuffer() is called in unexpected state of TxSM, i.e. other then  RXTX_TX_BUFFER_UNALLOCATED or
        RXTX_TX_BUFFER_ALLOCATED_UNLOCKED MKA shall ignore the request and return E_NOT_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_RxTx_UnitTest01019_GetTxBuffer_UnexpectedState</srcid><srcstatus/><internalId>2333</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.RxTx.TxSM</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1085</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1628</internalId></specobject>
    <specobject>
      <id>Mka.dsn.RxTx.TxSM.ReleaseTxBuffer.UnexpectedState</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>25285</sourceline>
      <version>1</version>
      <description>
        If Mka_RxTx_ReleaseTxBuffer() is called in unexpected state of TxSM, i.e. other then  RXTX_TX_BUFFER_ALLOCATED_LOCKED
        MKA shall ignore the request and return E_NOT_OK.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_RxTx_UnitTest01002_BufAlloc_2_WaitIcvGenFin_2_BufUnalloc</srcid><srcstatus/><internalId>2316</internalId></linkedfrom><linkedfrom><srcid>Mka_RxTx_UnitTest01026_BufAllocLocked_2_BufAllocUnlocked</srcid><srcstatus/><internalId>2339</internalId></linkedfrom><linkedfrom><srcid>Mka_RxTx_UnitTest01027_TxBufferReady_IcvGenerateAsync_ENotOk</srcid><srcstatus/><internalId>2340</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.RxTx.TxSM</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1085</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1629</internalId></specobject>
    <specobject>
      <id>Mka.dsn.RxTx.Api.Mka_RxTx_TxBufferReady.MField</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>25305</sourceline>
      <version>2</version>
      <description>
        Before the call to Mka_Crypto_IcvGenerateAsync(), as a result Mka_RxTx_TxBufferReady() API call, RxTx shall copy
        configured destination MAC address (MkaDstMacAddress), source MAC addresses of associated physical controller and
        MKA Ethernet type (0x888E) at the beginning of the buffer.
        Before the call to EthIf_Transmit() as a result of successful notification Mka_RxTx_IcvGenerateFinished(), RxTx shall remove
        DA, SA and EtherType from the beginning of the buffer, leaving only MKPDU and ICV within.
      </description>
      <comment>
        The buffer size is initially extended to accommodate for DA, SA and EtherType, and the actual MKPDU is written in a buffer with
        an offset (6 + 6 + 2 bytes). The reason for this that ICV shall be calculated not only over MKPDU, but also over DA, SA and
        EtherType.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_RxTx_UnitTest01002_BufAlloc_2_WaitIcvGenFin_2_BufUnalloc</srcid><srcstatus/><internalId>2316</internalId></linkedfrom><linkedfrom><srcid>Mka_RxTx_UnitTest01023_EthIf_Transmit_ParamCheck</srcid><srcstatus/><internalId>2336</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1630</internalId></specobject>
    <specobject>
      <id>Mka.dsn.RxTx.Api.TxBufferReady.IcvGenerateAsync_ENotOk</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>25333</sourceline>
      <version>1</version>
      <description>
        When RxTx calls Mka_Crypto_IcvGenerateAsync() as a result of Mka_RxTx_TxBufferReady() API call,
        and Mka_Crypto_IcvGenerateAsync() returns E_NOT_OK when crypto is configured as asynchronous, RxTx shall transit into state
        RXTX_TX_BUFFER_ALLOCATED_UNLOCKED.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_RxTx_UnitTest01027_TxBufferReady_IcvGenerateAsync_ENotOk</srcid><srcstatus/><internalId>2340</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1631</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs" title="XDM checks requirements">
    <specobject>
      <id>Mka.XDM.Pae.MkaPaeInstance_Consecutive</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>25559</sourceline>
      <version>1</version>
      <description>
          The generator shall raise an error message if MkaPaeIdx of the MkaPaeInstance are not consecutive.
        </description>
      <comment>
          Rationale:
          This check is necessary to protect the post build configuration structure to be filled with
          wrong values.
        </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_GenTest_01001_Invalid_Mka_Xdm_MkaPaeInstance_Consecutive</srcid><srcstatus/><internalId>1737</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1632</internalId></specobject>
    <specobject>
      <id>Mka.XDM.Mka.MkaEthIfControllerRef_InvalidRef</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>25577</sourceline>
      <version>1</version>
      <description>
          The generator shall raise an error message if parameter MkaEthIfControllerRef does not point to a valid reference.
        </description>
      <comment>
          Rationale:
          This check is necessary to protect the post build configuration structure to be filled with
          wrong values.
        </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_GenTest_01002_Invalid_Mka_Xdm_MkaEthIfControllerRef_InvalidRef</srcid><srcstatus/><internalId>1738</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1633</internalId></specobject>
    <specobject>
      <id>Mka.XDM.Mka.MkaPaeConfRef_InvalidRef</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>25595</sourceline>
      <version>1</version>
      <description>
          The generator shall raise an error message if parameter MkaPaeConfRef does not point to a valid reference.
        </description>
      <comment>
          Rationale:
          This check is necessary to protect the post build configuration structure to be filled with
          wrong values.
        </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_GenTest_01003_Invalid_Mka_Xdm_MkaPaeConfRef_InvalidRef</srcid><srcstatus/><internalId>1739</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1634</internalId></specobject>
    <specobject>
      <id>Mka.XDM.Mka.MkaSwitchPortRef_InvalidRef</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>25613</sourceline>
      <version>1</version>
      <description>
          The generator shall raise an error message if parameter MkaSwitchPortRef does not point to a valid reference.
        </description>
      <comment>
          Rationale:
          This check is necessary to protect the post build configuration structure to be filled with
          wrong values.
        </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_GenTest_01004_Invalid_Mka_Xdm_MkaSwitchPortRef_InvalidRef</srcid><srcstatus/><internalId>1740</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1635</internalId></specobject>
    <specobject>
      <id>Mka.XDM.KaY.MkaBypassEtherType_Repeating</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>25631</sourceline>
      <version>1</version>
      <description>
          The generator shall raise an error message if elements of MkaBypassEtherType list are repeated.
        </description>
      <comment>
          Rationale:
          This check is necessary to prevent memory waste.
        </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_GenTest_01005_Invalid_Mka_Xdm_MkaBypassEtherType_Repeating</srcid><srcstatus/><internalId>1741</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0116.BypassRules</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>968</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1636</internalId></specobject>
    <specobject>
      <id>Mka.XDM.KaY.MkaBypassVlan_Repeating</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>25654</sourceline>
      <version>1</version>
      <description>
          The generator shall raise an error message if elements of MkaBypassVlan list are repeated.
        </description>
      <comment>
          Rationale:
          This check is necessary to prevent memory waste.
        </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_GenTest_01006_Invalid_Mka_Xdm_MkaBypassVlan_Repeating</srcid><srcstatus/><internalId>1742</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0116.BypassRules</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>968</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1637</internalId></specobject>
    <specobject>
      <id>Mka.XDM.KaY.MkaDstMacAddress_MACAddressFormat</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>25677</sourceline>
      <version>1</version>
      <description>
          The generator shall raise an error message if MAC address is not in the format xx:xx:xx:xx:xx:xx.
        </description>
      <comment>
        </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_GenTest_01007_Invalid_Mka_Xdm_MkaDstMacAddress_MACAddressFormat</srcid><srcstatus/><internalId>1743</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1638</internalId></specobject>
    <specobject>
      <id>Mka.XDM.KaY.MkaKeyServerPriority_PriorityMissing</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>25692</sourceline>
      <version>1</version>
      <description>
          The generator shall raise an error message if MkaRole is set to MKA_KEY_SERVER_PRIORITY_BASED, but
          MkaKeyServerPriority is not set.
        </description>
      <comment>
        </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_GenTest_01008_Invalid_Mka_Xdm_MkaKeyServerPriority_PriorityMissing</srcid><srcstatus/><internalId>1744</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1639</internalId></specobject>
    <specobject>
      <id>Mka.XDM.KaYParticipant.MkaKayParticipant_Consecutive</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>25708</sourceline>
      <version>1</version>
      <description>
          The generator shall raise an error message if MkaParticipantIdx of the MkaKayParticipant are not consecutive.
        </description>
      <comment>
          Rationale:
          This check is necessary to protect the post build configuration structure to be filled with
          wrong values.
        </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_GenTest_01009_Invalid_Mka_Xdm_MkaKayParticipant_Consecutive</srcid><srcstatus/><internalId>1745</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1640</internalId></specobject>
    <specobject>
      <id>Mka.XDM.Crypto.MkaCryptoConfigId_Consecutive</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>25726</sourceline>
      <version>1</version>
      <description>
          The generator shall raise an error message if MkaCryptoConfigId of the MkaCryptoConfig are not consecutive.
        </description>
      <comment>
          Rationale:
          This check is necessary to protect the post build configuration structure to be filled with
          wrong values.
        </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_GenTest_01010_Invalid_Mka_Xdm_MkaCryptoConfigId_Consecutive</srcid><srcstatus/><internalId>1746</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1641</internalId></specobject>
    <specobject>
      <id>Mka.XDM.Crypto.MkaCryptoConfigId_ZeroBased</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>25744</sourceline>
      <version>1</version>
      <description>
          The generator shall raise an error message if MkaCryptoConfigId of the MkaCryptoConfig are not zero based.
        </description>
      <comment>
          Rationale:
          This check is necessary to protect the post build configuration structure to be filled with
          wrong values.
        </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_GenTest_01011_Invalid_Mka_Xdm_MkaCryptoConfigId_ZeroBased</srcid><srcstatus/><internalId>1747</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1642</internalId></specobject>
    <specobject>
      <id>Mka.XDM.Crypto.MkaCryptoAlgoRef_InvalidRef</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>25762</sourceline>
      <version>1</version>
      <description>
          The generator shall raise an error message if parameter MkaCryptoAlgoRef does not point to a valid reference.
        </description>
      <comment>
          Rationale:
          This check is necessary to protect the post build configuration structure to be filled with
          wrong values.
        </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_GenTest_01012_Invalid_Mka_Xdm_MkaCryptoAlgoRef_InvalidRef</srcid><srcstatus/><internalId>1748</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1643</internalId></specobject>
    <specobject>
      <id>Mka.XDM.Crypto.MkaCryptoCknCakKeyRef_InvalidRef</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>25780</sourceline>
      <version>1</version>
      <description>
          The generator shall raise an error message if parameter MkaCryptoCknCakKeyRef does not point to a valid reference.
        </description>
      <comment>
          Rationale:
          This check is necessary to protect the post build configuration structure to be filled with
          wrong values.
        </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_GenTest_01013_Invalid_Mka_Xdm_MkaCryptoCknCakKeyRef_InvalidRef</srcid><srcstatus/><internalId>1749</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1644</internalId></specobject>
    <specobject>
      <id>Mka.XDM.Crypto.MkaCryptoRandomJobRef_InvalidRef</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>25798</sourceline>
      <version>1</version>
      <description>
          The generator shall raise an error message if parameter MkaCryptoRandomJobRef does not point to a valid reference.
        </description>
      <comment>
          Rationale:
          This check is necessary to protect the post build configuration structure to be filled with
          wrong values.
        </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_GenTest_01014_Invalid_Mka_Xdm_MkaCryptoRandomJobRef_InvalidRef</srcid><srcstatus/><internalId>1750</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1645</internalId></specobject>
    <specobject>
      <id>Mka.XDM.Crypto.MkaCryptoIckJobRef_InvalidRef</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>25816</sourceline>
      <version>1</version>
      <description>
          The generator shall raise an error message if parameter MkaCryptoIckJobRef does not point to a valid reference.
        </description>
      <comment>
          Rationale:
          This check is necessary to protect the post build configuration structure to be filled with
          wrong values.
        </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_GenTest_01015_Invalid_Mka_Xdm_MkaCryptoIckJobRef_InvalidRef</srcid><srcstatus/><internalId>1751</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1646</internalId></specobject>
    <specobject>
      <id>Mka.XDM.Crypto.MkaCryptoIckJobRef_InvalidKey</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>25834</sourceline>
      <version>1</version>
      <description>
          The generator shall raise an error message if referenced job used for ICK generation does not have the same key configured
          as referenced by MkaCryptoCknCakKeyRef.
        </description>
      <comment>
          Rationale:
          This check is necessary to protect the post build configuration structure to be filled with
          wrong values.
        </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_GenTest_01016_Invalid_Mka_Xdm_MkaCryptoIckJobRef_InvalidKey</srcid><srcstatus/><internalId>1752</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1647</internalId></specobject>
    <specobject>
      <id>Mka.XDM.Crypto.MkaCryptoIcvGenerateJobRef_InvalidRef</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>25853</sourceline>
      <version>1</version>
      <description>
          The generator shall raise an error message if parameter MkaCryptoIcvGenerateJobRef does not point to a valid reference.
        </description>
      <comment>
          Rationale:
          This check is necessary to protect the post build configuration structure to be filled with
          wrong values.
        </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_GenTest_01017_Invalid_Mka_Xdm_MkaCryptoIcvGenerateJobRef_InvalidRef</srcid><srcstatus/><internalId>1753</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1648</internalId></specobject>
    <specobject>
      <id>Mka.XDM.Crypto.MkaCryptoHashGenerateJobRef_InvalidRef</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>25871</sourceline>
      <version>1</version>
      <description>
          The generator shall raise an error message if parameter MkaCryptoHashGenerateJobRef does not point to a valid reference.
        </description>
      <comment>
          Rationale:
          This check is necessary to protect the post build configuration structure to be filled with
          wrong values.
        </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_GenTest_01043_Invalid_Mka_Xdm_MkaCryptoHashGenerateJobRef_InvalidRef</srcid><srcstatus/><internalId>1779</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1649</internalId></specobject>
    <specobject>
      <id>Mka.XDM.Crypto.MkaCryptoHashGenerateJobRef_InvalidKeySize_128</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>25889</sourceline>
      <version>1</version>
      <description>
          The generator shall raise an error message if ciphers configured in MkaCryptoAlgoConfig have the size 128 and
          CsmEncryptAlgorithmKeyLength in CsmEncrypt hash job primitive is not set to 16.
        </description>
      <comment>
          Rationale:
          This check is necessary to protect the post build configuration structure to be filled with wrong values.
        </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_GenTest_01048_Invalid_Mka_Xdm_MkaCryptoHashGenerateJobRef_InvalidKeySize_128</srcid><srcstatus/><internalId>1784</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1650</internalId></specobject>
    <specobject>
      <id>Mka.XDM.Crypto.MkaCryptoHashGenerateJobRef_InvalidKeySize_256</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>25907</sourceline>
      <version>1</version>
      <description>
          The generator shall raise an error message if ciphers configured in MkaCryptoAlgoConfig have the size 256 and
          CsmEncryptAlgorithmKeyLength in CsmEncrypt hash job primitive is not set to 32.
        </description>
      <comment>
          Rationale:
          This check is necessary to protect the post build configuration structure to be filled with wrong values.
        </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_GenTest_01049_Invalid_Mka_Xdm_MkaCryptoHashGenerateJobRef_InvalidKeySize_256</srcid><srcstatus/><internalId>1785</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1651</internalId></specobject>
    <specobject>
      <id>Mka.XDM.Crypto.MkaCryptoHashGenerateJob2Ref_InvalidRef</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>25925</sourceline>
      <version>1</version>
      <description>
          The generator shall raise an error message if parameter MkaCryptoHashGenerateJob2Ref is enabled and does not point to a valid
          reference.
        </description>
      <comment>
          Rationale:
          This check is necessary to protect the post build configuration structure to be filled with
          wrong values.
        </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_GenTest_01051_Invalid_Mka_Xdm_MkaCryptoHashGenerateJob2Ref_InvalidRef</srcid><srcstatus/><internalId>1787</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1652</internalId></specobject>
    <specobject>
      <id>Mka.XDM.Crypto.MkaCryptoHashGenerateJob2Ref_InvalidKeySize</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>25944</sourceline>
      <version>1</version>
      <description>
          The generator shall raise an error message if ciphers configured in MkaCryptoAlgoConfig have mixed 128 and 256 sizes and
          CsmEncryptAlgorithmKeyLength in CsmEncrypt primitive of hash jobs (MkaCryptoHashGenerateJobRef and MkaCryptoHashGenerateJob2Ref)
          are not set - first to 16 and the second to 32, or vice versa.
        </description>
      <comment>
          Rationale:
          This check is necessary to protect the post build configuration structure to be filled with wrong values.
        </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_GenTest_01050_Invalid_Mka_Xdm_MkaCryptoHashGenerateJob2Ref_InvalidKeySize</srcid><srcstatus/><internalId>1786</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1653</internalId></specobject>
    <specobject>
      <id>Mka.XDM.Crypto.MkaCryptoIcvVerifyJobRef_InvalidRef</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>25963</sourceline>
      <version>1</version>
      <description>
          The generator shall raise an error message if parameter MkaCryptoIcvVerifyJobRef does not point to a valid reference.
        </description>
      <comment>
          Rationale:
          This check is necessary to protect the post build configuration structure to be filled with
          wrong values.
        </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_GenTest_01018_Invalid_Mka_Xdm_MkaCryptoIcvVerifyJobRef_InvalidRef</srcid><srcstatus/><internalId>1754</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1654</internalId></specobject>
    <specobject>
      <id>Mka.XDM.Crypto.MkaCryptoIcvGenerateJobRef_InvalidKey</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>25981</sourceline>
      <version>1</version>
      <description>
          The generator shall raise an error message if job referenced by parameter MkaCryptoIcvGenerateJobRef does
          not have the same key configured (CsmJobKeyRef) as parameter MkaCryptoIcvVerifyJobRef.
        </description>
      <comment>
          Rationale:
          This check is necessary to protect the post build configuration structure to be filled with
          wrong values.
        </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_GenTest_01019_Invalid_Mka_Xdm_MkaCryptoIcvGenerateJobRef_InvalidKey</srcid><srcstatus/><internalId>1755</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1655</internalId></specobject>
    <specobject>
      <id>Mka.XDM.Crypto.MkaCryptoIcvVerifyJobRef_InvalidKey</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>26000</sourceline>
      <version>1</version>
      <description>
          The generator shall raise an error message if job referenced by parameter MkaCryptoIcvVerifyJobRef does
          not have the same key configured (CsmJobKeyRef) as parameter MkaCryptoIcvGenerateJobRef.
        </description>
      <comment>
          Rationale:
          This check is necessary to protect the post build configuration structure to be filled with
          wrong values.
        </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_GenTest_01020_Invalid_Mka_Xdm_MkaCryptoIcvVerifyJobRef_InvalidKey</srcid><srcstatus/><internalId>1756</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1656</internalId></specobject>
    <specobject>
      <id>Mka.XDM.Crypto.MkaCryptoKekDeriveJobRef_InvalidRef</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>26019</sourceline>
      <version>1</version>
      <description>
          The generator shall raise an error message if parameter MkaCryptoKekDeriveJobRef does not point to a valid reference.
        </description>
      <comment>
          Rationale:
          This check is necessary to protect the post build configuration structure to be filled with
          wrong values.
        </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_GenTest_01021_Invalid_Mka_Xdm_MkaCryptoKekDeriveJobRef_InvalidRef</srcid><srcstatus/><internalId>1757</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1657</internalId></specobject>
    <specobject>
      <id>Mka.XDM.Crypto.MkaCryptoKekDeriveJobRef_InvalidKey</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>26037</sourceline>
      <version>1</version>
      <description>
          The generator shall raise an error message if referenced job used for KEK generation does not have the same key configured
          as referenced by MkaCryptoCknCakKeyRef.
        </description>
      <comment>
          Rationale:
          This check is necessary to protect the post build configuration structure to be filled with
          wrong values.
        </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_GenTest_01022_Invalid_Mka_Xdm_MkaCryptoKekDeriveJobRef_InvalidKey</srcid><srcstatus/><internalId>1758</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1658</internalId></specobject>
    <specobject>
      <id>Mka.XDM.Crypto.MkaCryptoKeyWrapJobRef_InvalidRef</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>26056</sourceline>
      <version>1</version>
      <description>
          The generator shall raise an error message if parameter MkaCryptoKeyWrapJobRef does not point to a valid reference.
        </description>
      <comment>
          Rationale:
          This check is necessary to protect the post build configuration structure to be filled with
          wrong values.
        </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_GenTest_01023_Invalid_Mka_Xdm_MkaCryptoKeyWrapJobRef_InvalidRef</srcid><srcstatus/><internalId>1759</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1659</internalId></specobject>
    <specobject>
      <id>Mka.XDM.Crypto.MkaCryptoKeyWrapJobRef_InvalidKey</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>26074</sourceline>
      <version>1</version>
      <description>
          The generator shall raise an error message if referenced job used for key wrap does not have the same key configured
          as referenced by MkaCryptoKeyUnwrapJobRef.
        </description>
      <comment>
          Rationale:
          This check is necessary to protect the post build configuration structure to be filled with
          wrong values.
        </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_GenTest_01024_Invalid_Mka_Xdm_MkaCryptoKeyWrapJobRef_InvalidKey</srcid><srcstatus/><internalId>1760</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1660</internalId></specobject>
    <specobject>
      <id>Mka.XDM.Crypto.MkaCryptoKeyUnwrapJobRef_InvalidRef</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>26093</sourceline>
      <version>1</version>
      <description>
          The generator shall raise an error message if parameter MkaCryptoKeyUnwrapJobRef does not point to a valid reference.
        </description>
      <comment>
          Rationale:
          This check is necessary to protect the post build configuration structure to be filled with
          wrong values.
        </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_GenTest_01025_Invalid_Mka_Xdm_MkaCryptoKeyUnwrapJobRef_InvalidRef</srcid><srcstatus/><internalId>1761</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1661</internalId></specobject>
    <specobject>
      <id>Mka.XDM.Crypto.MkaCryptoKeyUnwrapJobRef_InvalidKey</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>26111</sourceline>
      <version>1</version>
      <description>
          The generator shall raise an error message if referenced job used for key unwrap does not have the same key configured
          as referenced by MkaCryptoKeyWrapJobRef.
        </description>
      <comment>
          Rationale:
          This check is necessary to protect the post build configuration structure to be filled with
          wrong values.
        </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_GenTest_01026_Invalid_Mka_Xdm_MkaCryptoKeyUnwrapJobRef_InvalidKey</srcid><srcstatus/><internalId>1762</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1662</internalId></specobject>
    <specobject>
      <id>Mka.XDM.Crypto.MkaCryptoSakKeyRef_InvalidRef</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>26130</sourceline>
      <version>1</version>
      <description>
          The generator shall raise an error message if parameter MkaCryptoSakKeyRef is enabled and does not point to a valid reference.
        </description>
      <comment>
          Rationale:
          This check is necessary to protect the post build configuration structure to be filled with
          wrong values.
        </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_GenTest_01027_Invalid_Mka_Xdm_MkaCryptoSakKeyRef_InvalidRef</srcid><srcstatus/><internalId>1763</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1663</internalId></specobject>
    <specobject>
      <id>Mka.XDM.Crypto.MkaCryptoSak2KeyRef_InvalidRef</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>26148</sourceline>
      <version>1</version>
      <description>
          The generator shall raise an error message if parameter MkaCryptoSak2KeyRef is enabled and does not point to a valid reference.
        </description>
      <comment>
          Rationale:
          This check is necessary to protect the post build configuration structure to be filled with
          wrong values.
        </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_GenTest_01052_Invalid_Mka_Xdm_MkaCryptoSak2KeyRef_InvalidRef</srcid><srcstatus/><internalId>1788</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1664</internalId></specobject>
    <specobject>
      <id>Mka.XDM.PaeConfiguration.MkaPaeConfiguration_Consecutive</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>26166</sourceline>
      <version>1</version>
      <description>
          The generator shall raise an error message if MkaPaeConfigurationIdx of the MkaPaeConfiguration are not consecutive.
        </description>
      <comment>
          Rationale:
          This check is necessary to protect the post build configuration structure to be filled with
          wrong values.
        </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_GenTest_01028_Invalid_Mka_Xdm_MkaPaeConfiguration_Consecutive</srcid><srcstatus/><internalId>1764</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1665</internalId></specobject>
    <specobject>
      <id>Mka.XDM.CryptoAlgoConfig.MkaCryptoAlgoConfig_Consecutive</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>26184</sourceline>
      <version>1</version>
      <description>
          The generator shall raise an error message if MkaCryptoAlgoConfigIdx of the MkaCryptoAlgoConfig are not consecutive.
        </description>
      <comment>
          Rationale:
          This check is necessary to protect the post build configuration structure to be filled with
          wrong values.
        </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_GenTest_01029_Invalid_Mka_Xdm_MkaCryptoAlgoConfig_Consecutive</srcid><srcstatus/><internalId>1765</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1666</internalId></specobject>
    <specobject>
      <id>Mka.XDM.CryptoAlgoConfig.OffsetSetForXPN</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>26202</sourceline>
      <version>1</version>
      <description>
          The generator shall raise an error message if MkaMacSecConfidentialityOffset is enabled and set to value other than MKA_CONFIDENTIALITY_OFFSET_0,
          when XPN cipher suite has been selected.
        </description>
      <comment>
          Rationale:
          This check is necessary because Confidentiality Offset is not used with XPN cipher suite.
        </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_GenTest_01030_Invalid_Mka_Xdm_OffsetSetForXPN</srcid><srcstatus/><internalId>1766</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_1590</srcid><srcstatus/><internalId>885</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.34</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>236</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1667</internalId></specobject>
    <specobject>
      <id>Mka.XDM.CryptoAlgoConfig.Confidentiality_NoOffset</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>26227</sourceline>
      <version>1</version>
      <description>
          The generator shall raise an error message if MkaMacSecConfidentialityOffset is disabled when MkaMacSecCapability is set to INTEGRITY_AND_CONFIDENTIALITY.
        </description>
      <comment>
          Rationale:
          This check is necessary because Confidentiality Offset must be set when MkaMacSecCapability is INTEGRITY_AND_CONFIDENTIALITY.
        </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_GenTest_01031_Invalid_Mka_Xdm_Confidentiality_NoOffset</srcid><srcstatus/><internalId>1767</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1668</internalId></specobject>
    <specobject>
      <id>Mka.XDM.CryptoAlgoConfig.OffsetSet_NoConfidentiality</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>26244</sourceline>
      <version>1</version>
      <description>
          The generator shall raise an error message if MkaMacSecConfidentialityOffset is enabled when MkaMacSecCapability is set to INTEGRITY_WITHOUT_CONFIDENTIALITY.
        </description>
      <comment>
          Rationale:
          This check is necessary because Confidentiality Offset is not used when MkaMacSecCapability is INTEGRITY_WITHOUT_CONFIDENTIALITY.
        </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_GenTest_01032_Invalid_Mka_Xdm_OffsetSet_NoConfidentiality</srcid><srcstatus/><internalId>1768</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1669</internalId></specobject>
    <specobject>
      <id>Mka.XDM.CipherSuites.MkaCipherSuites_Consecutive</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>26261</sourceline>
      <version>1</version>
      <description>
          The generator shall raise an error message if MkaMacSecCipherSuitePrio of the MkaCryptoAlgoConfig are not consecutive.
        </description>
      <comment>
          Rationale:
          This check is necessary to protect the post build configuration structure to be filled with
          wrong values.
        </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_GenTest_01033_Invalid_Mka_Xdm_MkaCipherSuites_Consecutive</srcid><srcstatus/><internalId>1769</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1670</internalId></specobject>
    <specobject>
      <id>Mka.XDM.CipherSuites.MkaCipherSuites_Repeating</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>26279</sourceline>
      <version>1</version>
      <description>
          The generator shall raise an error message if MkaMacSecCipherSuite of MkaCipherSuites list are repeated.
        </description>
      <comment>
          Rationale:
          This check is necessary to prevent memory waste.
        </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_GenTest_01034_Invalid_Mka_Xdm_MkaCipherSuites_Repeating</srcid><srcstatus/><internalId>1770</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1671</internalId></specobject>
    <specobject>
      <id>Mka.XDM.PaeInstance.MkaMaxNumPaeInstances_InvalidValue</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>26296</sourceline>
      <version>1</version>
      <description>
          The generator shall raise an error message if MkaMaxNumPaeInstances is smaller than the number of configured Pae instances.
        </description>
      <comment>
          Rationale:
          This check is necessary to protect the post build configuration structure to be filled with
          wrong values.
        </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_GenTest_01035_Invalid_Mka_Xdm_MkaMaxNumPaeInstances_InvalidValue</srcid><srcstatus/><internalId>1771</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1672</internalId></specobject>
    <specobject>
      <id>Mka.XDM.PaeInstance.MkaMaxNumParticipants_InvalidValue</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>26314</sourceline>
      <version>1</version>
      <description>
          The generator shall raise an error message if MkaMaxNumParticipants is smaller than the number of configured Pae instances.
        </description>
      <comment>
          Rationale:
          This check is necessary to protect the post build configuration structure to be filled with
          wrong values.
        </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_GenTest_01036_Invalid_Mka_Xdm_MkaMaxNumParticipants_InvalidValue</srcid><srcstatus/><internalId>1772</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1673</internalId></specobject>
    <specobject>
      <id>Mka.XDM.MkaNvmBlockDescriptorRef.ReadAll</id>
      <status>approved</status>
      <source>EB</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>26332</sourceline>
      <version>1</version>
      <description>
          The generator shall raise an error if NvMSelectBlockForReadAll is not set in the NvM block referenced by
          MkaNvmBlockDescriptorRef so that reading will be done by BswM module.
        </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_GenTest_01037_Invalid_Mka_Xdm_MkaNvmBlockDescriptorRef_ReadAll</srcid><srcstatus/><internalId>1773</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_2413</srcid><srcstatus/><internalId>922</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.Mka.MkaNvmBlockDescriptorRef_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1453</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1674</internalId></specobject>
    <specobject>
      <id>Mka.XDM.MkaNvmBlockDescriptorRef.WriteAll</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>26353</sourceline>
      <version>1</version>
      <description>
          The generator shall raise an error if NvMSelectBlockForWriteAll flag is not set in the NvM block referenced by
          MkaNvmBlockDescriptorRef so that writing will be done by BswM module.
        </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_GenTest_01038_Invalid_Mka_Xdm_MkaNvmBlockDescriptorRef_WriteAll</srcid><srcstatus/><internalId>1774</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_2417</srcid><srcstatus/><internalId>923</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.Mka.MkaNvmBlockDescriptorRef_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1453</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1675</internalId></specobject>
    <specobject>
      <id>Mka.XDM.MkaNvmBlockDescriptorRef.RamAddress</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>26374</sourceline>
      <version>1</version>
      <description>
          The generator shall raise an error if Ram address for reading and writing is not set in the NvM block
          referenced by MkaNvmBlockDescriptorRef to MkaNvRam_Memory.
        </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_GenTest_01039_Invalid_Mka_Xdm_MkaNvmBlockDescriptorRef_RamAddress</srcid><srcstatus/><internalId>1775</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_2421</srcid><srcstatus/><internalId>924</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.Mka.MkaNvmBlockDescriptorRef_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1453</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1676</internalId></specobject>
    <specobject>
      <id>Mka.XDM.MkaNvmBlockDescriptorRef.UserHeader</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>26395</sourceline>
      <version>1</version>
      <description>
          The generator shall raise an error if one of the user headers in NvMUserHeader list is not Mka.h.
        </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_GenTest_01040_Invalid_Mka_Xdm_MkaNvmBlockDescriptorRef_UserHeader</srcid><srcstatus/><internalId>1776</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_2425</srcid><srcstatus/><internalId>925</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.Mka.MkaNvmBlockDescriptorRef_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1453</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1677</internalId></specobject>
    <specobject>
      <id>Mka.XDM.MkaNvmBlockDescriptorRef.MinimumMemorySize_Invalid</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>26415</sourceline>
      <version>1</version>
      <description>
          The generator shall raise an error if NvMNvBlockLength is smaller than size of MkaNvRam_Memory
          structure. Size is calculated as:
          sizeof(MkaNvRam_Memory) or
          1 *  uint32 (4 octets) +
          3 * uint8(1 octet) times maximum number of PAEs +
          for each Participant 1 bit aligned to octets, meaning minimum 1 octet
            - largest integer value less than or equal to ((MaxNumParticipants + 7) / 8)
          and sum of all aligned to 4.
            - largest integer value less than or equal to (((Sum + 3) * 4) / 4)
        </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_GenTest_01041_Invalid_Mka_Xdm_MinimumMemorySize_Invalid</srcid><srcstatus/><internalId>1777</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_2429</srcid><srcstatus/><internalId>926</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.Mka.MkaNvmBlockDescriptorRef_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1453</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1678</internalId></specobject>
    <specobject>
      <id>Mka.XDM.MkaGetMacSecStatisticsCallback_EmptyReference</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>26443</sourceline>
      <version>1</version>
      <description>
          The generator shall raise an error if MkaGetMacSecStatisticsCallback is set, but callback function name isn't specified.
        </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_GenTest_01042_Invalid_Mka_Xdm_MacSecStatisticsNotification_CallbackRef_Invalid</srcid><srcstatus/><internalId>1778</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_2511</srcid><srcstatus/><internalId>930</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.MkaGetMacSecStatisticsCallback_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1459</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1679</internalId></specobject>
    <specobject>
      <id>Mka.XDM.MkaSecYCallout_EmptyReference</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>26463</sourceline>
      <version>1</version>
      <description>
          The generator shall raise an error if MkaSecYCallout is set, but callback function name isn't specified.
        </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_GenTest_01053_Invalid_Mka_Xdm_MkaSecYCallout_EmptyReference</srcid><srcstatus/><internalId>1789</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_2546</srcid><srcstatus/><internalId>932</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0115.CallbackFunctions</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>967</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0124.InterruptMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>976</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1680</internalId></specobject>
    <specobject>
      <id>Mka.XDM.MkaTaskCallout_EmptyReference</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>26487</sourceline>
      <version>1</version>
      <description>
          The generator shall raise an error if MkaTaskCallout is set, but callback function name isn't specified.
        </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_GenTest_01054_Invalid_Mka_Xdm_MkaTaskCallout_EmptyReference</srcid><srcstatus/><internalId>1790</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_2581</srcid><srcstatus/><internalId>934</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0115.CallbackFunctions</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>967</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0124.InterruptMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>976</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1681</internalId></specobject>
    <specobject>
      <id>Mka.XDM.MkaReportEventCallout_EmptyReference</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>26511</sourceline>
      <version>1</version>
      <description>
          The generator shall raise an error if MkaReportEventCallout is enabled, but callback function name isn't specified.
        </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_GenTest_01055_Invalid_Mka_Xdm_MkaReportEventCallout_EmptyReference</srcid><srcstatus/><internalId>1791</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_2631</srcid><srcstatus/><internalId>936</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Func0115.CallbackFunctions</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>967</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Func0124.InterruptMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>976</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1682</internalId></specobject>
    <specobject>
      <id>Mka.XDM.MkaKayDemEventParameterRefs_InvalidReference</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>26535</sourceline>
      <version>1</version>
      <description>
          The generator shall raise an error if an event inside of container MkaKayDemEventParameterRefs does not point to a valid reference.
        </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_GenTest_01044_Invalid_Mka_Xdm_MkaKayDemEventParameterRefs_InvalidReference</srcid><srcstatus/><internalId>1780</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_1178</srcid><srcstatus/><internalId>862</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_1212</srcid><srcstatus/><internalId>865</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_1246</srcid><srcstatus/><internalId>868</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_1279</srcid><srcstatus/><internalId>871</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1683</internalId></specobject>
    <specobject>
      <id>Mka.XDM.MkaKayDemEventParameterRefs_UniqueReference</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>26549</sourceline>
      <version>1</version>
      <description>
          The generator shall raise an error if an event inside of container MkaKayDemEventParameterRefs does not have a unique reference.
        </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_GenTest_01045_Invalid_Mka_Xdm_MkaKayDemEventParameterRefs_UniqueReference</srcid><srcstatus/><internalId>1781</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_1181</srcid><srcstatus/><internalId>863</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_1215</srcid><srcstatus/><internalId>866</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_1249</srcid><srcstatus/><internalId>869</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/config/Mka.xdm.m4_1282</srcid><srcstatus/><internalId>872</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1684</internalId></specobject>
    <specobject>
      <id>Mka.XDM.MkaPaeEthIfEthTrcvRef_InvalidReference</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>26563</sourceline>
      <version>1</version>
      <description>
          The generator shall raise an error if MACsec PAE references EthIfControllers with invalid reference to EthIfEthTrcvRef.
        </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_GenTest_01046_Invalid_Mka_Xdm_MkaPaeEthIfEthTrcvRef_InvalidReference</srcid><srcstatus/><internalId>1782</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00002.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>297</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1685</internalId></specobject>
    <specobject>
      <id>Mka.XDM.MkaPaeEthIfEthTrcvRef_UniqueReference</id>
      <status>approved</status>
      <source>DESIGN</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/doc/project/design/pdf/Mka_Design-profiled.xml</sourcefile>
      <sourceline>26582</sourceline>
      <version>1</version>
      <description>
          The generator shall raise an error if two or more MACsec PAEs reference EthIfControllers with the same EthIfEthTrcvRef.
        </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Mka_GenTest_01047_Invalid_Mka_Xdm_MkaPaeEthIfEthTrcvRef_UniqueReference</srcid><srcstatus/><internalId>1783</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00002.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>297</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1686</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>Mka_ConTest00000_MkaInit</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Conformance/IN/Mka_ConTest01/TestSpec_Generated.h</sourcefile>
      <sourceline>9</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that Mka unit it properly initialized after calling function Mka_Init().
Test Object: Mka initialization.
Test Precondition: 
  
Test Execution: 
    01: Call Mka_Init() to initialize module.
    02: VP(Mka.CP_SWS_Mka_91001,1) Verify that Mka is properly initialized.
    03: VP(Mka.CP_SWS_Mka_00022,1) Verify that Crypto unit called Csm_KeySetValid() for ICK and KEK key for every configured participant.
    04: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_91001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>375</internalId></provcov>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00022</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>338</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1687</internalId></specobject>
    <specobject>
      <id>Mka_ConTest01000_PeriodicMkpduTransmission</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Conformance/IN/Mka_ConTest01/TestSpec_Generated.h</sourcefile>
      <sourceline>33</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies periodic MKPDU transmission after MKA module initialization, but no Live nor Potential peer.
Test Object: MKPDU transmission.
Test Precondition: 
    -   Mka module initialized.
  
Test Execution: 
    01: Asynchronous callback from Csm to Crypto unit indicating successful finish of ICK generation.
    02: Call Mka_MainFunction() to process Crypto requests.
    03: Call Mka_CsmRandomCallback() to indicate that random generation of Member identifier has finished.
    04: Sanity check - Sanity check.
    05: Call EbTest_LinkStateActive() (Mka_LinkStateChange(ACTIVE==true)) to start sending periodic MKPDU-s.
    06: Call EbTest_TickMain_UntilTxMkpdu() to trigger timer for sending Mkpdu.
    07: VP(Mka.CP_SWS_Mka_00031,1)
        VP(Mka.InterAct.LinkStateChange,1) Verify that MKA instance (KaY) shall start the MKA sequence(s) through the referred EthIf immediately after receiving the port link-up signal with the Mka_LinkStateChange function.
    08: VP(Mka.CP_SWS_Mka_00012,1)
        VP(Mka.dsn.KaY.Api.TimerCallbackTxMkpdu.LivePeerNotFound,1) Verify that Retry timer has increased (TickMaxOld != TickMax) and that timer expired (DirtyFlag was TRUE when Mka_MainFunction was called).
    09: Call Mka_CsmIcvGenerateCallback() to indicate that ICV generation has finished.
    10: VP(Mka.8021X.MkaTransport.4,1)
        VP(Mka.8021X.Eapol.12,1)
        VP(Mka.8021X.Eapol.16,1) Verify that Mka periodically transmits MKPDU with Basic parameter set and ICV.
    11: Set Message number in Basic parameter set in test MKPDU.
    12: VP(Mka.dsn.KaY.Api.TimerCallbackTxMkpdu.LivePeerNotFound,1) Verify that Retry timer has reached value of Mka_PaeConfiguration[1]-&amp;gt;RetryCyclicDelay.
    13: Prepare timer. Since no live peer has been found, TickMax shall double before each new DirtyFlag.
    14: Call Mka_MainFunction() to tick Mka Hello timer till it expires and add 5 more for each main function in loop.
    15: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00031</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>349</internalId></provcov>
        <provcov>
          <linksto>Mka.InterAct.LinkStateChange</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1080</internalId></provcov>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00012</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>321</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.Api.TimerCallbackTxMkpdu.LivePeerNotFound</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1572</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.MkaTransport.4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>154</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.Eapol.12</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>54</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.Eapol.16</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>58</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1688</internalId></specobject>
    <specobject>
      <id>Mka_ConTest01001_PeerList_TxPotentFirst</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Conformance/IN/Mka_ConTest01/TestSpec_Generated.h</sourcefile>
      <sourceline>93</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies Potential and Live Peer List transmission after receiving EAPOL_MKPDU from another member. First, the actor sends MKPDU without any peer list, then it receives an EAPOL_MKPDU also without a peer list. After this actor shall generate a potential peer list for next EAPOL_MKPDU it sends. After this, we receive an EAPOL_MKPDU with a live peer list that has actor's ID and MN, thus actor shall send EAPOL_MKPDU containing Live Peer List.
Test Object: MKPDU transmission.
Test Precondition: 
    -   Mka module initialized.
    -   Call Mka_DisableMacSec to disable MacSec and use PlainText.
    -   Mka module initialized.
    -   Call Mka_EnableMacSec to enable MacSec and use PlainText. This is done to verify Mka_EnableMacSec functionality.
    -   Mka module initialized.
  
Test Execution: 
    01: Call Mka_GetMacSecEnabled to check if the MacSec status has changed.
    02: VP(Mka.dsn.Api.GetMacSecEnabled,1) Verify that the MacSec status has changed.
    03: Generate new ICV and transmit first mkpdu that is transmitted immediately after LinkState changed to Active.
    04: Call function Mka_RxIndication() with EAPOL_MKPDU that doesn't contain a peer list.
    05: Call Mka_MainFunction to start ICV verification of received EAPOL_MKPDU.
    06: Sanity check - Sanity check.
    07: Call Mka_CsmIcvVerifyCallback to finish ICV Verification job.
    08: Call EbTest_TickMain_UntilTxMkpdu() to tick Mka Hello timer till it expires.
    09: Sanity check - Sanity check.
    10: Generate new ICV.
    11: VP(Mka.8021X.MkaTransport.18,1)
        VP(Mka.dsn.Api.EnableMacSec,1) Verify that Mka periodically transmitted MKPDU with Basic parameter set with Potential Peer List. This also verifies that Mka_EnableMacSec works as expected since MacSec is enabled.
    12: Call function Mka_RxIndication() with MKPDU that contains live peer list.
    13: Call Mka_MainFunction to start ICV verification of received EAPOL_MKPDU.
    14: Sanity check - Sanity check.
    15: Call Mka_CsmIcvVerifyCallback to finish ICV Verification job.
    16: Call EbTest_TickMain_UntilTxMkpdu() to tick Mka Hello timer till it expires.
    17: Sanity check - Sanity check.
    18: Generate new ICV.
    19: Adjust MKPDU values.
    20: VP(Mka.8021X.MkaTransport.17,1) Verify that Mka periodically transmitted MKPDU with Basic parameter set with Live Peer List.
    21: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Api.GetMacSecEnabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>987</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.MkaTransport.18</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>172</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Api.EnableMacSec</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>985</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.MkaTransport.17</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>171</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1689</internalId></specobject>
    <specobject>
      <id>Mka_ConTest01002_PeerList_TxLive</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Conformance/IN/Mka_ConTest01/TestSpec_Generated.h</sourcefile>
      <sourceline>148</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies Live Peer List transmission after receiving MKPDU with Potential Peer List that has our ID.
Test Object: MKPDU transmission.
Test Precondition: 
    -   Mka module initialized.
  
Test Execution: 
    01: Call EbTest_TickMain_UntilTxMkpdu() to tick Mka Hello timer till it expires.
    02: Generate new ICV and transmit first mkpdu.
    03: Call function Mka_RxIndication() with EAPOL_MKPDU that doesn't have a peer list.
    04: Call Mka_MainFunction to start ICV verification of received EAPOL_MKPDU.
    05: Sanity check - Sanity check.
    06: Call Mka_CsmIcvVerifyCallback to finish ICV Verification job.
    07: Call EbTest_TickMain_UntilTxMkpdu() to tick Mka Hello timer till it expires.
    08: Sanity check - Sanity check.
    09: Generate new ICV.
    10: VP(Mka.8021X.Eapol.28.3,1) Verify that Mka periodically transmitted MKPDU with Basic parameter set with Live Peer List.
    11: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.28.3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>80</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1690</internalId></specobject>
    <specobject>
      <id>Mka_ConTest01003_KSPLow_KSActor</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Conformance/IN/Mka_ConTest01/TestSpec_Generated.h</sourcefile>
      <sourceline>176</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that after actor detects a live peer, Key Server election will be done according to KeyServer priority. Local actor shall be elected as the Key Server and after that, SAK generation and distribution shall proceed. Local actor shall send Distributed SAK parameter set from which partner shall get SAK and thus send MKPDU containing MACsec SAK Use parameter set. After this, local actor shall send new MKPDU with SakUse parameter set.
Test Object: Priority based KeyServer election, actor shall generate and distribute SAK, in Asynchronous mode.
Test Precondition: 
    -   Mka module initialized.
  
Test Execution: 
    01: Communication cycle till both peers prove liveness.
    02: Call Mka_GetPaeStatus() to get a status for PAE 0.
    03: VP(Mka.CP_SWS_Mka_91018,1) Verify that Mka_GetPaeStatus() returned status MKA_STATUS_IN_PROGRESS for PAE 0 when Participant became principal actor.
    04: Call Mka_MainFunction to start generating SAK key after liveness has been proved.
    05: Simulate the asynchronous callout to continue the procedure.
    06: VP(Mka.EB.MkaTaskCallout,1) Verify that MKA_TASK_CALLOUT has been called after Mka_CsmRandomCallback.
    07: VP(Mka.8021X.MkaKeyHierarchy.10.1,1) Verify that SAK Key wrapping procedure has been started.
    08: Call Csm_Encrypt to continue encryption and wrapping of SAK key.
    09: Call Mka_CsmKeyWrapCallback and Mka_CsmHashGenerateCallback to finish SAKGenWrap and HashGen process.
    10: VP(Mka.EB.MkaTaskCallout,1) Verify that MKA_TASK_CALLOUT has been called.
    11: VP(Mka.CP_SWS_Mka_91033,1)
        VP(Mka.CP_SWS_Mka_91032,1) Verify that Mka_MacSecAddRxSaNotification() called Mka_Cp_MacSecAddRxSaNotification(), which indicates that SA for Rx is added, and it is called EthIf_MacSecAddTxSa() to add SA for Tx. Verify that Mka_MacSecAddTxSaNotification() called Mka_Cp_MacSecAddTxSaNotification(), which indicates that SA for Tx is added.
    12: Call Mka MainFunction.
    13: Generate new ICV.
    14: VP(Mka.8021X.KeyServerElection.58.1,1) Verify that Mka periodically transmitted MKPDU containing correct Distributed SAK parameter set and with KeyServer set to TRUE.
    15: Call function Mka_RxIndication() with MKPDU that contains MACsec SAK use parameter set.
    16: Call Mka_MainFunction to start ICV verification of received EAPOL_MKPDU.
    17: Sanity check - Sanity check.
    18: Call Mka_CsmIcvVerifyCallback to finish ICV Verification job.
    19: VP(Mka.EB.MkaTaskCallout,1) Verify that MKA_TASK_CALLOUT has been called after Mka_CsmIcvVerifyCallback.
    20: Sanity check - Check that LPn was updated.
    21: Call Mka_MainFunction() to tick Mka Hello timer right before it expires (-1).
    22: Call Mka_MainFunction when the Mka Hello Timer expired.
    23: VP(Mka.dsn.KaY.Api.TimerCallbackTxMkpdu.LivePeerFound,1) Verify that after the SecureConnection was established, timer expired after MkaHelloTime value.
    24: Generate new ICV.
    25: Adjust MKPDU values.
    26: Sanity check - Verify that Mka periodically transmitted MKPDU with Basic parameter set with Live Peer List and correct SakUse param. set.
    27: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_91018</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>383</internalId></provcov>
        <provcov>
          <linksto>Mka.EB.MkaTaskCallout</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1474</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.MkaKeyHierarchy.10.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>126</internalId></provcov>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_91033</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>395</internalId></provcov>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_91032</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>394</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.58.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>269</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.Api.TimerCallbackTxMkpdu.LivePeerFound</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1573</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1691</internalId></specobject>
    <specobject>
      <id>Mka_ConTest01004_KSPHigh_KSPartner</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Conformance/IN/Mka_ConTest01/TestSpec_Generated.h</sourcefile>
      <sourceline>245</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that after actor detects a live peer, Key Server election will be done according to KeyServer priority. Partner shall be elected as the Key Server and after that, SAK generation and distribution shall proceed. Partner shall send Distributed SAK parameter set from which local actor shall get SAK and thus send MKPDU containing MACsec SAK Use parameter set. Local actor shall enter CP_RETIRE state and generate new SakUse parameter set with old key being used.
Test Object: MKPDU transmission in asynchronous mode.
Test Precondition: 
    -   Mka module initialized.
  
Test Execution: 
    01: Communication cycle till both peers prove liveness.
    02: Call Mka_MainFunction() to tick Mka Hello timer till it expires (-1).
    03: Sanity check - Sanity check.
    04: Generate new ICV.
    05: Sanity check - Verify that Mka periodically transmitted MKPDU with KeyServer set to FALSE.
    06: Call function Mka_RxIndication() with MKPDU that contains Distributed SAK parameter set.
    07: Call Mka_MainFunction to start ICV verification of received EAPOL_MKPDU.
    08: Sanity check - Sanity check.
    09: Call Mka_CsmIcvVerifyCallback to finish ICV Verification job.
    10: Call Mka_MainFunction after ICV has been verified to start SAK unwrapping process.
    11: Simulate the asynchronous callback to continue the unwrapping procedure.
    12: Simulate the asynchronous callout to finish the procedure.
    13: Simulate the asynchronous callout to finish the procedure.
    14: Sanity check - Sanity check.
    15: Sanity check - Check that no event flag has been set.
    16: VP(Mka.EB.RunTimeEvent.BitFieldDefinition,1)
        VP(Mka.EB.RunTimeEvent.TriggeredEventPae,1) Verify that, after the new Sak has been received, a bit for that event has been set for the selected Pae.
    17: Tick Mka MainFunction.
    18: Generate new ICV and transmit new mkpdu.
    19: Adjust MKPDU values.
    20: VP(Mka.InterAct.MkaLatestKeyGetsOldAfterRetire,1) Verify that Mka periodically transmitted MKPDU with correct SakUse parameter set.
    21: Call Mka_MainFunction() to tick Mka Hello timer right before it expires (-1).
    22: Call Mka_MainFunction when the Mka Hello Timer expired.
    23: VP(Mka.dsn.KaY.Api.TimerCallbackTxMkpdu.LivePeerFound,1) Verify that after the SecureConnection was established, timer expired after MkaHelloTime value.
    24: Generate new ICV and transmit new mkpdu.
    25: Create MkpduRecv_SAK with Live peer list, Sak Use parameter set and other essential parameters.
    26: Call function Mka_RxIndication() with MKPDU that contains MACsec SAK use parameter set.
    27: Call Mka_MainFunction to start ICV verification of received EAPOL_MKPDU.
    28: Sanity check - Sanity check.
    29: Call Mka_CsmIcvVerifyCallback to finish ICV Verification job.
    30: Call Mka_MainFunction() to tick Mka Hello timer till it expires (-1).
    31: Sanity check - Sanity check.
    32: VP(Mka.CP_SWS_Mka_00032,1)
        VP(Mka.CP_SWS_Mka_00032.1,1) Verify that EthIf_MacSecOperational was called with parameter TRUE after successful configuration of MacSec protected port, indicating that MacSec protected frames can be transmitted and received.
    33: Generate new ICV.
    34: Adjust MKPDU values.
    35: Sanity check - Verify that Mka periodically transmitted MKPDU with correct SakUse parameter set.
    36: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.RunTimeEvent.BitFieldDefinition</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1478</internalId></provcov>
        <provcov>
          <linksto>Mka.EB.RunTimeEvent.TriggeredEventPae</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1480</internalId></provcov>
        <provcov>
          <linksto>Mka.InterAct.MkaLatestKeyGetsOldAfterRetire</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1084</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.Api.TimerCallbackTxMkpdu.LivePeerFound</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1573</internalId></provcov>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00032</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>350</internalId></provcov>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00032.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>351</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1692</internalId></specobject>
    <specobject>
      <id>Mka_ConTest01044_KSPHigh_KSPartner_Restart</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Conformance/IN/Mka_ConTest01/TestSpec_Generated.h</sourcefile>
      <sourceline>320</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that after successful Mka sequence KeY server is stopped for time longer than MkaLifeTime and then restarted, sequence shall be successfully established again.
Test Object: MKPDU transmission in asynchronous mode.
Test Precondition: 
  
Test Execution: 
    01: Timeout Key Server (do not receive any message from key server for period longer than MkaLifeTime.
    02: Wait one more time for TxMkpdu. This time key server liveness should expire since there was no response for over 6 seconds in total.
    03: Sanity check - Sanity check.
    04: Start key server and try to establish communication again. Communication cycle till both peers prove liveness.
    05: Call Mka_MainFunction() to tick Mka Hello timer till it expires (-1).
    06: Sanity check - Sanity check.
    07: Generate new ICV.
    08: Call function Mka_RxIndication() with MKPDU that contains Distributed SAK parameter set.
    09: Call Mka_CsmIcvVerifyCallback to finish ICV Verification job.
    10: Call Mka_MainFunction to start ICV verification of received EAPOL_MKPDU.
    11: Sanity check - Sanity check.
    12: Call Mka_MainFunction after ICV has been verified to start SAK unwrapping process.
    13: Simulate the asynchronous callback to continue the unwrapping procedure.
    14: VP(Mka.8021X.KeyServerElection.65, 1) SAK shall be unwrapped as this DistributedSAK parameter set came for principal actor.
    15: Simulate the asynchronous callout to finish the procedure.
    16: Sanity check - Sanity check.
    17: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.65</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>278</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1693</internalId></specobject>
    <specobject>
      <id>Mka_ConTest01005_KeyServerFlag_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Conformance/IN/Mka_ConTest01/TestSpec_Generated.h</sourcefile>
      <sourceline>353</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that our Key server flag is set to TRUE at beginning, but after receiving MKPDU with higher Key server priority, key server is determined with priority based protocol and our Key server flag is set to FALSE.
Test Object: Key server flag.
Test Precondition: 
    -   Mka module initialized.
  
Test Execution: 
    01: Call Mka_GetPaeStatus() to get a status for PAE 0.
    02: VP(Mka.CP_SWS_Mka_91018,1) Verify that Mka_GetPaeStatus() returned status MKA_STATUS_UNDEFINED for PAE 0.
    03: Call EbTest_InstSM_Running() to bring Instance SM to Running state.
    04: Call Mka_GetPaeStatus() to get a status for PAE 0.
    05: VP(Mka.CP_SWS_Mka_91018,1) Verify that Mka_GetPaeStatus() returned status MKA_STATUS_WAITING_PEER for PAE 0.
    06: Call Mka_MainFunction() to process Crypto requests and tick Mka Hello timer.
    07: Call EbTest_GenIcv_Async() to generate new ICV and transmit new MKPDU.
    08: VP(Mka.8021X.KeyServerElection.4.2,1)
        VP(Mka.CP_SWS_Mka_00015,1) Verify that Key server flag is set to TRUE when there is no other peers.
    09: Call EbTest_PeerSM_PeerLive() to send MKPDU that is Live and have higer key server priority.
    10: VP(Mka.CP_SWS_Mka_91031,1) Verify that EbTest_PeerSM_PeerLive() finished successfully which indicates that SecY was successfully updated.
    11: Call EbTest_TickMain_UntilTxMkpdu() to tick Mka Hello timer till it expires.
    12: Call EbTest_GenIcv_Async() to generate new ICV and transmit new MKPDU.
    13: VP(Mka.8021X.KeyServerElection.4.2,1)
        VP(Mka.EB.KeyServerElection.5,1)
        VP(Mka.CP_SWS_Mka_00015,1) Verify that Key server flag is set to FALSE when partners became Key server.
    14: VP(Mka.EB.KeyServerElection.27.1,1) Verify that MACsec Capability is set to 1 after a Key server has been chosen and the least of two capabilities has been selected.
    15: Call Mka_MainFunction() to tick Mka Hello timer till it expires.
    16: Sanity check - After the peer life timeout a peer is deleted.
    17: Sanity check - Mkpdu is being sent..
    18: Call EbTest_GenIcv_Async() to generate new ICV and transmit new MKPDU.
    19: VP(Mka.EB.KeyServerElection.27.1,1) Verify that MACsec Capability is set back to 2 after a the live peer has reached life timeout and has been removed.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_91018</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>383</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.4.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>200</internalId></provcov>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00015</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>326</internalId></provcov>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_91031</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>393</internalId></provcov>
        <provcov>
          <linksto>Mka.EB.KeyServerElection.5</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>202</internalId></provcov>
        <provcov>
          <linksto>Mka.EB.KeyServerElection.27.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>225</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1694</internalId></specobject>
    <specobject>
      <id>Mka_ConTest01006_KeyServerFlag_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Conformance/IN/Mka_ConTest01/TestSpec_Generated.h</sourcefile>
      <sourceline>412</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that our Key server flag is set to TRUE at beginning, but after receiving MKPDU with lower Key server priority, key server is determined with priority based protocol and our Key server flag remain TRUE.
Test Object: Key server flag.
Test Precondition: 
    -   Mka module initialized.
  
Test Execution: 
    01: Call EbTest_InstSM_Running() to bring Instance SM to Running state.
    02: Call Mka_MainFunction() to process Crypto requests.
    03: Call EbTest_TickMain_UntilTxMkpdu() to tick Mka Hello timer till it expires.
    04: Call EbTest_GenIcv_Async() to generate new ICV and transmit new MKPDU.
    05: VP(Mka.8021X.KeyServerElection.4.2,1)
        VP(Mka.CP_SWS_Mka_00015,1) Verify that Key server flag is set to TRUE when there is no other peers.
    06: Call EbTest_PeerSM_PeerLive() to send MKPDU that is Live and have lower key server priority.
    07: Call EbTest_TickMain_UntilTxMkpdu() to tick Mka Hello timer till it expires.
    08: Call EbTest_GenIcv_Async() to generate new ICV and transmit new MKPDU.
    09: VP(Mka.8021X.KeyServerElection.4.2,1)
        VP(Mka.CP_SWS_Mka_00015,1) Verify that Key server flag is set to TRUE when participant became Key server.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.4.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>200</internalId></provcov>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00015</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>326</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1695</internalId></specobject>
    <specobject>
      <id>Mka_ConTest01007_MACsecCapabilityDesired_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Conformance/IN/Mka_ConTest01/TestSpec_Generated.h</sourcefile>
      <sourceline>444</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that transmitted MKPDU contains MACsec capability depending on configuration and that with every MKPDU, MACsec desired is set to TRUE. Configured Mka Kay Participant 0 has:
Test Object: Software
Test Precondition: 
    -   Mka module initialized.
  
Test Execution: 
    01: Call EbTest_InstSM_Running() to bring Instance SM to Running state.
    02: Call EbTest_TickMain_UntilTxMkpdu() to tick Mka Hello timer.
    03: Call EbTest_GenIcv_Async() to generate new ICV and transmit new MKPDU.
    04: VP(Mka.EB.KeyServerElection.27.1,1) Verify that MACsec Capability is set to 2 for Mka Kay Participant 0.
    05: VP(Mka.EB.KeyServerElection.27.2,2) Verify that MACsec desired flag is set to TRUE for Mka Kay Participant 0.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.KeyServerElection.27.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>225</internalId></provcov>
        <provcov>
          <linksto>Mka.EB.KeyServerElection.27.2</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>227</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1696</internalId></specobject>
    <specobject>
      <id>Mka_ConTest01008_MACsecCapabilityDesired_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Conformance/IN/Mka_ConTest01/TestSpec_Generated.h</sourcefile>
      <sourceline>470</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that transmitted MKPDU contains MACsec capability depending on configuration and that with every MKPDU, MACsec desired is set to TRUE. Configured Mka Kay Participant 2, Participant 0 has:
Test Object: Software
Test Precondition: 
    -   Mka module initialized.
  
Test Execution: 
    01: Call EbTest_InstSM_Running() to bring Instance SM to Running state.
    02: Call EbTest_TickMain_UntilTxMkpdu() to tick Mka Hello timer.
    03: Call EbTest_GenIcv_Async() to generate new ICV and transmit new MKPDU.
    04: VP(Mka.EB.KeyServerElection.27.1,1) Verify that MACsec Capability is set to 3 for Mka Kay Participant 2.
    05: VP(Mka.EB.KeyServerElection.27.2,2) Verify that MACsec desired flag is set to TRUE for Mka Kay Participant 2.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.KeyServerElection.27.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>225</internalId></provcov>
        <provcov>
          <linksto>Mka.EB.KeyServerElection.27.2</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>227</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1697</internalId></specobject>
    <specobject>
      <id>Mka_ConTest01009_DistributedSak</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Conformance/IN/Mka_ConTest01/TestSpec_Generated.h</sourcefile>
      <sourceline>496</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that parameters inside of Distributed SAK are properly filled.
Test Object: Distributed SAK parameter set.
Test Precondition: 
    -   Mka module initialized.
  
Test Execution: 
    01: Call EbTest_InstSM_Running() to bring Instance SM to Running state.
    02: Call EbTest_PeerSM_PeerLive() to send MKPDU that is Live and have lower key server priority.
    03: Call EbTest_GenerateSak() to generate SAK.
    04: Generate new ICV.
    05: VP(Mka.CP_SWS_Mka_00008.5,1) Verify that Distibuted SaK parameter set contains correct parameter set type.
    06: VP(Mka.8021X.KeyServerElection.33.2,2) Verify that Distributed SAK encodes correct Confidentiality Offset.
    07: VP(Mka.8021X.KeyServerElection.58.1,1) Verify that Distributed SAK encodes correct SAK protected by AES Key Wrap.
    08: VP(Mka.8021X.KeyServerElection.58.2,1) Verify that Distributed SAK encodes correct Key number.
    09: VP(Mka.8021X.KeyServerElection.61,1) Verify that Distributed SAK encodes correct Distributed AN.
    10: VP(Mka.CP_SWS_Mka_CONSTR_00019.1,1) Verify that the correct cipher is used (GCM-AES-128).
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00008.5</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>313</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.33.2</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>235</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.58.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>269</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.58.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>270</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.61</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>274</internalId></provcov>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_CONSTR_00019.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>330</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1698</internalId></specobject>
    <specobject>
      <id>Mka_ConTest01010_SakUse</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Conformance/IN/Mka_ConTest01/TestSpec_Generated.h</sourcefile>
      <sourceline>543</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: Test case verifies that parameters inside of SAK Use are properly filled.
Test Object: SAK Use parameter set.
Test Precondition: 
    -   Mka module initialized.
  
Test Execution: 
    01: Call EbTest_InstSM_Running() to bring Instance SM to Running state.
    02: Call EbTest_PeerSM_PeerLive() to send MKPDU that is Live and have lower key server priority.
    03: Call EbTest_GenerateSak() to generate SAK.
    04: Generate new ICV.
    05: VP(Mka.8021X.Eapol.22,1) Verify that SAK Use bits that are not used are set to zeroes.
    06: VP(Mka.8021X.KeyServerElection.38,1)
        VP(Mka.8021X.KeyServerElection.77,1) Verify that SAK Use contain correct latest key identifier.
    07: VP(Mka.CP_SWS_Mka_00008.4,1) Verify that Sak Use Parameter set has correct parameter set type value.
    08: VP(Mka.8021X.KeyServerElection.77,1) Verify that SAK Use encodes correct latest and oldest AN.
    09: VP(Mka.8021X.KeyServerElection.77,1) Verify that SAK Use encodes correct latest Lowest PN.
    10: VP(Mka.8021X.KeyServerElection.77,1) Verify that SAK Use encodes correct Old Lowest PN.
    11: VP(Mka.8021X.KeyServerElection.77,1) Verify that SAK Use encodes correct Latest and Old Key Tx.
    12: VP(Mka.8021X.KeyServerElection.77,1) Verify that SAK Use encodes correct Latest and Old Key Rx.
    13: VP(Mka.8021X.KeyServerElection.77,1) Verify that SAK Use encodes correct Delay Protect.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.22</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>64</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.38</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>241</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.77</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>289</internalId></provcov>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00008.4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>312</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1699</internalId></specobject>
    <specobject>
      <id>Mka_ConTest01011_SakRekeyDelay</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Conformance/IN/Mka_ConTest01/TestSpec_Generated.h</sourcefile>
      <sourceline>586</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that Key server will not distribute new SAK key until timer NEW_SAK_DELAY expires.
Test Object: Timer NEW_SAK_DELAY.
Test Precondition: 
    -   Mka module initialized.
  
Test Execution: 
    01: Call EbTest_InstSM_Running() to bring Instance SM to Running state.
    02: Call EbTest_PeerSM_PeerLive() to send MKPDU that is Live and have lower key server priority.
    03: Call EbTest_GenerateSak() to generate SAK.
    04: Generate new ICV.
    05: Call function Mka_RxIndication() with SAK Use that have LPN equal PendingPNExhaustion.
    06: Call Mka_MainFunction to process received MKPDU.
    07: VP(Mka.CP_SWS_Mka_91029,1) Verify that Csm_MacVerify is called, which indicates that Mka_RxIndication() is successfully processed received MKPDU.
    08: Call Mka_CsmIcvVerifyCallback to finish ICV Verification job.
    09: Call Mka_MainFunction() to process Crypto requests.
    10: VP(Mka.EB.KeyServerElection.45.2,1) Check that Crypto didn't call Csm_RandomGenerate(), which indicate beginning of SAK key generation.
    11: Call Mka_MainFunction() to tick New SAK delay.
    12: Generate new ICV and transmit MKPDU.
    13: VP(Mka.EB.KeyServerElection.46,1) Verify that Key server didn't send Distributed SAK parameter set after it received MKPDU that contain SAK Use parameter set with LRX = TRUE and Latest Key Identifier is same as Key identifier of generated SAK.
    14: Call function Mka_RxIndication() to reset timer LifePeerTimeout.
    15: Start verification of received ICV.
    16: Call Mka_CsmIcvVerifyCallback to finish ICV Verification job.
    17: Call Mka_MainFunction() to tick New SAK delay.
    18: VP(Mka.EB.KeyServerElection.45.2,1) Check that Crypto called Csm_RandomGenerate() after New SAK delay is expired. Since generation of new SAK already had condition to start with trigger from previous Mka_RxIndication(), because Packet number was higher than PendingPNExhaustion.
    19: Generate new ICV and transmit MKPDU.
    20: Simulate the asynchronous callout to continue the procedure.
    21: Call Csm_Encrypt to continue encryption and wrapping of SAK key.
    22: Generate new ICV and transmit MKPDU.
    23: Call Mka_CsmKeyWrapCallback and Mka_CsmHashGenerateCallback to finish SAKGenWrap and Hash gen. process.
    24: Call EbTest_TickMain_UntilTxMkpdu() to tick Mka Hello timer till it expires.
    25: Generate new ICV.
    26: VP(Mka.EB.KeyServerElection.45.2,1) Verify that Key server send Distributed SAK parameter set after New SAK delay is expired and generated new SAK key.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_91029</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>391</internalId></provcov>
        <provcov>
          <linksto>Mka.EB.KeyServerElection.45.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>254</internalId></provcov>
        <provcov>
          <linksto>Mka.EB.KeyServerElection.46</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>256</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1700</internalId></specobject>
    <specobject>
      <id>Mka_ConTest01012_SakDistribution_WrongMi</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Conformance/IN/Mka_ConTest01/TestSpec_Generated.h</sourcefile>
      <sourceline>637</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when actor receives MKPDU with Distributed SAK, but with wrong Member Identifier in Live peer list, it will not accept SAK key.
Test Object: Distribution of SAK key.
Test Precondition: 
    -   Mka module initialized.
  
Test Execution: 
    01: Call EbTest_InstSM_Running() to bring Instance SM to Running state.
    02: Call EbTest_PeerSM_PeerLive() to send MKPDU that is Live and have lower key server priority.
    03: Call function Mka_RxIndication() with MKPDU that contains Distributed SAK parameter set with wrong Member identifier in Live Peer list.
    04: Call Mka_MainFunction to start ICV verification of received EAPOL_MKPDU.
    05: Call Mka_CsmIcvVerifyCallback to finish ICV Verification job.
    06: Call Mka_MainFunction after ICV has been verified to start SAK unwrapping process.
    07: VP(Mka.8021X.KeyServerElection.50,1) Verify that Actor didn't call Csm_Decrypt() to unwrap SAK key, which indicate that SAK from Distributed SAK isn't accepted.
    08: Set up MKPDU with correct Member Identifier in Live peer list.
    09: Trigger transmission to reset TxMkpdu timer.
    10: Call function Mka_RxIndication() with MKPDU that contains Distributed SAK parameter set with correct Member identifier in Live Peer list.
    11: Call EbTest_UnwrapSak to start unwrapping SAK key.
    12: Generate new ICV and transmit new MKPDU.
    13: VP(Mka.8021X.KeyServerElection.50,1) Verify that Actor accepted SAK key from Distributed SAK and newly transmitted MKPDU contain SAK Use parameter set.
    14: Call Mka_MainFunction after ICV has been verified.
    15: VP(Mka.dsn.KaY.MacSecDesired.Discard,1) Verify that Actor silently discarded Mkpdu because the MacSecDesired is not compatible.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.50</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>260</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.MacSecDesired.Discard</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1591</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1701</internalId></specobject>
    <specobject>
      <id>Mka_ConTest01013_SakDistribution_Potential</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Conformance/IN/Mka_ConTest01/TestSpec_Generated.h</sourcefile>
      <sourceline>673</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when actor receives MKPDU with Distributed SAK, but with Potential peer list, will not accept SAK key.
Test Object: Distribution of SAK key.
Test Precondition: 
    -   Mka module initialized.
  
Test Execution: 
    01: Call EbTest_InstSM_Running() to bring Instance SM to Running state.
    02: Call EbTest_PeerSM_PeerLive() to send MKPDU that is Live and have lower key server priority.
    03: Call function Mka_RxIndication() with MKPDU that contains Distributed SAK parameter set but it has Potential peer list, instead of Live peer list.
    04: Call Mka_MainFunction to start ICV verification of received EAPOL_MKPDU.
    05: Call Mka_CsmIcvVerifyCallback to finish ICV Verification job.
    06: Call Mka_MainFunction after ICV has been verified to start SAK unwrapping process.
    07: VP(Mka.8021X.KeyServerElection.51,1) Verify that Actor didn't call Csm_Decrypt() to unwrap SAK key, which indicate that SAK from Distributed SAK isn't accepted.
    08: Set up MKPDU with Live peer list.
    09: Trigger transmission to reset TxMkpdu timer.
    10: Call function Mka_RxIndication() with MKPDU that contains Distributed SAK parameter set with correct Member identifier in Live Peer list.
    11: Call EbTest_UnwrapSak to start unwrapping SAK key.
    12: Call Mka_CsmIcvGenerateCallback() to indicate that ICV generation has finished.
    13: VP(Mka.8021X.KeyServerElection.51,1) Verify that Actor accepted SAK key from Distributed SAK and newly transmitted MKPDU contain SAK Use parameter set.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.51</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>261</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1702</internalId></specobject>
    <specobject>
      <id>Mka_ConTest01014_UnsupportedCipherSuite</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Conformance/IN/Mka_ConTest01/TestSpec_Generated.h</sourcefile>
      <sourceline>703</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when actor receives MKPDU with Distributed SAK that contains unsupported cipher suite, but supported MACsec capability, SAK is not accepted.
Test Object: Compatibility with distributed Cipher suite or Confidentiality offset.
Test Precondition: 
    -   Mka module initialized.
  
Test Execution: 
    01: Call EbTest_InstSM_Running() to bring Instance SM to Running state.
    02: Call EbTest_PeerSM_PeerLive() to send MKPDU that is Live and have lower key server priority.
    03: Call function Mka_RxIndication() with MKPDU that contains Distributed SAK parameter set with unsupported Cipher suite.
    04: Call Mka_MainFunction to start ICV verification of received EAPOL_MKPDU.
    05: Call Mka_CsmIcvVerifyCallback to finish ICV Verification job.
    06: Call Mka_MainFunction after ICV has been verified to start SAK unwrapping process.
    07: VP(Mka.8021X.KeyServerElection.26,2)
        VP(Mka.8021X.KeyServerElection.35,2) Verify that Actor didn't call Csm_Decrypt() to unwrap SAK key, which indicate that SAK from Distributed SAK isn't accepted, because Actor doesn't support distributed Cipher suite. Verify that the participant was deleted (security channel deleted).
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.26</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>222</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.35</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>237</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1703</internalId></specobject>
    <specobject>
      <id>Mka_ConTest01015_UnsupportedCapability</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Conformance/IN/Mka_ConTest01/TestSpec_Generated.h</sourcefile>
      <sourceline>732</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when actor receives MKPDU with Distributed SAK that contains supported cipher suite but unsupported MACsec capability, SAK is not accepted.
Test Object: Compatibility with distributed Confidentiality offset.
Test Precondition: 
    -   Mka module initialized.
  
Test Execution: 
    01: Call EbTest_InstSM_Running() to bring Instance SM to Running state.
    02: Call EbTest_PeerSM_PeerLive() to send MKPDU that is Live and have lower key server priority.
    03: Set up MKPDU with supported Cipher suite (AES128) and unsupported Confidentiality offset.
    04: Call function Mka_RxIndication() with MKPDU that contains Distributed SAK parameter set with unsupported Confidentiality offset.
    05: Call Mka_MainFunction to start ICV verification of received EAPOL_MKPDU.
    06: Call Mka_CsmIcvVerifyCallback to finish ICV Verification job.
    07: Call Mka_MainFunction after ICV has been verified to start SAK unwrapping process.
    08: VP(Mka.8021X.KeyServerElection.35,2) Verify that Actor didn't call Csm_Decrypt() to unwrap SAK key, which indicate that SAK from Distributed SAK isn't accepted, because Actor don't support distributed Confidentiality offset. Check that participant has been deleted (security channel removed).
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.35</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>237</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1704</internalId></specobject>
    <specobject>
      <id>Mka_ConTest01016_SupportedCipherSuiteAndCapability</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Conformance/IN/Mka_ConTest01/TestSpec_Generated.h</sourcefile>
      <sourceline>757</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when actor receives MKPDU with Distributed SAK that contains supported cipher suite and MACsec capability, SAK is accepted.
Test Object: Compatibility with distributed Cipher suite or Confidentiality offset.
Test Precondition: 
    -   Mka module initialized.
  
Test Execution: 
    01: Call EbTest_InstSM_Running() to bring Instance SM to Running state.
    02: Call EbTest_PeerSM_PeerLive() to send MKPDU that is Live and have lower key server priority.
    03: Set up MKPDU with supported Cipher suite (AES128) and Confidentiality offset.
    04: Trigger transmission to reset TxMkpdu timer.
    05: Call function Mka_RxIndication() with MKPDU that contains Distributed SAK parameter set with supported Confidentiality offset and Cipher suite.
    06: Call EbTest_UnwrapSak to start unwrapping SAK key.
    07: Generate new ICV and transmit new MKPDU.
    08: VP(Mka.8021X.KeyServerElection.26,2) Verify that Actor accepted SAK key from Distributed SAK and newly transmitted MKPDU contain SAK Use parameter set.
    09: Call function Mka_RxIndication() with MKPDU that contains Distributed SAK parameter set for second time.
    10: VP(Mka.8021X.KeyServerElection.26,2) Verify that Sak is successfully unwrapped after we received DistributedSAK for second time.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.26</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>222</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1705</internalId></specobject>
    <specobject>
      <id>Mka_ConTest01017_SakRekeyTimer</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Conformance/IN/Mka_ConTest01/TestSpec_Generated.h</sourcefile>
      <sourceline>784</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that Key server will distribute new SAK after timer MKA_TIMERS_GROUP_KAY_SAK_REKEY expires.
Test Object: Timer MKA_TIMERS_GROUP_KAY_SAK_REKEY.
Test Precondition: 
    -   Mka module initialized.
  
Test Execution: 
    01: Call EbTest_InstSM_Running() to bring Instance SM to Running state.
    02: Call EbTest_PeerSM_PeerLive() to send MKPDU that is Live and have lower key server priority.
    03: Call EbTest_GenerateSak() to generate SAK.
    04: Generate new ICV.
    05: Call function Mka_RxIndication() with SAK Use.
    06: Call Mka_MainFunction to process received MKPDU.
    07: Call Mka_CsmIcvVerifyCallback to finish ICV Verification job.
    08: Call Mka_MainFunction() to tick New SAK delay.
    09: Generate new ICV and transmit MKPDU.
    10: Call function Mka_RxIndication() with SAK Use.
    11: Call Mka_MainFunction to process received MKPDU.
    12: Call Mka_CsmIcvVerifyCallback to finish ICV Verification job.
    13: Tick Mka_MainFunction() till Mka Sak Rekey timer expires + 1 tick.
    14: Call Mka_MainFunction() when Mka Sak Rekey timer expired.
    15: VP(Mka.CP_SWS_Mka_00013,1) Verify that Sak Rekey timer expired and started generating of new SAK.
    16: Simulate the asynchronous callout to continue the SAK gen. procedure.
    17: Call Csm_Encrypt to continue encryption and wrapping of SAK key.
    18: Generate new ICV and transmit MKPDU.
    19: Call Mka_CsmKeyWrapCallback and Mka_CsmHashGenerateCallback to finish SAKGenWrap and Hash gen. process.
    20: Call Mka_MainFunction() to tick Mka Hello timer till it expires.
    21: Generate new ICV.
    22: VP(Mka.CP_SWS_Mka_00013,1) Verify that Key server sent Distributed SAK parameter set after Sak Rekey timer expired and generated new SAK key.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00013</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>322</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1706</internalId></specobject>
    <specobject>
      <id>Mka_ConTest01018_XPN</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Conformance/IN/Mka_ConTest01/TestSpec_Generated.h</sourcefile>
      <sourceline>823</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that parameters inside of XPN are properly filled.
Test Object: XPN parameter set.
Test Precondition: 
    -   Restore NvM and Enable MacSec.
    -   Mka module initialized.
  
Test Execution: 
    01: Call EbTest_InstSM_Running() to bring Instance SM to Running state.
    02: Call EbTest_PeerSM_PeerLive() to send MKPDU that is Live and have lower key server priority.
    03: Call EbTest_GenerateSak() to generate SAK.
    04: Generate new ICV and parse Tx buffer.
    05: Call Mka_Cp_FillXpn() to add XPN parameter set in MKPDU and parse Tx buffer.
    06: Sanity check - Check that is chose Cipher suite AES-XPN-128.
    07: VP(Mka.8021X.KeyServerElection.80,1)
        VP(Mka.CP_SWS_Mka_00008.7,1)
        VP(Mka.dsn.Cp.Api.FillXpn,1)
        VP(Mka.CP_SWS_Mka_CONSTR_00019.3,1)
        VP(Mka.8021X.Eapol.22,1) Verify that Mka_Cp_FillXpn() properly filled XPN and that encodes correct parameter set type and LLPN and OLPN.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.80</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>292</internalId></provcov>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00008.7</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>315</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.Api.FillXpn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1016</internalId></provcov>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_CONSTR_00019.3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>332</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.Eapol.22</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>64</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1707</internalId></specobject>
    <specobject>
      <id>Mka_ConTest01019_TwoSaks_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Conformance/IN/Mka_ConTest01/TestSpec_Generated.h</sourcefile>
      <sourceline>868</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when two participants on the same port find a live peer, and both live peers send Distributed Sak, the only key that shall be installed is the one received for the principal actor.
Test Object: MKA with two live participants on same port.
Test Precondition: 
    -   Restore NvM and Enable MacSec.
    -   Mka module initialized.
  
Test Execution: 
    01: Call EbTest_InstSM_Running() to bring Instance SM to Running state for both Participants on same Port.
    02: Finish the procedure of keys gen. for Participant 3.
    03: Call EbTest_PeerSM_PeerLive() to send MKPDU from first peer that is Live and has higher key server priority.
    04: Call EbTest_PeerSM_PeerLive() to send MKPDU from second peer that is Live and has higher key server priority.
    05: Call EbTest_TickMain_UntilTxMkpdu() to tick Mka Hello timer till it expires.
    06: Send Mkpdus.
    07: Add Distributed Sak Use param. set to Mkpdu_Peer1 and correct confidentiality offset.
    08: Add Distributed Sak Use param. set to Mkpdu_Peer2 and correct confidentiality offset.
    09: Call function Mka_RxIndication() with MKPDU that contains Distributed SAK parameter set, but is not for a principal actor.
    10: Call Mka_MainFunction to start ICV verification of received EAPOL_MKPDU.
    11: Sanity check - Sanity check.
    12: Call Mka_CsmIcvVerifyCallback to finish ICV Verification job.
    13: Call Mka_MainFunction after ICV has been verified.
    14: VP(Mka.8021X.KeyServerElection.65, 1)
        VP(Mka.dsn.Logon.SinglePrincipalActorPerKaY,1) SAK shall not be unwrapped and no further progress shall be made since this is not a principal actor.
    15: Call function Mka_RxIndication() with MKPDU that contains Distributed SAK parameter set and is for a principal actor.
    16: Call Mka_MainFunction to start ICV verification of received EAPOL_MKPDU.
    17: Sanity check - Sanity check.
    18: Call Mka_CsmIcvVerifyCallback to finish ICV Verification job.
    19: Call Mka_MainFunction after ICV has been verified.
    20: VP(Mka.8021X.KeyServerElection.65, 1) SAK shall be unwrapped as this DistributedSAK parameter set came for principal actor.
    21: Simulate the asynchronous callback to continue the unwrapping procedure.
    22: Simulate the asynchronous callout to finish the key unwrapping procedure.
    23: Sanity check - Sanity check.
    24: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.65</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>278</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Logon.SinglePrincipalActorPerKaY</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1599</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1708</internalId></specobject>
    <specobject>
      <id>Mka_ConTest01020_PermissiveMode_TimerExpires</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Conformance/IN/Mka_ConTest01/TestSpec_Generated.h</sourcefile>
      <sourceline>915</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that when timer MkaOnFailPermissiveModeTimeout expires, Logon will call Cp unit to disable MacSec.
Test Object: Software
Test Precondition: 
    -   Mka module initialized.
  
Test Execution: 
    01: Tick Mka_MainFunction() number of times specified in MkaOnFailPermissiveModeTimeout to expire permissive mode timer for PAE_2.
    02: VP(Mka.dsn.Logon.PermissiveMode.PaeAutoStart.Disabled,1) Verify that permissive timer has not expired because PAE_2 was not started (it needs to be started manually).
    03: Call Mka_LinkStateChange() to indicate that link of PAE_2 is active.
    04: Tick Mka_MainFunction() number of times specified in MkaOnFailPermissiveModeTimeout to expire permissive mode timer for PAE_2.
    05: VP(Mka.dsn.Logon.PermissiveMode.PaeAutoStart.Disabled,1) Verify that permissive timer has not expired because PAE_2 was not yet started.
    06: Call Mka_StartPae() to manually start PAE_2.
    07: Tick Mka_MainFunction() one less number of times specified in MkaOnFailPermissiveModeTimeout.
    08: Tick Mka_MainFunction() one more time to expire permissive mode timer for PAE_2.
    09: VP(Mka.CP_SWS_Mka_00028,1) Verify that when timer MkaOnFailPermissiveModeTimeout expires, it will call Mka_Cp_DisableMacSec() which calls EthIf_MacSecUpdateSecY() to disable MACsec.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.PermissiveMode.PaeAutoStart.Disabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1616</internalId></provcov>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00028</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>345</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1709</internalId></specobject>
    <specobject>
      <id>Mka_ConTest01021_PermissiveMode_TimerResetOnMkpdu_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Conformance/IN/Mka_ConTest01/TestSpec_Generated.h</sourcefile>
      <sourceline>945</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that permissive mode timer will be reset only when the first MKPDU is received on a PAE. The feature needs to be enabled with MkaRestartPermissiveModeTimerOnFirstMkpdu.
Test Object: Software
Test Precondition: 
    -   Mka module initialized.
    -   PAE_2 manually started.
  
Test Execution: 
    01: Call EbTest_InstSM_Running() to bring Instance SM to Running state for the first participant of PAE_2.
    02: Call Mka_LinkStateChange() to indicate that link of PAE_2 is active.
    03: Tick Mka_MainFunction() 1/2 MkaOnFailPermissiveModeTimeout times.
    04: Receive MKPDU to the Participant_3 on PAE_2.
    05: Process received MKPDU.
    06: Tick Mka_MainFunction() another 1/2 MkaOnFailPermissiveModeTimeout times.
    07: VP(Mka.EB.RestartPermissiveModeTimerOnFirstMkpdu,1) Verify that permissive mode timer has not expired because it has been restarted when the first MKPDU was received.
    08: Tick Mka_MainFunction() 1/2 MkaOnFailPermissiveModeTimeout - 3 times (-3 because we will need 2 ticks for MKPDU processing) .
    09: Receive MKPDU again for the Participant_3 (pls. note that Message Identifier is not incremented - we want to check that only ICV is ok, not the package itself).
    10: Process received MKPDU.
    11: Tick Mka_MainFunction() one more times.
    12: VP(Mka.EB.RestartPermissiveModeTimerOnFirstMkpdu,1) Verify that MKPDU timer has expired, which proves that the second received MKPDU does not reset the permissive timer.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.RestartPermissiveModeTimerOnFirstMkpdu</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1448</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1710</internalId></specobject>
    <specobject>
      <id>Mka_ConTest01022_PermissiveMode_TimerResetOnMkpdu_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Conformance/IN/Mka_ConTest01/TestSpec_Generated.h</sourcefile>
      <sourceline>975</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that permissive mode timer will be reset only when the first MKPDU is received on a PAE, and the first MKPDU is counted since the link-up signal. The feature needs to be enabled with MkaRestartPermissiveModeTimerOnFirstMkpdu.
Test Object: Software
Test Precondition: 
    -   Mka module initialized.
    -   PAE_2 manually started.
  
Test Execution: 
    01: Call EbTest_InstSM_Running() to bring Instance SM to Running state for the first participant of PAE_2.
    02: Call Mka_LinkStateChange() to indicate that link of PAE_2 is active.
    03: Tick Mka_MainFunction() 1/2 MkaOnFailPermissiveModeTimeout times.
    04: Receive MKPDU to the Participant_3 on PAE_2.
    05: Process received MKPDU.
    06: Tick Mka_MainFunction() another 1/2 MkaOnFailPermissiveModeTimeout times.
    07: Simulate Crypto callback call to resolve pending request.
    08: Call Mka_LinkStateChange() twice to deactivate and activate link again.
    09: Call EbTest_InstSM_Running() to bring Instance SM to Running state for the first participant of PAE_2.
    10: Tick Mka_MainFunction() another 1/2 MkaOnFailPermissiveModeTimeout times.
    11: VP(Mka.CP_SWS_Mka_00030,1) Verify that permissive mode timer has not expired because link-down/link-up resets permissive timer.
    12: Receive MKPDU again for the Participant_3.
    13: Process received MKPDU.
    14: Tick Mka_MainFunction() MkaOnFailPermissiveModeTimeout -1 times.
    15: Tick Mka_MainFunction() one more times.
    16: VP(Mka.EB.RestartPermissiveModeTimerOnFirstMkpdu,1)
        VP(Mka.dsn.Logon.Api.MkpduReceived,1) Verify that MKPDU timer has expired, which proves link-down/link_up sequence not only reset permissive timer, but also "the first MKPDU" condition.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00030</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>348</internalId></provcov>
        <provcov>
          <linksto>Mka.EB.RestartPermissiveModeTimerOnFirstMkpdu</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1448</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Logon.Api.MkpduReceived</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1059</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1711</internalId></specobject>
    <specobject>
      <id>Mka_ConTest01023_XPN_ReserveBits_NegativeCase</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Conformance/IN/Mka_ConTest01/TestSpec_Generated.h</sourcefile>
      <sourceline>1018</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: Test case verifies that reserved bits inside of XPN are properly filled.
Test Object: XPN parameter set.
Test Precondition: 
    -   Restore NvM and Enable MacSec.
    -   Mka module initialized.
  
Test Execution: 
    01: Call EbTest_InstSM_Running() to bring Instance SM to Running state.
    02: Add the XPN parameter set the Mkpdu.
    03: Set and Verify that XPN reserve bits set to one.
    04: Call EbTest_PeerSM_PeerLive() to send MKPDU that is Live and have lower key server priority.
    05: Call EbTest_GenerateSak() to generate SAK.
    06: Generate new ICV and parse Tx buffer.
    07: Call Mka_Cp_FillXpn() to add XPN parameter set in MKPDU and parse Tx buffer.
    08: VP(Mka.8021X.Eapol.22,1) Verify that Mka_Cp_FillXpn() properly filled XPN with reserve bits set to zero.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.22</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>64</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1712</internalId></specobject>
    <specobject>
      <id>Mka_ConTest01024_MultiplePeers_DifferentCkn</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Conformance/IN/Mka_ConTest01/TestSpec_Generated.h</sourcefile>
      <sourceline>1044</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that MKPDU will be discarded if it has a different CKN than participant and that participant can't have more than one Peer member.
Test Object: Key server flag.
Test Precondition: 
    -   Mka module initialized.
  
Test Execution: 
    01: Call EbTest_InstSM_Running() to bring Instance SM to Running state.
    02: Call Mka_MainFunction() to process Crypto requests and tick Mka Hello timer.
    03: Call EbTest_TickMain_UntilTxMkpdu() to tick Mka Hello timer till it expires.
    04: Call EbTest_GenIcv_Async() to generate new ICV and transmit new MKPDU.
    05: Call function Mka_RxIndication() with MKPDU that has a peer list.
    06: Call Mka_MainFunction to start ICV verification of received EAPOL_MKPDU.
    07: VP(Mka.8021X.MkaKeyHierarchy.4.2,1) Verify that MKPDU is discarded, because participant doesn't have same CKN as Peer.
    08: Set up MKPDU with valid CKN.
    09: Call EbTest_PeerSM_PeerLive() to send MKPDU that is Live and have lower key server priority.
    10: Set up MKPDU from second Peer (Participant_3).
    11: Call function Mka_RxIndication() with MKPDU that has a peer list.
    12: Call Mka_MainFunction to start ICV verification of received EAPOL_MKPDU.
    13: Call Mka_CsmIcvVerifyCallback to finish ICV Verification job.
    14: VP(Mka.CP_SWS_Mka_00015,1) Verify that MKPDU is discarded, because participant already have Live Peer.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.MkaKeyHierarchy.4.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>114</internalId></provcov>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00015</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>326</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1713</internalId></specobject>
    <specobject>
      <id>Mka_ConTest01025_Eapol_8_8</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Conformance/IN/Mka_ConTest01/TestSpec_Generated.h</sourcefile>
      <sourceline>1079</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: Test case verifies that any octets following the packet body in the eapol pdu shall be ignored.
Test Object: Eapol pdu validation.
Test Precondition: 
    -   Mka module initialized.
  
Test Execution: 
    01: Call EbTest_InstSM_Running() to bring Instance SM to Running state.
    02: Call function Mka_RxIndication() with EAPOL_MKPDU that contain a live peer outside expected size.
    03: Call Mka_MainFunction to start ICV verification of received EAPOL_MKPDU.
    04: Call Mka_CsmIcvVerifyCallback to finish ICV Verification job.
    05: Call Mka_MainFunction() to tick Mka Hello timer till it expires.
    06: VP(Mka.8021X.Eapol.8.8,1) Verify that any octets following the packet body field in the EAPOL PDU are ignored.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.8.8</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>50</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1714</internalId></specobject>
    <specobject>
      <id>Mka_ConTest01026_PlainText_Peer</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Conformance/IN/Mka_ConTest01/TestSpec_Generated.h</sourcefile>
      <sourceline>1102</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when PlainText is used, empty DistributedSak and SakUse are used according to Mka.InterAct.MacSecDisabled.EmptyParamSets.
Test Object: PlainText.
Test Precondition: 
    -   Mka module initialized.
    -   Call Mka_DisableMacSec to disable MacSec and use PlainText.
    -   Mka module initialized.
  
Test Execution: 
    01: Call EbTest_InstSM_Running() to bring Instance SM to Running state.
    02: Call Mka_MainFunction() to process Crypto requests and tick Mka Hello timer.
    03: Call Mka_CsmIcvGenerateCallback() to indicate that ICV generation has finished.
    04: VP(Mka.EB.KeyServerElection.27.2,2)
        VP(Mka.EB.KeyServerElection.27.1,1) Verify that MacSec_Desired in BasicParameterSet is set to 0, but KeyServer to 1.
    05: Generate new ICV and transmit first MKPDU.
    06: Call function Mka_RxIndication() with MKPDU that has a peer list.
    07: Call Mka_MainFunction to start ICV verification of received EAPOL_MKPDU.
    08: Call Mka_CsmIcvVerifyCallback to finish ICV Verification job.
    09: VP(Mka.dsn.KaY.MacSecDisabled.NoKeysNoSc,1) Verify that KEK is not being generated and that EthIf_MacSecInitRxSc is not called.
    10: Add Distributed SAK to MKPDU.
    11: Set correct MN values.
    12: Trigger transmission to reset TxMkpdu timer.
    13: Call function Mka_RxIndication() with MKPDU that contains Distributed SAK and SAK Use parameter sets with plain text support.
    14: Call Mka_MainFunction to start ICV verification of received EAPOL_MKPDU.
    15: Call Mka_CsmIcvVerifyCallback to finish ICV Verification job.
    16: VP(Mka.InterAct.MacSecDisabled.EmptyParamSets,1) Verify that EthIf_MacSecUpdateSecY is called with correct input parameters.
    17: Call Mka_MacSecUpdateSecYNotification to finish UpdateSecY process.
    18: VP(Mka.dsn.Cp.MacSecOperational.Unsecured,1) Verify that EthIf_MacSecOperational(TRUE) is called to indicate to upper layers that link is available.
    19: Trigger transmission to reset TxMkpdu timer.
    20: Call Mka_MainFunction to start ICV verification of received EAPOL_MKPDU.
    21: Call Mka_CsmIcvGenerateCallback() to indicate that ICV generation has finished.
    22: VP(Mka.8021X.KeyServerElection.58.1,1) Verify that Distributed Sak parameter set is not transmitted as participant is not elected key server.
    23: VP(Mka.InterAct.MacSecDisabled.EmptyParamSets,1) Verify that Actor transmitted MKPDU containing SAK Use parameter set with support for plain text.
    24: Call second time function Mka_RxIndication() with MKPDU that contains Distributed SAK and SAK Use parameter sets with plain text support.
    25: Call Mka_CsmIcvVerifyCallback to finish ICV Verification job.
    26: VP(Mka.InterAct.MacSecDisabled.EmptyParamSets,1) Verify that Csm_MacGenerate is not called when Empty Distributed Sak was received for a second time. This verifies that repeated Distributed Sak didn't triggered deletion of Participant and then re-creation of same Participant.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.KeyServerElection.27.2</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>227</internalId></provcov>
        <provcov>
          <linksto>Mka.EB.KeyServerElection.27.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>225</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.MacSecDisabled.NoKeysNoSc</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1592</internalId></provcov>
        <provcov>
          <linksto>Mka.InterAct.MacSecDisabled.EmptyParamSets</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1081</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.MacSecOperational.Unsecured</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1487</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.58.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>269</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1715</internalId></specobject>
    <specobject>
      <id>Mka_ConTest01027_PlainText_Peer_Permissive</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Conformance/IN/Mka_ConTest01/TestSpec_Generated.h</sourcefile>
      <sourceline>1168</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when PlainText is used and MacSec is operational, Permissive timer is stopped.
Test Object: Permissive mode timer.
Test Precondition: 
    -   Mka module initialized.
    -   Call Mka_DisableMacSec to disable MacSec and use PlainText.
    -   Mka module initialized.
    -   PAE_2 manually started.
  
Test Execution: 
    01: Call EbTest_InstSM_Running() to bring Instance SM to Running state.
    02: Call Mka_MainFunction() to process Crypto requests and tick Mka Hello timer.
    03: Call Mka_CsmIcvGenerateCallback() to indicate that ICV generation has finished.
    04: Generate new ICV and transmit first MKPDU.
    05: Call function Mka_RxIndication() with MKPDU that has a peer list.
    06: Call Mka_MainFunction to start ICV verification of received EAPOL_MKPDU.
    07: Call Mka_CsmIcvVerifyCallback to finish ICV Verification job.
    08: VP(Mka.dsn.KaY.MacSecDisabled.NoKeysNoSc,1) Verify that KEK is not being generated and that EthIf_MacSecInitRxSc is not called.
    09: Add Distributed SAK to MKPDU.
    10: Set correct MN values.
    11: Trigger transmission to reset TxMkpdu timer.
    12: Call function Mka_RxIndication() with MKPDU that contains Distributed SAK and SAK Use parameter sets with plain text support.
    13: Call Mka_MainFunction to start ICV verification of received EAPOL_MKPDU.
    14: Call Mka_CsmIcvVerifyCallback to finish ICV Verification job.
    15: VP(Mka.InterAct.MacSecDisabled.EmptyParamSets,1) Verify that EthIf_MacSecUpdateSecY is called with correct input parameters CipherSuite is 0 since MacSec Is disabled.
    16: Call Mka_MacSecUpdateSecYNotification to finish UpdateSecY process.
    17: VP(Mka.dsn.Cp.MacSecOperational.Unsecured,1) Verify that EthIf_MacSecOperational(TRUE) is called to indicate to upper layers that link is available.
    18: Trigger transmission to reset TxMkpdu timer.
    19: Call Mka_MainFunction to start ICV verification of received EAPOL_MKPDU.
    20: Call Mka_CsmIcvGenerateCallback() to indicate that ICV generation has finished.
    21: VP(Mka.8021X.KeyServerElection.58.1,1) Verify that Distributed Sak parameter set is not transmitted as participant is not elected key server.
    22: VP(Mka.InterAct.MacSecDisabled.EmptyParamSets,1) Verify that Actor transmitted MKPDU containing SAK Use parameter set with support for plain text.
    23: Call second time function Mka_RxIndication() with MKPDU that contains Distributed SAK and SAK Use parameter sets with plain text support.
    24: Call Mka_CsmIcvVerifyCallback to finish ICV Verification job.
    25: Call Mka_Logon_MacSecOperational to set MacSec Operational False Inside of Logon unit and to enable functioning of Mka_Logon_TimerCallback_PermissiveMode for given PAE. Loop enough times for permissive timer to expire (timeout).
    26: VP(Mka.dsn.Logon.PermissiveMode.StopTimer,1) Verify that after permissive timer should have expired and MacSec was operational on PAE there is no additional EthIf_MacSecUpdateSecY for give PAE indicating that permissive timer was stopped.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.MacSecDisabled.NoKeysNoSc</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1592</internalId></provcov>
        <provcov>
          <linksto>Mka.InterAct.MacSecDisabled.EmptyParamSets</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1081</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.MacSecOperational.Unsecured</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1487</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.58.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>269</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Logon.PermissiveMode.StopTimer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1615</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1716</internalId></specobject>
    <specobject>
      <id>Mka_ConTest01028_PlainText_KeyServer</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Conformance/IN/Mka_ConTest01/TestSpec_Generated.h</sourcefile>
      <sourceline>1230</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when PlainText is used, empty DistributedSak and SakUse are used.
Test Object: PlainText.
Test Precondition: 
    -   Mka module initialized.
    -   Call Mka_DisableMacSec to disable MacSec and use PlainText.
    -   Mka module initialized.
  
Test Execution: 
    01: Call EbTest_InstSM_Running() to bring Instance SM to Running state.
    02: Call Mka_MainFunction() to process Crypto requests and tick Mka Hello timer.
    03: Call Mka_CsmIcvGenerateCallback() to indicate that ICV generation has finished.
    04: VP(Mka.EB.KeyServerElection.27.2,2)
        VP(Mka.EB.KeyServerElection.27.1,1)
        VP(Mka.dsn.Api.DisableMacSec,1) Verify that MacSec_Desired in BasicParameterSet is set to 0, but KeyServer to 1.
    05: Generate new ICV and transmit first MKPDU.
    06: Call function Mka_RxIndication() with MKPDU that has a peer list.
    07: Call Mka_MainFunction to start ICV verification of received EAPOL_MKPDU.
    08: Call Mka_CsmIcvVerifyCallback to finish ICV Verification job.
    09: Add Distributed SAK to MKPDU.
    10: Set correct MN values.
    11: Trigger transmission to reset TxMkpdu timer.
    12: VP(Mka.InterAct.MacSecDisabled.EmptyParamSets,1) Verify that EthIf_MacSecUpdateSecY is called with correct input parameters.
    13: Finish Icv Generate process to send the MKPDU.
    14: VP(Mka.InterAct.MacSecDisabled.EmptyParamSets,1)
        VP(Mka.8021X.KeyServerElection.31,1) Verify that actor had sent MKPDU with DistributedSak parameter set that supports only PlainText.
    15: Call Mka_MacSecUpdateSecYNotification to finish UpdateSecY process.
    16: Call function Mka_RxIndication() with MKPDU that contains SakUse parameter set with plain text Rx and Tx set to 0. Actor shall transmit the DistributedSakUse for PlainText again.
    17: Call Mka_MainFunction to start ICV verification of received EAPOL_MKPDU.
    18: Call Mka_CsmIcvVerifyCallback to finish ICV Verification job.
    19: Trigger sending of Mkpdu.
    20: Finish Icv Generate process to send the MKPDU.
    21: VP(Mka.InterAct.MacSecDisabled.EmptyParamSets,1)
        VP(Mka.8021X.KeyServerElection.31,1) Verify that actor had sent MKPDU with DistributedSak parameter set that supports only PlainText.
    22: Call function Mka_RxIndication() with MKPDU that contains SakUse parameter set with plain text support.
    23: Call Mka_MainFunction to start ICV verification of received EAPOL_MKPDU.
    24: Call Mka_CsmIcvVerifyCallback to finish ICV Verification job.
    25: VP(Mka.InterAct.MacSecDisabled.EmptyParamSets,1) Verify that, after receiving SakUse parameter set with PlainText, MacSecOperational was set to TRUE.
    26: Trigger transmission to reset TxMkpdu timer.
    27: VP(Mka.InterAct.MacSecDisabled.EmptyParamSets,1) Verify that Actor transmitted MKPDU containing SAK Use parameter set with support for plain text. Verify that Actor stopped transmitting DistributedSakUse parameter set.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.KeyServerElection.27.2</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>227</internalId></provcov>
        <provcov>
          <linksto>Mka.EB.KeyServerElection.27.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>225</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Api.DisableMacSec</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>986</internalId></provcov>
        <provcov>
          <linksto>Mka.InterAct.MacSecDisabled.EmptyParamSets</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1081</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.31</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>231</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1717</internalId></specobject>
    <specobject>
      <id>Mka_ConTest01029_MacSecDisabled_NoPlainText_Peer</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Conformance/IN/Mka_ConTest01/TestSpec_Generated.h</sourcefile>
      <sourceline>1296</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when PlainText is not used and Mka_MacSecDesired is False, the process is done according to Mka.InterAct.MacSecDisabled.NoEmptyParamSets.
Test Object: PlainText.
Test Precondition: 
    -   Mka module initialized.
    -   Call Mka_DisableMacSec to disable MacSec and use PlainText.
    -   Mka module initialized.
  
Test Execution: 
    01: Call EbTest_InstSM_Running() to bring Instance SM to Running state.
    02: Call Mka_MainFunction() to process Crypto requests and tick Mka Hello timer.
    03: Call Mka_CsmIcvGenerateCallback() to indicate that ICV generation has finished.
    04: VP(Mka.EB.KeyServerElection.27.2,2)
        VP(Mka.EB.KeyServerElection.27.1,1) Verify that MacSec_Desired in BasicParameterSet is set to 0, but KeyServer to 1.
    05: Generate new ICV and transmit first MKPDU.
    06: Call function Mka_RxIndication() with MKPDU that has a peer list and MacSecDesired. It shall be silently rejected.
    07: Call Mka_MainFunction to start ICV verification of received EAPOL_MKPDU.
    08: Call Mka_CsmIcvVerifyCallback to finish ICV Verification job.
    09: Call function Mka_RxIndication() with MKPDU that has a peer list.
    10: Call Mka_MainFunction to start ICV verification of received EAPOL_MKPDU.
    11: Call Mka_CsmIcvVerifyCallback to finish ICV Verification job.
    12: VP(Mka.dsn.KaY.MacSecDisabled.NoKeysNoSc,1) Verify that KEK is not being generated and that EthIf_MacSecInitRxSc is not called.
    13: VP(Mka.InterAct.MacSecDisabled.NoEmptyParamSets,1) Verify that EthIf_MacSecUpdateSecY is called with correct input parameters.
    14: Call Mka_MacSecUpdateSecYNotification to finish UpdateSecY process.
    15: VP(Mka.InterAct.MacSecDisabled.NoEmptyParamSets,1) Verify that, after receiving Mka_MacSecUpdateSecYNotification, MacSecOperational was set to TRUE.
    16: Call function Mka_RxIndication() with MKPDU that has incompatible MacSec Capability.
    17: Call Mka_MainFunction to start ICV verification of received EAPOL_MKPDU.
    18: Call Mka_CsmIcvVerifyCallback to finish ICV Verification job.
    19: Call Mka_MainFunction.
    20: VP(Mka.dsn.KaY.MacSecDesired.Discard,1) Verify that Mkpdu with incompatible MacSec Capability is silently discarded.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.KeyServerElection.27.2</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>227</internalId></provcov>
        <provcov>
          <linksto>Mka.EB.KeyServerElection.27.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>225</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.MacSecDisabled.NoKeysNoSc</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1592</internalId></provcov>
        <provcov>
          <linksto>Mka.InterAct.MacSecDisabled.NoEmptyParamSets</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1082</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.MacSecDesired.Discard</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1591</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1718</internalId></specobject>
    <specobject>
      <id>Mka_ConTest01030_MacSecDisabled_NoPlainText_KeyServer</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Conformance/IN/Mka_ConTest01/TestSpec_Generated.h</sourcefile>
      <sourceline>1352</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when PlainText is used, empty DistributedSak and SakUse are used.
Test Object: PlainText.
Test Precondition: 
    -   Mka module initialized.
    -   Call Mka_DisableMacSec to disable MacSec and use PlainText.
    -   Mka module initialized.
  
Test Execution: 
    01: Call EbTest_InstSM_Running() to bring Instance SM to Running state.
    02: Call Mka_MainFunction() to process Crypto requests and tick Mka Hello timer.
    03: Call Mka_CsmIcvGenerateCallback() to indicate that ICV generation has finished.
    04: VP(Mka.EB.KeyServerElection.27.2,2)
        VP(Mka.EB.KeyServerElection.27.1,1) Verify that MacSec_Desired and Capability in BasicParameterSet are set to 0, but KeyServer to 1.
    05: Generate new ICV and transmit first MKPDU.
    06: Call function Mka_RxIndication() with MKPDU that has a peer list.
    07: Call Mka_MainFunction to start ICV verification of received EAPOL_MKPDU.
    08: Call Mka_CsmIcvVerifyCallback to finish ICV Verification job.
    09: Call Mka_MacSecUpdateSecYNotification to finish UpdateSecY process.
    10: VP(Mka.InterAct.MacSecDisabled.NoEmptyParamSets,1) Verify that, after receiving SakUse parameter set with PlainText, MacSecOperational was set to TRUE.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.KeyServerElection.27.2</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>227</internalId></provcov>
        <provcov>
          <linksto>Mka.EB.KeyServerElection.27.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>225</internalId></provcov>
        <provcov>
          <linksto>Mka.InterAct.MacSecDisabled.NoEmptyParamSets</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1082</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1719</internalId></specobject>
    <specobject>
      <id>Mka_ConTest01031_MacSecDisabled_PlainText_Peer</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Conformance/IN/Mka_ConTest01/TestSpec_Generated.h</sourcefile>
      <sourceline>1390</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies peer side of MKA exchange sequence under the following circumstances:
Test Object: Software
Test Precondition: 
    -   Mka module initialized.
    -   Call Mka_DisableMacSec to disable MacSec and use PlainText.
    -   Mka module initialized.
  
Test Execution: 
    01: Call Mka_MacSecUpdateSecYNotification() to indicate successful SecY initialization.
    02: Call EbTest_InstSM_Running() to bring Instance SM to Running state.
    03: Call Mka_MainFunction() to process transmit request.
    04: Generate new ICV to transmit the first MKPDU.
    05: Call function Mka_RxIndication() with MKPDU that has a LIVE PEER LIST.
    06: Call Mka_CsmIcvVerifyCallback to finish ICV Verification job.
    07: VP(Mka.dsn.KaY.ImmediatePeerResponse.PeerSM, 1) Verify that Mka immediately responded with MKPDU transmission since Peer SM has made transition to LIVE state.
    08: Call function Mka_RxIndication() with MKPDU from key server with an empty Distributed SAK.
    09: Call Mka_CsmIcvVerifyCallback to finish ICV Verification job.
    10: VP(Mka.InterAct.MacSecDisabled.EmptyParamSets.DelayTimer,1) Verify that EthIf_MacSecUpdateSecY is called with correct input parameters.
    11: Call Mka_MacSecUpdateSecYNotification to finish UpdateSecY process.
    12: VP(Mka.dsn.Cp.ImmediatePeerResponse.EmptySakUse, 1) Verify that Mka immediately responded with MKPDU transmission since CP SM has transition into CP_UNSECURED state and SecY was successfully updated to bypass all traffic.
    13: Call function Mka_RxIndication() with MKPDU from key server with an empty SAK Use.
    14: Call Mka_CsmIcvVerifyCallback to finish ICV Verification job.
    15: Call Mka_Cp_TimerCallback_DelayMacSecOperational() to indicate that the timer is expired.
    16: VP(Mka.InterAct.MacSecDisabled.EmptyParamSets.DelayTimer,1) Verify that, after timer MkaDelayMacSecOperationalTimer expires, MacSecOperational is called.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.ImmediatePeerResponse.PeerSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1578</internalId></provcov>
        <provcov>
          <linksto>Mka.InterAct.MacSecDisabled.EmptyParamSets.DelayTimer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1083</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.ImmediatePeerResponse.EmptySakUse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1505</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1720</internalId></specobject>
    <specobject>
      <id>Mka_ConTest01032_MacSecDisabled_PlainText_KeyServer</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Conformance/IN/Mka_ConTest01/TestSpec_Generated.h</sourcefile>
      <sourceline>1433</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies key server side of MKA exchange sequence under the following circumstances:
Test Object: Software
Test Precondition: 
    -   Mka module initialized.
    -   Call Mka_DisableMacSec to disable MacSec and use PlainText.
    -   Mka module initialized.
  
Test Execution: 
    01: Call Mka_MacSecUpdateSecYNotification() to indicate successful SecY initialization.
    02: Call EbTest_InstSM_Running() to bring Instance SM to Running state.
    03: Call Mka_MainFunction() to process transmit request.
    04: Generate new ICV to transmit the first MKPDU.
    05: Call function Mka_RxIndication() with MKPDU that has a POTENTIAL PEER LIST.
    06: Call Mka_CsmIcvVerifyCallback to finish ICV Verification job.
    07: VP(Mka.InterAct.MacSecDisabled.EmptyParamSets.DelayTimer,1) Verify that EthIf_MacSecUpdateSecY is called with correct input parameters.
    08: VP(Mka.dsn.KaY.ImmediatePeerResponse.PeerSM, 1) Verify that Mka immediately responded with MKPDU transmission since Peer SM has made transition to LIVE state.
    09: VP(Mka.InterAct.MacSecDisabled.EmptyParamSets.DelayTimer,1) Verify that key server distributed MKPDU with an empty Distributed SAK, but no SAK Use, as SecY update has not finished
    10: Call Mka_MacSecUpdateSecYNotification to finish UpdateSecY process.
    11: VP(Mka.dsn.Cp.ImmediatePeerResponse.EmptySakUse, 1) Verify that Mka immediately responded with MKPDU transmission since CP SM is in CP_UNSECURED state and SecY was successfully updated to bypass all traffic.
    12: VP(Mka.InterAct.MacSecDisabled.EmptyParamSets.DelayTimer,1) Verify that key server distributed MKPDU with an empty Distributed SAK and SAK Use, as SecY update finished
    13: Call Mka_Cp_TimerCallback_DelayMacSecOperational() to indicate that the timer is expired.
    14: VP(Mka.InterAct.MacSecDisabled.EmptyParamSets.DelayTimer,1) Verify that MacSecOperational is NOT called, as peer has not transmitted empty SAK Use yet.
    15: Call function Mka_RxIndication() with MKPDU from key server with an empty SAK.
    16: Call Mka_CsmIcvVerifyCallback to finish ICV Verification job.
    17: VP(Mka.InterAct.MacSecDisabled.EmptyParamSets.DelayTimer,1) Verify that, after timer MkaDelayMacSecOperationalTimer expires, MacSecOperational is called.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.InterAct.MacSecDisabled.EmptyParamSets.DelayTimer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1083</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.ImmediatePeerResponse.PeerSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1578</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.ImmediatePeerResponse.EmptySakUse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1505</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1721</internalId></specobject>
    <specobject>
      <id>Mka_ConTest01033_Capability_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Conformance/IN/Mka_ConTest01/TestSpec_Generated.h</sourcefile>
      <sourceline>1477</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that, when our participant has a Capability of 3 and receives an MKPDU with the capability of 1, it accepts it.
Test Object: MacSec Capability.
Test Precondition: 
    -   Mka module initialized and PAE instance 2 manually started.
  
Test Execution: 
    01: Call EbTest_InstSM_Running() to bring Instance SM to Running state.
    02: Call Mka_MainFunction() to process Crypto requests and tick Mka Hello timer.
    03: Call EbTest_GenIcv_Async() to generate new ICV and transmit new MKPDU.
    04: Call EbTest_PeerSM_PeerLive() to send MKPDU that is Live and has higher key server priority.
    05: Call EbTest_TickMain_UntilTxMkpdu() to tick Mka Hello timer till it expires.
    06: Call Mka_CsmIcvGenerateCallback() to indicate that ICV generation has finished.
    07: VP(Mka.8021X.KeyServerElection.33.2,2) Verify that MACsec Capability is set to 1 after a Key server has been chosen and the least of two capabilities has been selected.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.33.2</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>235</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1722</internalId></specobject>
    <specobject>
      <id>Mka_ConTest01034_Capability_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Conformance/IN/Mka_ConTest01/TestSpec_Generated.h</sourcefile>
      <sourceline>1501</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that, when our participant has a Capability of 2 and receives an MKPDU with the capability of 1, it accepts it.
Test Object: MacSec Capability.
Test Precondition: 
    -   Mka module initialized and PAE instance 2 manually started.
  
Test Execution: 
    01: Call EbTest_InstSM_Running() to bring Instance SM to Running state.
    02: Call Mka_MainFunction() to process Crypto requests and tick Mka Hello timer.
    03: Call EbTest_GenIcv_Async() to generate new ICV and transmit new MKPDU.
    04: Call EbTest_PeerSM_PeerLive() to send MKPDU that is Live and has higher key server priority.
    05: Call EbTest_TickMain_UntilTxMkpdu() to tick Mka Hello timer till it expires.
    06: VP(Mka.8021X.KeyServerElection.33.2,2) Verify that MACsec Capability is set to 2 after a Key server has been chosen and the least of two capabilities has been selected.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.33.2</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>235</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1723</internalId></specobject>
    <specobject>
      <id>Mka_ConTest01035_Capability_3</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Conformance/IN/Mka_ConTest01/TestSpec_Generated.h</sourcefile>
      <sourceline>1524</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that, when our participant has a Capability of 3 and receives an MKPDU with the capability of 3, it accepts it.
Test Object: MacSec Capability.
Test Precondition: 
    -   Mka module initialized and PAE instance 2 manually started.
  
Test Execution: 
    01: Call EbTest_InstSM_Running() to bring Instance SM to Running state.
    02: Call Mka_MainFunction() to process Crypto requests and tick Mka Hello timer.
    03: Call EbTest_GenIcv_Async() to generate new ICV and transmit new MKPDU.
    04: Call EbTest_PeerSM_PeerLive() to send MKPDU that is Live and has higher key server priority.
    05: Call EbTest_TickMain_UntilTxMkpdu() to tick Mka Hello timer till it expires.
    06: Call Mka_CsmIcvGenerateCallback() to indicate that ICV generation has finished.
    07: VP(Mka.8021X.KeyServerElection.33.2,2) Verify that MACsec Capability is set to 3 after a Key server has been chosen and the least of two capabilities has been selected.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.33.2</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>235</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1724</internalId></specobject>
    <specobject>
      <id>Mka_ConTest01036_Capability_0</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Conformance/IN/Mka_ConTest01/TestSpec_Generated.h</sourcefile>
      <sourceline>1548</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that, when our participant has a Capability of 3 and receives an MKPDU with the capability of 0, it silently rejects the MKPDU.
Test Object: MacSec Capability.
Test Precondition: 
    -   Mka module initialized and PAE instance 2 manually started.
  
Test Execution: 
    01: Call EbTest_InstSM_Running() to bring Instance SM to Running state.
    02: Call Mka_MainFunction() to process Crypto requests and tick Mka Hello timer.
    03: Call EbTest_GenIcv_Async() to generate new ICV and transmit new MKPDU.
    04: Call EbTest_PeerSM_PeerLive() to send MKPDU that is Live and has higher key server priority.
    05: VP(Mka.EB.KeyServerElection.27.1,1) Verify that the MKPDU has been discarded since it has Capability configured as 0 (invalid config) while MacSec Desired is set to true.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.KeyServerElection.27.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>225</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1725</internalId></specobject>
    <specobject>
      <id>Mka_ConTest01037_DelayMacSecOperation_EmptySak</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Conformance/IN/Mka_ConTest01/TestSpec_Generated.h</sourcefile>
      <sourceline>1570</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when PlainText is used and MkaDelayMacSecOperationalTimer is enabled. MacSec operational isn't called, until MkaDelayMacSecOperationalTimer expires.
Test Object: MkaDelayMacSecOperationalTimer.
Test Precondition: 
    -   Mka module initialized.
    -   Call Mka_DisableMacSec to disable MacSec and use PlainText.
    -   Mka module initialized.
  
Test Execution: 
    01: Call EbTest_InstSM_Running() to bring Instance SM to Running state.
    02: Call Mka_MainFunction() to process Crypto requests and tick Mka Hello timer.
    03: Generate new ICV and transmit first MKPDU.
    04: Call function Mka_RxIndication() with MKPDU that has a peer list.
    05: Call Mka_MainFunction to start ICV verification of received EAPOL_MKPDU.
    06: Call Mka_CsmIcvVerifyCallback to finish ICV Verification job.
    07: Add SakUse to MKPDU.
    08: Set correct MN values.
    09: Trigger transmission to reset TxMkpdu timer.
    10: VP(Mka.InterAct.MacSecDisabled.EmptyParamSets.DelayTimer,1) Verify that EthIf_MacSecUpdateSecY is called.
    11: Finish Icv Generate process to send the MKPDU.
    12: VP(Mka.InterAct.MacSecDisabled.EmptyParamSets.DelayTimer,1) Verify that actor had sent MKPDU with DistributedSak parameter set that supports only PlainText.
    13: Call Mka_MacSecUpdateSecYNotification to finish UpdateSecY process.
    14: Call function Mka_RxIndication() with MKPDU that contains SakUse parameter set with plain text support.
    15: Call Mka_MainFunction to start ICV verification of received EAPOL_MKPDU.
    16: Call Mka_CsmIcvVerifyCallback to finish ICV Verification job.
    17: VP(Mka.InterAct.MacSecDisabled.EmptyParamSets.DelayTimer,1)
        VP(Mka.EB.Net_Sec_2158,1) Verify that, after receiving SakUse parameter set with PlainText, MacSecOperational was not called, because timer MkaDelayMacSecOperationalTimer isn't expired.
    18: Call Mka_Cp_TimerCallback_DelayMacSecOperational() to indicate that timer is expired.
    19: VP(Mka.InterAct.MacSecDisabled.EmptyParamSets.DelayTimer,1)
        VP(Mka.EB.Net_Sec_2158,1)
        VP(Mka.dsn.Cp.Api.DelayMacSecOperational,1) Verify that, after timer MkaDelayMacSecOperationalTimer expires, MacSecOperational is called.
    20: Trigger transmission of new MKPDU.
    21: VP(Mka.InterAct.MacSecDisabled.EmptyParamSets.DelayTimer,1) Verify that Actor transmitted MKPDU containing SAK Use parameter set with support for plain text. Verify that Actor stopped transmitting DistributedSakUse parameter set.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.InterAct.MacSecDisabled.EmptyParamSets.DelayTimer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1083</internalId></provcov>
        <provcov>
          <linksto>Mka.EB.Net_Sec_2158</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1484</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.Api.DelayMacSecOperational</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1022</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1726</internalId></specobject>
    <specobject>
      <id>Mka_ConTest01038_DelayMacSecOperation_NoPlainText</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Conformance/IN/Mka_ConTest01/TestSpec_Generated.h</sourcefile>
      <sourceline>1621</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when PlainText is used and EmptySak is disabled and we receive Live parameter set after MkaDelayMacSecOperationalTimer expired, MacSecOperational is called.
Test Object: MkaDelayMacSecOperationalTimer.
Test Precondition: 
    -   Mka module initialized.
    -   Call Mka_DisableMacSec to disable MacSec and use PlainText.
    -   Mka module initialized.
  
Test Execution: 
    01: Call EbTest_InstSM_Running() to bring Instance SM to Running state.
    02: Call Mka_MainFunction() to process Crypto requests.
    03: VP(Mka.EB.MkaTaskCallout,1) Verify that MKA_TASK_CALLOUT has been called.
    04: Tick timer MkaDelayMacSecOperationalTimer until expires.
    05: VP(Mka.EB.Net_Sec_2158,1) Verify that, after timer MkaDelayMacSecOperationalTimer expired, and Peer is found, MacSecOperational isn't called.
    06: Call function Mka_RxIndication() with MKPDU that has a peer list.
    07: Call Mka_MainFunction to start ICV verification of received EAPOL_MKPDU.
    08: Call Mka_CsmIcvVerifyCallback to finish ICV Verification job.
    09: VP(Mka.EB.MkaTaskCallout,1) Verify that MKA_TASK_CALLOUT has been called.
    10: Call Mka_MacSecUpdateSecYNotification to finish UpdateSecY process.
    11: VP(Mka.EB.MkaTaskCallout,1) Verify that MKA_TASK_CALLOUT has been called.
    12: VP(Mka.EB.Net_Sec_2158,1)
        VP(Mka.dsn.Cp.Api.DelayMacSecOperational,1) Verify that, after receiving Live parameter set with PlainText and EmptySak is disabled and timer MkaDelayMacSecOperationalTimer is already expired, MacSecOperational was called and set to TRUE.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.MkaTaskCallout</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1474</internalId></provcov>
        <provcov>
          <linksto>Mka.EB.Net_Sec_2158</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1484</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.Api.DelayMacSecOperational</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1022</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1727</internalId></specobject>
    <specobject>
      <id>Mka_ConTest01039_DelayMacSecOperation_NoPlainText_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Conformance/IN/Mka_ConTest01/TestSpec_Generated.h</sourcefile>
      <sourceline>1661</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when PlainText is used and EmptySak is disabled and we receive Live parameter set before MkaDelayMacSecOperationalTimer expired, MacSecOperational is not called. After MkaDelayMacSecOperationalTimer expires, MacSecOperational is called.
Test Object: MkaDelayMacSecOperationalTimer.
Test Precondition: 
    -   Mka module initialized.
    -   Call Mka_DisableMacSec to disable MacSec and use PlainText.
    -   Mka module initialized.
  
Test Execution: 
    01: Call EbTest_InstSM_Running() to bring Instance SM to Running state.
    02: Call Mka_MainFunction() to process Crypto requests.
    03: VP(Mka.EB.MkaTaskCallout,1) Verify that MKA_TASK_CALLOUT has been called.
    04: Call function Mka_RxIndication() with MKPDU that has a peer list.
    05: Call Mka_MainFunction to start ICV verification of received EAPOL_MKPDU.
    06: Call Mka_CsmIcvVerifyCallback to finish ICV Verification job.
    07: Finish generation of ICV to transmit MKPDU.
    08: Call Mka_MacSecUpdateSecYNotification to finish UpdateSecY process.
    09: VP(Mka.EB.MkaTaskCallout,1) Verify that MKA_TASK_CALLOUT has been called.
    10: VP(Mka.EB.Net_Sec_2158,1) Verify that, after receiving Live parameter set with PlainText and EmptySak is disabled, MacSecOperational was not called, because timer MkaDelayMacSecOperationalTimer isn't expired.
    11: Tick timer MkaDelayMacSecOperationalTimer until expires.
    12: VP(Mka.EB.Net_Sec_2158,1)
        VP(Mka.dsn.Cp.Api.DelayMacSecOperational,1) Verify that, after receiving Live parameter set with PlainText and EmptySak is disabled and timer MkaDelayMacSecOperationalTimer is expired, MacSecOperational was called and set to TRUE.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.MkaTaskCallout</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1474</internalId></provcov>
        <provcov>
          <linksto>Mka.EB.Net_Sec_2158</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1484</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.Api.DelayMacSecOperational</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1022</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1728</internalId></specobject>
    <specobject>
      <id>Mka_ConTest01040_ChangeCipher</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Conformance/IN/Mka_ConTest01/TestSpec_Generated.h</sourcefile>
      <sourceline>1701</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that the initial call of EthIf_MacSecUpdateSecY() for a PEER is made with the configured values of cipher suite (highest priority) and configured confidentiality offset. Furthermore test case verifies that when Distributed SAK is received from a key server with different values of cipher suite and confidentiality then initially configured, a new call of EthIf_MacSecUpdateSecY() is issued with distributed vales.
Test Object: Change of cipher suite in SecY after principal actor is found.
Test Precondition: 
    -   Mka module initialized.
  
Test Execution: 
    01: Call EbTest_InstSM_Running() to bring Instance SM to Running state.
    02: Call EbTest_PeerSM_PeerLive() to send MKPDU that is Live and have lower key server priority.
    03: Set up MKPDU with DistributedSak that has Cipher AES-256.
    04: Call function Mka_RxIndication() with MKPDU that contains Distributed SAK parameter set with CipherSuite that is not default.
    05: Call Mka_MainFunction to start ICV verification of received EAPOL_MKPDU.
    06: Call Mka_CsmIcvVerifyCallback to finish ICV Verification job.
    07: VP(Mka.dsn.Cp.CpSM.Secured_2_UpdateSecY,1) Verify that Peer updated its CipherSuite on SecY level, after received Distributed SAK has different CipherSuite then our default one.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Secured_2_UpdateSecY</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1376</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1729</internalId></specobject>
    <specobject>
      <id>Mka_ConTest01041_ConfidentialityOffset</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Conformance/IN/Mka_ConTest01/TestSpec_Generated.h</sourcefile>
      <sourceline>1725</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that the initial call of EthIf_MacSecUpdateSecY() for a Key server is made with the configured values of cipher suite (highest priority) and configured confidentiality offset. Furthermore test case verifies that when Key server receives MKPDU from PEER with different confidentiality then initially configured, a new call of EthIf_MacSecUpdateSecY() is issued with received vales.
Test Object: Change of confidentiality offset in SecY after principal actor is found.
Test Precondition: 
    -   Mka module initialized.
  
Test Execution: 
    01: Call EbTest_InstSM_Running() to bring Instance SM to Running state.
    02: Call Mka_MainFunction() to process Crypto requests and tick Mka Hello timer.
    03: Generate new ICV and transmit first MKPDU.
    04: Call function Mka_RxIndication() with MKPDU that has a peer list.
    05: Call Mka_MainFunction to start ICV verification of received EAPOL_MKPDU.
    06: Call Mka_CsmIcvVerifyCallback to finish ICV Verification job.
    07: VP(Mka.dsn.Logon.Api.ParticipantSuccessfulActor,2) Verify that Key server updated its CipherSuite on SecY level, after chosen Confidentiality offset is different than our default one.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.Api.ParticipantSuccessfulActor</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1042</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1730</internalId></specobject>
    <specobject>
      <id>Mka_ConTest01042_PreSharedKeys</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Conformance/IN/Mka_ConTest01/TestSpec_Generated.h</sourcefile>
      <sourceline>1749</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when MkaUsePresharedIckKek is set to TRUE, Mka will not call CSM unit to generate ICK and KEK keys, instead it will move to the next state (e.g. LOGON_PARTICIPANT_SM_INIT to LOGON_PARTICIPANT_SM_ACTIVE).
Test Object: KaY and Logon init.
Test Precondition: 
    -   Mka module initialized.
  
Test Execution: 
    01: Call Mka_MainFunction() to continue initialization.
    02: VP(Mka.dsn.Logon.ParticipantSM.Init_2_Active,1)
        VP(Mka.CP_SWS_Mka_00022,1) Verify that KaY called CSM to start random generate to generate MI for participants when Logon is initialized, instead of generating ICK key.
    03: Finish generation of member identifiers.
    04: Receive UpdateSecY notification.
    05: Call Mka_RxIndication() with MKPDU that has a Live peer list.
    06: Call Mka_MainFunction to start ICV verification of received EAPOL_MKPDU.
    07: Call Mka_CsmIcvVerifyCallback to finish ICV Verification job.
    08: VP(Mka.dsn.KaY.KeySM.Disabled_2_GenerateNewSak,1)
        VP(Mka.CP_SWS_Mka_00022,1) Verify that KaY called CSM to start generating SAK Key after Participant became principal actor, instead of generating KEK key.
    09: Simulate the asynchronous callout to continue the procedure of SAK generation.
    10: VP(Mka.dsn.KaY.KeySM.Disabled_2_GenerateNewSak,1)
        VP(Mka.CP_SWS_Mka_00022,1) Verify that SAK Key wrapping procedure has been started.
    11: Call Csm_Encrypt to continue encryption and wrapping of SAK key.
    12: Call Mka_CsmKeyWrapCallback and Mka_CsmHashGenerateCallback to finish SAKGenWrap and HashGen process.
    13: Finish generation of Hash.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.ParticipantSM.Init_2_Active</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1362</internalId></provcov>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00022</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>338</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.KeySM.Disabled_2_GenerateNewSak</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1425</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1731</internalId></specobject>
    <specobject>
      <id>Mka_ConTest01043_NvM_ImmediateWriteBlock</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Conformance/IN/Mka_ConTest01/TestSpec_Generated.h</sourcefile>
      <sourceline>1790</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when Nv Memory is changed Mka shall call NvM_WriteBlock in the same main tick. If there is previous write in progress NvM_WriteBlock shall be delayed for next main tick and so on until current write is finished. All changes up until NvM_WriteBlock shall be copied in shadow buffer and written into NvM. Test also verifies that default state of MacSec Enabled is FALSE.
Test Object: Mka_Logon_Nvm_WriteBlockIfChanged.
Test Precondition: 
    -   Mka module initialized. Set default values in NvMemory
    -   Verify that there is no Nvm_WriteBlock queued and that there is no NvM write in progress.
  
Test Execution: 
    01: Call Mka_GetMacSecEnabled to get initial state of is MacSec enabled.
    02: VP(Mka.dsn.Logon.Nvm.MacSecDisabledByDefault,1) Verify that MacSec is not enabled
    03: Sanity check - Check if initial memory reset is done (default data writtend).
    04: Call Mka_MainFunction to process any queued request for Nvm_WriteBlock.
    05: Sanity check - Sanity check.
    06: Call Mka_EnableMacSec to enable MacSec and queue Nvm_WriteBlock immediately in next main tick.
    07: VP(Mka.dsn.Logon.Nvm.WriteBlockImmediately,1) Verify that NvM_WriteBlock is queued by calling NvM_SetRamBlockStatus(TRUE).
    08: Call Mka_MainFunction to process any queued request for Nvm_WriteBlock.
    09: VP(Mka.dsn.Logon.Nvm.WriteBlockImmediately,1) Verify that NvM_WriteBlock started in previous tick and that correct block Id is written to NvM .
    10: Call Mka_DisableMacSec to disable MacSec and queue Nvm_WriteBlock immediately in next main tick.
    11: Sanity check - Check that block is again queued for a write.
    12: Set NvM_GetErrorStatus_Stub.RetVal to return NVM_REQ_PENDING indicating that previous request has not yet finished. Set EbTest_Logon_NvRam_ShadowMemory to Null
    13: Call Mka_MainFunction to again try to write changed block to NvM.
    14: VP(Mka.dsn.Logon.Nvm.WriteBlockImmediately,1) Verify that since previous NvM_WriteBlock is not yet finished no NvM_WriteBlock is called .
    15: Set NvM_GetErrorStatus_Stub.RetVal to return NVM_REQ_PENDING indicating that previous request has finished.
    16: Call Mka_MainFunction to verify that block write is finished and new NvM_WriteBlock is started.
    17: VP(Mka.dsn.Logon.Nvm.WriteBlockImmediately,1) Verify that since previous NvM_WriteBlock is finished NvM_WriteBlock is called for new data. Verify that data thst is written is equal to MkaNvRam_Memory.
    18: Clear MkaNvRam_Memory.
    19: VP(Mka.dsn.Logon.Nvm.ShadowNvMemoryBlock,1) Verify that data that is passed to NvM_WriteBlock is not real MkaNvRam_Memory but shadow copy.
    20: Set NvM_GetErrorStatus_Stub.RequestResultPtr_Out to NVM_REQ_NOT_OK meaning that writeblock has failed. Mka should repeat write.
    21: Call Mka_MainFunction and check if previous write failed.If previous write failed, write again .
    22: Call Since previous writes failed, start write again.
    23: VP(Mka.dsn.Logon.Nvm.ShadowNvMemoryBlock,1) Verify that data that is passed to NvM_WriteBlock is now contains last copy of MkaNvRam_Memory.
    24: Write finished successfully, there should be no write any more.
    25: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.Nvm.MacSecDisabledByDefault</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1613</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Logon.Nvm.WriteBlockImmediately</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1611</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Logon.Nvm.ShadowNvMemoryBlock</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1612</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1732</internalId></specobject>
    <specobject>
      <id>Mka_ConTest01045_ValidateCakCkn_Retry</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Conformance/IN/Mka_ConTest01/TestSpec_Generated.h</sourcefile>
      <sourceline>1841</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies retry functionality for key validation of CAK and CKN.
Test Object: Key validation retry functionality.
Test Precondition: 
  
Test Execution: 
    01: Configure Csm_KeyElementGet() to return E_BUSY for CAK read for Participant_0 and CKN read for Participant_2.
    02: Call Mka_Init() to initialize module.
    03: VP(Mka.dsn.Crypto.CryptoSM.Initial_ValidateKeys, 1) Verify that Csm_KeyElementGet() is called to verify the keys, which verifies transition from the Initial to VALIDATE_KEYS state.
    04: Configure Csm_KeyElementGet() to return E_OK for CAK and CKN read for Participant_0 and Participant_2.
    05: Call Mka_Crypto_MainFunction().
    06: VP(Mka.dsn.Crypto.ValidateKeys.Retry, 1) Verify that that CAK and CKN access is repeated for Participant_0 and 2.
    07: Call Mka_Crypto_MainFunction().
    08: VP(Mka.dsn.Crypto.ValidateKeys.Retry, 1) Verify that that CAK and CKN access is not repeated as all keys are validated.
    09: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.CryptoSM.Initial_ValidateKeys</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1345</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.ValidateKeys.Retry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1560</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1733</internalId></specobject>
    <specobject>
      <id>Mka_ConTest01046_IckKekGen_KEY_NOT_PRESENT</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Conformance/IN/Mka_ConTest01/TestSpec_Generated.h</sourcefile>
      <sourceline>1870</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when Csm_MacGenerate() fails during ICK or KEK generation with an error code indicating that CAK is missing, MKA will raise KEY_NOT_PRESENT event and notify DEM module about it.
Test Object: DEM reporting.
Test Precondition: 
    -   Mka module initialized.
  
Test Execution: 
    01: Set Csm_MacGenerate_Stub.RetVal to CRYPTO_E_KEY_NOT_AVAILABLE or CRYPTO_E_KEY_EMPTY to simulate that CAK is missing.
    02: Call Mka_MainFunction() to start creating participants.
    03: VP(Mka.CP_SWS_Mka_00033,1) Verify that Dem_SetEventStatus() is called to report KEY_NOT_PRESENT event indicating that CAK is missing.
    04: VP(Mka.CP_SWS_Mka_00033,1) Verify that Dem_SetEventStatus() is called to report KEY_NOT_PRESENT event indicating that CAK is missing.
    05: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00033</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>352</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1734</internalId></specobject>
    <specobject>
      <id>Mka_ConTest01047_ValidateCakCkn_Retry_CachedPrincipal</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Conformance/IN/Mka_ConTest01/TestSpec_Generated.h</sourcefile>
      <sourceline>1892</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies retry functionality for key validation of CAK and CKN in case that cached principal actor exist.
Test Object: Key validation retry functionality.
Test Precondition: 
    -   Restore NvM and Enable MacSec.
    -   Mka module initialized.
  
Test Execution: 
    01: Call EbTest_InstSM_Running() to bring Instance SM to Running state.
    02: Call EbTest_PeerSM_PeerLive() to send MKPDU that is Live and have lower key server priority.
    03: Configure Csm_KeyElementGet() to return E_BUSY for CAK read for Participant_0 and CKN read for Participant_2.
    04: Call Mka_Init() to the initialize module. Participant_2 is set as a principal actor for PAE_1.
    05: Configure Csm_KeyElementGet() to return E_BUSY for CAK and CKN read for Participant_0 and Participant_2.
    06: Configure Csm_KeyElementGet() to return E_OK for CAK and CKN read for Participant_0 and Participant_2.
    07: Call Mka_Crypto_MainFunction().
    08: VP(Mka.dsn.Crypto.ValidateKeys.Retry, 1) Verify that that CAK and CKN access is repeated for Participant_0 and 2.
    09: Call Mka_Crypto_MainFunction().
    10: VP(Mka.dsn.Crypto.ValidateKeys.Retry, 1) Verify that that CAK and CKN access is not repeated as all keys are validated.
    11: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.ValidateKeys.Retry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1560</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1735</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>Mka_ConTest0200_ResourceConsumption</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Conformance/IN/Mka_ConTest02_ResourceConsumption/TestSpec_Generated.h</sourcefile>
      <sourceline>9</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: This is dummy test case used only for resource consumption analysis.
Test Object: Mka initialization.
Test Precondition: 
  
Test Execution: 
    01: Call Mka module extern APIs.
    02: VP(Mka.swdd.ROMConsumption,1)
        VP(Mka.swdd.RAMConsumption,1) Verify Mka resource consumption.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.swdd.ROMConsumption</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1255</internalId></provcov>
        <provcov>
          <linksto>Mka.swdd.RAMConsumption</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1257</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1736</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>Mka_GenTest_01001_Invalid_Mka_Xdm_MkaPaeInstance_Consecutive</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Generic/IN/Mka_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>27</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test will check that an error is generated if MkaPaeInstance is not consecutive.
&lt;/para&gt;

Test Object: XDM check
Test Precondition: 

Test Execution: 
  VP(Mka.XDM.Pae.MkaPaeInstance_Consecutive):
  The following error must be issued:
  MkaPaeIdx shall be 0-based and dense.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.Pae.MkaPaeInstance_Consecutive</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1632</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1737</internalId></specobject>
    <specobject>
      <id>Mka_GenTest_01002_Invalid_Mka_Xdm_MkaEthIfControllerRef_InvalidRef</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Generic/IN/Mka_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>52</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test will check that an error is generated if MkaEthIfControllerRef does not point to a valid reference.
&lt;/para&gt;

Test Object: XDM check
Test Precondition: 

Test Execution: 
  VP(Mka.XDM.Mka.MkaEthIfControllerRef_InvalidRef):
  The following error must be issued:
  Reference shall point to a valid node.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.Mka.MkaEthIfControllerRef_InvalidRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1633</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1738</internalId></specobject>
    <specobject>
      <id>Mka_GenTest_01003_Invalid_Mka_Xdm_MkaPaeConfRef_InvalidRef</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Generic/IN/Mka_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>77</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test will check that an error is generated if MkaPaeConfRef does not point to a valid reference.
&lt;/para&gt;

Test Object: XDM check
Test Precondition: 

Test Execution: 
  VP(Mka.XDM.Mka.MkaPaeConfRef_InvalidRef):
  The following error must be issued:
  Reference shall point to a valid node.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.Mka.MkaPaeConfRef_InvalidRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1634</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1739</internalId></specobject>
    <specobject>
      <id>Mka_GenTest_01004_Invalid_Mka_Xdm_MkaSwitchPortRef_InvalidRef</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Generic/IN/Mka_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>102</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test will check that an error is generated if MkaSwitchPortRef does not point to a valid reference.
&lt;/para&gt;

Test Object: XDM check
Test Precondition: 

Test Execution: 
  VP(Mka.XDM.Mka.MkaSwitchPortRef_InvalidRef):
  The following error must be issued:
  Reference shall point to a valid node.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.Mka.MkaSwitchPortRef_InvalidRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1635</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1740</internalId></specobject>
    <specobject>
      <id>Mka_GenTest_01005_Invalid_Mka_Xdm_MkaBypassEtherType_Repeating</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Generic/IN/Mka_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>127</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test will check that an error is generated if elements of MkaBypassEtherType list are repeated.
&lt;/para&gt;

Test Object: XDM check
Test Precondition: 

Test Execution: 
  VP(Mka.XDM.KaY.MkaBypassEtherType_Repeating):
  The following error must be issued:
  MkaBypassEtherType shall not be repeated in MkaBypassEtherType container.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.KaY.MkaBypassEtherType_Repeating</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1636</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1741</internalId></specobject>
    <specobject>
      <id>Mka_GenTest_01006_Invalid_Mka_Xdm_MkaBypassVlan_Repeating</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Generic/IN/Mka_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>152</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test will check that an error is generated if elements of MkaBypassVlan list are repeated.
&lt;/para&gt;

Test Object: XDM check
Test Precondition: 

Test Execution: 
  VP(Mka.XDM.KaY.MkaBypassVlan_Repeating):
  The following error must be issued:
  MkaBypassVlan shall not be repeated in MkaBypassVlan container.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.KaY.MkaBypassVlan_Repeating</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1637</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1742</internalId></specobject>
    <specobject>
      <id>Mka_GenTest_01007_Invalid_Mka_Xdm_MkaDstMacAddress_MACAddressFormat</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Generic/IN/Mka_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>177</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test will check that an error is generated if MAC address is not in the format xx:xx:xx:xx:xx:xx.
&lt;/para&gt;

Test Object: XDM check
Test Precondition: 

Test Execution: 
  VP(Mka.XDM.KaY.MkaDstMacAddress_MACAddressFormat):
  The following error must be issued:
  MAC address is not valid, it should be in the format: xx:xx:xx:xx:xx:xx..

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.KaY.MkaDstMacAddress_MACAddressFormat</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1638</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1743</internalId></specobject>
    <specobject>
      <id>Mka_GenTest_01008_Invalid_Mka_Xdm_MkaKeyServerPriority_PriorityMissing</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Generic/IN/Mka_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>202</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test will check that an error is generated if MkaRole is set to MKA_KEY_SERVER_PRIORITY_BASED, but MkaKeyServerPriority is not set.
&lt;/para&gt;

Test Object: XDM check
Test Precondition: 

Test Execution: 
  VP(Mka.XDM.KaY.MkaKeyServerPriority_PriorityMissing):
  The following error must be issued:
  When MkaRole is set to MKA_KEY_SERVER_PRIORITY_BASED, MkaKeyServerPriority must also be set..

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.KaY.MkaKeyServerPriority_PriorityMissing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1639</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1744</internalId></specobject>
    <specobject>
      <id>Mka_GenTest_01009_Invalid_Mka_Xdm_MkaKayParticipant_Consecutive</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Generic/IN/Mka_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>227</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test will check that an error is generated if MkaParticipantIdx of the MkaKayParticipant are not consecutive.
&lt;/para&gt;

Test Object: XDM check
Test Precondition: 

Test Execution: 
  VP(Mka.XDM.KaYParticipant.MkaKayParticipant_Consecutive):
  The following error must be issued:
  MkaPaeIdx shall be 0-based and dense.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.KaYParticipant.MkaKayParticipant_Consecutive</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1640</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1745</internalId></specobject>
    <specobject>
      <id>Mka_GenTest_01010_Invalid_Mka_Xdm_MkaCryptoConfigId_Consecutive</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Generic/IN/Mka_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>252</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test will check that an error is generated if MkaCryptoConfigId of the MkaCryptoConfig are not consecutive.
&lt;/para&gt;

Test Object: XDM check
Test Precondition: 

Test Execution: 
  VP(Mka.XDM.Crypto.MkaCryptoConfigId_Consecutive):
  The following error must be issued:
  MkaCryptoAlgoConfigIdx shall be 0-based and dense.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.Crypto.MkaCryptoConfigId_Consecutive</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1641</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1746</internalId></specobject>
    <specobject>
      <id>Mka_GenTest_01011_Invalid_Mka_Xdm_MkaCryptoConfigId_ZeroBased</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Generic/IN/Mka_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>277</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test will check that an error is generated if MkaCryptoConfigId of the MkaCryptoConfig are not zero based.
&lt;/para&gt;

Test Object: XDM check
Test Precondition: 

Test Execution: 
  VP(Mka.XDM.Crypto.MkaCryptoConfigId_ZeroBased):
  The following error must be issued:
  MkaCryptoAlgoConfigIdx shall be 0-based and dense.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.Crypto.MkaCryptoConfigId_ZeroBased</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1642</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1747</internalId></specobject>
    <specobject>
      <id>Mka_GenTest_01012_Invalid_Mka_Xdm_MkaCryptoAlgoRef_InvalidRef</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Generic/IN/Mka_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>302</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test will check that an error is generated if MkaCryptoAlgoRef does not point to a valid reference.
&lt;/para&gt;

Test Object: XDM check
Test Precondition: 

Test Execution: 
  VP(Mka.XDM.Crypto.MkaCryptoAlgoRef_InvalidRef):
  The following error must be issued:
  Reference shall point to a valid node.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.Crypto.MkaCryptoAlgoRef_InvalidRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1643</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1748</internalId></specobject>
    <specobject>
      <id>Mka_GenTest_01013_Invalid_Mka_Xdm_MkaCryptoCknCakKeyRef_InvalidRef</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Generic/IN/Mka_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>327</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test will check that an error is generated if MkaCryptoCknCakKeyRef does not point to a valid reference.
&lt;/para&gt;

Test Object: XDM check
Test Precondition: 

Test Execution: 
  VP(Mka.XDM.Crypto.MkaCryptoCknCakKeyRef_InvalidRef):
  The following error must be issued:
  Referenced key must be valid.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.Crypto.MkaCryptoCknCakKeyRef_InvalidRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1644</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1749</internalId></specobject>
    <specobject>
      <id>Mka_GenTest_01014_Invalid_Mka_Xdm_MkaCryptoRandomJobRef_InvalidRef</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Generic/IN/Mka_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>352</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test will check that an error is generated if MkaCryptoRandomJobRef does not point to a valid reference.
&lt;/para&gt;

Test Object: XDM check
Test Precondition: 

Test Execution: 
  VP(Mka.XDM.Crypto.MkaCryptoRandomJobRef_InvalidRef):
  The following error must be issued:
  Referenced job must be valid.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.Crypto.MkaCryptoRandomJobRef_InvalidRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1645</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1750</internalId></specobject>
    <specobject>
      <id>Mka_GenTest_01015_Invalid_Mka_Xdm_MkaCryptoIckJobRef_InvalidRef</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Generic/IN/Mka_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>377</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test will check that an error is generated if MkaCryptoIckJobRef does not point to a valid reference.
&lt;/para&gt;

Test Object: XDM check
Test Precondition: 

Test Execution: 
  VP(Mka.XDM.Crypto.MkaCryptoIckJobRef_InvalidRef):
  The following error must be issued:
  Referenced job must be valid.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.Crypto.MkaCryptoIckJobRef_InvalidRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1646</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1751</internalId></specobject>
    <specobject>
      <id>Mka_GenTest_01016_Invalid_Mka_Xdm_MkaCryptoIckJobRef_InvalidKey</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Generic/IN/Mka_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>402</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test will check that an error is generated if referenced job used for ICK generation does not have the same key configured as
  referenced by MkaCryptoCknCakKeyRef.
&lt;/para&gt;

Test Object: XDM check
Test Precondition: 

Test Execution: 
  VP(Mka.XDM.Crypto.MkaCryptoIckJobRef_InvalidKey):
  The following error must be issued:
  CAK (MkaCryptoCknCakKeyRef) must be configured as referenced Jobs CsmJobKeyRef for ICK generation.

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.Crypto.MkaCryptoIckJobRef_InvalidKey</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1647</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1752</internalId></specobject>
    <specobject>
      <id>Mka_GenTest_01017_Invalid_Mka_Xdm_MkaCryptoIcvGenerateJobRef_InvalidRef</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Generic/IN/Mka_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>428</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test will check that an error is generated if MkaCryptoIcvGenerateJobRef does not point to a valid reference.
&lt;/para&gt;

Test Object: XDM check
Test Precondition: 

Test Execution: 
  VP(Mka.XDM.Crypto.MkaCryptoIcvGenerateJobRef_InvalidRef):
  The following error must be issued:
  Referenced job must be valid.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.Crypto.MkaCryptoIcvGenerateJobRef_InvalidRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1648</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1753</internalId></specobject>
    <specobject>
      <id>Mka_GenTest_01018_Invalid_Mka_Xdm_MkaCryptoIcvVerifyJobRef_InvalidRef</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Generic/IN/Mka_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>453</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test will check that an error is generated if MkaCryptoIcvVerifyJobRef does not point to a valid reference.
&lt;/para&gt;

Test Object: XDM check
Test Precondition: 

Test Execution: 
  VP(Mka.XDM.Crypto.MkaCryptoIcvVerifyJobRef_InvalidRef):
  The following error must be issued:
  Referenced job must be valid.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.Crypto.MkaCryptoIcvVerifyJobRef_InvalidRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1654</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1754</internalId></specobject>
    <specobject>
      <id>Mka_GenTest_01019_Invalid_Mka_Xdm_MkaCryptoIcvGenerateJobRef_InvalidKey</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Generic/IN/Mka_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>478</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test will check that an error is generated if job referenced by parameter MkaCryptoIcvGenerateJobRef does not have the same key
  configured (CsmJobKeyRef) as parameter MkaCryptoIcvVerifyJobRef.
&lt;/para&gt;

Test Object: XDM check
Test Precondition: 

Test Execution: 
  VP(Mka.XDM.Crypto.MkaCryptoIcvGenerateJobRef_InvalidKey):
  The following error must be issued:
  ICV verify and ICV generate jobs must reference the same key (CsmJobKeyRef).

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.Crypto.MkaCryptoIcvGenerateJobRef_InvalidKey</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1655</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1755</internalId></specobject>
    <specobject>
      <id>Mka_GenTest_01020_Invalid_Mka_Xdm_MkaCryptoIcvVerifyJobRef_InvalidKey</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Generic/IN/Mka_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>504</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test will check that an error is generated if job referenced by parameter MkaCryptoIcvVerifyJobRef does not have the same key
  configured (CsmJobKeyRef) as parameter MkaCryptoIcvGenerateJobRef.
&lt;/para&gt;

Test Object: XDM check
Test Precondition: 

Test Execution: 
  VP(Mka.XDM.Crypto.MkaCryptoIcvVerifyJobRef_InvalidKey):
  The following error must be issued:
  ICV verify and ICV generate jobs must reference the same key (CsmJobKeyRef).

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.Crypto.MkaCryptoIcvVerifyJobRef_InvalidKey</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1656</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1756</internalId></specobject>
    <specobject>
      <id>Mka_GenTest_01021_Invalid_Mka_Xdm_MkaCryptoKekDeriveJobRef_InvalidRef</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Generic/IN/Mka_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>530</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test will check that an error is generated if MkaCryptoKekDeriveJobRef does not point to a valid reference.
&lt;/para&gt;

Test Object: XDM check
Test Precondition: 

Test Execution: 
  VP(Mka.XDM.Crypto.MkaCryptoKekDeriveJobRef_InvalidRef):
  The following error must be issued:
  Referenced job must be valid.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.Crypto.MkaCryptoKekDeriveJobRef_InvalidRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1657</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1757</internalId></specobject>
    <specobject>
      <id>Mka_GenTest_01022_Invalid_Mka_Xdm_MkaCryptoKekDeriveJobRef_InvalidKey</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Generic/IN/Mka_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>555</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test will check that an error is generated if referenced job used for KEK generation does not have the same key configured as
  referenced by MkaCryptoCknCakKeyRef.
&lt;/para&gt;

Test Object: XDM check
Test Precondition: 

Test Execution: 
  VP(Mka.XDM.Crypto.MkaCryptoKekDeriveJobRef_InvalidKey):
  The following error must be issued:
  CAK (MkaCryptoCknCakKeyRef) must be configured as referenced Jobs CsmJobKeyRef for KEK generation.

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.Crypto.MkaCryptoKekDeriveJobRef_InvalidKey</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1658</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1758</internalId></specobject>
    <specobject>
      <id>Mka_GenTest_01023_Invalid_Mka_Xdm_MkaCryptoKeyWrapJobRef_InvalidRef</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Generic/IN/Mka_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>581</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test will check that an error is generated if MkaCryptoKeyWrapJobRef does not point to a valid reference.
&lt;/para&gt;

Test Object: XDM check
Test Precondition: 

Test Execution: 
  VP(Mka.XDM.Crypto.MkaCryptoKeyWrapJobRef_InvalidRef):
  The following error must be issued:
  Referenced job must be valid.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.Crypto.MkaCryptoKeyWrapJobRef_InvalidRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1659</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1759</internalId></specobject>
    <specobject>
      <id>Mka_GenTest_01024_Invalid_Mka_Xdm_MkaCryptoKeyWrapJobRef_InvalidKey</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Generic/IN/Mka_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>606</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test will check that an error is generated if referenced job used for key wrap does not have the same key configured as referenced
  by MkaCryptoKeyUnwrapJobRef.
&lt;/para&gt;

Test Object: XDM check
Test Precondition: 

Test Execution: 
  VP(Mka.XDM.Crypto.MkaCryptoKeyWrapJobRef_InvalidKey):
  The following error must be issued:
  Key wrap and key unwrap jobs must reference the same key (CsmJobKeyRef).

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.Crypto.MkaCryptoKeyWrapJobRef_InvalidKey</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1660</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1760</internalId></specobject>
    <specobject>
      <id>Mka_GenTest_01025_Invalid_Mka_Xdm_MkaCryptoKeyUnwrapJobRef_InvalidRef</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Generic/IN/Mka_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>632</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test will check that an error is generated if MkaCryptoKeyUnwrapJobRef does not point to a valid reference.
&lt;/para&gt;

Test Object: XDM check
Test Precondition: 

Test Execution: 
  VP(Mka.XDM.Crypto.MkaCryptoKeyUnwrapJobRef_InvalidRef):
  The following error must be issued:
  Referenced job must be valid.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.Crypto.MkaCryptoKeyUnwrapJobRef_InvalidRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1661</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1761</internalId></specobject>
    <specobject>
      <id>Mka_GenTest_01026_Invalid_Mka_Xdm_MkaCryptoKeyUnwrapJobRef_InvalidKey</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Generic/IN/Mka_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>657</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test will check that an error is generated if referenced job used for key unwrap does not have the same key configured as referenced
  by MkaCryptoKeyWrapJobRef.
&lt;/para&gt;

Test Object: XDM check
Test Precondition: 

Test Execution: 
  VP(Mka.XDM.Crypto.MkaCryptoKeyUnwrapJobRef_InvalidKey):
  The following error must be issued:
  Key wrap and key unwrap jobs must reference the same key (CsmJobKeyRef).

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.Crypto.MkaCryptoKeyUnwrapJobRef_InvalidKey</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1662</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1762</internalId></specobject>
    <specobject>
      <id>Mka_GenTest_01027_Invalid_Mka_Xdm_MkaCryptoSakKeyRef_InvalidRef</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Generic/IN/Mka_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>683</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test will check that an error is generated if MkaCryptoSakKeyRef does not point to a valid reference.
&lt;/para&gt;

Test Object: XDM check
Test Precondition: 

Test Execution: 
  VP(Mka.XDM.Crypto.MkaCryptoSakKeyRef_InvalidRef):
  The following error must be issued:
  Referenced key must be valid.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.Crypto.MkaCryptoSakKeyRef_InvalidRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1663</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1763</internalId></specobject>
    <specobject>
      <id>Mka_GenTest_01028_Invalid_Mka_Xdm_MkaPaeConfiguration_Consecutive</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Generic/IN/Mka_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>708</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test will check that an error is generated if MkaPaeConfigurationIdx of the MkaPaeConfiguration are not consecutive.
&lt;/para&gt;

Test Object: XDM check
Test Precondition: 

Test Execution: 
  VP(Mka.XDM.PaeConfiguration.MkaPaeConfiguration_Consecutive):
  The following error must be issued:
  MkaPaeConfigurationIdx shall be 0-based and dense.

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.PaeConfiguration.MkaPaeConfiguration_Consecutive</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1665</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1764</internalId></specobject>
    <specobject>
      <id>Mka_GenTest_01029_Invalid_Mka_Xdm_MkaCryptoAlgoConfig_Consecutive</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Generic/IN/Mka_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>733</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test will check that an error is generated if MkaCryptoAlgoConfigIdx of the MkaCryptoAlgoConfig are not consecutive.
&lt;/para&gt;

Test Object: XDM check
Test Precondition: 

Test Execution: 
  VP(Mka.XDM.CryptoAlgoConfig.MkaCryptoAlgoConfig_Consecutive):
  The following error must be issued:
  MkaCryptoAlgoConfigIdx shall be 0-based and dense.

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.CryptoAlgoConfig.MkaCryptoAlgoConfig_Consecutive</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1666</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1765</internalId></specobject>
    <specobject>
      <id>Mka_GenTest_01030_Invalid_Mka_Xdm_OffsetSetForXPN</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Generic/IN/Mka_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>758</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test will check that an error is generated if MkaMacSecCapability is set to MKA_INTEGRITY_AND_CONFIDENTIALITY and MkaMacSecConfidentialityOffset
  is set to a value other than MKA_CONFIDENTIALITY_OFFSET_0, when XPN cipher suite has been selected.
&lt;/para&gt;

Test Object: XDM check
Test Precondition: 

Test Execution: 
  VP(Mka.XDM.CryptoAlgoConfig.OffsetSetForXPN):
  The following error must be issued:
  When XPN cipher suite is selected and MkaMacSecCapability is MKA_INTEGRITY_AND_CONFIDENTIALITY, MkaMacSecConfidentialityOffset must be MKA_CONFIDENTIALITY_OFFSET_0.

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.CryptoAlgoConfig.OffsetSetForXPN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1667</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1766</internalId></specobject>
    <specobject>
      <id>Mka_GenTest_01031_Invalid_Mka_Xdm_Confidentiality_NoOffset</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Generic/IN/Mka_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>784</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test will check that an error is generated if MkaMacSecConfidentialityOffset is disabled when MkaMacSecCapability is set to
  MKA_INTEGRITY_AND_CONFIDENTIALITY.
&lt;/para&gt;

Test Object: XDM check
Test Precondition: 

Test Execution: 
  VP(Mka.XDM.CryptoAlgoConfig.Confidentiality_NoOffset):
  The following error must be issued:
  When MkaMacSecCapability is set to MKA_INTEGRITY_AND_CONFIDENTIALITY, MkaMacSecConfidentialityOffset must also be set.

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.CryptoAlgoConfig.Confidentiality_NoOffset</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1668</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1767</internalId></specobject>
    <specobject>
      <id>Mka_GenTest_01032_Invalid_Mka_Xdm_OffsetSet_NoConfidentiality</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Generic/IN/Mka_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>810</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test will check that an error is generated if MkaMacSecConfidentialityOffset is enabled when MkaMacSecCapability is set to
  MKA_INTEGRITY_WITHOUT_CONFIDENTIALITY.
&lt;/para&gt;

Test Object: XDM check
Test Precondition: 

Test Execution: 
  VP(Mka.XDM.CryptoAlgoConfig.OffsetSet_NoConfidentiality):
  The following error must be issued:
  When MkaMacSecCapability is set to MKA_INTEGRITY_WITHOUT_CONFIDENTIALITY, MkaMacSecConfidentialityOffset must be disabled.

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.CryptoAlgoConfig.OffsetSet_NoConfidentiality</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1669</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1768</internalId></specobject>
    <specobject>
      <id>Mka_GenTest_01033_Invalid_Mka_Xdm_MkaCipherSuites_Consecutive</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Generic/IN/Mka_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>836</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test will check that an error is generated if MkaMacSecCipherSuitePrio of the MkaCryptoAlgoConfig are not consecutive.
&lt;/para&gt;

Test Object: XDM check
Test Precondition: 

Test Execution: 
  VP(Mka.XDM.CipherSuites.MkaCipherSuites_Consecutive):
  The following error must be issued:
  MkaMacSecCipherSuitePrio shall be consecutive and start with 1.

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.CipherSuites.MkaCipherSuites_Consecutive</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1670</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1769</internalId></specobject>
    <specobject>
      <id>Mka_GenTest_01034_Invalid_Mka_Xdm_MkaCipherSuites_Repeating</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Generic/IN/Mka_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>861</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test will check that an error is generated if MkaMacSecCipherSuite of MkaCipherSuites list are repeated.
&lt;/para&gt;

Test Object: XDM check
Test Precondition: 

Test Execution: 
  VP(Mka.XDM.CipherSuites.MkaCipherSuites_Repeating):
  The following error must be issued:
  Cipher suite shall not be repeated in MkaCipherSuites container.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.CipherSuites.MkaCipherSuites_Repeating</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1671</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1770</internalId></specobject>
    <specobject>
      <id>Mka_GenTest_01035_Invalid_Mka_Xdm_MkaMaxNumPaeInstances_InvalidValue</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Generic/IN/Mka_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>886</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test will check that an error is generated if MkaMaxNumPaeInstances is smaller than the number of configured Pae instances.
&lt;/para&gt;

Test Object: XDM check
Test Precondition: 

Test Execution: 
  VP(Mka.XDM.PaeInstance.MkaMaxNumPaeInstances_InvalidValue):
  The following error must be issued:
  The value is smaller then the number of configured PAE instances.

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.PaeInstance.MkaMaxNumPaeInstances_InvalidValue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1672</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1771</internalId></specobject>
    <specobject>
      <id>Mka_GenTest_01036_Invalid_Mka_Xdm_MkaMaxNumParticipants_InvalidValue</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Generic/IN/Mka_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>911</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test will check that an error is generated if MkaMaxNumParticipants is smaller than the number of configured Pae instances.
&lt;/para&gt;

Test Object: XDM check
Test Precondition: 

Test Execution: 
  VP(Mka.XDM.PaeInstance.MkaMaxNumParticipants_InvalidValue):
  The following error must be issued:
  The value is smaller then the number of configured PAE instances.

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.PaeInstance.MkaMaxNumParticipants_InvalidValue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1673</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1772</internalId></specobject>
    <specobject>
      <id>Mka_GenTest_01037_Invalid_Mka_Xdm_MkaNvmBlockDescriptorRef_ReadAll</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Generic/IN/Mka_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>936</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test will check that an error is generated if NvMSelectBlockForReadAll is not set in the NvM block referenced by
  MkaNvmBlockDescriptorRef so that reading will be done by BswM module.
&lt;/para&gt;

Test Object: XDM check
Test Precondition: 

Test Execution: 
  VP(Mka.XDM.MkaNvmBlockDescriptorRef.ReadAll):
  The following error must be issued:
  NvMSelectBlockForReadAll must be enabled in the referenced NvM block (reliance on BswM)!

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.MkaNvmBlockDescriptorRef.ReadAll</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1674</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1773</internalId></specobject>
    <specobject>
      <id>Mka_GenTest_01038_Invalid_Mka_Xdm_MkaNvmBlockDescriptorRef_WriteAll</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Generic/IN/Mka_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>962</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test will check that an error is generated if NvMSelectBlockForWriteAll is not set in the NvM block referenced by
  MkaNvmBlockDescriptorRef so that writing will be done by BswM module.
&lt;/para&gt;

Test Object: XDM check
Test Precondition: 

Test Execution: 
  VP(Mka.XDM.MkaNvmBlockDescriptorRef.WriteAll):
  The following error must be issued:
  NvMSelectBlockForWriteAll must be enabled in the referenced NvM block (reliance on BswM)!

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.MkaNvmBlockDescriptorRef.WriteAll</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1675</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1774</internalId></specobject>
    <specobject>
      <id>Mka_GenTest_01039_Invalid_Mka_Xdm_MkaNvmBlockDescriptorRef_RamAddress</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Generic/IN/Mka_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>988</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test will check that an error is generated if NvMRamBlockDataAddress is not set in the NvM block referenced by
  MkaNvmBlockDescriptorRef to MkaNvRam_Memory.
&lt;/para&gt;

Test Object: XDM check
Test Precondition: 

Test Execution: 
  VP(Mka.XDM.MkaNvmBlockDescriptorRef.RamAddress):
  The following error must be issued:
  NvMRamBlockDataAddress must be set in the referenced NvM block to MkaNvRam_Memory !

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.MkaNvmBlockDescriptorRef.RamAddress</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1676</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1775</internalId></specobject>
    <specobject>
      <id>Mka_GenTest_01040_Invalid_Mka_Xdm_MkaNvmBlockDescriptorRef_UserHeader</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Generic/IN/Mka_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>1014</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test will check that an error is generated if one of the user headers in NvMUserHeader list is not Mka.h.
&lt;/para&gt;

Test Object: XDM check
Test Precondition: 

Test Execution: 
  VP(Mka.XDM.MkaNvmBlockDescriptorRef.UserHeader):
  The following error must be issued:
  One of the user headers must be Mka.h !

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.MkaNvmBlockDescriptorRef.UserHeader</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1677</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1776</internalId></specobject>
    <specobject>
      <id>Mka_GenTest_01041_Invalid_Mka_Xdm_MinimumMemorySize_Invalid</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Generic/IN/Mka_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>1039</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test will check that an error is generated if NvMNvBlockLength is smaller than size of MkaNvRam_Memory structure.
  Size is calculated as:
    sizeof(MkaNvRam_Memory) or
    1 *  uint32 (4 octets) +
    3 * uint8(1 octet) times maximum number of PAEs +
    for each Participant 1 bit aligned to octets, meaning minimum 1 octet
      - largest integer value less than or equal to ((MaxNumParticipants + 7) / 8)
    and sum of all aligned to 4.
      - largest integer value less than or equal to (((Sum + 3) * 4) / 4)
&lt;/para&gt;

Test Object: XDM check
Test Precondition: 

Test Execution: 
  VP(Mka.XDM.MkaNvmBlockDescriptorRef.MinimumMemorySize_Invalid):
  The following error must be issued:
  Size of NvM NvMNvBlockLength must be equal or greater than NvRam minimum required size !

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.MkaNvmBlockDescriptorRef.MinimumMemorySize_Invalid</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1678</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1777</internalId></specobject>
    <specobject>
      <id>Mka_GenTest_01042_Invalid_Mka_Xdm_MacSecStatisticsNotification_CallbackRef_Invalid</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Generic/IN/Mka_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>1072</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test will check that an error is generated if MkaGetMacSecStatisticsCallback is set but no callback function has been defined.
&lt;/para&gt;

Test Object: XDM check
Test Precondition: 

Test Execution: 
  VP(Mka.XDM.MkaGetMacSecStatisticsCallback_EmptyReference):
  The following error must be issued:
  Callback function name must be specified when MkaGetMacSecStatisticsCallback container is enabled.

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.MkaGetMacSecStatisticsCallback_EmptyReference</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1679</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1778</internalId></specobject>
    <specobject>
      <id>Mka_GenTest_01043_Invalid_Mka_Xdm_MkaCryptoHashGenerateJobRef_InvalidRef</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Generic/IN/Mka_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>1097</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test will check that an error is generated if MkaCryptoHashGenerateJobRef does not point to a valid reference.
&lt;/para&gt;

Test Object: XDM check
Test Precondition: 

Test Execution: 
  VP(Mka.XDM.Crypto.MkaCryptoHashGenerateJobRef_InvalidRef):
  The following error must be issued:
  Referenced job must be valid.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.Crypto.MkaCryptoHashGenerateJobRef_InvalidRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1649</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1779</internalId></specobject>
    <specobject>
      <id>Mka_GenTest_01044_Invalid_Mka_Xdm_MkaKayDemEventParameterRefs_InvalidReference</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Generic/IN/Mka_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>1122</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test will check that an error is generated if an event inside of container MkaKayDemEventParameterRefs does not
  point to a valid reference.
&lt;/para&gt;

Test Object: XDM check
Test Precondition: 

Test Execution: 
  VP(Mka.XDM.MkaKayDemEventParameterRefs_InvalidReference):
  The following error must be issued:
  _DemError_ configuration parameter must reference a valid Dem event.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.MkaKayDemEventParameterRefs_InvalidReference</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1683</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1780</internalId></specobject>
    <specobject>
      <id>Mka_GenTest_01045_Invalid_Mka_Xdm_MkaKayDemEventParameterRefs_UniqueReference</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Generic/IN/Mka_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>1148</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test will check that an error is generated if an event inside of container MkaKayDemEventParameterRefs does not
  have a unique reference.
&lt;/para&gt;

Test Object: XDM check
Test Precondition: 

Test Execution: 
  VP(Mka.XDM.MkaKayDemEventParameterRefs_UniqueReference):
  The following error must be issued:
  _DemError_ reference must be unique.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.MkaKayDemEventParameterRefs_UniqueReference</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1684</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1781</internalId></specobject>
    <specobject>
      <id>Mka_GenTest_01046_Invalid_Mka_Xdm_MkaPaeEthIfEthTrcvRef_InvalidReference</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Generic/IN/Mka_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>1174</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test will check that an error is generated if PaeInstance references EthIfController with the invalid reference
  to EthIfEthTrcvRef.&lt;/para&gt;

Test Object: XDM check
Test Precondition: 

Test Execution: 
  VP(Mka.XDM.MkaPaeEthIfEthTrcvRef_InvalidReference):
  The following error must be issued:
  MACsec PAE's referenced MkaEthIfControllerRef must have a valid reference to EthIfEthTrcvRef.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.MkaPaeEthIfEthTrcvRef_InvalidReference</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1685</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1782</internalId></specobject>
    <specobject>
      <id>Mka_GenTest_01047_Invalid_Mka_Xdm_MkaPaeEthIfEthTrcvRef_UniqueReference</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Generic/IN/Mka_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>1199</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test will check that an error is generated if the same EthIfEthTrcvRef, inside referenced MkaEthIfControllerRef,
  is referenced across multiple Pae instances.
&lt;/para&gt;

Test Object: XDM check
Test Precondition: 

Test Execution: 
  VP(Mka.XDM.MkaPaeEthIfEthTrcvRef_UniqueReference):
  The following error must be issued:
  Different MacSec PAEs must have uniquely referenced EthIfEthTrcvRef (inside the referenced MkaEthIfControllerRef).

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.MkaPaeEthIfEthTrcvRef_UniqueReference</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1686</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1783</internalId></specobject>
    <specobject>
      <id>Mka_GenTest_01048_Invalid_Mka_Xdm_MkaCryptoHashGenerateJobRef_InvalidKeySize_128</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Generic/IN/Mka_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>1225</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test will check that an error is generated if the MkaCryptoAlgoConfig has configured Cipher that has the size 128 and
  CsmEncryptAlgorithmKeyLength in CsmEncrypt hash job primitive not set to 16.
&lt;/para&gt;

Test Object: XDM check
Test Precondition: 

Test Execution: 
  VP(Mka.XDM.Crypto.MkaCryptoHashGenerateJobRef_InvalidKeySize_128):
  The following error must be issued:
  The size of configured ciphers in MkaCryptoAlgoConfig is 128 - CsmEncryptAlgorithmKeyLength of a hash job primitive must be set to 16.

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.Crypto.MkaCryptoHashGenerateJobRef_InvalidKeySize_128</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1650</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1784</internalId></specobject>
    <specobject>
      <id>Mka_GenTest_01049_Invalid_Mka_Xdm_MkaCryptoHashGenerateJobRef_InvalidKeySize_256</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Generic/IN/Mka_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>1251</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test will check that an error is generated if the MkaCryptoAlgoConfig has configured Cipher that has the size 256 and
  CsmEncryptAlgorithmKeyLength in CsmEncrypt hash job primitive not set to 32.
&lt;/para&gt;

Test Object: XDM check
Test Precondition: 

Test Execution: 
  VP(Mka.XDM.Crypto.MkaCryptoHashGenerateJobRef_InvalidKeySize_256):
  The following error must be issued:
  The size of configured ciphers in MkaCryptoAlgoConfig is 256 - CsmEncryptAlgorithmKeyLength of a hash job primitive must be set to 32.

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.Crypto.MkaCryptoHashGenerateJobRef_InvalidKeySize_256</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1651</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1785</internalId></specobject>
    <specobject>
      <id>Mka_GenTest_01050_Invalid_Mka_Xdm_MkaCryptoHashGenerateJob2Ref_InvalidKeySize</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Generic/IN/Mka_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>1277</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test will check that an error is generated if the MkaCryptoAlgoConfig has configured Ciphers with mixed sizes 128 and 256 and
  CsmEncryptAlgorithmKeyLength in CsmEncrypt primitive of hash jobs is configured for only one size.
&lt;/para&gt;

Test Object: XDM check
Test Precondition: 

Test Execution: 
  VP(Mka.XDM.Crypto.MkaCryptoHashGenerateJob2Ref_InvalidKeySize):
  The following error must be issued:
  When both cipher suite sizes (128 and 256) are configured in MkaCryptoAlgoConfig the size of keys in CsmEncryptAlgorithmKeyLength of a
  hash job primitives must be 16 and 32.

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.Crypto.MkaCryptoHashGenerateJob2Ref_InvalidKeySize</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1653</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1786</internalId></specobject>
    <specobject>
      <id>Mka_GenTest_01051_Invalid_Mka_Xdm_MkaCryptoHashGenerateJob2Ref_InvalidRef</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Generic/IN/Mka_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>1304</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test will check that an error is generated if MkaCryptoHashGenerateJob2Ref references with the invalid reference to CsmJobs.
&lt;/para&gt;

Test Object: XDM check
Test Precondition: 

Test Execution: 
  VP(Mka.XDM.Crypto.MkaCryptoHashGenerateJob2Ref_InvalidRef):
  The following error must be issued:
  Referenced job must be valid!

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.Crypto.MkaCryptoHashGenerateJob2Ref_InvalidRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1652</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1787</internalId></specobject>
    <specobject>
      <id>Mka_GenTest_01052_Invalid_Mka_Xdm_MkaCryptoSak2KeyRef_InvalidRef</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Generic/IN/Mka_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>1329</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test will check that an error is generated if MkaCryptoSak2KeyRef references with the invalid reference to CsmJobs.
&lt;/para&gt;

Test Object: XDM check
Test Precondition: 

Test Execution: 
  VP(Mka.XDM.Crypto.MkaCryptoSak2KeyRef_InvalidRef):
  The following error must be issued:
  Referenced job must be valid!

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.Crypto.MkaCryptoSak2KeyRef_InvalidRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1664</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1788</internalId></specobject>
    <specobject>
      <id>Mka_GenTest_01053_Invalid_Mka_Xdm_MkaSecYCallout_EmptyReference</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Generic/IN/Mka_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>1354</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test will check that an error is generated if MkaSecYCallout is set but no function name is given.
&lt;/para&gt;

Test Object: XDM check
Test Precondition: 

Test Execution: 
  VP(Mka.XDM.MkaSecYCallout_EmptyReference):
  The following error must be issued:
  Callout function name must be specified when MkaSecYCallout container is enabled.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.MkaSecYCallout_EmptyReference</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1680</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1789</internalId></specobject>
    <specobject>
      <id>Mka_GenTest_01054_Invalid_Mka_Xdm_MkaTaskCallout_EmptyReference</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Generic/IN/Mka_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>1379</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test will check that an error is generated if MkaTaskCallout is set but no function name is given.
&lt;/para&gt;

Test Object: XDM check
Test Precondition: 

Test Execution: 
  VP(Mka.XDM.MkaTaskCallout_EmptyReference):
  The following error must be issued:
  Callout function name must be specified when MkaTaskCallout container is enabled.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.MkaTaskCallout_EmptyReference</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1681</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1790</internalId></specobject>
    <specobject>
      <id>Mka_GenTest_01055_Invalid_Mka_Xdm_MkaReportEventCallout_EmptyReference</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Generic/IN/Mka_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>1404</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test will check that an error is generated if MkaReportEventCallout is set but no function name is given.
&lt;/para&gt;

Test Object: XDM check
Test Precondition: 

Test Execution: 
  VP(Mka.XDM.MkaReportEventCallout_EmptyReference):
  The following error must be issued:
  Callout function name must be specified when MkaReportEventCallout container is enabled.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.XDM.MkaReportEventCallout_EmptyReference</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1682</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1791</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EcuC_Timers_01000_AutoTestTimers</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/EcuC_Timers/TestSpec_Generated.h</sourcefile>
      <sourceline>9</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This is a test case for test of the timers. Timers are split into five groups, some groups are auto repeating and some are not. Correct number of timeouts for each timer is calculated based on number of ECUC_TIMERS_PROCESS calls and timer interval and stored in Test_TimerTimeoutCounters array. During timeout for each timer callback is called and corresponding counter in Test_TimerTimeoutCounters is decreased. In the end all counters should reach zero.
Test Object: Timer API-s and functionality automated test.
Test Precondition: 
  
Test Execution: 
    01: Call EcuC_Timers_InitTimerHandler() to initialize timers.
    02: Start all timers and precalculate number of timeouts for each timer and store it.
    03: Call ECUC_TIMERS_PROCESS predefined number of times.
    04: VP(EcuC_Timers.dsn.Api.StartTimer,1)
        VP(EcuC_Timers.dsn.Api.StartTimerAutorepeat,1)
        VP(EcuC_Timers.dsn.Api.ProcessTimerTimeout,1) Verify that each timer timeout counter has reached zero.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EcuC_Timers.dsn.Api.StartTimer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>9</internalId></provcov>
        <provcov>
          <linksto>EcuC_Timers.dsn.Api.StartTimerAutorepeat</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>12</internalId></provcov>
        <provcov>
          <linksto>EcuC_Timers.dsn.Api.ProcessTimerTimeout</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>27</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1792</internalId></specobject>
    <specobject>
      <id>EcuC_Timers_01001_InitTimerHandler</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/EcuC_Timers/TestSpec_Generated.h</sourcefile>
      <sourceline>39</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that EcuC_Timers_InitTimerHandler() called with correct set of inputs sets initial values for timer handler.
Test Object: EcuC_Timers_InitTimerHandler().
Test Precondition: 
  
Test Execution: 
    01: Set timer handler as not initialized.
    02: Call EcuC_Timers_InitTimerHandler to start initialization procedure.
    03: VP(EcuC_Timers.dsn.Api.InitTimerHandler,1) Verify that timer handler has been initialized.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EcuC_Timers.dsn.Api.InitTimerHandler</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>7</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1793</internalId></specobject>
    <specobject>
      <id>EcuC_Timers_01002_InitTimerHandler_Ignore</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/EcuC_Timers/TestSpec_Generated.h</sourcefile>
      <sourceline>58</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that EcuC_Timers_InitTimerHandler() called with TimerHandlerPtr as NULL_PTR or TimerHndCfgPtr as NULL_PTR will ignore the call.
Test Object: EcuC_Timers_InitTimerHandler().
Test Precondition: 
  
Test Execution: 
    01: Set timer handler as initialized.
    02: Call EcuC_Timers_InitTimerHandler with NULL TimerHndCfgPtr.
    03: VP(EcuC_Timers.dsn.Api.InitTimerHandler.Ignore,1) Verify that EcuC_Timers_InitTimerHandler() call was ignored and initialization flag was updated accordingly.
    04: Set timeout value for timers to a value different than initial value.
    05: Call EcuC_Timers_InitTimerHandler with NULL TimerHandlerPtr.
    06: VP(EcuC_Timers.dsn.Api.InitTimerHandler.Ignore,1) Verify that EcuC_Timers_InitTimerHandler() call was ignored and time out value of timers have not been initialized.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EcuC_Timers.dsn.Api.InitTimerHandler.Ignore</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>8</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1794</internalId></specobject>
    <specobject>
      <id>EcuC_Timers_01003_StartTimer_Ignore</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/EcuC_Timers/TestSpec_Generated.h</sourcefile>
      <sourceline>80</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that EcuC_Timers_StartTimer() called with TimerHandlerPtr as NULL_PTR will ignore the call and will not start the timer.
Test Object: EcuC_Timers_StartTimer().
Test Precondition: 
    -   Call EcuC_Timers_InitTimerHandler() to initialize timer handler.
  
Test Execution: 
    01: Sanity check - Confirm there are no timers currently running.
    02: Call EcuC_Timers_StartTimer() with NULL TimerHandlerPtr.
    03: VP(EcuC_Timers.dsn.Api.StartTimer.Ignore,1) Verify that EcuC_Timers_StartTimer() call was ignored and there are no timers running.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EcuC_Timers.dsn.Api.StartTimer.Ignore</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>10</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1795</internalId></specobject>
    <specobject>
      <id>EcuC_Timers_01004_StartTimer_Uninitialized</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/EcuC_Timers/TestSpec_Generated.h</sourcefile>
      <sourceline>100</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that EcuC_Timers_StartTimer() called when the timer handler has not been initialized will ignore the call and will not start the timer.
Test Object: EcuC_Timers_StartTimer().
Test Precondition: 
    -   Call EcuC_Timers_InitTimerHandler() to initialize timer handler.
  
Test Execution: 
    01: Sanity check - Confirm there are no timers currently running.
    02: Set timer handler as not initialized.
    03: Call EcuC_Timers_StartTimer().
    04: VP(EcuC_Timers.dsn.Api.StartTimer.Uninitialized,1) Verify that EcuC_Timers_StartTimer() call was ignored and there are no timers running.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EcuC_Timers.dsn.Api.StartTimer.Uninitialized</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>11</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1796</internalId></specobject>
    <specobject>
      <id>EcuC_Timers_01005_StartTimerAutorepeat_Ignore</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/EcuC_Timers/TestSpec_Generated.h</sourcefile>
      <sourceline>121</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that EcuC_Timers_StartTimerAutorepeat() called with TimerHandlerPtr as NULL_PTR will ignore the call and will not start the timer.
Test Object: EcuC_Timers_StartTimerAutorepeat().
Test Precondition: 
    -   Call EcuC_Timers_InitTimerHandler() to initialize timer handler.
  
Test Execution: 
    01: Sanity check - Confirm there are no timers currently running.
    02: Call EcuC_Timers_StartTimerAutorepeat().
    03: VP(EcuC_Timers.dsn.Api.StartTimerAutorepeat.Ignore,1) Verify that EcuC_Timers_StartTimerAutorepeat() call was ignored and there are no timers running.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EcuC_Timers.dsn.Api.StartTimerAutorepeat.Ignore</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>13</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1797</internalId></specobject>
    <specobject>
      <id>EcuC_Timers_01006_StartTimerAutorepeat_Uninitialized</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/EcuC_Timers/TestSpec_Generated.h</sourcefile>
      <sourceline>141</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that EcuC_Timers_StartTimerAutorepeat() called when the timer handler has not been initialized will ignore the call and will not start the timer.
Test Object: EcuC_Timers_StartTimerAutorepeat().
Test Precondition: 
    -   Call EcuC_Timers_InitTimerHandler() to initialize timer handler.
  
Test Execution: 
    01: Sanity check - Confirm there are no timers currently running.
    02: Set timer handler as not initialized.
    03: Call EcuC_Timers_StartTimerAutorepeat().
    04: VP(EcuC_Timers.dsn.Api.StartTimerAutorepeat.Uninitialized,1) Verify that EcuC_Timers_StartTimerAutorepeat() call was ignored and there are no timers running.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EcuC_Timers.dsn.Api.StartTimerAutorepeat.Uninitialized</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>14</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1798</internalId></specobject>
    <specobject>
      <id>EcuC_Timers_01007_StopTimer</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/EcuC_Timers/TestSpec_Generated.h</sourcefile>
      <sourceline>162</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that EcuC_Timers_StopTimer() called with correct set of inputs will stop the specified timer.
Test Object: EcuC_Timers_StopTimer().
Test Precondition: 
    -   Call EcuC_Timers_InitTimerHandler() to initialize timer handler.
    -   Call EcuC_Timers_StartTimer() to start timer.
  
Test Execution: 
    01: Sanity check - Confirm there is one timer currently running.
    02: Call EcuC_Timers_StopTimer().
    03: VP(EcuC_Timers.dsn.Api.StopTimer,1) Verify that there are no timers running.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EcuC_Timers.dsn.Api.StopTimer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>15</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1799</internalId></specobject>
    <specobject>
      <id>EcuC_Timers_01008_StopTimer_Ignore</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/EcuC_Timers/TestSpec_Generated.h</sourcefile>
      <sourceline>183</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that EcuC_Timers_StopTimer() called with TimerHandlerPtr as NULL_PTR will ignore the call and will not stop the timer.
Test Object: EcuC_Timers_StopTimer().
Test Precondition: 
    -   Call EcuC_Timers_InitTimerHandler() to initialize timer handler.
    -   Call EcuC_Timers_StartTimer() to start timer.
  
Test Execution: 
    01: Sanity check - Confirm there is one timer currently running.
    02: Call EcuC_Timers_StopTimer() with NULL TimerHandlerPtr.
    03: VP(EcuC_Timers.dsn.Api.StopTimer.Ignore,1) Verify that EcuC_Timers_StopTimer() call was ignored and no timers were stopped.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EcuC_Timers.dsn.Api.StopTimer.Ignore</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>16</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1800</internalId></specobject>
    <specobject>
      <id>EcuC_Timers_01009_StopTimer_Uninitialized</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/EcuC_Timers/TestSpec_Generated.h</sourcefile>
      <sourceline>204</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that EcuC_Timers_StopTimer() called when the timer handler has not been initialized will ignore the call and will not stop the timer.
Test Object: EcuC_Timers_StopTimer().
Test Precondition: 
    -   Call EcuC_Timers_InitTimerHandler() to initialize timer handler.
    -   Call EcuC_Timers_StartTimer() to start timer.
  
Test Execution: 
    01: Sanity check - Confirm there is one timer currently running.
    02: Set timer handler as not initialized.
    03: Call EcuC_Timers_StopTimer() when timer handler is not initialized.
    04: VP(EcuC_Timers.dsn.Api.StopTimer.Uninitialized,1) Verify that EcuC_Timers_StopTimer() call was ignored and no timers were stopped.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EcuC_Timers.dsn.Api.StopTimer.Uninitialized</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>17</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1801</internalId></specobject>
    <specobject>
      <id>EcuC_Timers_01010_PauseTimer_Ignore</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/EcuC_Timers/TestSpec_Generated.h</sourcefile>
      <sourceline>226</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that EcuC_Timers_PauseTimer() called with TimerHandlerPtr as NULL_PTR will ignore the call and not pause the timer.
Test Object: EcuC_Timers_PauseTimer().
Test Precondition: 
    -   Call EcuC_Timers_InitTimerHandler() to initialize timer handler.
    -   Call EcuC_Timers_StartTimer() to start timer.
  
Test Execution: 
    01: Call EcuC_Timers_PauseTimer() before timer is started, so it shall be ignored.
    02: Sanity check - Confirm there is one timer currently running.
    03: Set the timer count value.
    04: Call EcuC_Timers_PauseTimer().
    05: Call EcuC_Timers_ProcessTimerTimeout() through the function like macro to make the timeout pass.
    06: VP(EcuC_Timers.dsn.Api.PauseTimer.Ignore,1) Verify that the timer is still running and the timeout counter has reached zero.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EcuC_Timers.dsn.Api.PauseTimer.Ignore</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>19</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1802</internalId></specobject>
    <specobject>
      <id>EcuC_Timers_01011_PauseTimer_Uninitialized</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/EcuC_Timers/TestSpec_Generated.h</sourcefile>
      <sourceline>250</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that EcuC_Timers_PauseTimer() called when the timer handler has not been initialized will ignore the call and will not pause the timer, however timeout will not be reached since EcuC_Timers_ProcessTimerTimeout also needs the timer handler to be initialized.
Test Object: EcuC_Timers_PauseTimer().
Test Precondition: 
    -   Call EcuC_Timers_InitTimerHandler() to initialize timer handler.
    -   Call EcuC_Timers_StartTimer() to start timer.
  
Test Execution: 
    01: Sanity check - Confirm there is one timer currently running.
    02: Set timer handler as not initialized.
    03: Call EcuC_Timers_PauseTimer() when timer handler is not initialized.
    04: VP(EcuC_Timers.dsn.Api.PauseTimer.Uninitialized,1) Verify that the timer is still running.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EcuC_Timers.dsn.Api.PauseTimer.Uninitialized</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>20</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1803</internalId></specobject>
    <specobject>
      <id>EcuC_Timers_01012_ResumeTimer</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/EcuC_Timers/TestSpec_Generated.h</sourcefile>
      <sourceline>272</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that EcuC_Timers_ResumeTimer() called with correct set of inputs will make the timer continue running and that, once is resumed, the timeout counter will reach zero after the timeout passes.
Test Object: EcuC_Timers_ResumeTimer().
Test Precondition: 
    -   Call EcuC_Timers_InitTimerHandler() to initialize timer handler.
    -   Call EcuC_Timers_StartTimer() to start timer.
  
Test Execution: 
    01: Sanity check - Confirm there is one timer currently running.
    02: Call EcuC_Timers_ResumeTimer() before it is paused, so it shall be ignored.
    03: Call EcuC_Timers_PauseTimer() to pause timer.
    04: Set the timer count value.
    05: Call EcuC_Timers_ProcessTimerTimeout() through the function like macro.
    06: VP(EcuC_Timers.dsn.Api.PauseTimer,1)
        VP(EcuC_Timers.dsn.Api.ResumeTimer,1) Verify that there are no timers running and that the timeout counter has not changed.
    07: Call EcuC_Timers_ResumeTimer().
    08: VP(EcuC_Timers.dsn.Api.ResumeTimer,1) Verify that the timer is running.
    09: Call EcuC_Timers_ProcessTimerTimeout() through the function like macro to make the timeout pass.
    10: VP(EcuC_Timers.dsn.Api.ResumeTimer,1) Verify that the timeout counter has reached zero.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EcuC_Timers.dsn.Api.PauseTimer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>18</internalId></provcov>
        <provcov>
          <linksto>EcuC_Timers.dsn.Api.ResumeTimer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>21</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1804</internalId></specobject>
    <specobject>
      <id>EcuC_Timers_01013_ResumeTimer_Ignore</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/EcuC_Timers/TestSpec_Generated.h</sourcefile>
      <sourceline>305</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that EcuC_Timers_ResumeTimer() called with TimerHandlerPtr as NULL_PTR will ignore the call and no progress shall be made.
Test Object: EcuC_Timers_ResumeTimer().
Test Precondition: 
    -   Call EcuC_Timers_InitTimerHandler() to initialize timer handler.
    -   Call EcuC_Timers_StartTimer() to start timer.
    -   Call EcuC_Timers_PauseTimer() to pause timer.
  
Test Execution: 
    01: Sanity check - Confirm there is one timer currently running.
    02: Sanity check - Confirm there is no timer currently running.
    03: Set the timer count value.
    04: Call EcuC_Timers_ProcessTimerTimeout() through the function like macro.
    05: Sanity check - Verify that the timeout counter has not changed.
    06: Call EcuC_Timers_ResumeTimer() with NULL TimerHandlerPtr.
    07: VP(EcuC_Timers.dsn.Api.ResumeTimer.Ignore,1) Verify that the timer is not running.
    08: Call EcuC_Timers_ProcessTimerTimeout() through the function like macro to make the timeout pass.
    09: VP(EcuC_Timers.dsn.Api.ResumeTimer.Ignore,1) Verify that the timeout counter has not changed.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EcuC_Timers.dsn.Api.ResumeTimer.Ignore</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>22</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1805</internalId></specobject>
    <specobject>
      <id>EcuC_Timers_01014_ResumeTimer_Uninitialized</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/EcuC_Timers/TestSpec_Generated.h</sourcefile>
      <sourceline>333</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that EcuC_Timers_ResumeTimer() called when the timer handler has not been initialized will ignore the call and will not resume the timer.
Test Object: EcuC_Timers_ResumeTimer().
Test Precondition: 
    -   Call EcuC_Timers_InitTimerHandler() to initialize timer handler.
    -   Call EcuC_Timers_StartTimer() to start timer.
    -   Call EcuC_Timers_PauseTimer() to pause timer.
  
Test Execution: 
    01: Sanity check - Confirm there is one timer currently running.
    02: Sanity check - Confirm there is no timer currently running.
    03: Set the timer count value.
    04: Call EcuC_Timers_ProcessTimerTimeout() through the function like macro.
    05: VP(EcuC_Timers.dsn.Api.ResumeTimer,1) Verify that the timeout counter has not changed.
    06: Set timer handler as not initialized.
    07: Call EcuC_Timers_ResumeTimer() when timer handler is not initialized.
    08: VP(EcuC_Timers.dsn.Api.ResumeTimer.Uninitialized,1) Verify that the timer is not running.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EcuC_Timers.dsn.Api.ResumeTimer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>21</internalId></provcov>
        <provcov>
          <linksto>EcuC_Timers.dsn.Api.ResumeTimer.Uninitialized</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>23</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1806</internalId></specobject>
    <specobject>
      <id>EcuC_Timers_01015_IsTimerStarted</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/EcuC_Timers/TestSpec_Generated.h</sourcefile>
      <sourceline>364</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that EcuC_Timers_IsTimerStarted() called with correct set of inputs will return E_OK if timer has been started or E_NOT_OK if timer is not running.
Test Object: EcuC_Timers_IsTimerStarted().
Test Precondition: 
    -   Call EcuC_Timers_InitTimerHandler() to initialize timer handler.
    -   Call EcuC_Timers_StartTimer() to start timer.
  
Test Execution: 
    01: Sanity check - Confirm there is one timer currently running.
    02: Call EcuC_Timers_IsTimerStarted().
    03: VP(EcuC_Timers.dsn.Api.IsTimerStarted,1) Verify that the return value is E_OK since timer has been started.
    04: Call EcuC_Timers_StopTimer().
    05: Sanity check - Confirm there is no timer currently running.
    06: Call EcuC_Timers_IsTimerStarted().
    07: VP(EcuC_Timers.dsn.Api.IsTimerStarted,1) Verify that the return value is E_NOT_OK since timer is not running.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EcuC_Timers.dsn.Api.IsTimerStarted</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>24</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1807</internalId></specobject>
    <specobject>
      <id>EcuC_Timers_01016_IsTimerStarted_Ignore</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/EcuC_Timers/TestSpec_Generated.h</sourcefile>
      <sourceline>389</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that EcuC_Timers_IsTimerStarted() called with TimerHandlerPtr as NULL_PTR will ignore the call and will return E_NOT_OK.
Test Object: EcuC_Timers_IsTimerStarted().
Test Precondition: 
    -   Call EcuC_Timers_InitTimerHandler() to initialize timer handler.
    -   Call EcuC_Timers_StartTimer() to start timer.
  
Test Execution: 
    01: Sanity check - Confirm there is one timer currently running.
    02: Call EcuC_Timers_IsTimerStarted() with NULL TimerHandlerPtr.
    03: VP(EcuC_Timers.dsn.Api.IsTimerStarted.Ignore,1) Verify that the return value is E_NOT_OK since EcuC_Timers_IsTimerStarted() failed.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EcuC_Timers.dsn.Api.IsTimerStarted.Ignore</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>25</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1808</internalId></specobject>
    <specobject>
      <id>EcuC_Timers_01017_IsTimerStarted_Uninitialized</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/EcuC_Timers/TestSpec_Generated.h</sourcefile>
      <sourceline>410</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that EcuC_Timers_IsTimerStarted() called when the timer handler has not been initialized will ignore the call and will return E_NOT_OK.
Test Object: EcuC_Timers_IsTimerStarted().
Test Precondition: 
    -   Call EcuC_Timers_InitTimerHandler() to initialize timer handler.
    -   Call EcuC_Timers_StartTimer() to start timer.
  
Test Execution: 
    01: Sanity check - Confirm there is one timer currently running.
    02: Set timer handler as not initialized.
    03: Call EcuC_Timers_IsTimerStarted() when timer handler is not initialized.
    04: VP(EcuC_Timers.dsn.Api.IsTimerStarted.Uninitialized,1) Verify that the return value is E_NOT_OK since EcuC_Timers_IsTimerStarted() failed.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EcuC_Timers.dsn.Api.IsTimerStarted.Uninitialized</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>26</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1809</internalId></specobject>
    <specobject>
      <id>EcuC_Timers_01018_ProcessTimerTimeout_Ignore</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/EcuC_Timers/TestSpec_Generated.h</sourcefile>
      <sourceline>432</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that EcuC_Timers_ProcessTimerTimeout() called with TimerHandlerPtr as NULL_PTR will ignore the call and will not modify the timeout counter.
Test Object: EcuC_Timers_ProcessTimerTimeout() through function like macro ECUC_TIMERS_PROCESS().
Test Precondition: 
    -   Call EcuC_Timers_InitTimerHandler() to initialize timer handler.
    -   Call EcuC_Timers_StartTimer() to start timer.
  
Test Execution: 
    01: Sanity check - Confirm there is one timer currently running.
    02: Set the timer count value.
    03: Call EcuC_Timers_ProcessTimerTimeout() through the function like macro with NULL TimerHandlerPtr.
    04: VP(EcuC_Timers.dsn.Api.ProcessTimerTimeout.Ignore,1) Verify that the timeout counter has not been modified.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EcuC_Timers.dsn.Api.ProcessTimerTimeout.Ignore</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>28</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1810</internalId></specobject>
    <specobject>
      <id>EcuC_Timers_01019_ProcessTimerTimeout_Uninitialized</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/EcuC_Timers/TestSpec_Generated.h</sourcefile>
      <sourceline>454</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that EcuC_Timers_ProcessTimerTimeout() called when the timer handler has not been initialized will ignore the call and will not modify the timeout counter.
Test Object: EcuC_Timers_ProcessTimerTimeout() through function like macro ECUC_TIMERS_PROCESS().
Test Precondition: 
    -   Call EcuC_Timers_InitTimerHandler() to initialize timer handler.
    -   Call EcuC_Timers_StartTimer() to start timer.
  
Test Execution: 
    01: Sanity check - Confirm there is one timer currently running.
    02: Set the timer count value.
    03: Set timer handler as not initialized.
    04: Call EcuC_Timers_ProcessTimerTimeout() through the function like macro when timer handler is not initialized.
    05: VP(EcuC_Timers.dsn.Api.ProcessTimerTimeout.Uninitialized,1) Verify that the timeout counter has not been modified.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EcuC_Timers.dsn.Api.ProcessTimerTimeout.Uninitialized</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>29</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1811</internalId></specobject>
    <specobject>
      <id>EcuC_Timers_01020_InitTimerHandler_Failed</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/EcuC_Timers/TestSpec_Generated.h</sourcefile>
      <sourceline>477</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that EcuC_Timers_InitTimerHandler() called with incorrect timer handler, timers will not be initialized.
Test Object: EcuC_Timers_InitTimerHandler().
Test Precondition: 
  
Test Execution: 
    01: Call EcuC_Timers_InitTimerHandler to start initialization procedure.
    02: VP(EcuC_Timers.dsn.Api.InitTimerHandler,1) Verify that timer handler has not been initialized.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>EcuC_Timers.dsn.Api.InitTimerHandler</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>7</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1812</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>Mka_Cp_UnitTest01001_CpSM_Uninit2Secured</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>9</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies transition from Initial-&amp;gt;CP_UNINIT-&amp;gt;CP_UPDATE_SECY-&amp;gt;CP_WAIT_RX_SC-&amp;gt;CP_UPDATE_SECY. For transition CP_UPDATE_SECY-&amp;gt;CP_WAIT_RX_SC it is verified that this transition will not occur until parameter UpdateSecYCalledBack is set to TRUE.
Test Object: Cp state machine.
Test Precondition: 
  
Test Execution: 
    01: Module configuration initialized with Mka_Init(), Mka_Cp_Init is also called.
    02: VP(Mka.dsn.Cp.CpSM.Uninit,1)
        VP(Mka.dsn.Cp.Api.Init,1) Verify that after state CP_UNINIT is entered, no APIs are called.
    03: Call function Mka_Cp_MainFunction() to verify that CP will not transit to other state until Mka_Cp_SetCipherSuite is called.
    04: VP(Mka.dsn.Cp.CpSM.Uninit_2_UpdateSecY,1)
        VP(Mka.dsn.Cp.Api.MainFunction,1) Verify that CP state machine didn't transit from CP_UNINIT to CP_UPDATE_SECY. Verification is made by checking that function EthIf_MacSecUpdateSecY() wasn't called.
    05: Call function Mka_Cp_SetCipherSuite() to simulate call from Logon that selected PAE can be initialized. EthIf_MacSecUpdateSecY() shall be called.
    06: VP(Mka.dsn.Cp.CpSM.Uninit_2_UpdateSecY,1)
        VP(Mka.CP_SWS_Mka_00003,1)
        VP(Mka.CP_SWS_Mka_00004,1)
        VP(Mka.dsn.Cp.Api.SetCipherSuite,2) Verify that CP state machine transitioned from CP_UNINIT to CP_UPDATE_SECY. When CP state machine enters state CP_UPDATE_SECY, CP shall call EthIf to update SecY with function call EthIf_MacSecUpdateSecY(). Verify that bypassed VLANs and EtherTypes were also set.
    07: Call function Mka_Cp_MacSecUpdateSecYNotification() to simulate that MacSecUpdateSecY request has been finished. State machine shall transition to CP_WAIT_RX_SC.
    08: Call function Mka_Cp_MainFunction() to go through Mka main loop. Cp SM shall transition to CP_WAIT_RX_SC.
    09: VP(Mka.dsn.Cp.CpSM.UpdateSecY_2_WaitRxSc,1) Verify that CP state machine transitioned from CP_UPDATE_SECY to CP_WAIT_RX_SC. Since PeerSci is not available at the moment, StateMachine will stay in this state.
    10: Call function Mka_Cp_SetCipherSuite() to change Cipher suite and CP state machine should transit from CP_WAIT_RX_SC to CP_UPDATE_SECY.
    11: VP(Mka.dsn.Cp.CpSM.WaitRxSc_2_UpdateSecY,1) Verify that CP state machine transitioned from CP_WAIT_RX_SC to CP_UPDATE_SECY. When CP state machine enters state CP_UPDATE_SECY, CP shall call EthIf to update SecY with function call EthIf_MacSecUpdateSecY().
    12: Call function Mka_Cp_MacSecUpdateSecYNotification() to simulate that MacSecUpdateSecY request has been finished.
    13: Call function Mka_Cp_MainFunction() to go through Mka main loop. Cp SM shall transition to CP_WAIT_RX_SC.
    14: VP(Mka.dsn.Cp.CpSM.UpdateSecY_2_WaitRxSc,1)
        VP(Mka.dsn.Cp.Api.MacSecUpdateSecYNotification,1) Verify that CP state machine transitioned from CP_UPDATE_SECY to CP_WAIT_RX_SC. Since PeerSci is not available at the moment, StateMachine will stay in this state.
    15: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Uninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1387</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.Api.Init</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1010</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Uninit_2_UpdateSecY</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1386</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.Api.MainFunction</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1011</internalId></provcov>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>298</internalId></provcov>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00004</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>299</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.Api.SetCipherSuite</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1019</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.UpdateSecY_2_WaitRxSc</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1384</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.WaitRxSc_2_UpdateSecY</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1383</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.Api.MacSecUpdateSecYNotification</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1023</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1813</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01002_CpSM_Secured2WaitAddTxSa</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>82</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies transition from CP_SECURED-&amp;gt;CP_WAIT_ADD_RX_SA-&amp;gt;CP_WAIT_ADD_TX_SA.
Test Object: Cp state machine.
Test Precondition: 
    -   Mka_Init() initialized. CP unit initialized.
  
Test Execution: 
    01: Call function Mka_Cp_NewSak() to indicate that new SAK is ready and that CP isn't key server. No state transition shall be made since Cp SM is not in one of the conditional states.
    02: VP(Mka.dsn.Cp.CpSM.NewSak,1) Verify that CP state machine made no transitions.
    03: Call function Mka_Cp_SetCipherSuite() to simulate call from Logon that selected PAE can be initialized.
    04: Call function Mka_Cp_MacSecUpdateSecYNotification() to simulate that MacSecUpdateSecY request has been finished.
    05: Call function Mka_Cp_MainFunction() to go through Mka main loop. Cp SM shall transition to CP_WAIT_RX_SC.
    06: Call Mka_Cp_InitRxSc to give PeerSci to Cp SM and thus enable the Cp SM to transition to CP_INIT_RX_SC.
    07: VP(Mka.dsn.Cp.CpSM.WaitRxSc_2_InitRxSc,1)
        VP(Mka.dsn.Cp.CpSM.InitRxSc_2_Secured,1) Verify that CP state machine transitioned from CP_WAIT_RX_SC to CP_INIT_RX_SC. When CP state machine enters state CP_INIT_RX_SC, CP shall call EthIf to initialize Rx SC with function call EthIf_MacSecInitRxSc(). Because EthIf_MacSecInitRxSc returned E_OK, the Cp SM instantly makes a transition to state CP_SECURED.
    08: Call function Mka_Cp_NewSak() to indicate that new SAK is ready and that CP isn't key server.
    09: VP(Mka.dsn.Cp.CpSM.Secured_2_WaitAddRxSa,1)
        VP(Mka.dsn.Cp.Api.NewSak,1) Verify that CP state machine transitioned from CP_SECURED to CP_WAIT_ADD_RX_SA. When CP state machine enters state CP_WAIT_ADD_RX_SA, CP shall call EthIf_MacSecAddRxSa() with belonging EthIfCtrlIdx, AN, LowestPn, SSCI, SAK key and that is active.
    10: Call function Mka_Cp_MacSecAddRxSaNotification() to indicate that MacSecAddRxSa request has been processed.
    11: Call Mka_Cp_MainFunction() to run state machine and make necessary transitions.
    12: VP(Mka.dsn.Cp.CpSM.WaitAddRxSa_2_WaitAddTxSa,1)
        VP(Mka.dsn.Cp.Api.MacSecAddRxSaNotification,1) Verify that CP state machine transitioned from CP_WAIT_ADD_RX_SA to CP_WAIT_ADD_TX_SA. When CP state machine enters state CP_WAIT_ADD_TX_SA, CP shall call EthIf_MacSecAddTxSa() with belonging EthIfCtrlIdx, AN, Next Pn, SSCI, SAK key and is it active.
    13: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.NewSak</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1501</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.WaitRxSc_2_InitRxSc</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1382</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.InitRxSc_2_Secured</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1377</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Secured_2_WaitAddRxSa</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1375</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.Api.NewSak</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1012</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.WaitAddRxSa_2_WaitAddTxSa</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1390</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.Api.MacSecAddRxSaNotification</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1025</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1814</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01003_CpSM_Receiving2Transmitting</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>139</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies transition from CP_RECEIVING-&amp;gt;CP_TRANSMITTING. This test verifies the transition from CP_RECEIVING to CP_TRANSMITTING when conditions were already fulfilled for transition from CP_READY to CP_TRANSMITTING. It also verifies that transition happen as fast as possible, including scenario where EthIf_MacSecAddRxSa notification is received immediately after call EthIf_MacSecAddRxSa.
Test Object: Cp state machine.
Test Precondition: 
    -   Set the callout so that the notification is immediately called.
    -   Mka_Init() initialized. CP unit initialized.
  
Test Execution: 
    01: Create MKPDU from a peer Participant_1 that proves liveliness to Participant_0.
    02: Call function Mka_Cp_SetCipherSuite() to simulate call from Logon that selected PAE can be initialized.
    03: Call function Mka_Cp_MacSecUpdateSecYNotification() to simulate that MacSecUpdateSecY request has been finished.
    04: Call function Mka_Cp_MainFunction() to go through Mka main loop. Cp SM shall transition to CP_WAIT_RX_SC.
    05: Call Mka_Cp_InitRxSc to give PeerSci to Cp SM and thus enable the Cp SM to transition to CP_INIT_RX_SC and then to CP_SECURED.
    06: Sanity check - Sanity check.
    07: Simulate reception of SakUse from alive peer with SakUse parameter set before NewSak has been installed.
    08: VP(Mka.dsn.Cp.PacketNumber.UpdateLPn,1) Verify that Cp unit did not update the RxSa because it doesn't have an installed key.
    09: Call Mka_Cp_MacSecAddTxSaNotification and Mka_Cp_MacSecAddRxSaNotification before CpSm transitioned to states CP_WAIT_ADD_TX_SA and CP_WAIT_ADD_RX_SA. Cp unit shall ignore the call.
    10: VP(Mka.dsn.Cp.Api.MacSecAddTxSaNotification,1)
        VP(Mka.dsn.Cp.Api.MacSecAddRxSaNotification,1) Verify that Cp unit ignored the call.
    11: Call function Mka_Cp_NewSak() to indicate that new SAK is ready and that CP isn't key server.
    12: VP(Mka.dsn.Cp.CpSM.Secured_2_WaitAddRxSa,1)
        VP(Mka.dsn.Cp.CpSM.WaitAddRxSa_2_WaitAddTxSa,1)
        VP(Mka.InterAct.Cp.NewSak,1) Verify that, because EthIf_MacSecAddRxSaNotification was called extremely fast, the State Machine transitioned further to CP_WAIT_ADD_TX_SA.
    13: Call function Mka_Cp_MacSecAddTxSaNotification() to indicate that EthIf_MacSecAddTxSa request has been processed. With this function call, CP state machine transitions from CP_WAIT_ADD_TX_SA to CP_RECEIVING and ElectedSelf is FALSE and state machine will transit from CP_RECEIVING to CP_TRANSMITTING.
    14: Run the main function.
    15: Simulate reception of SakUse from alive peer with SakUse parameter set.
    16: VP(Mka.dsn.Cp.CpSM.WaitAddTxSa_2_Receiving,1)
        VP(Mka.dsn.Cp.CpSM.Receiving_2_Transmitting2,1)
        VP(Mka.dsn.Cp.Api.MacSecAddTxSaNotification,1)
        VP(Mka.InterAct.Cp.NewSak,1) Verify that CP state machine transitioned from CP_RECEIVING to CP_TRANSMITTING, this transition also confirms that CP state machine transit from CP_WAIT_ADD_TX_SA to CP_RECEIVING after function Mka_Cp_MacSecAddTxSaNotification() call. When CP state machine enters state CP_TRANSMITTING, CP shall set up ControlledPortEnable to True, start transmitting with a new key, stop transmitting with an old key, indicate that MacSec is now active and operational on the specified port and stop timer for transmit.
    17: VP(Mka.dsn.Cp.Api.ProcessSakUse,1)
        VP(Mka.dsn.Cp.Api.CheckAllReceivingServerTransmittingPlainText,1)
        VP(Mka.dsn.Cp.PacketNumber.UpdateLPn,1)
        VP(Mka.InterAct.Cp.MacSecOperational,1) Verify that participant called EthIf_MacSecUpdateRxSa() to update LPn after it received SAK Use parameter set. Verify that MacSecOperational was set to TRUE after the analysis of SakUse parameter set that had the corresponding key with both Tx and Rx set.
    18: VP(Mka.EB.RunTimeEvent.BitFieldDefinition,1)
        VP(Mka.EB.RunTimeEvent.TriggeredEventPae,1) Verify that, after MacSec Operational was set during transition to CP_TRANSMITTING, a bit for that event has been set for the selected Pae.
    19: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.PacketNumber.UpdateLPn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1502</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.Api.MacSecAddTxSaNotification</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1024</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.Api.MacSecAddRxSaNotification</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1025</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Secured_2_WaitAddRxSa</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1375</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.WaitAddRxSa_2_WaitAddTxSa</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1390</internalId></provcov>
        <provcov>
          <linksto>Mka.InterAct.Cp.NewSak</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1104</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.WaitAddTxSa_2_Receiving</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1389</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Receiving_2_Transmitting2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1380</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.Api.ProcessSakUse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1013</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.Api.CheckAllReceivingServerTransmittingPlainText</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1014</internalId></provcov>
        <provcov>
          <linksto>Mka.InterAct.Cp.MacSecOperational</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1106</internalId></provcov>
        <provcov>
          <linksto>Mka.EB.RunTimeEvent.BitFieldDefinition</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1478</internalId></provcov>
        <provcov>
          <linksto>Mka.EB.RunTimeEvent.TriggeredEventPae</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1480</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1815</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01004_CpSM_Ready2Retire</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>234</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies transition from CP_TRANSMITTING-&amp;gt;CP_RETIRE. This test only tests first loop, where ControlledPortEnable is still FALSE, O_RX = 0 and ElectedSelf is FALSE.
Test Object: Cp state machine.
Test Precondition: 
    -   Mka_Init() initialized. CP unit initialized.
  
Test Execution: 
    01: Call function Mka_Cp_SetCipherSuite() to simulate call from Logon that selected PAE can be initialized.
    02: Create MKPDU from a peer Participant_1 that proves liveliness to Participant_0.
    03: Call function Mka_Cp_MacSecUpdateSecYNotification() to simulate that MacSecUpdateSecY request has been finished.
    04: Call function Mka_Cp_MainFunction() to go through Mka main loop. Cp SM shall transition to CP_WAIT_RX_SC.
    05: Call Mka_Cp_InitRxSc to give PeerSci to Cp SM and thus enable the Cp SM to transition to CP_INIT_RX_SC and then to CP_SECURED.
    06: Sanity check - Sanity check.
    07: Call function Mka_Cp_NewSak() to indicate that new SAK is ready and that CP isn't key server.
    08: VP(Mka.EB.MkaSecYCallout,1) Verify that Cp unit called the MkaSecYCallout function if it was set in the config.
    09: Call function Mka_Cp_MacSecAddRxSaNotification() to indicate that MacSecAddRxSa request has been processed.
    10: Call Mka_Cp_MainFunction() to run state machine and make necessary transitions.
    11: VP(Mka.EB.MkaSecYCallout,1) Verify that Cp unit called the MkaSecYCallout function if it was set in the config.
    12: Call function Mka_Cp_MacSecAddTxSaNotification() to indicate that EthIf_MacSecAddTxSa request has been processed. With this function call, CP state machine will transition from CP_WAIT_ADD_TX_SA to CP_RECEIVING and ElectedSelf is FALSE and state machine will transit from CP_RECEIVING to CP_TRANSMITTING.
    13: Run the main function.
    14: Simulate reception of SakUse from alive peer with SakUse parameter set.
    15: VP(Mka.InterAct.Cp.NewSak,1) Verify that Cp unit called the following sequence after the AddTxSa Notification has been received.
    16: Call function Mka_Cp_MainFunction() to transit from CP_TRANSMITTING to CP_RETIRE. Transition happened because O_RX is still 0 and timeout of RetireWhen is not needed.
    17: VP(Mka.dsn.Cp.CpSM.Transmitting_2_Retire,1) Verify that CP state machine transitioned from CP_TRANSMITTING to CP_RETIRE. When CP state machine enters state CP_RETIRE, CP shall delete old SAs, but this is first time when we don't have old SAs so there is no call of functions.
    18: Set EthIf_MacSecGetTxSaNextPn to return E_NOT_OK.
    19: Call Mka_Cp_FillSakUse. No Sak shall be generated.
    20: Call function Mka_Cp_NewSak() to indicate that new SAK is ready and that CP isn't key server.
    21: VP(Mka.dsn.Cp.CpSM.Transmitting_2_Retire,1)
        VP(Mka.dsn.Cp.CpSM.Retire_2_WaitAddRxSa,1) Verify that CP state machine transitioned from CP_RETIRE to CP_WAIT_ADD_RX_SA, this transition confirms that in previous call of Mka_Cp_MainFunction() we transitioned from CP_TRANSMITTING to CP_RETIRE. When CP state machine enters state CP_WAIT_ADD_RX_SA, CP shall call EthIf_MacSecAddRxSa() with belonging EthIfCtrlIdx, AN, LowestPn, SSCI, SAK key and is it active.
    22: VP(Mka.EB.MkaSecYCallout,1) Verify that Cp unit called the MkaSecYCallout function if it was set in the config.
    23: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.MkaSecYCallout</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1473</internalId></provcov>
        <provcov>
          <linksto>Mka.InterAct.Cp.NewSak</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1104</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Transmitting_2_Retire</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1378</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Retire_2_WaitAddRxSa</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1397</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1816</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01005_CpSM_Receiving2Retire</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>287</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies transition from CP_RECEIVING-&amp;gt;CP_TRANSMITTING-&amp;gt;CP_RETIRE. This test only tests first loop, where ControlledPortEnable is still FALSE and O_RX = 0.
Test Object: Cp state machine.
Test Precondition: 
    -   Mka_Init() initialized. CP unit initialized.
  
Test Execution: 
    01: Call function Mka_Cp_SetCipherSuite() to simulate call from Logon that selected PAE can be initialized.
    02: Call function Mka_Cp_MacSecUpdateSecYNotification() to simulate that MacSecUpdateSecY request has been finished.
    03: Call function Mka_Cp_MainFunction() to go through Mka main loop. Cp SM shall transition to CP_WAIT_RX_SC.
    04: Call Mka_Cp_InitRxSc to give PeerSci to Cp SM and thus enable the Cp SM to transition to CP_INIT_RX_SC and then to CP_SECURED.
    05: Sanity check - Sanity check.
    06: Call function Mka_Cp_NewSak() to indicate that new SAK is ready and that CP is key server.
    07: Call function Mka_Cp_MacSecAddRxSaNotification() to indicate that MacSecAddRxSa request has been processed.
    08: Call Mka_Cp_MainFunction() to run state machine and make necessary transitions.
    09: Call function Mka_Cp_MacSecAddTxSaNotification() to indicate that EthIf_MacSecAddTxSa request has been processed. With this function call, CP state machine transitioned from CP_WAIT_ADD_TX_SA to CP_RECEIVING and ElectedSelf is TRUE and state machine will transit from CP_RECEIVING to CP_TRANSMITTING.
    10: Run the main function.
    11: Receive MKPDU with SakUse parameter set that has newest Sak installed and active.
    12: VP(Mka.dsn.Cp.CpSM.Receiving_2_Transmitting,1) Verify that CP state machine transitioned from CP_RECEIVING to CP_TRANSMITTING. When CP state machine enters state CP_TRANSMITTING, CP shall set up ControlledPortEnable to True, start transmitting with a new key, stop transmitting with an old key, indicate that MacSec is now active and operational on the specified port and stop timer for transmit.
    13: Call function Mka_Cp_MainFunction() to transit from CP_TRANSMITTING to CP_RETIRE. Transition is performed, since O_RX is still 0 and timeout of RetireWhen is not needed.
    14: Call function Mka_Cp_NewSak() to indicate that new SAK is ready and that CP isn't key server.
    15: VP(Mka.dsn.Cp.CpSM.Transmitting_2_Retire,1)
        VP(Mka.dsn.Cp.CpSM.Retire_2_WaitAddRxSa,1) Verify that CP state machine transitioned from CP_RETIRE to CP_WAIT_ADD_RX_SA, this transition confirms that in previous call of Mka_Cp_MainFunction() we transitioned from CP_TRANSMITTING to CP_RETIRE. When CP state machine enters state CP_WAIT_ADD_RX_SA, CP shall call EthIf_MacSecAddRxSa() with belonging EthIfCtrlIdx, AN, LowestPn, SSCI, SAK key and is it active.
    16: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Receiving_2_Transmitting</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1379</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Transmitting_2_Retire</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1378</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Retire_2_WaitAddRxSa</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1397</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1817</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01006_CpSM_Ready2Retire_2ndLoop</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>329</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies transition from CP_READY-&amp;gt;CP_TRANSMITTING-&amp;gt;CP_RETIRE. This test is performed within the second loop, where ControlledPortEnable is True and O_RX = 1.
Test Object: Cp state machine.
Test Precondition: 
    -   Mka_Init() initialized. CP unit initialized.
  
Test Execution: 
    01: Call function Mka_Cp_SetCipherSuite() to simulate call from Logon that selected PAE can be initialized. EthIf_MacSecUpdateSecY() shall be called.
    02: Call function EbTest_CpSM_GoThroghFirstLoop() to go through CP state machine from CP_UNINIT to CP_RETIRE and back to CP_WAIT_ADD_RX_SA.
    03: Call function Mka_Cp_MacSecAddRxSaNotification() to indicate that MacSecAddRxSa request has been processed.
    04: Call Mka_Cp_MainFunction() to run state machine and make necessary transitions.
    05: Run the main function.
    06: Call function Mka_Cp_MacSecAddTxSaNotification() to indicate that EthIf_MacSecAddTxSa request has been processed. With this function call, CP state machine will transition from CP_WAIT_ADD_TX_SA to CP_RECEIVING.
    07: Call function Mka_Cp_MainFunction() to transit from CP_RECEIVING to CP_READY.
    08: VP(Mka.dsn.Cp.CpSM.Receiving_2_Ready,1) Verify that CP state machine transitioned from CP_RECEIVING to CP_READY. When CP state machine enters state CP_READY, CP shall call EcuC_Timers_StopTimer() to stop timer and Mka_KaY_NewInfo().
    09: Call function Mka_Cp_MainFunction() to transit from CP_READY to CP_TRANSMITTING.
    10: VP(Mka.dsn.Cp.CpSM.Ready_2_Transmitting,2) Verify that CP state machine hasn't transitioned from CP_READY to CP_TRANSMITTING. Transition isn't possible because ServerTransmitting == FALSE.
    11: Call Cp APIs to parse SakUse param.set with SakUse that has no key flags set.
    12: VP(Mka.dsn.Cp.Api.ProcessSakUse,1)
        VP(Mka.InterAct.Cp.MacSecOperational,1) Verify that MacSecOperational status changed after receiving SakUse with parameters L_Tx, L_Rx, O_Tx and O_Rx not set.
    13: Receive MKPDU with SakUse parameter set that has newest Sak installed and active.
    14: VP(Mka.dsn.Cp.CpSM.Ready_2_Transmitting,2)
        VP(Mka.InterAct.Cp.NewSak.Rekeying,1) Verify that CP state machine transitioned from CP_READY to CP_TRANSMITTING since ServerTransmitting is TRUE. When CP state machine enters state CP_TRANSMITTING, CP shall set up ControlledPortEnable to True, start transmitting with a new key, stop transmitting with an old key, indicate that MacSec is now active and operational on the specified port, start timer for retire and stop timer for transmit.
    15: Call function Mka_Cp_TimerCallback_RetireWhen() to transit from CP_TRANSMITTING to CP_RETIRE. This function call indicates that CP timer RetireWhen has expired.
    16: VP(Mka.dsn.Cp.CpSM.Transmitting_2_Retire,1)
        VP(Mka.InterAct.Cp.NewSak.Rekeying,1) Verify that CP state machine transitioned from CP_TRANSMITTING to CP_RETIRE. When CP state machine enters state CP_RETIRE, CP shall delete old SAs.
    17: VP(Mka.dsn.Cp.DisableSAsBeforeDelete,1) Verify that RX SA was disabled before deleting.
    18: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Receiving_2_Ready</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1391</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Ready_2_Transmitting</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1381</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.Api.ProcessSakUse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1013</internalId></provcov>
        <provcov>
          <linksto>Mka.InterAct.Cp.MacSecOperational</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1106</internalId></provcov>
        <provcov>
          <linksto>Mka.InterAct.Cp.NewSak.Rekeying</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1105</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Transmitting_2_Retire</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1378</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.DisableSAsBeforeDelete</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1504</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1818</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01007_CpSM_Receiving2Retire_2ndLoop</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>391</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies transition from CP_RECEIVING-&amp;gt;CP_TRANSMITTING-&amp;gt;CP_RETIRE. This test is performed within second loop, where ControlledPortEnable is True and O_RX = 1.
Test Object: Cp state machine.
Test Precondition: 
    -   Mka_Init() initialized. CP unit initialized.
  
Test Execution: 
    01: Call function Mka_Cp_SetCipherSuite() to simulate call from Logon that selected PAE can be initialized. EthIf_MacSecUpdateSecY() shall be called.
    02: Call function EbTest_CpSM_GoThroghFirstLoop() to go through CP state machine from CP_UNINIT to CP_RETIRE and back to CP_WAIT_ADD_RX_SA.
    03: Call function Mka_Cp_MacSecAddRxSaNotification() to indicate that MacSecAddRxSa request has been processed.
    04: Call Mka_Cp_MainFunction() to run state machine and make necessary transitions.
    05: Call function Mka_Cp_MacSecAddTxSaNotification() to indicate that EthIf_MacSecAddTxSa request has been processed. With this function call, CP state machine will transition from CP_WAIT_ADD_TX_SA to CP_RECEIVING during next MainFunction tick.
    06: Call function Mka_Cp_MainFunction() to try to transition from CP_RECEIVING to CP_TRANSMITTING.
    07: VP(Mka.dsn.Cp.CpSM.Receiving_2_Transmitting,1) Verify that CP state machine hasn't transitioned from CP_RECEIVING to CP_TRANSMITTING. Transition isn't possible, because ControlledPortEnable = TRUE and AllReceiving = FALSE.
    08: Call Mka_Cp_TimerCallback_RetireWhen before the CpSm entered the state CP_TRANSMITTING. Call shall be ignored.
    09: VP(Mka.dsn.Cp.Api.RetireWhen,1) Verify that CP ignored the call.
    10: Receive MKPDU with SakUse parameter set that has newest Sak installed and active.
    11: Call function Mka_Cp_MainFunction() to transit from CP_RECEIVING to CP_TRANSMITTING.
    12: VP(Mka.dsn.Cp.CpSM.Receiving_2_Transmitting,1) Verify that CP state machine transitioned from CP_RECEIVING to CP_TRANSMITTING when ControlledPortEnable is TRUE and AllReceiving is also TRUE. When CP state machine enters state CP_TRANSMITTING, CP shall set up ControlledPortEnable to True, start transmitting with a new key, stop transmitting with an old key, indicate that MacSec is now active and operational on the specified port, start timer for retire and stop timer for transmit.
    13: Call Mka_Cp_MainFunction. The Cp state machine shall not make any transitions.
    14: Sanity check - Check that no API was called, meaning that no state machine transition were made.
    15: Call function Mka_Cp_TimerCallback_RetireWhen() to transit from CP_TRANSMITTING to CP_RETIRE. This function call indicates that CP timer RetireWhen has expired.
    16: VP(Mka.dsn.Cp.CpSM.Transmitting_2_Retire,1)
        VP(Mka.dsn.Cp.Api.RetireWhen,1) Verify that CP state machine transitioned from CP_TRANSMITTING to CP_RETIRE. When CP state machine enters state CP_RETIRE, CP shall delete old SAs.
    17: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Receiving_2_Transmitting</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1379</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.Api.RetireWhen</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1021</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Transmitting_2_Retire</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1378</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1819</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01008_CpSM_Ready2WaitAddRxSa</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>434</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies transition from CP_READY-&amp;gt;CP_WAIT_ADD_RX_SA.
Test Object: Cp state machine.
Test Precondition: 
    -   Mka_Init() initialized. CP unit initialized. Link state setup to TRUE.
  
Test Execution: 
    01: Call function Mka_Cp_SetCipherSuite() to simulate call from Logon that selected PAE can be initialized. EthIf_MacSecUpdateSecY() shall be called.
    02: Call function EbTest_CpSM_GoThroghFirstLoop() to go through CP state machine from CP_UNINIT to CP_RETIRE and back to CP_WAIT_ADD_RX_SA.
    03: Call function Mka_Cp_MacSecAddRxSaNotification() to indicate that MacSecAddRxSa request has been processed.
    04: Call Mka_Cp_MainFunction() to run state machine and make necessary transitions.
    05: Call function Mka_Cp_MacSecAddTxSaNotification() to indicate that EthIf_MacSecAddTxSa request has been processed. With this function call, CP state machine will transition from CP_WAIT_ADD_TX_SA to CP_RECEIVING and ElectedSelf is FALSE and state machine will transit from CP_RECEIVING to CP_READY.
    06: Run the main function.
    07: Call function Mka_Cp_NewSak() to indicate that new SAK is ready.
    08: VP(Mka.dsn.Cp.CpSM.Ready_2_WaitAddRxSa,1) Verify that during the transition from CP_READY to CP_WAIT_ADD_RX_SA Latest key Tx a Rx SA have been deleted.
    09: VP(Mka.dsn.Cp.DisableSAsBeforeDelete,1) Verify that LATEST RX SA was disabled before deleting. LATEST TX SA was not enabled, thus no need for disabling.
    10: VP(Mka.dsn.Cp.CpSM.Ready_2_WaitAddRxSa,1) Verify that CP state machine transitioned from CP_READY to CP_WAIT_ADD_RX_SA. When CP state machine enters state CP_WAIT_ADD_RX_SA, CP shall call EthIf_MacSecAddRxSa() with belonging EthIfCtrlIdx, AN, LowestPn, SSCI, SAK key and is it active.
    11: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Ready_2_WaitAddRxSa</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1396</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.DisableSAsBeforeDelete</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1504</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1820</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01009_CpSM_Receiving2Transmitting</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>466</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies transition from CP_RECEIVING-&amp;gt;CP_TRANSMITTING. This test verifies the transition from CP_RECEIVING to CP_TRANSMITTING when the timer TransmitWhen expires.
Test Object: Cp state machine.
Test Precondition: 
    -   Mka_Init() initialized. CP unit initialized.
  
Test Execution: 
    01: Call function Mka_Cp_SetCipherSuite() to simulate call from Logon that selected PAE can be initialized. EthIf_MacSecUpdateSecY() shall be called.
    02: Call function EbTest_CpSM_GoThroghFirstLoop() to go through CP state machine from from CP_UNINIT to CP_RETIRE and back to CP_WAIT_ADD_RX_SA.
    03: Call function Mka_Cp_MacSecAddRxSaNotification() to indicate that MacSecAddRxSa request has been processed.
    04: Call Mka_Cp_MainFunction() to run state machine and make necessary transitions.
    05: Call Mka_Cp_TimerCallback_TransmitWhen while CpSm is not in CP_RECEIVING state. The call shall be ignored.
    06: VP(Mka.dsn.Cp.Api.TransmitWhen,1) Verify that the call has been ignored.
    07: Call function Mka_Cp_MacSecAddTxSaNotification() to indicate that EthIf_MacSecAddTxSa request has been processed. With this function call, CP state machine will transition from CP_WAIT_ADD_TX_SA to CP_RECEIVING.
    08: Call Mka_Cp_MainFunction() to run state machine and make necessary transitions.
    09: Call function Mka_Cp_TimerCallback_TransmitWhen() to transit from CP_RECEIVING to CP_TRANSMITTING. This function call indicates that CP timer TransmitWhen has expired.
    10: VP(Mka.dsn.Cp.CpSM.Receiving_2_Transmitting,1)
        VP(Mka.dsn.Cp.Api.TransmitWhen,1) Verify that CP state machine transitioned from CP_RECEIVING to CP_TRANSMITTING when ControlledPortEnable is TRUE and AllReceiving is also TRUE. When CP state machine enters state CP_TRANSMITTING, CP shall set up ControlledPortEnable to True, start transmitting with a new key, stop transmitting with an old key, indicate that MacSec is now active and operational on the specified port, start timer for retire and stop timer for transmit.
    11: Call function Mka_Cp_TimerCallback_RetireWhen() to transit from CP_TRANSMITTING to CP_RETIRE. This function call indicates that CP timer RetireWhen has expired.
    12: VP(Mka.dsn.Cp.CpSM.Transmitting_2_Retire,1) Verify that CP state machine transitioned from CP_TRANSMITTING to CP_RETIRE. When CP state machine enters state CP_RETIRE, CP shall delete old SAs.
    13: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.Api.TransmitWhen</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1020</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Receiving_2_Transmitting</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1379</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Transmitting_2_Retire</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1378</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1821</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01010_CpSM_Receiving2WaitAddRxSa</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>505</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies transition from CP_RECEIVING-&amp;gt;CP_WAIT_ADD_RX_SA.
Test Object: Cp state machine.
Test Precondition: 
    -   Mka_Init() initialized. CP unit initialized.
  
Test Execution: 
    01: Call function Mka_Cp_SetCipherSuite() to simulate call from Logon that selected PAE can be initialized. EthIf_MacSecUpdateSecY() shall be called.
    02: Call function EbTest_CpSM_GoThroghFirstLoop() to go through CP state machine from CP_UNINIT to CP_RETIRE and back to CP_WAIT_ADD_RX_SA.
    03: Call function Mka_Cp_MacSecAddRxSaNotification() to indicate that MacSecAddRxSa request has been processed.
    04: Call Mka_Cp_MainFunction() to run state machine and make necessary transitions.
    05: Call function Mka_Cp_MacSecAddTxSaNotification() to indicate that EthIf_MacSecAddTxSa request has been processed. With this function call, CP state machine will transition from CP_WAIT_ADD_TX_SA to CP_RECEIVING.
    06: Call function Mka_Cp_MainFunction() to transit from CP_UNINIT to CP_WAIT_RX_SC.
    07: Call function Mka_Cp_NewSak() to indicate that new SAK is ready and that CP isn't key server.
    08: VP(Mka.dsn.Cp.CpSM.Receiving_2_WaitAddRxSa,1) Verify that CP state machine transitioned from CP_RECEIVING to CP_WAIT_ADD_RX_SA. Verify that during the transition from CP_RECEIVING to CP_WAIT_ADD_RX_SA, Latest (L_An) Tx and Rx SA have been deleted, TransmitWhen timer stopped. When CP enters state CP_WAIT_ADD_RX_SA, it will call EthIf to add new Rx SA.
    09: VP(Mka.dsn.Cp.DisableSAsBeforeDelete,1) Verify that LATEST RX SA was disabled before deleting. LATEST TX SA was not enabled, thus no need for disabling.
    10: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Receiving_2_WaitAddRxSa</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1392</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.DisableSAsBeforeDelete</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1504</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1822</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01011_CpSM_Uninit2Unsecured</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>536</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies transition from CP_UNINIT-&amp;gt;CP_UNSECURED.
Test Object: Cp state machine.
Test Precondition: 
    -   Mka_Init() initialized. CP unit initialized.
  
Test Execution: 
    01: Call function Mka_Cp_DisableMacSec() to setup parameter Connect to FALSE.
    02: Call function Mka_Cp_MacSecUpdateSecYNotification() to simulate that MacSecUpdateSecY request has been finished.
    03: Call function Mka_Cp_MainFunction() to transit from CP_UNINIT to CP_WAIT_RX_SC.
    04: VP(Mka.dsn.Cp.Api.DisableMacSec,1)
        VP(Mka.dsn.Cp.CpSM.Unsecured.Testing,1)
        VP(Mka.dsn.Cp.MacSecOperational.Unsecured,1)
        VP(Mka.EB.MkaSecYCallout,1) Verify that Mka_Cp_DisableMacSec() resulted in a call to EthIf_MacSecUpdateSecY() to disable MACsec. Verify that CP state machine transitioned from CP_UNINIT to CP_UNSECURED. When CP state machine enters state CP_UNSECURED from CP_UNINIT, CP shall call EthIf_MacSecUpdateSecY() to with parameters to disable MACsec, set ControlledPortEnabled to TRUE and call EthIf_MacSecOperational(TRUE). Verify that Cp unit called the MkaSecYCallout function if it was set in the config.
    05: Call function Mka_Cp_MainFunction() again. No transitions shall occur.
    06: Sanity check - Check that no APIs have been called.
    07: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.Api.DisableMacSec</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1017</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Unsecured.Testing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1481</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.MacSecOperational.Unsecured</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1487</internalId></provcov>
        <provcov>
          <linksto>Mka.EB.MkaSecYCallout</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1473</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1823</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01012_CpSM_WaitRxSc2Unsecured</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>575</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies transition from CP_WAIT_RX_SC-&amp;gt;CP_UNSECURED.
Test Object: Cp state machine.
Test Precondition: 
    -   Mka_Init() initialized. CP unit initialized.
  
Test Execution: 
    01: Call function Mka_Cp_SetCipherSuite() to simulate call from Logon that selected PAE can be initialized.
    02: Call function Mka_Cp_MacSecUpdateSecYNotification() to simulate that MacSecUpdateSecY request has been finished.
    03: Call function Mka_Cp_MainFunction() to go through Mka main loop. Cp SM shall transition to CP_WAIT_RX_SC.
    04: Call function Mka_Cp_DisableMacSec() to setup parameter Connect to FALSE.
    05: Call function Mka_Cp_MacSecUpdateSecYNotification() to simulate that MacSecUpdateSecY request has been finished.
    06: Call function Mka_Cp_MainFunction() to process notification.
    07: VP(Mka.dsn.Cp.CpSM.Unsecured.Testing,1) Verify that CP state machine transitioned from CP_WAIT_RX_SC to CP_UNSECURED. When CP state machine enters state CP_UNSECURED from CP_WAIT_RX_SC, CP shall call EthIf_MacSecUpdateSecY() to disable MACsc and call EthIf_MacSecOperational(TRUE).
    08: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Unsecured.Testing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1481</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1824</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01013_CpSM_WaitAddRxSa2Unsecured</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>600</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies transition from CP_WAIT_ADD_RX_SA-&amp;gt;CP_UNSECURED.
Test Object: Cp state machine.
Test Precondition: 
    -   Mka_Init() initialized. CP unit initialized.
  
Test Execution: 
    01: Call function Mka_Cp_SetCipherSuite() to simulate call from Logon that selected PAE can be initialized.
    02: Call function Mka_Cp_MacSecUpdateSecYNotification() to simulate that MacSecUpdateSecY request has been finished.
    03: Call function Mka_Cp_MainFunction() to go through Mka main loop. Cp SM shall transition to CP_WAIT_RX_SC.
    04: Call Mka_Cp_InitRxSc to give PeerSci to Cp SM and thus enable the Cp SM to transition to CP_INIT_RX_SC and then to CP_SECURED.
    05: Sanity check - Sanity check.
    06: Call function Mka_Cp_NewSak() to indicate that new SAK is ready and that CP isn't key server.
    07: Call function Mka_Cp_DisableMacSec() to setup parameter Connect to FALSE.
    08: VP(Mka.dsn.Cp.CpSM.Unsecured.Testing,1) Verify that CP state machine transitioned from CP_WAIT_ADD_RX_SA to CP_UNSECURED. When CP state machine enters state CP_UNSECURED, CP shall delete all active SAs, set ControlledPortEnabled to TRUE, and call EthIf_MacSecUpdateSecY().
    09: VP(Mka.dsn.Cp.DisableSAsBeforeDelete,1) Verify that LATEST RX SA was disabled before deleting. LATEST TX SA was not enabled, thus no need for disabling.
    10: Call function Mka_Cp_MacSecUpdateSecYNotification() to simulate that MacSecUpdateSecY request has been finished.
    11: Call function Mka_Cp_MainFunction() to process notification.
    12: VP(Mka.dsn.Cp.MacSecOperational.Unsecured,1) Verify that EthIf_MacSecOperational(TRUE) is called to indicate to upper layers that link is available.
    13: VP(Mka.EB.RunTimeEvent.BitFieldDefinition,1)
        VP(Mka.EB.RunTimeEvent.TriggeredEventPae,1) Verify that, after MacSec Operational was set during transition to CP_UNSECURED, a bit for that event has been set for the selected Pae.
    14: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Unsecured.Testing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1481</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.DisableSAsBeforeDelete</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1504</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.MacSecOperational.Unsecured</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1487</internalId></provcov>
        <provcov>
          <linksto>Mka.EB.RunTimeEvent.BitFieldDefinition</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1478</internalId></provcov>
        <provcov>
          <linksto>Mka.EB.RunTimeEvent.TriggeredEventPae</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1480</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1825</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01014_CpSM_WaitAddTxSa2Unsecured</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>648</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies transition from CP_WAIT_ADD_TX_SA-&amp;gt;CP_UNSECURED.
Test Object: Cp state machine.
Test Precondition: 
    -   Mka_Init() initialized. CP unit initialized.
  
Test Execution: 
    01: Call function Mka_Cp_SetCipherSuite() to simulate call from Logon that selected PAE can be initialized.
    02: Call function Mka_Cp_MacSecUpdateSecYNotification() to simulate that MacSecUpdateSecY request has been finished.
    03: Call function Mka_Cp_MainFunction() to go through Mka main loop. Cp SM shall transition to CP_WAIT_RX_SC.
    04: Call Mka_Cp_InitRxSc to give PeerSci to Cp SM and thus enable the Cp SM to transition to CP_INIT_RX_SC and then to CP_SECURED.
    05: Sanity check - Sanity check.
    06: Call function Mka_Cp_NewSak() to indicate that new SAK is ready and that CP isn't key server.
    07: Call function Mka_Cp_MacSecAddRxSaNotification() to indicate that MacSecAddRxSa request has been processed.
    08: Call Mka_Cp_MainFunction() to run state machine and make necessary transitions.
    09: Call function Mka_Cp_DisableMacSec() to setup parameter Connect to FALSE.
    10: VP(Mka.dsn.Cp.CpSM.Unsecured.Testing,1) Verify that CP state machine transitioned from CP_WAIT_ADD_TX_SA to CP_UNSECURED. When CP state machine enters state CP_UNSECURED, CP shall delete all active SAs, set ControlledPortEnabled to TRUE, and call EthIf_MacSecUpdateSecY().
    11: Call function Mka_Cp_MacSecUpdateSecYNotification() to simulate that MacSecUpdateSecY request has been finished.
    12: Call function Mka_Cp_MainFunction() to transit from CP_WAIT_ADD_TX_SA to CP_UNSECURED.
    13: VP(Mka.dsn.Cp.MacSecOperational.Unsecured,1) Verify that EthIf_MacSecOperational(TRUE) is called to indicate to upper layers that link is available.
    14: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Unsecured.Testing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1481</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.MacSecOperational.Unsecured</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1487</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1826</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01015_CpSM_Receiving2Unsecured</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>683</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies transition from CP_RECEIVING-&amp;gt;CP_UNSECURED.
Test Object: Cp state machine.
Test Precondition: 
    -   Mka_Init() initialized. CP unit initialized.
  
Test Execution: 
    01: Call function Mka_Cp_SetCipherSuite() to simulate call from Logon that selected PAE can be initialized. EthIf_MacSecUpdateSecY() shall be called.
    02: Call function EbTest_CpSM_GoThroghFirstLoop() to go through CP state machine from CP_UNINIT to CP_RETIRE and back to CP_WAIT_ADD_RX_SA.
    03: Call function Mka_Cp_MacSecAddRxSaNotification() to indicate that MacSecAddRxSa request has been processed.
    04: Call Mka_Cp_MainFunction() to run state machine and make necessary transitions.
    05: Call function Mka_Cp_MacSecAddTxSaNotification() to indicate that EthIf_MacSecAddTxSa request has been processed. With this function call, CP state machine will transition from CP_WAIT_ADD_TX_SA to CP_RECEIVING.
    06: Call Mka_Cp_MainFunction to transition Cp State Machine to CP_RECEIVING State.
    07: Call function Mka_Cp_DisableMacSec() to setup parameter Connect to FALSE.
    08: Call function Mka_Cp_MacSecUpdateSecYNotification() to simulate that MacSecUpdateSecY request has been finished.
    09: Call function Mka_Cp_MainFunction() to transit from CP_RECEIVING to CP_UNSECURED.
    10: VP(Mka.dsn.Cp.CpSM.Unsecured.Testing,1) Verify that CP state machine transitioned from CP_RECEIVING to CP_UNSECURED. When CP state machine enters state CP_UNSECURED, CP shall delete all SAs, set ControlledPortEnabled to TRUE, call EthIf_MacSecUpdateSecY() and EthIf_MacSecOperational().
    11: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Unsecured.Testing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1481</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1827</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01016_CpSM_Ready2Unsecured</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>711</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies transition from CP_READY-&amp;gt;CP_UNSECURED.
Test Object: Cp state machine.
Test Precondition: 
    -   Mka_Init() initialized. CP unit initialized.
  
Test Execution: 
    01: Call function Mka_Cp_SetCipherSuite() to simulate call from Logon that selected PAE can be initialized. EthIf_MacSecUpdateSecY() shall be called.
    02: Call function EbTest_CpSM_GoThroghFirstLoop() to go through CP state machine from CP_UNINIT to CP_RETIRE and back to CP_WAIT_ADD_RX_SA.
    03: Call function Mka_Cp_MacSecAddRxSaNotification() to indicate that MacSecAddRxSa request has been processed.
    04: Call Mka_Cp_MainFunction() to run state machine and make necessary transitions.
    05: Call function Mka_Cp_MacSecAddTxSaNotification() to indicate that EthIf_MacSecAddTxSa request has been processed. With this function call, CP state machine transitions from CP_WAIT_ADD_TX_SA to CP_RECEIVING and ElectedSelf is FALSE and state machine will transit from CP_RECEIVING to CP_READY.
    06: Run the main function.
    07: Call function Mka_Cp_DisableMacSec() to setup parameter Connect to FALSE.
    08: VP(Mka.dsn.Cp.CpSM.Unsecured.Testing,1)
        VP(Mka.InterAct.Cp.MacSecDisabled,1) Verify that CP state machine transitioned from CP_READY to CP_UNSECURED, by verifying that receive security channel was deleted, so as Old and Latest security associations. Finally EthIf_MacSecUpdateSecY() is called to disable MACsec.
    09: Call function Mka_Cp_MacSecUpdateSecYNotification() to simulate that MacSecUpdateSecY request has been finished.
    10: Call function Mka_Cp_MainFunction() to transit from CP_READY to CP_UNSECURED.
    11: Sanity check - Sanity check.
    12: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Unsecured.Testing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1481</internalId></provcov>
        <provcov>
          <linksto>Mka.InterAct.Cp.MacSecDisabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1107</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1828</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01017_CpSM_Transmitting2Unsecured</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>745</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies transition from CP_TRANSMITTING-&amp;gt;CP_UNSECURED.
Test Object: Cp state machine.
Test Precondition: 
    -   Mka_Init() initialized. CP unit initialized.
  
Test Execution: 
    01: Call function Mka_Cp_SetCipherSuite() to simulate call from Logon that selected PAE can be initialized.
    02: Call function Mka_Cp_MacSecUpdateSecYNotification() to simulate that MacSecUpdateSecY request has been finished.
    03: Call function Mka_Cp_MainFunction() to go through Mka main loop. Cp SM shall transition to CP_WAIT_RX_SC.
    04: Call Mka_Cp_InitRxSc to give PeerSci to Cp SM and thus enable the Cp SM to transition to CP_INIT_RX_SC and then to CP_SECURED.
    05: Sanity check - Sanity check.
    06: Call function Mka_Cp_NewSak() to indicate that new SAK is ready and that CP is key server.
    07: Call function Mka_Cp_MacSecAddRxSaNotification() to indicate that MacSecAddRxSa request has been processed.
    08: Call Mka_Cp_MainFunction() to run state machine and make necessary transitions.
    09: Set EthIf_MacSecSetControlledPortEnabled stub to return E_NOT_OK so the Cp Sm doesn't transition from CP_TRANSMITTING to CP_RETIRE.
    10: Call function Mka_Cp_MacSecAddTxSaNotification() to indicate that EthIf_MacSecAddTxSa request has been processed. With this function call, CP state machine transitions from CP_WAIT_ADD_TX_SA to CP_RECEIVING and ElectedSelf is TRUE and state machine will transit from CP_RECEIVING to CP_TRANSMITTING.
    11: Run the main function.
    12: Call function Mka_Cp_DisableMacSec() to setup parameter Connect to FALSE.
    13: VP(Mka.dsn.Cp.CpSM.Unsecured.Testing,1) Verify that CP state machine transitioned from CP_TRANSMITTING to CP_UNSECURED, by verifying that receive security channel was deleted, and the Latest security associations. Finally EthIf_MacSecUpdateSecY() is called to disable MACsec.
    14: Call function Mka_Cp_MacSecUpdateSecYNotification() to simulate that MacSecUpdateSecY request has been finished.
    15: Call function Mka_Cp_MainFunction() to transit trigger processing UpdateSecY notification.
    16: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Unsecured.Testing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1481</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1829</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01018_CpSM_Retire2Unsecured</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>778</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies transition from CP_RETIRE-&amp;gt;CP_UNSECURED.
Test Object: Cp state machine.
Test Precondition: 
    -   Mka_Init() initialized. CP unit initialized.
  
Test Execution: 
    01: Call function Mka_Cp_SetCipherSuite() to simulate call from Logon that selected PAE can be initialized. EthIf_MacSecUpdateSecY() shall be called.
    02: Call function EbTest_CpSM_GoThroghFirstLoop() to go through CP state machine from CP_UNINIT to CP_RETIRE and back to CP_WAIT_ADD_RX_SA.
    03: Call Mka_Cp_SetCipherSuite. Since Cp Sm is not in state CP_WAIT_RX_SC nor in state CP_UNINIT, call shall be ignored.
    04: VP(Mka.dsn.Cp.Api.SetCipherSuite,2) Verify that the call was ignored since the Cp SM is not in the CP_WAIT_RX_SC or CP_UNINIT state.
    05: Call Mka_Cp_MacSecAddRxSaNotification and Mka_MainFunction to transition from CP_WAIT_ADD_RX_SA to CP_WAIT_ADD_TX_SA.
    06: Sanity check - Sanity.
    07: Call Mka_Cp_MacSecAddTxSaNotification and Mka_MainFunction to transition from CP_WAIT_ADD_TX_SA to CP_RECEIVING and to CP_TRANSMITTING.
    08: Sanity check - Sanity.
    09: Call Mka_Cp_ServerTransmitting to transition from CP_READY to CP_TRANSMITTING.
    10: Sanity check - Sanity.
    11: Call Mka_Cp_TimerCallback_RetireWhen to transition from CP_TRANSMITTING to CP_RETIRE.
    12: Call function Mka_Cp_DisableMacSec() to setup parameter Connect to FALSE.
    13: Call function Mka_Cp_MacSecUpdateSecYNotification() to simulate that MacSecUpdateSecY request has been finished.
    14: Call function Mka_Cp_MainFunction() to transit from CP_RETIRE to CP_UNSECURED.
    15: VP(Mka.dsn.Cp.CpSM.Unsecured.Testing,1)
        VP(Mka.EB.Net_Sec_2158,1) Verify that CP state machine transitioned from CP_RETIRE to CP_UNSECURED. When CP state machine enters state CP_UNSECURED, CP shall delete all SAs, set ControlledPortEnabled to TRUE, call EthIf_MacSecUpdateSecY() and EthIf_MacSecOperational().
    16: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.Api.SetCipherSuite</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1019</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Unsecured.Testing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1481</internalId></provcov>
        <provcov>
          <linksto>Mka.EB.Net_Sec_2158</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1484</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1830</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01019_CpSM_Uninit2WaitRxSc_PortEnabled</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>820</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies transition from CP_UNINIT to CP_WAIT_RX_SC, and when Link state is down, it verifies that state machine stays in CP_WAIT_RX_SC state.
Test Object: Cp state machine.
Test Precondition: 
  
Test Execution: 
    01: Module configuration initialized with Mka_Init(), Mka_Cp_Init is also called.
    02: Sanity check - Verify that after state CP_UNINIT is entered, no APIs are called.
    03: Call function Mka_Cp_LinkStateDown() to change link state to FALSE.
    04: VP(Mka.dsn.Cp.CpSM.Any_2_WaitRxSc,1) Verify that if Mka_Cp_LinkStateDown() is called from CP_UNINIT state, it doesn't perform additional actions.
    05: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Any_2_WaitRxSc</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1385</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1831</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01020_CpSM_WaitRxSc2WaitRxSc_PortEnabled</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>841</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies transition from CP_WAIT_RX_SC-&amp;gt;CP_WAIT_RX_SC.
Test Object: Cp state machine.
Test Precondition: 
    -   Mka_Init() initialized. CP unit initialized. Link state setup to TRUE.
  
Test Execution: 
    01: Call function Mka_Cp_SetCipherSuite() to simulate call from Logon that selected PAE can be initialized.
    02: Call function Mka_Cp_MacSecUpdateSecYNotification() to simulate that MacSecUpdateSecY request has been finished.
    03: Call function Mka_Cp_MainFunction() to transit from CP_UPDATE_SECY to CP_WAIT_RX_SC.
    04: Call function Mka_Cp_LinkStateDown() to change link state to FALSE.
    05: VP(Mka.dsn.Cp.CpSM.Any_2_WaitRxSc,1) Verify that CP state machine remained in CP_WAIT_RX_SC to CP_WAIT_RX_SC.
    06: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Any_2_WaitRxSc</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1385</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1832</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01021_CpSM_WaitAddRxSa2WaitRxSc_PortEnabled</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>864</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies transition from CP_WAIT_ADD_RX_SA-&amp;gt;CP_WAIT_RX_SC.
Test Object: Cp state machine.
Test Precondition: 
    -   Mka_Init() initialized. CP unit initialized. Link state setup to TRUE.
  
Test Execution: 
    01: Call function Mka_Cp_SetCipherSuite() to simulate call from Logon that selected PAE can be initialized.
    02: Call function Mka_Cp_MacSecUpdateSecYNotification() to simulate that MacSecUpdateSecY request has been finished.
    03: Call Mka_Cp_InitRxSc to give PeerSci to Cp SM and thus enable the Cp SM to transition to CP_INIT_RX_SC and then to CP_SECURED.
    04: Sanity check - Sanity check.
    05: Call function Mka_Cp_NewSak() to indicate that new SAK is ready and that CP isn't key server.
    06: Call function Mka_Cp_LinkStateDown() to change link state to FALSE.
    07: VP(Mka.EB.RunTimeEvent.BitFieldDefinition,1)
        VP(Mka.EB.RunTimeEvent.TriggeredEventPae,1) Verify that, after LinkState changed to Down, a bit for that event has been set for the selected Pae.
    08: VP(Mka.dsn.Cp.CpSM.Any_2_WaitRxSc,1)
        VP(Mka.dsn.Cp.MacSecOperational.LinkStateDown,1) Verify that CP state machine transitioned from CP_WAIT_ADD_RX_SA to CP_WAIT_RX_SC, by verifying that MacSecOperational is reported FALSE and controlled port was disabled. Also verify that receive security channel and receive security association were deleted.
    09: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.RunTimeEvent.BitFieldDefinition</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1478</internalId></provcov>
        <provcov>
          <linksto>Mka.EB.RunTimeEvent.TriggeredEventPae</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1480</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Any_2_WaitRxSc</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1385</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.MacSecOperational.LinkStateDown</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1486</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1833</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01022_CpSM_UpdateSecY2WaitRxSc_LinkStateDown</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>904</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that call to Mka_Cp_LinkStateDown() from CP_UPDATE_SECY is ignored.
Test Object: Cp state machine.
Test Precondition: 
    -   Mka_Init() initialized. CP unit initialized. Mka_Cp_SetCipherSuite() call from Logon that selected PAE can be initalized.
  
Test Execution: 
    01: Sanity check - Verify that CP state machine transitioned from CP_UNINIT to CP_UPDATE_SECY. When CP state machine enters state CP_UPDATE_SECY, CP shall call EthIf to update SecY with function call EthIf_MacSecUpdateSecY().
    02: Call function Mka_Cp_LinkStateDown() to change link state to FALSE.
    03: Call function Mka_Cp_MainFunction() run state machine.
    04: VP(Mka.dsn.Cp.CpSM.Any_2_WaitRxSc,1) Verify that if Mka_Cp_LinkStateDown() is called from CP_UPDATE_SECY state, it doesn't perform additional actions.
    05: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Any_2_WaitRxSc</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1385</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1834</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01023_CpSM_WaitAddTxSa2WaitRxSc_PortEnabled</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>926</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies transition from CP_WAIT_ADD_TX_SA -&amp;gt; CP_WAIT_RX_SC.
Test Object: Cp state machine.
Test Precondition: 
    -   Mka_Init() initialized. CP unit initialized. Link state setup to TRUE.
  
Test Execution: 
    01: Call function Mka_Cp_SetCipherSuite() to simulate call from Logon that selected PAE can be initialized.
    02: Call function Mka_Cp_MacSecUpdateSecYNotification() to simulate that MacSecUpdateSecY request has been finished.
    03: Call Mka_Cp_InitRxSc to give PeerSci to Cp SM and thus enable the Cp SM to transition to CP_INIT_RX_SC and then to CP_SECURED.
    04: Sanity check - Sanity check.
    05: Call function Mka_Cp_NewSak() to indicate that new SAK is ready and that CP is key server.
    06: Call function Mka_Cp_MacSecAddRxSaNotification() to indicate that MacSecAddRxSa request has been processed.
    07: Call Mka_Cp_MainFunction() to run state machine and make necessary transitions.
    08: Call function Mka_Cp_LinkStateDown() to change link state to FALSE. This signals the CpSM to enter the state CP_WAIT_RX_SC.
    09: VP(Mka.dsn.Cp.CpSM.Any_2_WaitRxSc,1)
        VP(Mka.dsn.Cp.Api.LinkStateDown,1) Verify that CP state machine transitioned from CP_WAIT_ADD_TX_SA to CP_WAIT_RX_SC, by verifying that TRANSMIT_WHEN timer is stopped, MacSecOperational is reported FALSE and controlled port was disabled. Also verify that receive security channel and receive security association were deleted.
    10: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Any_2_WaitRxSc</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1385</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.Api.LinkStateDown</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1018</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1835</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01024_CpSM_Transmitting2WaitRxSc_PortEnabled</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>958</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies transition from CP_TRANSMITTING-&amp;gt;CP_WAIT_RX_SC.
Test Object: Cp state machine.
Test Precondition: 
    -   Mka_Init() initialized. CP unit initialized. Link state setup to TRUE.
  
Test Execution: 
    01: Call function Mka_Cp_SetCipherSuite() to simulate call from Logon that selected PAE can be initialized.
    02: Call function Mka_Cp_MacSecUpdateSecYNotification() to simulate that MacSecUpdateSecY request has been finished.
    03: Call Mka_Cp_InitRxSc to give PeerSci to Cp SM and thus enable the Cp SM to transition to CP_INIT_RX_SC and then to CP_SECURED.
    04: Sanity check - Sanity check.
    05: Call function Mka_Cp_NewSak() to indicate that new SAK is ready and that CP is key server.
    06: Call function Mka_Cp_MacSecAddRxSaNotification() to indicate that MacSecAddRxSa request has been processed.
    07: Call Mka_Cp_MainFunction() to run state machine and make necessary transitions.
    08: Call function Mka_Cp_MacSecAddTxSaNotification() to indicate that EthIf_MacSecAddTxSa request has been processed. With this function call, CP state machine will transition from CP_WAIT_ADD_TX_SA to CP_RECEIVING and ElectedSelf is TRUE and state machine will transit from CP_RECEIVING to CP_TRANSMITTING.
    09: Run the main function.
    10: Call function Mka_Cp_LinkStateDown() to change link state to FALSE.
    11: Call function Mka_Cp_MainFunction() to transit from CP_TRANSMITTING to CP_WAIT_RX_SC.
    12: VP(Mka.dsn.Cp.CpSM.Any_2_WaitRxSc,1)
        VP(Mka.dsn.Cp.Api.LinkStateDown,1) Verify that CP state machine transitioned from CP_TRANSMITTING to CP_WAIT_RX_SC.
    13: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Any_2_WaitRxSc</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1385</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.Api.LinkStateDown</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1018</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1836</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01025_CpSM_Retire2WaitRxSc_PortEnabled</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>993</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies transition from CP_RETIRE-&amp;gt;CP_WAIT_RX_SC.
Test Object: Cp state machine.
Test Precondition: 
    -   Mka_Init() initialized. CP unit initialized. Link state setup to TRUE.
  
Test Execution: 
    01: Call function Mka_Cp_SetCipherSuite() to simulate call from Logon that selected PAE can be initialized.
    02: Call function Mka_Cp_MacSecUpdateSecYNotification() to simulate that MacSecUpdateSecY request has been finished.
    03: Call Mka_Cp_InitRxSc to give PeerSci to Cp SM and thus enable the Cp SM to transition to CP_INIT_RX_SC and then to CP_SECURED.
    04: Sanity check - Sanity check.
    05: Call function Mka_Cp_NewSak() to indicate that new SAK is ready and that CP is key server.
    06: Call function Mka_Cp_MacSecAddRxSaNotification() to indicate that MacSecAddRxSa request has been processed.
    07: Call Mka_Cp_MainFunction() to run state machine and make necessary transitions.
    08: Call function Mka_Cp_MacSecAddTxSaNotification() to indicate that EthIf_MacSecAddTxSa request has been processed. With this function call, CP state machine will transition from CP_WAIT_ADD_TX_SA to CP_RECEIVING and ElectedSelf is TRUE and state machine will transit from CP_RECEIVING to CP_TRANSMITTING.
    09: Run the main function.
    10: Call function Mka_Cp_MainFunction() to transit from CP_TRANSMITTING to CP_RETIRE.
    11: Call function Mka_Cp_LinkStateDown() to change link state to FALSE.
    12: Call function Mka_Cp_MainFunction() to process change of link state.
    13: VP(Mka.dsn.Cp.CpSM.Any_2_WaitRxSc,1) Verify that CP state machine transitioned from CP_TRANSMITTING to CP_WAIT_RX_SC.
    14: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Any_2_WaitRxSc</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1385</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1837</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01026_CpSM_Ready2WaitRxSc_PortEnabled</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>1024</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies transition from CP_READY-&amp;gt;CP_WAIT_RX_SC.
Test Object: Cp state machine.
Test Precondition: 
    -   Mka_Init() initialized. CP unit initialized. Link state setup to TRUE.
  
Test Execution: 
    01: Call function Mka_Cp_SetCipherSuite() to simulate call from Logon that selected PAE can be initialized. EthIf_MacSecUpdateSecY() shall be called.
    02: Call function EbTest_CpSM_GoThroghFirstLoop() to go through CP state machine from CP_UNINIT to CP_RETIRE and back to CP_WAIT_ADD_RX_SA.
    03: Call function Mka_Cp_MacSecAddRxSaNotification() to indicate that MacSecAddRxSa request has been processed.
    04: Call Mka_Cp_MainFunction() to run state machine and make necessary transitions.
    05: Call function Mka_Cp_MacSecAddTxSaNotification() to indicate that EthIf_MacSecAddTxSa request has been processed. With this function call, CP state machine will transition from CP_WAIT_ADD_TX_SA to CP_RECEIVING and ElectedSelf is FALSE and state machine will transit from CP_RECEIVING to CP_READY.
    06: Run the main function.
    07: Call function Mka_Cp_LinkStateDown() to change link state to FALSE.
    08: Call function Mka_Cp_MainFunction() to process change of link state.
    09: VP(Mka.dsn.Cp.CpSM.Any_2_WaitRxSc,1)
        VP(Mka.dsn.Cp.Api.LinkStateDown,1) Verify that CP state machine transitioned from CP_READY to CP_WAIT_RX_SC.
    10: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Any_2_WaitRxSc</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1385</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.Api.LinkStateDown</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1018</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1838</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01027_FillSakUse</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>1056</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies if Mka_Cp_FillSakUse() correctly fill parameters L_Tx, L_Rx, O_Tx and O_Rx in the given buffer.
Test Object: Cp state machine.
Test Precondition: 
    -   Mka_Init() initialized. CP unit initialized.
  
Test Execution: 
    01: Call function Mka_Cp_SetCipherSuite() to simulate call from Logon that selected PAE can be initialized. EthIf_MacSecUpdateSecY() shall be called.
    02: Call function EbTest_CpSM_GoThroghFirstLoop() to go through CP state machine from CP_UNINIT to CP_RETIRE and back to CP_WAIT_ADD_RX_SA.
    03: Call function Mka_Cp_MacSecAddRxSaNotification() to indicate that MacSecAddRxSa request has been processed.
    04: Call Mka_Cp_MainFunction() to run state machine and make necessary transitions.
    05: Call function Mka_Cp_MacSecAddTxSaNotification() to indicate that EthIf_MacSecAddTxSa request has been processed. With this function call, CP state machine will transition from CP_WAIT_ADD_TX_SA to CP_RECEIVING.
    06: Call Mka_Cp_MainFunction() to run state machine and make necessary transitions.
    07: Call Mka_Cp_FillSakUse() before we enters CP_TRANSMITTING.
    08: Verify L_Tx, L_Rx, O_Tx and O_Rx.
    09: VP(Mka.8021X.KeyServerElection.66,1)
        VP(Mka.dsn.Cp.Api.FillSakUse,1) Verify that CP state machine called EthIf_MacSecGetTxSaNextPn() to get Latest and Old Key Lowest PN.
    10: VP(Mka.dsn.Cp.PacketNumber.SakUseLPn,1) Verify that CP state machine encodes Lowest PN equal 1, because it is lower than ReplayProtectionWindow.
    11: Call function Mka_Cp_ServerTransmitting() to indicate that every peer is waiting for the transmission of the SAK key.
    12: Call Mka_Cp_FillSakUse() when we entered CP_TRANSMITTING.
    13: Verify L_Tx, L_Rx, O_Tx and O_Rx.
    14: VP(Mka.8021X.KeyServerElection.66,1)
        VP(Mka.dsn.Cp.Api.FillSakUse,1) Verify that CP state machine called EthIf_MacSecGetTxSaNextPn() to get nextPn and calculate Latest and Old Key Lowest PN.
    15: VP(Mka.dsn.Cp.PacketNumber.SakUseLPn,1) Verify that CP state machine encodes Lowest PN equal (LowestPn-ReplayProtectionWindow), because it is higher than ReplayProtectionWindow.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.66</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>279</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.Api.FillSakUse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1015</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.PacketNumber.SakUseLPn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1485</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1839</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01028_PnExhausted</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>1098</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies if Mka_Cp_FillSakUse() will call KaY's unit API Mka_KaY_PnExhausted() when Latest LowestPn is equal to or greater than PNExhaustion.
Test Object: Mka_KaY_PnExhausted().
Test Precondition: 
    -   Mka_Init() initialized. CP unit initialized.
  
Test Execution: 
    01: Create MKPDU from a peer Participant_1 that proves liveliness to Participant_0.
    02: Call function Mka_Cp_SetCipherSuite() to simulate call from Logon that selected PAE can be initialized. EthIf_MacSecUpdateSecY() shall be called.
    03: Call function EbTest_CpSM_GoThroghFirstLoop() to go through CP state machine from CP_UNINIT to CP_RETIRE and back to CP_WAIT_ADD_RX_SA.
    04: Call function Mka_Cp_MacSecAddRxSaNotification() to indicate that MacSecAddRxSa request has been processed.
    05: Call Mka_Cp_MainFunction() to run state machine and make necessary transitions.
    06: Call function Mka_Cp_MacSecAddTxSaNotification() to indicate that EthIf_MacSecAddTxSa request has been processed. With this function call, CP state machine will transition from CP_WAIT_ADD_TX_SA to CP_RECEIVING.
    07: Call function EbTest_Cp_AllReceiving() to indicate that every peer is waiting for the transmission of the SAK key.
    08: Call Mka_Cp_FillSakUse() to fill SakUse parameter set.
    09: VP(Mka.8021X.KeyServerElection.41,1) Verify that Mka_KaY_PnExhausted() is called when our L_LPn is equal or greater than PNExhaustion.
    10: Set-up LatestPn to EBTEST_SAK_USE_EXHAUSTED_PN.
    11: Call function Mka_Cp APIs to parse received SakUse with exhausted Pn.
    12: VP(Mka.8021X.KeyServerElection.41,1) Verify that Mka_KaY_PnExhausted() is called when peers L_LPn is equal or greater than PNExhaustion.
    13: Set-up LatestAn to unused An.
    14: Call function Mka_Cp APIs to parse received SakUse with exhausted Pn.
    15: VP(Mka.dsn.KaY.Api.PnExhausted,1) Verify that Cp unit did not call Mka_KaY_PnExhausted because the key's AN was not the one used by actor.
    16: Set peers OAn to be the same as actors LAn, and it's Pn to become exhausted.
    17: Call function Mka_Cp APIs to parse received SakUse with exhausted Pn.
    18: VP(Mka.8021X.KeyServerElection.41,1) Verify that Mka_KaY_PnExhausted() is called when peers O_LPn (of the newest key) is equal or greater than PNExhaustion.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.41</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>244</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.Api.PnExhausted</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1006</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1840</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01029_CheckSsci_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>1137</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that CP unit calls EthIf_MacSecAddRxSa() with correct SCI (two).
Test Object: Ssci in EthIf_MacSecAddRxSa().
Test Precondition: 
    -   Mka_Init() initialized. CP unit initialized.
  
Test Execution: 
    01: Call function Mka_Cp_SetCipherSuite() to simulate call from Logon that selected PAE can be initialized.
    02: Call function Mka_Cp_MacSecUpdateSecYNotification() to simulate that MacSecUpdateSecY request has been finished.
    03: Call function Mka_Cp_MainFunction() to go through Mka main loop. Cp SM shall transition to CP_WAIT_RX_SC.
    04: Call Mka_Cp_InitRxSc to give PeerSci to Cp SM and thus enable the Cp SM to transition to CP_INIT_RX_SC and then to CP_SECURED.
    05: Sanity check - Sanity check.
    06: Call function Mka_Cp_NewSak() to indicate that new SAK is ready and that CP isn't key server.
    07: VP(Mka.8021X.KeyServerElection.75,1) Verify that EthIf_MacSecAddRxSa() is called with correct RxSsci when TxSsci is not zero.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.75</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>287</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1841</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01030_CheckSsci_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>1161</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that CP unit calls EthIf_MacSecAddRxSa() with correct SCI (one).
Test Object: Ssci in EthIf_MacSecAddRxSa().
Test Precondition: 
    -   Mka_Init() initialized. CP unit initialized.
  
Test Execution: 
    01: Call function Mka_Cp_SetCipherSuite() to simulate call from Logon that selected PAE can be initialized.
    02: Call function Mka_Cp_MacSecUpdateSecYNotification() to simulate that MacSecUpdateSecY request has been finished.
    03: Call function Mka_Cp_MainFunction() to go through Mka main loop. Cp SM shall transition to CP_WAIT_RX_SC.
    04: Call Mka_Cp_InitRxSc to give PeerSci to Cp SM and thus enable the Cp SM to transition to CP_INIT_RX_SC and then to CP_SECURED.
    05: Sanity check - Sanity check.
    06: Call function Mka_Cp_NewSak() to indicate that new SAK is ready and that CP isn't key server.
    07: VP(Mka.8021X.KeyServerElection.75,1) Verify that EthIf_MacSecAddRxSa() is called with correct RxSsci when TxSsci is not zero.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.75</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>287</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1842</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01031_CheckSsci_3</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>1185</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that CP unit calls EthIf_MacSecAddRxSa() with correct SCI (zero).
Test Object: Ssci in EthIf_MacSecAddRxSa().
Test Precondition: 
    -   Mka_Init() initialized. CP unit initialized.
  
Test Execution: 
    01: Call function Mka_Cp_SetCipherSuite() to simulate call from Logon that selected PAE can be initialized.
    02: Call function Mka_Cp_MacSecUpdateSecYNotification() to simulate that MacSecUpdateSecY request has been finished.
    03: Call function Mka_Cp_MainFunction() to go through Mka main loop. Cp SM shall transition to CP_WAIT_RX_SC.
    04: Call Mka_Cp_InitRxSc to give PeerSci to Cp SM and thus enable the Cp SM to transition to CP_INIT_RX_SC and then to CP_SECURED.
    05: Sanity check - Sanity check.
    06: Call function Mka_Cp_NewSak() to indicate that new SAK is ready and that CP isn't key server.
    07: VP(Mka.8021X.KeyServerElection.75,1) Verify that EthIf_MacSecAddRxSa() is called with zero when TxSsci is zero.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.75</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>287</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1843</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01032_L_XLPn_Recovery</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>1209</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that function Mka_Cp_XLPn_Recovery() correctly encodes L_LPn.
Test Object: Mka_Cp_XLPn_Recovery().
Test Precondition: 
    -   Mka_Init() initialized. CP unit initialized.
  
Test Execution: 
    01: Create MKPDU from a peer Participant_1 that proves liveliness to Participant_0.
    02: Call function Mka_Cp_SetCipherSuite() to simulate call from Logon that selected PAE can be initialized.
    03: Set the Cp state machine to the desired state.
    04: Set SakUse parameter set LPN to value 0x80000000.
    05: Simulate reception of SakUse from alive peer with SakUse parameter set that has LPN value 0x80000000.
    06: VP(Mka.dsn.Cp.ExtendedPacketNumber.PnRecovery,1) Verify that for the first call of Mka_Cp_XLPn_Recovery() LatestPn stayed the same.
    07: Set SakUse parameter set LPN to value 0x0.
    08: Simulate reception of SakUse from alive peer with SakUse parameter set that has LPN value 0x0. This simulates overflow and the LPn's most significant 32bits should increase by 1U.
    09: VP(Mka.dsn.Cp.ExtendedPacketNumber.PnRecovery,1) Verify that for the second call of Mka_Cp_XLPn_Recovery() with number equals zero, after it is called with value equal or greater than EBTEST_XPN_TRIGGER_INCREASE_MSB_PN, LatestPn is increased in least significant bit of the 32 most significant bits.
    10: Set-up LatestPn to 0x80000000.
    11: Simulate reception of SakUse from alive peer with SakUse parameter set that has LPN value 0x80000000.
    12: VP(Mka.dsn.Cp.ExtendedPacketNumber.PnRecovery,1) Verify that for after call of Mka_Cp_XLPn_Recovery() LatestPn is updated with MSB.
    13: Set-up LatestPn to zero, to simulate overflow of PN.
    14: Call function Mka_Cp_XLPn_Recovery() with value 0x80000001.
    15: VP(Mka.dsn.Cp.ExtendedPacketNumber.PnRecovery,1) Verify that that for the second call of Mka_Cp_XLPn_Recovery() with number equals zero, after it is called with value equal or greater than EBTEST_XPN_TRIGGER_INCREASE_MSB_PN, LatestPn is increased in least significant bit of the 32 most significant bits.
    16: VP(Mka.CP_SWS_Mka_00014.2,1)
        VP(Mka.8021X.KeyServerElection.42,1)
        VP(Mka.CP_SWS_Mka_CONSTR_00019.3,1) Verify that Cp unit didn't initiate generation of new SAK key, when transmitting PN is equal or greater than 32bit PN Exhaustion, but lower than 64bit PN Exhaustion.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.ExtendedPacketNumber.PnRecovery</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1492</internalId></provcov>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00014.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>325</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.42</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>245</internalId></provcov>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_CONSTR_00019.3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>332</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1844</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01033_SaltKey</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>1256</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that Salt key is correctly calculated and transmitted.
Test Object: Salt key.
Test Precondition: 
    -   Mka_Init() initialized. CP unit initialized. Link state setup to TRUE.
  
Test Execution: 
    01: Call function Mka_Cp_SetCipherSuite() to simulate call from Logon that selected PAE can be initialized.
    02: Call function Mka_Cp_MacSecUpdateSecYNotification() to simulate that MacSecUpdateSecY request has been finished.
    03: Call function Mka_Cp_MainFunction() to transit from CP_UPDATE_SECY to CP_WAIT_RX_SC.
    04: Call Mka_Cp_InitRxSc to give PeerSci to Cp SM and thus enable the Cp SM to transition to CP_INIT_RX_SC and then to CP_SECURED.
    05: Sanity check - Sanity check.
    06: Call function Mka_Cp_NewSak() to indicate that new SAK is ready and that CP is key server.
    07: VP(Mka.dsn.Cp.ExtendedPacketNumber.Salt,1)
        VP(Mka.CP_SWS_Mka_91013,1) Verify that EthIf_MacSecAddRxSa() is called with correct salt key.
    08: Call function Mka_Cp_MacSecAddRxSaNotification() to indicate that MacSecAddRxSa request has been processed.
    09: Call Mka_Cp_MainFunction() to run state machine and make necessary transitions.
    10: VP(Mka.dsn.Cp.ExtendedPacketNumber.Salt,1)
        VP(Mka.CP_SWS_Mka_91013,1) Verify that EthIf_MacSecAddTxSa() is called with correct salt key.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.ExtendedPacketNumber.Salt</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1489</internalId></provcov>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_91013</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>369</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1845</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01034_CorrectKeys</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>1289</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that correct keys are passed to EthIf and deleted after that.
Test Object: Correct keys are passed to EthIf.
Test Precondition: 
    -   Mka_Init() initialized. CP unit initialized. Link state setup to TRUE.
  
Test Execution: 
    01: Call function Mka_Cp_SetCipherSuite() to simulate call from Logon that selected PAE can be initialized.
    02: Call function Mka_Cp_MacSecUpdateSecYNotification() to simulate that MacSecUpdateSecY request has been finished.
    03: Call function Mka_Cp_MainFunction() to transit from CP_UPDATE_SECY to CP_WAIT_RX_SC.
    04: Call Mka_Cp_InitRxSc to give PeerSci to Cp SM and thus enable the Cp SM to transition to CP_INIT_RX_SC and then to CP_SECURED.
    05: Sanity check - Sanity check.
    06: Call function Mka_Cp_NewSak() to indicate that new SAK is ready and that CP is key server.
    07: VP(Mka.CP_SWS_Mka_91013,1) Verify that EthIf_MacSecAddRxSa() is called with correct Hash and SAK key.
    08: Call function Mka_Cp_MacSecAddRxSaNotification() to indicate that MacSecAddRxSa request has been processed.
    09: Call Mka_Cp_MainFunction() to run state machine and make necessary transitions.
    10: VP(Mka.CP_SWS_Mka_91013,1)
        VP(Mka.dsn.Cp.KeysReset,1) Verify that after function EthIf_MacSecAddTxSa() call, keys are reset to zero.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_91013</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>369</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.KeysReset</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1488</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1846</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01035_NoKeys</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>1321</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that if Mka_Cp_FillXpn and Mka_Cp_FillSakUse are called when no keys are active, the call is ignored.
Test Object: Mka_Cp_FillXpn and Mka_Cp_FillSakUse with no key.
Test Precondition: 
    -   Mka_Init() initialized. CP unit initialized.
  
Test Execution: 
    01: Call function Mka_Cp_SetCipherSuite() to simulate call from Logon that selected PAE can be initialized. EthIf_MacSecUpdateSecY() shall be called.
    02: Call Mka_Cp_FillSakUse before any key has been installed.
    03: VP(Mka.dsn.Cp.FillSakUse.NoKeys,1) Verify that the call has been ignored since no key is installed.
    04: Call Mka_Cp_FillXpn before any key has been installed.
    05: VP(Mka.dsn.Cp.FillXpn.NoKeys,1) Verify that the call has been ignored since no key is installed.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.FillSakUse.NoKeys</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1495</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.FillXpn.NoKeys</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1496</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1847</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01036_O_XLPn_Recovery</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>1347</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that function Mka_Cp_XLPn_Recovery() correctly encodes O_LPn.
Test Object: Mka_Cp_XLPn_Recovery().
Test Precondition: 
    -   Mka_Init() initialized. CP unit initialized.
  
Test Execution: 
    01: Call function Mka_Cp_SetCipherSuite() to simulate call from Logon that selected PAE can be initialized.
    02: Create MKPDU from a peer Participant_1 that proves liveliness to Participant_0. Set SakUse param. set to only use the Old key.
    03: Call function EbTest_CpSM_GoThroghFirstLoop() to go through CP state machine and set Old_Sa. Set the CpSm to state CP_TRANSMITTING.
    04: Set SakUse parameter set LPN to value 0x80000000.
    05: Simulate reception of SakUse from alive peer with SakUse parameter set that has LPN value 0x80000000.
    06: VP(Mka.dsn.Cp.ExtendedPacketNumber.PnRecovery,1) Verify that for the first call of Mka_Cp_XLPn_Recovery() LatestPn stayed the same.
    07: Set-up LatestPn to zero, to simulate overflow of PN.
    08: Simulate reception of SakUse from alive peer with SakUse parameter set that has LPN value 0.
    09: VP(Mka.dsn.Cp.ExtendedPacketNumber.PnRecovery,1) Verify that for the second call of Mka_Cp_XLPn_Recovery() with number equals zero, after it is called with value equal or greater than EBTEST_XPN_TRIGGER_INCREASE_MSB_PN, LatestPn is increased in least significant bit of the 32 most significant bits.
    10: Set-up LatestPn to 0x80000000.
    11: Simulate reception of SakUse from alive peer with SakUse parameter set that has LPN value 0.
    12: VP(Mka.dsn.Cp.ExtendedPacketNumber.PnRecovery,1) Verify that for after call of Mka_Cp_XLPn_Recovery() LatestPn is updated with MSB.
    13: Set-up LatestPn to zero, to simulate overflow of PN.
    14: Call function Mka_Cp_XLPn_Recovery() with value 0x80000001.
    15: VP(Mka.dsn.Cp.ExtendedPacketNumber.PnRecovery,1) Verify that that for the second call of Mka_Cp_XLPn_Recovery() with number equals zero, after it is called with value equal or greater than EBTEST_XPN_TRIGGER_INCREASE_MSB_PN, LatestPn is increased in least significant bit of the 32 most significant bits.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.ExtendedPacketNumber.PnRecovery</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1492</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1848</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01037_NoBypass</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>1379</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that correct parameters are passed to EthIf_MacSecUpdateSecY when there are no bypass rules.
Test Object: Cp state machine.
Test Precondition: 
  
Test Execution: 
    01: Module configuration initialized with Mka_Init(), Mka_Cp_Init is also called.
    02: Call function Mka_Cp_MainFunction() to verify that CP will not transit to other state until Mka_Cp_SetCipherSuite is called.
    03: Call function Mka_Cp_SetCipherSuite() to simulate call from Logon that selected PAE can be initialized. EthIf_MacSecUpdateSecY() shall be called.
    04: VP(Mka.dsn.Cp.BypassEtherType.Empty,1)
        VP(Mka.dsn.Cp.BypassVlan.Empty,1) Verify that, since length of both bypassed rules is zero, the pointer to bypassed rule is NULL_PTR and the Length parameter is zero.
    05: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.BypassEtherType.Empty</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1493</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.BypassVlan.Empty</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1494</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1849</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01041_SecYRetry_CpSmUpdateSecY</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>1405</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that if EthIf_MacSecUpdateSecY() returns E_NOT_OK while CpSm is in state CP_UPDATE_SECY, the call shall be retried in next MainFunction tick. After the successful call to SecY, CpSm should make state transitions as expected.
Test Object: Software
Test Precondition: 
    -   CP unit initialized.
  
Test Execution: 
    01: Set SecY stub to return E_NOT_OK.
    02: Call function Mka_Cp_SetCipherSuite() to simulate call from Logon that selected PAE can be initialized. CpSM shall transition to CP_UPDATE_SECY.
    03: Sanity check - Check that EthIf_MacSecUpdateSecY returned E_NOT_OK.
    04: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to SecY.
    05: VP(Mka.dsn.Cp.Retry,1)
        VP(Mka.dsn.Cp.CpSM.Retry,1) Verify that Cp retried the call to SecY.
    06: VP(Mka.EB.RunTimeEvent.BitFieldDefinition,1)
        VP(Mka.EB.RunTimeEvent.TriggeredEventPae,1) Verify that, after SecY call has been retried, a bit for that event has been set for the selected Pae.
    07: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to SecY one last time.
    08: VP(Mka.dsn.Cp.Retry,1)
        VP(Mka.dsn.Cp.CpSM.Retry,1) Verify that Cp retried the call to SecY for the last time and that EthIf_MacSecUpdateSecY returned E_OK.
    09: Call function Mka_Cp_MacSecUpdateSecYNotification() to simulate that MacSecUpdateSecY request has been finished.
    10: Call Mka_Cp_MainFunction to tick main function.
    11: Call Mka_Cp_InitRxSc to give PeerSci to Cp and thus enable the Cp SM to transition to CP_INIT_RX_SC.
    12: VP(Mka.dsn.Cp.Retry,1)
        VP(Mka.dsn.Cp.CpSM.Retry,1) Verify that EthIf_MacSecInitRxSc has been called, indicating a successful state transition.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.Retry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1497</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Retry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1500</internalId></provcov>
        <provcov>
          <linksto>Mka.EB.RunTimeEvent.BitFieldDefinition</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1478</internalId></provcov>
        <provcov>
          <linksto>Mka.EB.RunTimeEvent.TriggeredEventPae</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1480</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1850</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01042_SecYRetry_CpSmInitRxSc</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>1450</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that if EthIf_MacSecInitRxSc() returns E_NOT_OK while CpSm is in state CP_INIT_RX_SC, the call shall be retried in next MainFunction tick. After the successful call to SecY, CpSm should make state transitions as expected.
Test Object: Software
Test Precondition: 
    -   CP unit initialized.
  
Test Execution: 
    01: Set SecY stub to return E_NOT_OK.
    02: Call function Mka_Cp_SetCipherSuite() to simulate call from Logon that selected PAE can be initialized. CpSM shall transition to Cp_Update_SecY.
    03: Sanity check - Check that EthIf_MacSecInitRxSc returned E_OK. CpSm shall transition to CP_WAIT_RX_SC
    04: Call function Mka_Cp_MacSecUpdateSecYNotification() to simulate that MacSecUpdateSecY request has been finished.
    05: Call Mka_Cp_MainFunction to tick main function.
    06: Call Mka_Cp_InitRxSc to give PeerSci to Cp SM and thus enable the Cp SM to transition to CP_INIT_RX_SC.
    07: Sanity check - Check that EthIf_MacSecInitRxSc returned E_NOT_OK. Call to EthIf_MacSecInitRxSc shall be retried
    08: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to EthIf_MacSecInitRxSc.
    09: VP(Mka.dsn.Cp.Retry,1)
        VP(Mka.dsn.Cp.CpSM.Retry,1) Verify that Cp retried the call to EthIf_MacSecInitRxSc.
    10: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to EthIf_MacSecInitRxSc one last time.
    11: VP(Mka.dsn.Cp.Retry,1)
        VP(Mka.dsn.Cp.CpSM.Retry,1) Verify that Cp retried the call to EthIf_MacSecInitRxSc for the last time and that EthIf_MacSecInitRxSc returned E_OK.
    12: Call function Mka_Cp_NewSak() to indicate that new SAK is ready and that CP isn't key server.
    13: VP(Mka.dsn.Cp.Retry,1)
        VP(Mka.dsn.Cp.CpSM.Retry,1) Verify that EthIf_MacSecAddRxSa has been called, indicating a successful state transition.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.Retry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1497</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Retry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1500</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1851</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01043_SecYRetry_CpSmWaitAddRxSa</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>1487</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that if EthIf_MacSecAddRxSa() returns E_NOT_OK while CpSm is in state CP_WAIT_ADD_RX_SA, the call shall be retried in next MainFunction tick. After the successful call to SecY, CpSm should make state transitions as expected.
Test Object: Software
Test Precondition: 
    -   CP unit initialized.
  
Test Execution: 
    01: Set SecY stub to return E_NOT_OK.
    02: Set the Cp state machine to the desired state.
    03: Call function Mka_Cp_NewSak() to indicate that new SAK is ready and notify CP that it isn't a key server.
    04: Sanity check - Check that EthIf_MacSecAddRxSa returned E_NOT_OK. Call to SecY shall be retried
    05: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to SecY.
    06: VP(Mka.dsn.Cp.Retry,1)
        VP(Mka.dsn.Cp.CpSM.Retry,1) Verify that Cp retried the call to SecY.
    07: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to SecY one last time.
    08: VP(Mka.dsn.Cp.Retry,1)
        VP(Mka.dsn.Cp.CpSM.Retry,1) Verify that Cp retried the call to SecY for the last time and that EthIf_MacSecAddRxSa returned E_OK.
    09: Call function Mka_Cp_MacSecAddRxSaNotification() to indicate that MacSecAddRxSa request has been processed.
    10: Call Mka_Cp_MainFunction() to run state machine and make necessary transitions.
    11: VP(Mka.dsn.Cp.Retry,1)
        VP(Mka.dsn.Cp.CpSM.Retry,1) Verify that EthIf_MacSecAddTxSa has been called, indicating a successful state transition.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.Retry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1497</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Retry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1500</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1852</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01044_SecYRetry_CpSmWaitAddTxSa</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>1522</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that if EthIf_MacSecAddTxSa() returns E_NOT_OK while CpSm is in state CP_WAIT_ADD_TX_SA, the call shall be retried in next MainFunction tick. After the successful call to SecY, CpSm should make state transitions as expected.
Test Object: Software
Test Precondition: 
    -   CP unit initialized.
  
Test Execution: 
    01: Set SecY stub to return E_NOT_OK.
    02: Set the Cp state machine to the desired state.
    03: Call function Mka_Cp_MacSecAddRxSaNotification() to indicate that MacSecAddRxSa request has been processed.
    04: Call Mka_Cp_MainFunction() to run state machine and make necessary transitions.
    05: Sanity check - Check that EthIf_MacSecAddTxSa returned E_NOT_OK. Call to SecY shall be retried
    06: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to SecY.
    07: VP(Mka.dsn.Cp.Retry,1)
        VP(Mka.dsn.Cp.CpSM.Retry,1) Verify that Cp retried the call to SecY.
    08: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to SecY one last time.
    09: VP(Mka.dsn.Cp.Retry,1)
        VP(Mka.dsn.Cp.CpSM.Retry,1) Verify that Cp retried the call to SecY for the last time and that EthIf_MacSecAddTxSa returned E_OK.
    10: Call function Mka_Cp_MacSecAddRxSaNotification() to indicate that EthIf_MacSecAddTxSa request has been processed.
    11: Call Mka_Cp_MainFunction() to run state machine and make necessary transitions.
    12: VP(Mka.dsn.Cp.Retry,1)
        VP(Mka.dsn.Cp.CpSM.Retry,1) Verify that a successful state transition has been made.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.Retry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1497</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Retry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1500</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1853</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01045_SecYRetry_CpSmTransmitting_Step0</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>1558</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that if EthIf_MacSecSetControlledPortEnabled() returns E_NOT_OK while CpSm is in state CP_TRANSMITTING (step_0), the call shall be retried in next MainFunction tick. After the successful call to SecY, CpSm should make state transitions as expected.
Test Object: Software
Test Precondition: 
    -   CP unit initialized.
  
Test Execution: 
    01: Set SecY stub to return E_NOT_OK.
    02: Set the Cp state machine to the desired state.
    03: Call function Mka_Cp_MainFunction() to allow the CpSm to make the transition to CP_TRANSMITTING.
    04: Sanity check - Check that EthIf_MacSecSetControlledPortEnabled returned E_NOT_OK. Call to SecY shall be retried
    05: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to SecY.
    06: VP(Mka.dsn.Cp.Retry,1)
        VP(Mka.dsn.Cp.CpSM.Retry,1) Verify that Cp retried the call to SecY.
    07: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to SecY one last time.
    08: VP(Mka.dsn.Cp.Retry,1)
        VP(Mka.dsn.Cp.CpSM.Retry,1) Verify that Cp retried the call to SecY for the last time and that EthIf_MacSecSetControlledPortEnabled returned E_OK.
    09: VP(Mka.dsn.Cp.Retry,1)
        VP(Mka.dsn.Cp.CpSM.Retry,1) Verify that a successful state transition has been made.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.Retry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1497</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Retry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1500</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1854</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01046_SecYRetry_CpSmTransmitting_Step1</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>1591</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that if EthIf_MacSecUpdateTxSa(TRUE) returns E_NOT_OK while CpSm is in state CP_TRANSMITTING (step_1), the call shall be retried in next MainFunction tick. After the successful call to SecY, CpSm should continue and make state transitions as expected.
Test Object: Software
Test Precondition: 
    -   CP unit initialized.
  
Test Execution: 
    01: Set SecY stub to return E_NOT_OK.
    02: Set the Cp state machine to the desired state.
    03: Call function Mka_Cp_MainFunction() to allow the CpSm to make the transition to CP_TRANSMITTING.
    04: Sanity check - Check that EthIf_MacSecUpdateTxSa(TRUE) returned E_NOT_OK. Call to SecY shall be retried
    05: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to SecY.
    06: VP(Mka.dsn.Cp.Retry,1)
        VP(Mka.dsn.Cp.CpSM.Retry,1) Verify that Cp retried the call to SecY.
    07: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to SecY one last time.
    08: VP(Mka.dsn.Cp.Retry,1)
        VP(Mka.dsn.Cp.CpSM.Retry,1) Verify that Cp retried the call to SecY for the last time and that EthIf_MacSecUpdateTxSa returned E_OK.
    09: VP(Mka.dsn.Cp.Retry,1)
        VP(Mka.dsn.Cp.CpSM.Retry,1) Verify that a successful state transition has been made.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.Retry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1497</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Retry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1500</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1855</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01047_SecYRetry_CpSmTransmitting_Step2</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>1624</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that if EthIf_MacSecUpdateTxSa(FALSE) returns E_NOT_OK while CpSm is in state CP_TRANSMITTING (step_2), the call shall be retried in next MainFunction tick. After the successful call to SecY, CpSm should continue and make state transitions as expected.
Test Object: Software
Test Precondition: 
    -   CP unit initialized.
  
Test Execution: 
    01: Set the Cp state machine to the desired state.
    02: Call function Mka_Cp_MacSecAddRxSaNotification() to indicate that MacSecAddRxSa request has been processed.
    03: Call function Mka_Cp_MacSecAddTxSaNotification() to indicate that EthIf_MacSecAddTxSa request has been processed.
    04: Set SecY stub to return E_NOT_OK.
    05: Call function EbTest_Cp_PeerReceivingAndTransmitting() to allow the CpSm to make the transition to CP_TRANSMITTING.
    06: Sanity check - Check that EthIf_MacSecUpdateTxSa(FALSE) returned E_NOT_OK. Call to SecY shall be retried
    07: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to SecY.
    08: VP(Mka.dsn.Cp.Retry,1)
        VP(Mka.dsn.Cp.CpSM.Retry,1) Verify that Cp retried the call to SecY.
    09: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to SecY one last time.
    10: VP(Mka.dsn.Cp.Retry,1)
        VP(Mka.dsn.Cp.CpSM.Retry,1) Verify that Cp retried the call to SecY for the last time and that EthIf_MacSecUpdateTxSa returned E_OK.
    11: VP(Mka.dsn.Cp.Retry,1)
        VP(Mka.dsn.Cp.CpSM.Retry,1) Verify that a successful state transition has been made.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.Retry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1497</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Retry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1500</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1856</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01048_SecYRetry_CpSmRetire_Step0</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>1659</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that if EthIf_MacSecDeleteTxSa() returns E_NOT_OK while CpSm is in state CP_RETIRE (step_0), the call shall be retried in next MainFunction tick. After the successful call to SecY, CpSm should continue and make state transitions as expected.
Test Object: Software
Test Precondition: 
    -   CP unit initialized.
  
Test Execution: 
    01: Reset SecY stubs.
    02: Set the Cp state to CP_TRANSMITTING, but go through CP_RETIRE beforehand. This is done so that Cp unit could call EthIf_MacSecDeleteTxSa as it will have Old and Latest Key in CP_RETIRE state.
    03: Prepare stubs for testing.
    04: Call function Mka_Cp_TimerCallback_RetireWhen() to transit from CP_TRANSMITTING to CP_RETIRE. This function call indicates that CP timer RetireWhen has expired.
    05: Sanity check - Check that EthIf_MacSecDeleteTxSa returned E_NOT_OK. Call to SecY shall be retried
    06: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to SecY.
    07: VP(Mka.dsn.Cp.Retry,1)
        VP(Mka.dsn.Cp.CpSM.Retry,1) Verify that Cp retried the call to SecY.
    08: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to SecY one last time.
    09: VP(Mka.dsn.Cp.Retry,1)
        VP(Mka.dsn.Cp.CpSM.Retry,1) Verify that Cp retried the call to SecY for the last time and that EthIf_MacSecDeleteTxSa returned E_OK.
    10: VP(Mka.dsn.Cp.Retry,1)
        VP(Mka.dsn.Cp.CpSM.Retry,1) Verify that a successful state transition has been made.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.Retry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1497</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Retry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1500</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1857</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01049_SecYRetry_CpSmRetire_Step1</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>1693</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that if EthIf_MacSecDeleteRxSa() returns E_NOT_OK while CpSm is in state CP_RETIRE (step_1), the call shall be retried in next MainFunction tick. After the successful call to SecY, CpSm should continue and make state transitions as expected.
Test Object: Software
Test Precondition: 
    -   CP unit initialized.
  
Test Execution: 
    01: Reset SecY stubs.
    02: Set the Cp state to CP_TRANSMITTING, but go through CP_RETIRE beforehand. This is done so that Cp unit could call EthIf_MacSecDeleteTxSa as it will have Old and Latest Key in CP_RETIRE state.
    03: Prepare stubs for testing.
    04: Call function Mka_Cp_TimerCallback_RetireWhen() to transit from CP_TRANSMITTING to CP_RETIRE. This function call indicates that CP timer RetireWhen has expired.
    05: Sanity check - Check that EthIf_MacSecDeleteRxSa returned E_NOT_OK. Call to SecY shall be retried
    06: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to SecY.
    07: VP(Mka.dsn.Cp.Retry,1)
        VP(Mka.dsn.Cp.CpSM.Retry,1) Verify that Cp retried the call to SecY.
    08: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to SecY one last time.
    09: VP(Mka.dsn.Cp.Retry,1)
        VP(Mka.dsn.Cp.CpSM.Retry,1) Verify that Cp retried the call to SecY for the last time and that EthIf_MacSecDeleteRxSa returned E_OK.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.Retry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1497</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Retry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1500</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1858</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01050_SecYRetry_CpSmUnsecured_Step0</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>1725</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that if EthIf_MacSecUpdateSecY() returns E_NOT_OK while CpSm is in state CP_UNSECURED (step_0), the call shall be retried in next MainFunction tick. After the successful call to SecY, CpSm should continue and make state transitions as expected.
Test Object: Software
Test Precondition: 
    -   CP unit initialized.
    -   Reset SecY stubs.
  
Test Execution: 
    01: Prepare stubs for testing.
    02: Call function Mka_Cp_DisableMacSec() to transition to CP_UNSECURED.
    03: Sanity check - Check that EthIf_MacSecUpdateSecY returned E_NOT_OK. Call to SecY shall be retried
    04: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to SecY.
    05: VP(Mka.dsn.Cp.Retry,1)
        VP(Mka.dsn.Cp.CpSM.Retry,1) Verify that Cp retried the call to SecY.
    06: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to SecY one last time.
    07: VP(Mka.dsn.Cp.Retry,1)
        VP(Mka.dsn.Cp.CpSM.Retry,1) Verify that Cp retried the call to SecY for the last time and that EthIf_MacSecUpdateSecY returned E_OK.
    08: Call function Mka_Cp_MacSecUpdateSecYNotification() to simulate that MacSecUpdateSecY request has been finished.
    09: Call Mka_Cp_MainFunction to tick main function.
    10: VP(Mka.dsn.Cp.Retry,1)
        VP(Mka.dsn.Cp.CpSM.Retry,1) Verify that Cp continued as expected.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.Retry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1497</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Retry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1500</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1859</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01051_SecYRetry_CpSmUnsecured_Step1</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>1760</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that if EthIf_MacSecOperational() returns E_NOT_OK while CpSm is in state CP_UNSECURED (step_1), the call shall be retried in next MainFunction tick. After the successful call to SecY, CpSm should continue and make state transitions as expected.
Test Object: Software
Test Precondition: 
    -   CP unit initialized.
    -   Reset SecY stubs.
  
Test Execution: 
    01: Prepare stubs for testing.
    02: Call function Mka_Cp_DisableMacSec() to transition to CP_UNSECURED.
    03: Sanity check - Sanity check.
    04: Call function Mka_Cp_MacSecUpdateSecYNotification() to simulate that MacSecUpdateSecY request has been finished.
    05: Call Mka_Cp_MainFunction to tick main function.
    06: Sanity check - Check that EthIf_MacSecOperational returned E_NOT_OK. Call to SecY shall be retried.
    07: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to SecY.
    08: VP(Mka.dsn.Cp.Retry,1)
        VP(Mka.dsn.Cp.CpSM.Retry,1) Verify that Cp retried the call to SecY.
    09: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to SecY one last time.
    10: VP(Mka.dsn.Cp.Retry,1)
        VP(Mka.dsn.Cp.CpSM.Retry,1) Verify that Cp retried the call to SecY for the last time and that EthIf_MacSecOperational returned E_OK.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.Retry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1497</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Retry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1500</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1860</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01052_SecYRetry_CpSmDelete_Step0</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>1794</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that if EthIf_MacSecSetControlledPortEnabled() returns E_NOT_OK while CpSm is in state CP_DELETE (step_0), the call shall be retried in next MainFunction tick. After the successful call to SecY, CpSm should continue and make state transitions as expected.
Test Object: Software
Test Precondition: 
    -   CP unit initialized.
  
Test Execution: 
    01: Reset SecY stubs.
    02: Set the Cp state to CP_TRANSMITTING, but go through CP_RETIRE beforehand. This is done so Cp unit could call EthIf_MacSecDeleteTxSa as it will have both Old and Latest Key.
    03: Prepare stubs for testing.
    04: Call function Mka_Cp_LinkStateDown() to transition to CP_DELETE.
    05: Sanity check - Check that EthIf_MacSecSetControlledPortEnabled returned E_NOT_OK. Call to SecY shall be retried.
    06: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to SecY.
    07: VP(Mka.dsn.Cp.Retry,1)
        VP(Mka.dsn.Cp.CpSM.Retry,1) Verify that Cp retried the call to SecY.
    08: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to SecY one last time.
    09: VP(Mka.dsn.Cp.Retry,1)
        VP(Mka.dsn.Cp.CpSM.Retry,1) Verify that Cp retried the call to SecY for the last time and that EthIf_MacSecSetControlledPortEnabled returned E_OK.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.Retry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1497</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Retry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1500</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1861</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01053_SecYRetry_CpSmDelete_Step1</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>1826</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that if EthIf_MacSecResetRxSc() returns E_NOT_OK while CpSm is in state CP_DELETE (step_1), the call shall be retried in next MainFunction tick. After the successful call to SecY, CpSm should continue and make state transitions as expected.
Test Object: Software
Test Precondition: 
    -   CP unit initialized.
  
Test Execution: 
    01: Reset SecY stubs.
    02: Set the Cp state to CP_TRANSMITTING, but go through CP_RETIRE beforehand. This is done so Cp unit could call EthIf_MacSecDeleteRxSa as it will have both Old and Latest Key.
    03: Prepare stubs for testing.
    04: Call function Mka_Cp_LinkStateDown() to transition to CP_DELETE.
    05: Sanity check - Check that EthIf_MacSecResetRxSc returned E_NOT_OK. Call to SecY shall be retried.
    06: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to SecY.
    07: VP(Mka.dsn.Cp.Retry,1)
        VP(Mka.dsn.Cp.CpSM.Retry,1) Verify that Cp retried the call to SecY.
    08: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to SecY one last time.
    09: VP(Mka.dsn.Cp.Retry,1)
        VP(Mka.dsn.Cp.CpSM.Retry,1) Verify that Cp retried the call to SecY for the last time and that EthIf_MacSecResetRxSc returned E_OK.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.Retry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1497</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Retry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1500</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1862</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01054_SecYRetry_CpSmDelete_Step2</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>1858</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that if EthIf_MacSecDeleteTxSa() returns E_NOT_OK while CpSm is in state CP_DELETE (step_2), the call shall be retried in next MainFunction tick. After the successful call to SecY, CpSm should continue and make state transitions as expected.
Test Object: Software
Test Precondition: 
    -   CP unit initialized.
  
Test Execution: 
    01: Reset SecY stubs.
    02: Set the Cp state to CP_TRANSMITTING, but go through CP_RETIRE beforehand. This is done so Cp unit could call EthIf_MacSecDeleteTxSa as it will have both Old and Latest Key.
    03: Prepare stubs for testing.
    04: Call function Mka_Cp_LinkStateDown() to transition to CP_DELETE.
    05: Sanity check - Check that EthIf_MacSecDeleteTxSa returned E_NOT_OK. Call to SecY shall be retried.
    06: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to SecY.
    07: VP(Mka.dsn.Cp.Retry,1)
        VP(Mka.dsn.Cp.CpSM.Retry,1) Verify that Cp retried the call to SecY.
    08: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to SecY one last time.
    09: VP(Mka.dsn.Cp.Retry,1)
        VP(Mka.dsn.Cp.CpSM.Retry,1) Verify that Cp retried the call to SecY for the last time and that EthIf_MacSecDeleteTxSa returned E_OK.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.Retry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1497</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Retry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1500</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1863</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01055_SecYRetry_CpSmDelete_Step3</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>1890</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that if EthIf_MacSecDeleteRxSa() returns E_NOT_OK while CpSm is in state CP_DELETE (step_3), the call shall be retried in next MainFunction tick. After the successful call to SecY, CpSm should continue and make state transitions as expected.
Test Object: Software
Test Precondition: 
    -   CP unit initialized.
  
Test Execution: 
    01: Reset SecY stubs.
    02: Set the Cp state to CP_TRANSMITTING, but go through CP_RETIRE beforehand. This is done so Cp unit could call EthIf_MacSecDeleteTxSa as it will have both Old and Latest Key.
    03: Prepare stubs for testing.
    04: Call function Mka_Cp_LinkStateDown() to transition to CP_DELETE.
    05: Sanity check - Check that EthIf_MacSecDeleteRxSa returned E_NOT_OK. Call to SecY shall be retried.
    06: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to SecY.
    07: VP(Mka.dsn.Cp.Retry,1)
        VP(Mka.dsn.Cp.CpSM.Retry,1) Verify that Cp retried the call to SecY.
    08: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to SecY one last time.
    09: VP(Mka.dsn.Cp.Retry,1)
        VP(Mka.dsn.Cp.CpSM.Retry,1) Verify that Cp retried the call to SecY for the last time and that EthIf_MacSecDeleteRxSa returned E_OK.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.Retry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1497</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Retry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1500</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1864</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01056_SecYRetry_CpSmDelete_Step4</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>1922</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that if EthIf_MacSecDeleteTxSa() returns E_NOT_OK while CpSm is in state CP_DELETE (step_4), the call shall be retried in next MainFunction tick. After the successful call to SecY, CpSm should continue and make state transitions as expected.
Test Object: Software
Test Precondition: 
    -   CP unit initialized.
  
Test Execution: 
    01: Reset SecY stubs.
    02: Set the Cp state to CP_TRANSMITTING, but go through CP_RETIRE beforehand. This is done so Cp unit could call EthIf_MacSecDeleteTxSa as it will have both Old and Latest Key.
    03: Prepare stubs for testing.
    04: Call function Mka_Cp_LinkStateDown() to transition to CP_DELETE.
    05: Sanity check - Check that EthIf_MacSecDeleteTxSa returned E_NOT_OK. Call to SecY shall be retried.
    06: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to SecY.
    07: VP(Mka.dsn.Cp.Retry,1)
        VP(Mka.dsn.Cp.CpSM.Retry,1) Verify that Cp retried the call to SecY.
    08: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to SecY one last time.
    09: VP(Mka.dsn.Cp.Retry,1)
        VP(Mka.dsn.Cp.CpSM.Retry,1) Verify that Cp retried the call to SecY for the last time and that EthIf_MacSecDeleteTxSa returned E_OK.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.Retry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1497</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Retry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1500</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1865</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01057_SecYRetry_CpSmDelete_Step5</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>1954</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that if EthIf_MacSecDeleteRxSa() returns E_NOT_OK while CpSm is in state CP_DELETE (step_5), the call shall be retried in next MainFunction tick. After the successful call to SecY, CpSm should continue and make state transitions as expected.
Test Object: Software
Test Precondition: 
    -   CP unit initialized.
  
Test Execution: 
    01: Reset SecY stubs.
    02: Set the Cp state to CP_TRANSMITTING, but go through CP_RETIRE beforehand. This is done so Cp unit could call EthIf_MacSecDeleteRxSa as it will have both Old and Latest Key.
    03: Prepare stubs for testing.
    04: Call function Mka_Cp_LinkStateDown() to transition to CP_DELETE.
    05: Sanity check - Check that EthIf_MacSecDeleteRxSa returned E_NOT_OK. Call to SecY shall be retried.
    06: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to SecY.
    07: VP(Mka.dsn.Cp.Retry,1)
        VP(Mka.dsn.Cp.CpSM.Retry,1) Verify that Cp retried the call to SecY.
    08: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to SecY one last time.
    09: VP(Mka.dsn.Cp.Retry,1)
        VP(Mka.dsn.Cp.CpSM.Retry,1) Verify that Cp retried the call to SecY for the last time and that EthIf_MacSecDeleteRxSa returned E_OK.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.Retry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1497</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Retry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1500</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1866</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01058_SecYRetry_CpSmDelete_Step6</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>1986</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that if EthIf_MacSecOperational() returns E_NOT_OK while CpSm is in state CP_DELETE (step_6), the call shall be retried in next MainFunction tick. After the successful call to SecY, CpSm should continue and make state transitions as expected.
Test Object: Software
Test Precondition: 
    -   CP unit initialized.
  
Test Execution: 
    01: Reset SecY stubs.
    02: Set the Cp state to CP_TRANSMITTING, but go through CP_RETIRE beforehand. This is done so Cp unit could call EthIf_MacSecDeleteTxSa as it will have both Old and Latest Key.
    03: Prepare stubs for testing.
    04: Call function Mka_Cp_LinkStateDown() to transition to CP_DELETE.
    05: Sanity check - Check that EthIf_MacSecOperational returned E_NOT_OK. Call to SecY shall be retried.
    06: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to SecY.
    07: VP(Mka.dsn.Cp.Retry,1)
        VP(Mka.dsn.Cp.CpSM.Retry,1) Verify that Cp retried the call to SecY.
    08: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to SecY one last time.
    09: VP(Mka.dsn.Cp.Retry,1)
        VP(Mka.dsn.Cp.CpSM.Retry,1) Verify that Cp retried the call to SecY for the last time and that EthIf_MacSecOperational returned E_OK.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.Retry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1497</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Retry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1500</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1867</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01059_SecYRetry_Fail_CpSmUpdateSecY</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>2018</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that if EthIf_MacSecUpdateSecY() returns E_NOT_OK while CpSm is in state CP_UPDATE_SECY, the call shall be retried in next MainFunction tick. After too many failed calls to SecY, CpSm should transitions to state CP_DELETE and then CP_UNINIT.
Test Object: Software
Test Precondition: 
    -   CP unit initialized.
  
Test Execution: 
    01: Set SecY stub to return E_NOT_OK.
    02: Call function Mka_Cp_SetCipherSuite() to simulate call from Logon that selected PAE can be initialized. CpSM shall transition to CP_UPDATE_SECY.
    03: Sanity check - Check that EthIf_MacSecUpdateSecY returned E_NOT_OK.
    04: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to SecY.
    05: Sanity check - Check that Cp retried the call to SecY.
    06: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to SecY one last time.
    07: Sanity check - Check that Cp retried the call to SecY for the last time and that EthIf_MacSecUpdateSecY returned E_NOT_OK.
    08: VP(Mka.EB.RunTimeEvent.BitFieldDefinition,1)
        VP(Mka.EB.RunTimeEvent.TriggeredEventPae,1) Verify that, after SecY calls have been retried too many times, a bit for that event has been set for the selected Pae.
    09: VP(Mka.dsn.Cp.CpSM.Retry.CleanUp,1)
        VP(Mka.dsn.Cp.CpSM.Retry,1) Verify that a transition to state CP_DELETE has been made because the SecY retries exceeded the maximum configured number of retries.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.RunTimeEvent.BitFieldDefinition</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1478</internalId></provcov>
        <provcov>
          <linksto>Mka.EB.RunTimeEvent.TriggeredEventPae</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1480</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Retry.CleanUp</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1499</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Retry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1500</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1868</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01060_SecYRetry_Fail_CpSmInitRxSc</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>2058</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that if EthIf_MacSecInitRxSc() returns E_NOT_OK while CpSm is in state CP_INIT_RX_SC, the call shall be retried in next MainFunction tick. After too many failed calls to SecY, CpSm should transitions to state CP_DELETE and then CP_UNINIT.
Test Object: Software
Test Precondition: 
    -   CP unit initialized.
  
Test Execution: 
    01: Set EthIf_MacSecInitRxSc stub to return E_NOT_OK.
    02: Call function Mka_Cp_SetCipherSuite() to simulate call from Logon that selected PAE can be initialized. CpSM shall transition to Cp_Update_SecY.
    03: Sanity check - Check that EthIf_MacSecInitRxSc returned E_OK. CpSm shall transition to CP_WAIT_RX_SC
    04: Call function Mka_Cp_MacSecUpdateSecYNotification() to simulate that MacSecUpdateSecY request has been finished.
    05: Call Mka_Cp_MainFunction to tick main function.
    06: Call Mka_Cp_InitRxSc to give PeerSci to Cp SM and thus enable the Cp SM to transition to CP_INIT_RX_SC.
    07: Sanity check - Check that EthIf_MacSecInitRxSc returned E_NOT_OK. Call to EthIf_MacSecInitRxSc shall be retried
    08: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to EthIf_MacSecInitRxSc.
    09: Sanity check - Check that Cp retried the call to EthIf_MacSecInitRxSc.
    10: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to EthIf_MacSecInitRxSc one last time.
    11: Sanity check - Check that Cp retried the call to EthIf_MacSecInitRxSc for the last time and that EthIf_MacSecInitRxSc returned E_NOT_OK.
    12: VP(Mka.dsn.Cp.CpSM.Retry.CleanUp,1)
        VP(Mka.dsn.Cp.CpSM.Retry,1) Verify that a transition to state CP_DELETE has been made because the SecY retries exceeded the maximum configured number of retries.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Retry.CleanUp</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1499</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Retry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1500</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1869</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01061_SecYRetry_Fail_CpSmWaitAddRxSa</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>2092</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that if EthIf_MacSecAddRxSa() returns E_NOT_OK while CpSm is in state CP_WAIT_ADD_RX_SA, the call shall be retried in next MainFunction tick. After too many failed calls to SecY, CpSm should transitions to state CP_DELETE and then CP_UNINIT.
Test Object: Software
Test Precondition: 
    -   CP unit initialized.
  
Test Execution: 
    01: Set SecY stub to return E_NOT_OK.
    02: Set the Cp state machine to the desired state.
    03: Call function Mka_Cp_NewSak() to indicate that new SAK is ready and notify CP that it isn't a key server.
    04: Sanity check - Check that EthIf_MacSecAddRxSa returned E_NOT_OK. Call to SecY shall be retried
    05: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to SecY.
    06: Sanity check - Check that Cp retried the call to SecY.
    07: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to SecY one last time.
    08: Sanity check - Check that Cp retried the call to SecY for the last time and that EthIf_MacSecAddRxSa returned E_NOT_OK.
    09: VP(Mka.dsn.Cp.CpSM.Retry.CleanUp,1)
        VP(Mka.dsn.Cp.CpSM.Retry,1) Verify that a transition to state CP_DELETE has been made because the SecY retries exceeded the maximum configured number of retries.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Retry.CleanUp</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1499</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Retry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1500</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1870</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01062_SecYRetry_Fail_CpSmWaitAddTxSa</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>2123</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that if EthIf_MacSecAddTxSa() returns E_NOT_OK while CpSm is in state CP_WAIT_ADD_TX_SA, the call shall be retried in next MainFunction tick. After too many failed calls to SecY, CpSm should transitions to state CP_DELETE and then CP_UNINIT.
Test Object: Software
Test Precondition: 
    -   CP unit initialized.
  
Test Execution: 
    01: Set SecY stub to return E_NOT_OK.
    02: Set the Cp state machine to the desired state.
    03: Call function Mka_Cp_MacSecAddRxSaNotification() to indicate that MacSecAddRxSa request has been processed.
    04: Call Mka_Cp_MainFunction() to run state machine and make necessary transitions.
    05: Sanity check - Check that EthIf_MacSecAddTxSa returned E_NOT_OK. Call to SecY shall be retried
    06: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to SecY.
    07: Sanity check - Check that Cp retried the call to SecY.
    08: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to SecY one last time.
    09: Sanity check - Check that Cp retried the call to SecY for the last time and that EthIf_MacSecAddTxSa returned E_NOT_OK.
    10: VP(Mka.dsn.Cp.CpSM.Retry.CleanUp,1)
        VP(Mka.dsn.Cp.CpSM.Retry,1) Verify that a transition to state CP_DELETE has been made because the SecY retries exceeded the maximum configured number of retries.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Retry.CleanUp</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1499</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Retry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1500</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1871</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01063_SecYRetry_Fail_CpSmTransmitting_Step0</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>2155</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that if EthIf_MacSecSetControlledPortEnabled() returns E_NOT_OK while CpSm is in state CP_TRANSMITTING (step_0), the call shall be retried in next MainFunction tick. After too many failed calls to SecY, CpSm should transitions to state CP_DELETE and then CP_UNINIT.
Test Object: Software
Test Precondition: 
    -   CP unit initialized.
  
Test Execution: 
    01: Set SecY stub to return E_NOT_OK.
    02: Set the Cp state machine to the desired state.
    03: Call function Mka_Cp_MainFunction() to allow the CpSm to make the transition to CP_TRANSMITTING.
    04: Sanity check - Check that EthIf_MacSecSetControlledPortEnabled returned E_NOT_OK. Call to SecY shall be retried
    05: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to SecY.
    06: Sanity check - Check that Cp retried the call to SecY.
    07: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to SecY one last time.
    08: Sanity check - Check that Cp retried the call to SecY for the last time and that EthIf_MacSecSetControlledPortEnabled returned E_NOT_OK.
    09: VP(Mka.dsn.Cp.CpSM.Retry.CleanUp,1)
        VP(Mka.dsn.Cp.CpSM.Retry,1)
        VP(Mka.InterAct.Cp.SecYRetry_Exhausted,1) Verify that a transition to state CP_DELETE has been made because the SecY retries exceeded the maximum configured number of retries.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Retry.CleanUp</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1499</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Retry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1500</internalId></provcov>
        <provcov>
          <linksto>Mka.InterAct.Cp.SecYRetry_Exhausted</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1108</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1872</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01064_SecYRetry_Fail_CpSmTransmitting_Step1</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>2191</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that if EthIf_MacSecUpdateTxSa(TRUE) returns E_NOT_OK while CpSm is in state CP_TRANSMITTING (step_1), the call shall be retried in next MainFunction tick. After too many failed calls to SecY, CpSm should transitions to state CP_DELETE and then CP_UNINIT.
Test Object: Software
Test Precondition: 
    -   CP unit initialized.
  
Test Execution: 
    01: Reset SecY stubs.
    02: Set the Cp state machine to the desired state.
    03: Set SecY stub to return E_NOT_OK.
    04: Call function Mka_Cp_MainFunction() to allow the CpSm to make the transition to CP_TRANSMITTING.
    05: Sanity check - Check that EthIf_MacSecUpdateTxSa(TRUE) returned E_NOT_OK. Call to SecY shall be retried
    06: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to SecY.
    07: Sanity check - Check that Cp retried the call to SecY.
    08: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to SecY one last time.
    09: Sanity check - Check that Cp retried the call to SecY for the last time and that EthIf_MacSecUpdateTxSa returned E_OK.
    10: VP(Mka.dsn.Cp.CpSM.Retry.CleanUp,1)
        VP(Mka.dsn.Cp.CpSM.Retry,1) Verify that a transition to state CP_DELETE has been made because the SecY retries exceeded the maximum configured number of retries.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Retry.CleanUp</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1499</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Retry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1500</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1873</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01065_SecYRetry_Fail_CpSmTransmitting_Step2</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>2223</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that if EthIf_MacSecUpdateTxSa(FALSE) returns E_NOT_OK while CpSm is in state CP_TRANSMITTING (step_2), the call shall be retried in next MainFunction tick. After too many failed calls to SecY, CpSm should transitions to state CP_DELETE and then CP_UNINIT.
Test Object: Software
Test Precondition: 
    -   CP unit initialized.
  
Test Execution: 
    01: Set SecY stub to return E_NOT_OK.
    02: Set the Cp state machine to the desired state.
    03: Call function Mka_Cp_MainFunction() to allow the CpSm to make the transition to CP_TRANSMITTING.
    04: Sanity check - Check that EthIf_MacSecUpdateTxSa(FALSE) returned E_NOT_OK. Call to SecY shall be retried
    05: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to SecY.
    06: Sanity check - Check that Cp retried the call to SecY.
    07: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to SecY one last time.
    08: Sanity check - Check that Cp retried the call to SecY for the last time and that EthIf_MacSecUpdateTxSa returned E_NOT_OK.
    09: VP(Mka.dsn.Cp.CpSM.Retry.CleanUp,1)
        VP(Mka.dsn.Cp.CpSM.Retry,1) Verify that a transition to state CP_DELETE has been made because the SecY retries exceeded the maximum configured number of retries.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Retry.CleanUp</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1499</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Retry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1500</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1874</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01066_SecYRetry_Fail_CpSmRetire_Step0</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>2254</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that if EthIf_MacSecDeleteTxSa() returns E_NOT_OK while CpSm is in state CP_RETIRE (step_0), the call shall be retried in next MainFunction tick. After too many failed calls to SecY, CpSm should transitions to state CP_UNINIT.
Test Object: Software
Test Precondition: 
    -   CP unit initialized.
  
Test Execution: 
    01: Reset SecY stubs.
    02: Set the Cp state to CP_TRANSMITTING, but go through CP_RETIRE beforehand. This is done so that Cp unit could call EthIf_MacSecDeleteTxSa as it will have Old and Latest Key in CP_RETIRE state.
    03: Prepare stubs for testing.
    04: Call function Mka_Cp_TimerCallback_RetireWhen() to transit from CP_TRANSMITTING to CP_RETIRE. This function call indicates that CP timer RetireWhen has expired.
    05: Sanity check - Check that EthIf_MacSecDeleteTxSa returned E_NOT_OK. Call to SecY shall be retried
    06: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to SecY.
    07: Sanity check - Check that Cp retried the call to SecY.
    08: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to SecY one last time.
    09: Sanity check - Check that Cp retried the call to SecY for the last time and that EthIf_MacSecDeleteTxSa returned E_NOT_OK.
    10: Call Mka_Cp_MainFunction to tick main function. Cp shall call Mka_Logon_Pae_Restart.
    11: VP(Mka.dsn.Cp.CpSM.Retry.CleanUp,1)
        VP(Mka.dsn.Cp.CpSM.Retry,1)
        VP(Mka.dsn.Cp.CpSM.Delete_2_Restart,1) Verify that a transition to state CP_RESTART, and then to CP_UNINIT, has been made because the SecY retries exceeded the maximum configured number of retries.
    12: Sanity check - Call Mka_Cp_MainFunction to tick main function. Cp shall not call any API because it is in state CP_UNINIT.
    13: VP(Mka.dsn.Cp.CpSM.Restart_2_Uninit,1) Verify that, after the main function tick, before which the Cp SM was in state CP_RESTART (call to Mka_Logon_Pae_Restart), the Cp SM transitioned to CP_UNINIT and didn't make any other API calls.
    14: Call function Mka_Cp_SetCipherSuite() to verify that transition to CP_UNINIT has actually been made.
    15: VP(Mka.dsn.Cp.CpSM.Restart_2_Uninit,1) Verify that a call to Mka_Cp_SetCipherSuite was successful, which implies that the CP StateMachine did indeed transition to CP_UNINIT beforehand.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Retry.CleanUp</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1499</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Retry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1500</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Delete_2_Restart</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1393</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Restart_2_Uninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1388</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1875</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01067_SecYRetry_Fail_CpSmRetire_Step1</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>2300</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that if EthIf_MacSecDeleteRxSa() returns E_NOT_OK while CpSm is in state CP_RETIRE (step_1), the call shall be retried in next MainFunction tick. After too many failed calls to SecY, CpSm should transitions to state CP_UNINIT.
Test Object: Software
Test Precondition: 
    -   CP unit initialized.
  
Test Execution: 
    01: Reset SecY stubs.
    02: Set the Cp state to CP_TRANSMITTING, but go through CP_RETIRE beforehand. This is done so that Cp unit could call EthIf_MacSecDeleteTxSa as it will have Old and Latest Key in CP_RETIRE state.
    03: Prepare stubs for testing.
    04: Call function Mka_Cp_TimerCallback_RetireWhen() to transit from CP_TRANSMITTING to CP_RETIRE. This function call indicates that CP timer RetireWhen has expired.
    05: Sanity check - Check that EthIf_MacSecDeleteTxSa returned E_NOT_OK. Call to SecY shall be retried
    06: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to SecY.
    07: Sanity check - Check that Cp retried the call to SecY.
    08: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to SecY one last time.
    09: Sanity check - Check that Cp retried the call to SecY for the last time and that EthIf_MacSecDeleteRxSa returned E_NOT_OK.
    10: Call Mka_Cp_MainFunction to tick main function. Cp shall call Mka_Logon_Pae_Restart.
    11: VP(Mka.dsn.Cp.CpSM.Retry.CleanUp,1)
        VP(Mka.dsn.Cp.CpSM.Retry,1) Verify that a transition to state CP_UNINIT has been made because the SecY retries exceeded the maximum configured number of retries.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Retry.CleanUp</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1499</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Retry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1500</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1876</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01068_SecYRetry_Fail_CpSmUnsecured_Step0</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>2333</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that if EthIf_MacSecUpdateSecY() returns E_NOT_OK while CpSm is in state CP_UNSECURED (step_0), the call shall be retried in next MainFunction tick. After too many failed calls to SecY, CpSm should transitions to state CP_DELETE and then CP_UNINIT.
Test Object: Software
Test Precondition: 
    -   CP unit initialized.
    -   Reset SecY stubs.
  
Test Execution: 
    01: Prepare stubs for testing.
    02: Call function Mka_Cp_DisableMacSec() to transition to CP_UNSECURED.
    03: Sanity check - Check that EthIf_MacSecUpdateSecY returned E_NOT_OK. Call to SecY shall be retried
    04: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to SecY.
    05: Sanity check - Check that Cp retried the call to SecY.
    06: Call function Mka_Cp_MacSecUpdateSecYNotification() to simulate that MacSecUpdateSecY request has been finished.
    07: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to SecY one last time.
    08: Sanity check - Check that Cp retried the call to SecY for the last time and that EthIf_MacSecUpdateSecY returned E_NOT_OK.
    09: VP(Mka.dsn.Cp.CpSM.Retry.CleanUp,1)
        VP(Mka.dsn.Cp.CpSM.Retry,1) Verify that a transition to state CP_DELETE has been made because the SecY retries exceeded the maximum configured number of retries.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Retry.CleanUp</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1499</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Retry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1500</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1877</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01069_SecYRetry_Fail_CpSmUnsecured_Step1</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>2365</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that if EthIf_MacSecOperational() returns E_NOT_OK while CpSm is in state CP_UNSECURED (step_1), the call shall be retried in next MainFunction tick. After too many failed calls to SecY, CpSm should transitions to state CP_DELETE and then CP_UNINIT.
Test Object: Software
Test Precondition: 
    -   CP unit initialized.
    -   Reset SecY stubs.
  
Test Execution: 
    01: Prepare stubs for testing.
    02: Call function Mka_Cp_DisableMacSec() to transition to CP_UNSECURED.
    03: Sanity check - Sanity check.
    04: Call function Mka_Cp_MacSecUpdateSecYNotification() to simulate that MacSecUpdateSecY request has been finished.
    05: Call Mka_Cp_MainFunction to tick main function.
    06: Sanity check - Check that EthIf_MacSecOperational returned E_NOT_OK. Call to SecY shall be retried.
    07: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to SecY.
    08: Sanity check - Check that Cp retried the call to SecY.
    09: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to SecY one last time.
    10: Sanity check - Check that Cp retried the call to SecY for the last time and that EthIf_MacSecOperational returned E_NOT_OK.
    11: VP(Mka.dsn.Cp.CpSM.Retry.CleanUp,1)
        VP(Mka.dsn.Cp.CpSM.Retry,1) Verify that a transition to state CP_DELETE has been made because the SecY retries exceeded the maximum configured number of retries.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Retry.CleanUp</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1499</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Retry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1500</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1878</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01070_SecYRetry_Fail_CpSmDelete_Step0</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>2399</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that if EthIf_MacSecSetControlledPortEnabled() returns E_NOT_OK while CpSm is in state CP_DELETE (step_0), the call shall be retried in next MainFunction tick. After too many failed calls to SecY, CpSm should transitions to stateCP_UNINIT.
Test Object: Software
Test Precondition: 
    -   CP unit initialized.
  
Test Execution: 
    01: Reset SecY stubs.
    02: Set the Cp state to CP_TRANSMITTING, but go through CP_RETIRE beforehand. This is done so Cp unit could call EthIf_MacSecDeleteTxSa as it will have both Old and Latest Key.
    03: Prepare stubs for testing.
    04: Call function Mka_Cp_LinkStateDown() to transition to CP_DELETE.
    05: Sanity check - Check that EthIf_MacSecSetControlledPortEnabled returned E_NOT_OK. Call to SecY shall be retried.
    06: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to SecY.
    07: Sanity check - Check that Cp retried the call to SecY.
    08: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to SecY one last time.
    09: Sanity check - Check that Cp retried the call to SecY for the last time and that EthIf_MacSecSetControlledPortEnabled returned E_NOT_OK.
    10: Call Mka_Cp_MainFunction to tick main function. Cp shall call Mka_Logon_Pae_Restart.
    11: VP(Mka.dsn.Cp.CpSM.Retry.CleanUp,1)
        VP(Mka.dsn.Cp.CpSM.Retry,1) Verify that a transition to state CP_UNINIT has been made because the SecY retries exceeded the maximum configured number of retries.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Retry.CleanUp</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1499</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Retry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1500</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1879</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01071_SecYRetry_Fail_CpSmDelete_Step1</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>2432</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that if EthIf_MacSecResetRxSc() returns E_NOT_OK while CpSm is in state CP_DELETE (step_1), the call shall be retried in next MainFunction tick. After too many failed calls to SecY, CpSm should transitions to state CP_UNINIT.
Test Object: Software
Test Precondition: 
    -   CP unit initialized.
  
Test Execution: 
    01: Reset SecY stubs.
    02: Set the Cp state to CP_TRANSMITTING, but go through CP_RETIRE beforehand. This is done so Cp unit could call EthIf_MacSecDeleteRxSa as it will have both Old and Latest Key.
    03: Prepare stubs for testing.
    04: Call function Mka_Cp_LinkStateDown() to transition to CP_DELETE.
    05: Sanity check - Check that EthIf_MacSecResetRxSc returned E_NOT_OK. Call to SecY shall be retried.
    06: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to SecY.
    07: Sanity check - Check that Cp retried the call to SecY.
    08: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to SecY one last time.
    09: Sanity check - Check that Cp retried the call to SecY for the last time and that EthIf_MacSecResetRxSc returned E_NOT_OK.
    10: Call Mka_Cp_MainFunction to tick main function. Cp shall call Mka_Logon_Pae_Restart.
    11: VP(Mka.dsn.Cp.CpSM.Retry.CleanUp,1)
        VP(Mka.dsn.Cp.CpSM.Retry,1) Verify that a transition to state CP_UNINIT has been made because the SecY retries exceeded the maximum configured number of retries.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Retry.CleanUp</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1499</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Retry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1500</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1880</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01072_SecYRetry_Fail_CpSmDelete_Step2</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>2465</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that if EthIf_MacSecDeleteTxSa() returns E_NOT_OK while CpSm is in state CP_DELETE (step_2), the call shall be retried in next MainFunction tick. After too many failed calls to SecY, CpSm should transitions to state CP_UNINIT.
Test Object: Software
Test Precondition: 
    -   CP unit initialized.
  
Test Execution: 
    01: Reset SecY stubs.
    02: Set the Cp state to CP_TRANSMITTING, but go through CP_RETIRE beforehand. This is done so Cp unit could call EthIf_MacSecDeleteTxSa as it will have both Old and Latest Key.
    03: Prepare stubs for testing.
    04: Call function Mka_Cp_LinkStateDown() to transition to CP_DELETE.
    05: Sanity check - Check that EthIf_MacSecDeleteTxSa returned E_NOT_OK. Call to SecY shall be retried.
    06: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to SecY.
    07: Sanity check - Check that Cp retried the call to SecY.
    08: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to SecY one last time.
    09: Sanity check - Check that Cp retried the call to SecY for the last time and that EthIf_MacSecDeleteTxSa returned E_NOT_OK.
    10: Call Mka_Cp_MainFunction to tick main function. Cp shall call Mka_Logon_Pae_Restart.
    11: VP(Mka.dsn.Cp.CpSM.Retry.CleanUp,1)
        VP(Mka.dsn.Cp.CpSM.Retry,1) Verify that a transition to state CP_UNINIT has been made because the SecY retries exceeded the maximum configured number of retries.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Retry.CleanUp</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1499</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Retry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1500</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1881</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01073_SecYRetry_Fail_CpSmDelete_Step3</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>2498</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that if EthIf_MacSecDeleteRxSa() returns E_NOT_OK while CpSm is in state CP_DELETE (step_3), the call shall be retried in next MainFunction tick. After too many failed calls to SecY, CpSm should transitions to state CP_UNINIT.
Test Object: Software
Test Precondition: 
    -   CP unit initialized.
  
Test Execution: 
    01: Reset SecY stubs.
    02: Set the Cp state to CP_TRANSMITTING, but go through CP_RETIRE beforehand. This is done so Cp unit could call EthIf_MacSecDeleteTxSa as it will have both Old and Latest Key.
    03: Prepare stubs for testing.
    04: Call function Mka_Cp_LinkStateDown() to transition to CP_DELETE.
    05: Sanity check - Check that EthIf_MacSecDeleteRxSa returned E_NOT_OK. Call to SecY shall be retried.
    06: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to SecY.
    07: Sanity check - Check that Cp retried the call to SecY.
    08: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to SecY one last time.
    09: Sanity check - Check that Cp retried the call to SecY for the last time and that EthIf_MacSecDeleteRxSa returned E_NOT_OK.
    10: Call Mka_Cp_MainFunction to tick main function. Cp shall call Mka_Logon_Pae_Restart.
    11: VP(Mka.dsn.Cp.CpSM.Retry.CleanUp,1)
        VP(Mka.dsn.Cp.CpSM.Retry,1) Verify that a transition to state CP_UNINIT has been made because the SecY retries exceeded the maximum configured number of retries.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Retry.CleanUp</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1499</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Retry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1500</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1882</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01074_SecYRetry_Fail_CpSmDelete_Step4</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>2531</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that if EthIf_MacSecDeleteTxSa() returns E_NOT_OK while CpSm is in state CP_DELETE (step_4), the call shall be retried in next MainFunction tick. After too many failed calls to SecY, CpSm should transitions to state CP_UNINIT.
Test Object: Software
Test Precondition: 
    -   CP unit initialized.
  
Test Execution: 
    01: Reset SecY stubs.
    02: Set the Cp state to CP_TRANSMITTING, but go through CP_RETIRE beforehand. This is done so Cp unit could call EthIf_MacSecDeleteTxSa as it will have both Old and Latest Key.
    03: Prepare stubs for testing.
    04: Call function Mka_Cp_LinkStateDown() to transition to CP_DELETE.
    05: Sanity check - Check that EthIf_MacSecDeleteTxSa returned E_NOT_OK. Call to SecY shall be retried.
    06: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to SecY.
    07: Sanity check - Check that Cp retried the call to SecY.
    08: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to SecY one last time.
    09: Sanity check - Check that Cp retried the call to SecY for the last time and that EthIf_MacSecDeleteTxSa returned E_NOT_OK.
    10: Call Mka_Cp_MainFunction to tick main function. Cp shall call Mka_Logon_Pae_Restart.
    11: VP(Mka.dsn.Cp.CpSM.Retry.CleanUp,1)
        VP(Mka.dsn.Cp.CpSM.Retry,1) Verify that a transition to state CP_UNINIT has been made because the SecY retries exceeded the maximum configured number of retries.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Retry.CleanUp</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1499</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Retry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1500</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1883</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01075_SecYRetry_Fail_CpSmDelete_Step5</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>2564</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that if EthIf_MacSecDeleteRxSa() returns E_NOT_OK while CpSm is in state CP_DELETE (step_5), the call shall be retried in next MainFunction tick. After too many failed calls to SecY, CpSm should transitions to state CP_UNINIT.
Test Object: Software
Test Precondition: 
    -   CP unit initialized.
  
Test Execution: 
    01: Reset SecY stubs.
    02: Set the Cp state to CP_TRANSMITTING, but go through CP_RETIRE beforehand. This is done so Cp unit could call EthIf_MacSecDeleteRxSa as it will have both Old and Latest Key.
    03: Prepare stubs for testing.
    04: Call function Mka_Cp_LinkStateDown() to transition to CP_DELETE.
    05: Sanity check - Check that EthIf_MacSecDeleteRxSa returned E_NOT_OK. Call to SecY shall be retried.
    06: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to SecY.
    07: Sanity check - Check that Cp retried the call to SecY.
    08: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to SecY one last time.
    09: Sanity check - Check that Cp retried the call to SecY for the last time and that EthIf_MacSecDeleteRxSa returned E_NOT_OK.
    10: Call Mka_Cp_MainFunction to tick main function. Cp shall call Mka_Logon_Pae_Restart.
    11: VP(Mka.dsn.Cp.CpSM.Retry.CleanUp,1)
        VP(Mka.dsn.Cp.CpSM.Retry,1) Verify that a transition to state CP_UNINIT has been made because the SecY retries exceeded the maximum configured number of retries.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Retry.CleanUp</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1499</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Retry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1500</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1884</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01076_SecYRetry_Fail_CpSmDelete_Step6</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>2597</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that if EthIf_MacSecOperational() returns E_NOT_OK while CpSm is in state CP_DELETE (step_6), the call shall be retried in next MainFunction tick. After too many failed calls to SecY, CpSm should transition to state CP_UNINIT.
Test Object: Software
Test Precondition: 
    -   CP unit initialized.
  
Test Execution: 
    01: Reset SecY stubs.
    02: Set the Cp state to CP_TRANSMITTING, but go through CP_RETIRE beforehand. This is done so Cp unit could call EthIf_MacSecDeleteTxSa as it will have both Old and Latest Key.
    03: Prepare stubs for testing.
    04: Call function Mka_Cp_LinkStateDown() to transition to CP_DELETE.
    05: Sanity check - Check that EthIf_MacSecOperational returned E_NOT_OK. Call to SecY shall be retried.
    06: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to SecY.
    07: Sanity check - Check that Cp retried the call to SecY.
    08: Call Mka_Cp_MainFunction to tick main function. Cp shall retry the call to SecY one last time.
    09: Sanity check - Check that Cp retried the call to SecY for the last time and that EthIf_MacSecOperational returned E_NOT_OK.
    10: Call Mka_Cp_MainFunction to tick main function. Cp shall call Mka_Logon_Pae_Restart.
    11: VP(Mka.dsn.Cp.CpSM.Retry.CleanUp,1)
        VP(Mka.dsn.Cp.CpSM.Retry,1) Verify that a transition to state CP_UNINIT has been made because the SecY retries exceeded the maximum configured number of retries.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Retry.CleanUp</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1499</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Retry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1500</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1885</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01077_CpSM_UpdateSecY2Unsecured</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>2630</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies the transisition from the CP_UPDATE_SECY state to the CP_UNSECURED state.
Test Object: Cp state machine.
Test Precondition: 
    -   Mka_Init() initialized. CP unit initialized.
  
Test Execution: 
    01: Call function Mka_Cp_SetCipherSuite() to simulate call from Logon that selected PAE can be initialized. EthIf_MacSecUpdateSecY() shall be called.
    02: check that we have successfully transitioned to CP_UPDATE_SECY state.
    03: Call function Mka_Cp_DisableMacSec().
    04: Call function Mka_Cp_MacSecUpdateSecYNotification() to simulate that MacSecUpdateSecY request has been finished.
    05: Call function Mka_Cp_MainFunction() to transit from CP_RETIRE to CP_UNSECURED.
    06: VP(Mka.dsn.Cp.CpSM.Unsecured.Testing,1) Verify that CP state machine transitioned from CP_UPDATE_SECY to CP_UNSECURED. When CP state machine enters state CP_UNSECURED, CP shall delete all SAs, set ControlledPortEnabled to TRUE, call EthIf_MacSecUpdateSecY() and EthIf_MacSecOperational(). However, no SAs were secured.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Unsecured.Testing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1481</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1886</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01078_CpSM_InitRxSc2Unsecured</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>2653</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies the transisition from the CP_INIT_RX_SC state to the CP_UNSECURED state.
Test Object: Cp state machine.
Test Precondition: 
    -   Mka_Init() initialized. CP unit initialized.
    -   Set EthIf_MacSecInitRxSc to return E_NOT_OK on first call to stop the CpSM State Machine at CP_INIT_RX_SC.
  
Test Execution: 
    01: Call function Mka_Cp_SetCipherSuite() to simulate call from Logon that selected PAE can be initialized. EthIf_MacSecUpdateSecY() shall be called.
    02: Call function Mka_Cp_MacSecUpdateSecYNotification() to simulate that MacSecUpdateSecY request has been finished. State machine shall transition to CP_WAIT_RX_SC.
    03: Call Mka_Cp_InitRxSc to give EBTEST_SCI_NUM to CpSM, which transitions CpSM to CP_INIT_RX_SC state.
    04: Sanity check - Sanity
    05: Call function Mka_Cp_DisableMacSec().
    06: Call function Mka_Cp_MacSecUpdateSecYNotification() to simulate that MacSecUpdateSecY request has been finished.
    07: Call function Mka_Cp_MainFunction() to transit from CP_RETIRE to CP_UNSECURED.
    08: VP(Mka.dsn.Cp.CpSM.Unsecured.Testing,1) Verify that CP state machine transitioned from CP_INIT_RX_SC to CP_UNSECURED. When CP state machine enters state CP_UNSECURED, CP shall delete all SAs, set ControlledPortEnabled to TRUE, call EthIf_MacSecUpdateSecY() and EthIf_MacSecOperational(). However, no SAs were secured.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Unsecured.Testing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1481</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1887</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01079_CpSM_Secured2Unsecured</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>2679</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies the transisition from the CP_SECURED state to the CP_UNSECURED state.
Test Object: Cp state machine.
Test Precondition: 
    -   Mka_Init() initialized. CP unit initialized.
  
Test Execution: 
    01: Call function Mka_Cp_SetCipherSuite() to simulate call from Logon that selected PAE can be initialized. EthIf_MacSecUpdateSecY() shall be called.
    02: Call function Mka_Cp_MacSecUpdateSecYNotification() to simulate that MacSecUpdateSecY request has been finished. State machine shall transition to CP_WAIT_RX_SC.
    03: Call Mka_Cp_InitRxSc to give EBTEST_SCI_NUM to CpSM, which transitions CpSM to CP_INIT_RX_SC state.
    04: Sanity check - Sanity.
    05: Call function Mka_Cp_DisableMacSec().
    06: Call function Mka_Cp_MacSecUpdateSecYNotification() to simulate that MacSecUpdateSecY request has been finished.
    07: Call function Mka_Cp_MainFunction() to transit from CP_RETIRE to CP_UNSECURED.
    08: VP(Mka.dsn.Cp.CpSM.Unsecured.Testing,1) Verify that CP state machine transitioned from CP_SECURE to CP_UNSECURED. When CP state machine enters state CP_UNSECURED, CP shall delete all SAs, set ControlledPortEnabled to TRUE, call EthIf_MacSecUpdateSecY() and EthIf_MacSecOperational(). However, no SAs were secured.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Unsecured.Testing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1481</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1888</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01080_CpSM_Secured2WaitRxSc_LinkStateDown</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>2704</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies transition from CP_SECURED to CP_WAIT_RX_SC after call to Mka_Cp_LinkStateDown().
Test Object: Cp state machine.
Test Precondition: 
    -   Reset SecY stubs. Mka_Init() initialized. Mka_Cp_Init() initialized. Mka_Cp_SetCipherSuite() call from Logon that selected PAE can be initalized. Mka_Cp_MacSecUpdateSecYNotification() MacSecUpdateSecY request has finished. Mka_Cp_InitRxSc() to give PeerSci to Cp SM.
  
Test Execution: 
    01: Sanity check - Verify that CP state machine transitioned to CP_SECURED. When CP state machine enters state CP_INIT_RX_SC, CP shall call EthIf to initialize Rx SC with function call EthIf_MacSecInitRxSc(). Because EthIf_MacSecInitRxSc returned E_OK, the Cp SM instantly makes a transition to state CP_SECURED.
    02: Call function Mka_Cp_LinkStateDown() to change link state to FALSE.
    03: VP(Mka.dsn.Cp.CpSM.Any_2_WaitRxSc,1) Verify that CP state machine transitioned from CP_SECURED to CP_WAIT_RX_SC, by verifying that MacSecOperational is reported FALSE and controlled port was disabled. Also verify that receive security channel was deleted.
    04: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Any_2_WaitRxSc</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1385</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1889</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01081_CpSM_InitRxSc2WaitRxSc_LinkStateDown</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>2725</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies transition from CP_INIT_RX_SC to CP_WAIT_RX_SC after call to Mka_Cp_LinkStateDown().
Test Object: Cp state machine.
Test Precondition: 
    -   Mka_Init() initialized. Mka_Cp_Init() initialized. Mka_Cp_SetCipherSuite() call from Logon that selected PAE can be initalized. Mka_Cp_MacSecUpdateSecYNotification() MacSecUpdateSecY request has finished. Mka_Cp_InitRxSc() to give PeerSci to Cp SM.
  
Test Execution: 
    01: Sanity check - Verify that CP state machine transitioned to CP_INIT_RX_SC. When CP state machine enters state CP_INIT_RX_SC, CP shall call EthIf to initialize Rx SC with function call EthIf_MacSecInitRxSc(). Because EthIf_MacSecInitRxSc returned E_NOT_OK, the Cp SM stays in CP_INIT_RX_SC.
    02: Call function Mka_Cp_LinkStateDown() to change link state to FALSE.
    03: VP(Mka.dsn.Cp.CpSM.Any_2_WaitRxSc,1) Verify that CP state machine transitioned from CP_INIT_RX_SC to CP_WAIT_RX_SC, by verifying that MacSecOperational is reported FALSE and controlled port was disabled.
    04: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Any_2_WaitRxSc</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1385</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1890</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01082_FillSakUse_ENotOk</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>2746</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that Mka_Cp_FillSakUse() returns E_NOT_OK if the call to EthIf_MacSecGetTxSaNextPn fails with E_NOT_OK for either Old or the Latest key.
Test Object: Mka_Cp_FillSakUse fails.
Test Precondition: 
    -   Mka_Init() initialized. CP unit initialized.
  
Test Execution: 
    01: Call function Mka_Cp_SetCipherSuite() to simulate call from Logon that selected PAE can be initialized. EthIf_MacSecUpdateSecY() shall be called.
    02: Call function EbTest_CpSM_GoThroghFirstLoop() to go through CP state machine from CP_UNINIT to CP_RETIRE and back to CP_WAIT_ADD_RX_SA.
    03: Call function Mka_Cp_MacSecAddRxSaNotification() to indicate that MacSecAddRxSa request has been processed.
    04: Call Mka_Cp_MainFunction() to run state machine and make necessary transitions.
    05: Call function Mka_Cp_MacSecAddTxSaNotification() to indicate that EthIf_MacSecAddTxSa request has been processed. With this function call, CP state machine will transition from CP_WAIT_ADD_TX_SA to CP_RECEIVING.
    06: Call function Mka_Cp_ServerTransmitting() to indicate that every peer is waiting for the transmission of the SAK key.
    07: Prepare EthIf_MacSecGetTxSaNextPn stub to return E_NOT_OK when called for Latest key. Mka_Cp_FillSakUse shall return E_NOT_OK.
    08: Call Mka_Cp_FillSakUse() after Cp Sm entered CP_TRANSMITTING.
    09: VP(Mka.dsn.Cp.Api.FillSakUse,1) Verify that Mka_Cp_FillSakUse returned E_NOT_OK and did not change SakUseBufferSize because it called EthIf API which returned E_NOT_OK.
    10: Prepare EthIf_MacSecGetTxSaNextPn stub to return E_NOT_OK when called for Old key. Mka_Cp_FillSakUse shall return E_NOT_OK.
    11: Call Mka_Cp_FillSakUse() after Cp Sm entered CP_TRANSMITTING.
    12: VP(Mka.dsn.Cp.Api.FillSakUse,1) Verify that Mka_Cp_FillSakUse returned E_NOT_OK and did not change SakUseBufferSize because it called EthIf API which returned E_NOT_OK.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.Api.FillSakUse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1015</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1891</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01083_UpdateRxSa_Fail</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>2775</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that if a call to EthIf_MacSecUpdateRxSa fails with E_NOT_OK, the call will not be retried in the next main function tick.
Test Object: EthIf_MacSecUpdateRxSa no retry.
Test Precondition: 
    -   CP unit initialized.
  
Test Execution: 
    01: Create MKPDU from a peer Participant_1 that proves liveliness to Participant_2.
    02: Call function Mka_Cp_SetCipherSuite() to simulate call from Logon that selected PAE can be initialized.
    03: Set the Cp state machine to the desired state.
    04: Prepare stubs for testing, set EthIf_MacSecUpdateRxSa and EthIf_MacSecOperational to return E_NOT_OK.
    05: Simulate reception of SakUse from alive peer.
    06: VP(Mka.dsn.Cp.Retry.NotRequired,1) Verify that EhtIf_MacSecUpdateRxSa returned E_NOT_OK.
    07: Call Mka_MainFunction. The call to EthIf shall not be retried.
    08: VP(Mka.dsn.Cp.Retry.NotRequired,1) Verify that Cp unit didn't call EhtIf_MacSecUpdateRxSa and EthIf_MacSecOperational.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.Retry.NotRequired</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1498</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1892</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01084_SecYRetry_Disabled_CpSmUpdateSecY</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>2800</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that if EthIf_MacSecUpdateSecY() returns E_NOT_OK while CpSm is in state CP_UPDATE_SECY, and retry for SecY APIs is disabled, CP unit will make transition into state CP_UNINIT.
Test Object: Software
Test Precondition: 
    -   CP unit initialized and configure stubs.
  
Test Execution: 
    01: Call function Mka_Cp_SetCipherSuite() to simulate call from Logon that selected PAE can be initialized. CpSM shall transition to CP_UPDATE_SECY.
    02: Sanity check - Check that EthIf_MacSecUpdateSecY returned E_NOT_OK.
    03: VP(Mka.dsn.Cp.CpSM.Any_2_Uninit,1) Verify that a transition to state CP_UNINIT has been made because the SecY Api EthIf_MacSecUpdateSecY() returned E_NOT_OK in state CP_UPDATE_SECY.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Any_2_Uninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1503</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1893</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01085_SecYRetry_Disabled_CpSmInitRxSc</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>2820</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that if EthIf_MacSecInitRxSc() returns E_NOT_OK while CpSm is in state CP_INIT_RX_SC, and retry for SecY APIs is disabled, CP unit will make transition into state CP_UNINIT.
Test Object: Software
Test Precondition: 
    -   CP unit initialized and configure stubs.
  
Test Execution: 
    01: Call function Mka_Cp_SetCipherSuite() to simulate call from Logon that selected PAE can be initialized. CpSM shall transition to Cp_Update_SecY.
    02: Sanity check - Check that EthIf_MacSecInitRxSc returned E_OK. CpSm shall transition to CP_WAIT_RX_SC
    03: Call function Mka_Cp_MacSecUpdateSecYNotification() to simulate that MacSecUpdateSecY request has been finished.
    04: Call Mka_Cp_MainFunction to tick main function.
    05: Call Mka_Cp_InitRxSc to give PeerSci to Cp SM and thus enable the Cp SM to transition to CP_INIT_RX_SC.
    06: Sanity check - Check that EthIf_MacSecInitRxSc returned E_NOT_OK. Call to EthIf_MacSecInitRxSc shall be retried
    07: VP(Mka.dsn.Cp.CpSM.Any_2_Uninit,1) Verify that a transition to state CP_UNINIT has been made because the SecY Api EthIf_MacSecInitRxSc() returned E_NOT_OK in state CP_INIT_RX_SC.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Any_2_Uninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1503</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1894</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01086_SecYRetry_Disabled_CpSmWaitAddRxSa</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>2844</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that if EthIf_MacSecAddRxSa() returns E_NOT_OK while CpSm is in state CP_WAIT_ADD_RX_SA, and retry for SecY APIs is disabled, CP unit will make transition into state CP_UNINIT.
Test Object: Software
Test Precondition: 
    -   CP unit initialized and configure stubs.
  
Test Execution: 
    01: Set the Cp state machine to the desired state.
    02: Call function Mka_Cp_NewSak() to indicate that new SAK is ready and notify CP that it isn't a key server.
    03: Sanity check - Check that EthIf_MacSecAddRxSa returned E_NOT_OK. Call to SecY shall be retried
    04: VP(Mka.dsn.Cp.CpSM.Any_2_Uninit,1) Verify that a transition to state CP_UNINIT has been made because the SecY Api EthIf_MacSecAddRxSa() returned E_NOT_OK in state CP_WAIT_ADD_RX_SA.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Any_2_Uninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1503</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1895</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01087_SecYRetry_Disabled_CpSmWaitAddTxSa</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>2865</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that if EthIf_MacSecAddTxSa() returns E_NOT_OK while CpSm is in state CP_WAIT_ADD_TX_SA, and retry for SecY APIs is disabled, CP unit will make transition into state CP_UNINIT.
Test Object: Software
Test Precondition: 
    -   CP unit initialized and configure stubs.
  
Test Execution: 
    01: Set the Cp state machine to the desired state.
    02: Call function Mka_Cp_MacSecAddRxSaNotification() to indicate that MacSecAddRxSa request has been processed.
    03: Call Mka_Cp_MainFunction() to run state machine and make necessary transitions.
    04: Sanity check - Check that EthIf_MacSecAddTxSa returned E_NOT_OK. Call to SecY shall be retried
    05: VP(Mka.dsn.Cp.CpSM.Any_2_Uninit,1) Verify that a transition to state CP_UNINIT has been made because the SecY Api EthIf_MacSecAddTxSa() returned E_NOT_OK in state CP_WAIT_ADD_TX_SA.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Any_2_Uninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1503</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1896</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01088_SecYRetry_Disabled_CpSmTransmitting</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>2887</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that if EthIf_MacSecSetControlledPortEnabled() returns E_NOT_OK while CpSm is in state CP_TRANSMITTING, and retry for SecY APIs is disabled, CP unit will make transition into state CP_UNINIT.
Test Object: Software
Test Precondition: 
    -   CP unit initialized and configure stubs.
  
Test Execution: 
    01: Set the Cp state machine to the desired state.
    02: Call function Mka_Cp_MainFunction() to allow the CpSm to make the transition to CP_TRANSMITTING.
    03: Sanity check - Check that EthIf_MacSecSetControlledPortEnabled returned E_NOT_OK. Call to SecY shall be retried
    04: VP(Mka.dsn.Cp.CpSM.Any_2_Uninit,1) Verify that a transition to state CP_UNINIT has been made because the SecY Api EthIf_MacSecSetControlledPortEnabled() returned E_NOT_OK in state CP_TRANSMITTING.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Any_2_Uninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1503</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1897</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01089_SecYRetry_Disabled_CpSmRetire</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>2908</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that if EthIf_MacSecDeleteTxSa() returns E_NOT_OK while CpSm is in state CP_RETIRE, and retry for SecY APIs is disabled, CP unit will make transition into state CP_UNINIT.
Test Object: Software
Test Precondition: 
    -   CP unit initialized.
  
Test Execution: 
    01: Set the Cp state to CP_TRANSMITTING, but go through CP_RETIRE beforehand. This is done so that Cp unit could call EthIf_MacSecDeleteTxSa as it will have Old and Latest Key in CP_RETIRE state.
    02: Prepare stubs for testing.
    03: Call function Mka_Cp_TimerCallback_RetireWhen() to transit from CP_TRANSMITTING to CP_RETIRE. This function call indicates that CP timer RetireWhen has expired.
    04: Sanity check - Check that EthIf_MacSecDeleteTxSa returned E_NOT_OK. Call to SecY shall be retried
    05: Call Mka_Cp_MainFunction to tick main function. Cp shall call Mka_Logon_Pae_Restart.
    06: VP(Mka.dsn.Cp.CpSM.Any_2_Uninit,1) Verify that a transition to state CP_UNINIT has been made because the SecY Api EthIf_MacSecDeleteTxSa() returned E_NOT_OK in state CP_RETIRE.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Any_2_Uninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1503</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1898</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01090_SecYRetry_Disabled_CpSmUnsecured</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>2931</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that if EthIf_MacSecUpdateSecY() returns E_NOT_OK while CpSm is in state CP_UNSECURED, and retry for SecY APIs is disabled, CP unit will make transition into state CP_UNINIT.
Test Object: Software
Test Precondition: 
    -   CP unit initialized and configure stubs.
  
Test Execution: 
    01: Call function Mka_Cp_DisableMacSec() to transition to CP_UNSECURED.
    02: Sanity check - Check that EthIf_MacSecUpdateSecY returned E_NOT_OK. Call to SecY shall be retried
    03: VP(Mka.dsn.Cp.CpSM.Any_2_Uninit,1) Verify that a transition to state CP_UNINIT has been made because the SecY Api EthIf_MacSecUpdateSecY() returned E_NOT_OK in state CP_UNSECURED.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Any_2_Uninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1503</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1899</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01091_SecYRetry_Disabled_CpSmDelete</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>2951</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that if EthIf_MacSecSetControlledPortEnabled() returns E_NOT_OK while CpSm is in state CP_DELETE, and retry for SecY APIs is disabled, CP unit will make transition into state CP_UNINIT.
Test Object: Software
Test Precondition: 
    -   CP unit initialized and configure stubs.
  
Test Execution: 
    01: Set the Cp state to CP_TRANSMITTING, but go through CP_RETIRE beforehand. This is done so Cp unit could call EthIf_MacSecDeleteTxSa as it will have both Old and Latest Key.
    02: Prepare stubs for testing.
    03: Call function Mka_Cp_LinkStateDown() to transition to CP_DELETE.
    04: Sanity check - Check that EthIf_MacSecSetControlledPortEnabled returned E_NOT_OK. Call to SecY shall be retried.
    05: VP(Mka.dsn.Cp.CpSM.Any_2_Uninit,1) Verify that a transition to state CP_UNINIT has been made because the SecY Api EthIf_MacSecSetControlledPortEnabled() returned E_NOT_OK in state CP_DELETE.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Any_2_Uninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1503</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1900</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01092_L_XLPn_RxMkpdu</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>2973</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that function Mka_Cp_XLPn_Recovery() correctly encodes L_LPn from RxMkpdu.
Test Object: Mka_Cp_XLPn_Recovery().
Test Precondition: 
    -   Mka_Init() initialized. Mka_Cp_Init() initialized.
  
Test Execution: 
    01: Call function Mka_Cp_SetCipherSuite() to simulate call from Logon that selected PAE can be initialized.
    02: Create MKPDU from a peer Participant_1 that proves liveliness to Participant_2.
    03: Set the Cp state machine to the desired state.
    04: Set SakUse parameter set LPN to value 0x04040404, Xpn parameter set LPN to value 0x05050505.
    05: Simulate reception of SakUse from alive peer with SakUse parameter set that has LPN value 0x04040404 and Xpn parameter set that has LPN value 0x05050505.
    06: VP(Mka.dsn.Cp.ExtendedPacketNumber.XPN,1) Verify that 32 MSB of calculated XPN are the same from RxMkpdu XPN parameter LLPN value.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.ExtendedPacketNumber.XPN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1491</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1901</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01093_O_XLPn_RxMkpdu</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>2996</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that function Mka_Cp_XLPn_Recovery() correctly encodes O_LPn from RxMkpdu.
Test Object: Mka_Cp_XLPn_Recovery().
Test Precondition: 
    -   Mka_Init() initialized. Mka_Cp_Init() initialized.
  
Test Execution: 
    01: Call function Mka_Cp_SetCipherSuite() to simulate call from Logon that selected PAE can be initialized.
    02: Create MKPDU from a peer Participant_1 that proves liveliness to Participant_2.
    03: Call function EbTest_CpSM_GoThroghFirstLoop() to go through CP state machine and set Old_Sa. Set the CpSm to state CP_TRANSMITTING.
    04: Set SakUse parameter set LPN to value 0x40404040, Xpn parameter set LPN to value 0x50505050.
    05: Simulate reception of SakUse from alive peer with SakUse parameter set that has OLPN value value 0x40404040 and Xpn parameter set that has OLPN value 0x50505050.
    06: VP(Mka.dsn.Cp.ExtendedPacketNumber.XPN,1) Verify that 32 MSB of calculated XPN are the same from RxMkpdu XPN parameter OLPN value.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.ExtendedPacketNumber.XPN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1491</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1902</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01094_CpSM_InitRxSc2UpdateSecY</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>3019</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies transition from CP_INIT_RX_SC-&amp;gt;CP_UPDATE_SECY when Mka_Cp_SetCipherSuite() is called.
Test Object: Cp state machine.
Test Precondition: 
  
Test Execution: 
    01: Module configuration initialized with Mka_Init(), Mka_Cp_Init is also called.
    02: Call function Mka_Cp_SetCipherSuite() to simulate call from Logon that selected PAE can be initialized.
    03: Sanity check - Check that EthIf_MacSecInitRxSc returned E_OK. CpSm shall transition to CP_WAIT_RX_SC.
    04: Call function Mka_Cp_MacSecUpdateSecYNotification() to simulate that MacSecUpdateSecY request has been finished.
    05: Call Mka_Cp_MainFunction to tick main function.
    06: Call Mka_Cp_InitRxSc to give PeerSci to Cp SM and thus enable the Cp SM to transition to CP_INIT_RX_SC.
    07: Call function Mka_Cp_SetCipherSuite() to change Cipher suite and CP state machine should transit from CP_INIT_RX_SC to CP_UPDATE_SECY.
    08: VP(Mka.dsn.Cp.CpSM.InitRxSc_2_UpdateSecY,1) Verify that CP state machine transitioned from CP_INIT_RX_SC to CP_UPDATE_SECY. When CP state machine enters state CP_UPDATE_SECY, CP shall call EthIf to update SecY with function call EthIf_MacSecUpdateSecY(). Because EthIf_MacSecInitRxSc returned E_OK, the Cp SM instantly makes a transition to state CP_UPDATE_SECY.
    09: Call function Mka_Cp_MacSecUpdateSecYNotification() to simulate that MacSecUpdateSecY request has been finished, after we received new CiphetSuite.
    10: Call Mka_Cp_MainFunction to tick main function.
    11: VP(Mka.dsn.Cp.CpSM.InitRxSc_2_UpdateSecY,1) Verify that CP state machine transitioned from CP_UPDATE_SECY to CP_INIT_RX_SC. When CP state machine enters state CP_UPDATE_SECY, and Mka_Cp_MacSecUpdateSecYNotification() is received, SM will move into state before new request Mka_Cp_SetCipherSuite().
    12: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.InitRxSc_2_UpdateSecY</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1395</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1903</internalId></specobject>
    <specobject>
      <id>Mka_Cp_UnitTest01095_CpSM_Secured2UpdateSecY</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Cp/TestSpec_Generated.h</sourcefile>
      <sourceline>3047</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies transition from CP_SECURED-&amp;gt;CP_UPDATE_SECY when Mka_Cp_SetCipherSuite() is called in state CP_SECURED.
Test Object: Cp state machine.
Test Precondition: 
  
Test Execution: 
    01: Module configuration initialized with Mka_Init(), Mka_Cp_Init is also called.
    02: Call function Mka_Cp_SetCipherSuite() to simulate call from Logon that selected PAE can be initialized.
    03: Sanity check - Check that EthIf_MacSecInitRxSc returned E_OK. CpSm shall transition to CP_WAIT_RX_SC.
    04: Call function Mka_Cp_MacSecUpdateSecYNotification() to simulate that MacSecUpdateSecY request has been finished.
    05: Call Mka_Cp_MainFunction to tick main function.
    06: Call Mka_Cp_InitRxSc to give PeerSci to Cp SM and thus enable the Cp SM to transition to CP_SECURED.
    07: Call function Mka_Cp_SetCipherSuite() to change Cipher suite and CP state machine should transit from CP_SECURED to CP_UPDATE_SECY.
    08: VP(Mka.dsn.Cp.CpSM.Secured_2_UpdateSecY,1) Verify that CP state machine transitioned from CP_SECURED to CP_UPDATE_SECY. When CP state machine enters state CP_UPDATE_SECY, CP shall reset RxSc and call EthIf to update SecY with function call EthIf_MacSecUpdateSecY(). Because EthIf_MacSecInitRxSc returned E_OK, the Cp SM instantly makes a transition to state CP_UPDATE_SECY.
    09: Call function Mka_Cp_MacSecUpdateSecYNotification() to simulate that MacSecUpdateSecY request has been finished, after we received new CiphetSuite.
    10: Call Mka_Cp_MainFunction to tick main function.
    11: VP(Mka.dsn.Cp.CpSM.Secured_2_UpdateSecY,1) Verify that CP state machine transitioned from CP_UPDATE_SECY to CP_SECURED. When CP state machine enters state CP_UPDATE_SECY, and Mka_Cp_MacSecUpdateSecYNotification() is received, SM will move into state before new request Mka_Cp_SetCipherSuite().
    12: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Cp.CpSM.Secured_2_UpdateSecY</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1376</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1904</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>Mka_Crypto_UnitTest01001_CsmRandomCallback_Uninit_Check</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>9</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that the service Mka_CsmRandomCallback checks if Mka module is not initialized. The check should fail and the function shall raise the development error MKA_E_UNINIT.
Test Object: Mka_CsmRandomCallback().
Test Precondition: 
  
Test Execution: 
    01: Call Mka_CsmRandomCallback() without init function called.
    02: VP(Mka.Det.Crypto.Mka_CsmRandomCallback_Uninit,1) Check that MKA_DET_REPORT_ERROR was called successfully.
    03: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Det.Crypto.Mka_CsmRandomCallback_Uninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1176</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1905</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01002_CsmKeyGenerateCallback_Uninit_Check</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>28</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that the service Mka_CsmKeyGenerateCallback checks if Mka module is not initialized. The check should fail and the function shall raise the development error MKA_E_UNINIT.
Test Object: Mka_CsmKeyGenerateCallback().
Test Precondition: 
  
Test Execution: 
    01: Call Mka_CsmKeyGenerateCallback() without init function called.
    02: VP(Mka.Det.Crypto.Mka_CsmKeyGenerateCallback_Uninit,1) Check that MKA_DET_REPORT_ERROR was called successfully.
    03: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Det.Crypto.Mka_CsmKeyGenerateCallback_Uninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1177</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1906</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01003_CsmIcvGenerateCallback_Uninit_Check</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>47</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that the service Mka_CsmIcvGenerateCallback checks if Mka module is not initialized. The check should fail and the function shall raise the development error MKA_E_UNINIT.
Test Object: Mka_CsmIcvGenerateCallback().
Test Precondition: 
  
Test Execution: 
    01: Call Mka_CsmIcvGenerateCallback() without init function called.
    02: VP(Mka.Det.Crypto.Mka_CsmIcvGenerateCallback_Uninit,1) Check that MKA_DET_REPORT_ERROR was called successfully.
    03: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Det.Crypto.Mka_CsmIcvGenerateCallback_Uninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1178</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1907</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01004_CsmHashGenerateCallback_Uninit_Check</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>66</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that the service Mka_CsmHashGenerateCallback checks if Mka module is not initialized. The check should fail and the function shall raise the development error MKA_E_UNINIT.
Test Object: Mka_CsmHashGenerateCallback().
Test Precondition: 
  
Test Execution: 
    01: Call Mka_CsmHashGenerateCallback() without init function called.
    02: VP(Mka.Det.Crypto.Mka_CsmHashGenerateCallback_Uninit,1) Check that MKA_DET_REPORT_ERROR was called successfully.
    03: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Det.Crypto.Mka_CsmHashGenerateCallback_Uninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1179</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1908</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01005_CsmIcvVerifyCallback_Uninit_Check</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>85</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that the service Mka_CsmIcvVerifyCallback checks if Mka module is not initialized. The check should fail and the function shall raise the development error MKA_E_UNINIT.
Test Object: Mka_CsmIcvVerifyCallback().
Test Precondition: 
  
Test Execution: 
    01: Call Mka_CsmIcvVerifyCallback() without init function called.
    02: VP(Mka.Det.Crypto.Mka_CsmIcvVerifyCallback_Uninit,1) Check that MKA_DET_REPORT_ERROR was called successfully.
    03: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Det.Crypto.Mka_CsmIcvVerifyCallback_Uninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1181</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1909</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01006_CsmKeyWrapCallback_Uninit_Check</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>104</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that the service Mka_CsmKeyWrapCallback checks if Mka module is not initialized. The check should fail and the function shall raise the development error MKA_E_UNINIT.
Test Object: Mka_CsmKeyWrapCallback().
Test Precondition: 
  
Test Execution: 
    01: Call Mka_CsmKeyWrapCallback() without init function called.
    02: VP(Mka.Det.Crypto.Mka_CsmKeyWrapCallback_Uninit,1) Check that MKA_DET_REPORT_ERROR was called successfully.
    03: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Det.Crypto.Mka_CsmKeyWrapCallback_Uninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1182</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1910</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01007_CsmKeyUnwrapCallback_Uninit_Check</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>123</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that the service Mka_CsmKeyUnwrapCallback checks if Mka module is not initialized. The check should fail and the function shall raise the development error MKA_E_UNINIT.
Test Object: Mka_CsmKeyUnwrapCallback().
Test Precondition: 
  
Test Execution: 
    01: Call Mka_CsmKeyUnwrapCallback() without init function called.
    02: VP(Mka.Det.Crypto.Mka_CsmKeyUnwrapCallback_Uninit,1) Check that MKA_DET_REPORT_ERROR was called successfully.
    03: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Det.Crypto.Mka_CsmKeyUnwrapCallback_Uninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1183</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1911</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01008_RandomGen_Async128</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>142</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that correct Csm functions are called in correct order with correct set of input variables in asynchronous mode. Mka_Crypto_RandomGenerateAsync() is called as KaY unit, Mka_CsmRandomCallback is asynchronous callback from Csm. 128bit key algorithms are used.
Test Object: Mka_Crypto_RandomGenerateAsync() in Asynchronous mode.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Setting up stubs.
  
Test Execution: 
    01: Call Mka_Crypto_Init().
    02: VP(Mka.dsn.Crypto.RandomGenSM.Initial_Initialization,1)
        VP(Mka.dsn.Crypto.Api.Init,1)
        VP(Mka.dsn.Crypto.KeyGenSM.Initial_Initialization,1) Verify that Csm_KeyElementGet() is called for each participant. Also, after Mka_Crypto_Init() RandomGenSM transitions to RNG_IDLE
    03: Call Mka crypto unit API Mka_Crypto_RandomGenerateAsync to start RandomGenerate procedure.
    04: VP(Mka.InterAct.Crypto.RandomGenerateAsync,1)
        VP(Mka.dsn.Crypto.Api.RandomGenerateAsync,1)
        VP(Mka.8021X.MkaKeyHierarchy.16.2,1)
        VP(Mka.dsn.Crypto.RandomGenSM.Idle_2_Busy ,1) Verify that after call to Mka_Crypto_RandomGenerateAsync() RandomGenSM transitions to RNG_BUSY and that Csm functions are called in correct order with correct input variables.
    05: Asynchronous call from Csm to Crypto unit Mka_CsmRandomCallback().
    06: VP(Mka.dsn.Crypto.Api.RandomGenerate.CsmGranularity,1)
        VP(Mka.dsn.Crypto.RandomGenSM.Busy_2_GenMoreData,1)
        VP(Mka.dsn.Crypto.RandomGenSM.GenMoreData,1) Verify that Csm_RandomGenerate is called required number of times to get required number of random numbers. In this case it is length of Member identifier (12 bytes) / Amount of random data that Csm generates at one time (5 bytes).
    07: VP(Mka.InterAct.Crypto.RandomGenerateAsync,1)
        VP(Mka.dsn.Crypto.Api.RandomGenerateAsync.AsynDone,1)
        VP(Mka.dsn.Crypto.Api.MainFunction,1)
        VP(Mka.dsn.Crypto.RandomGenSM.Notified_2_Idle,1)
        VP(Mka.dsn.Crypto.RandomGenSM.GenMoreData_2_Notified,1) Verify that Crypto unit is calling correct KaY function. This also confirms (successful) transition from RNG_BUSY to RNG_NOTIFIED and from RNG_NOTIFIED to RNG_IDLE
    08: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.RandomGenSM.Initial_Initialization</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1355</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.Init</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1026</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.KeyGenSM.Initial_Initialization</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1303</internalId></provcov>
        <provcov>
          <linksto>Mka.InterAct.Crypto.RandomGenerateAsync</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1117</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.RandomGenerateAsync</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1036</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.MkaKeyHierarchy.16.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>134</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.RandomGenSM.Idle_2_Busy</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1358</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.RandomGenerate.CsmGranularity</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1537</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.RandomGenSM.Busy_2_GenMoreData</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1350</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.RandomGenSM.GenMoreData</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1348</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.RandomGenerateAsync.AsynDone</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1533</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.MainFunction</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1027</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.RandomGenSM.Notified_2_Idle</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1353</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.RandomGenSM.GenMoreData_2_Notified</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1346</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1912</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01009_RandomGen_Sync128</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>231</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that correct Csm functions are called in correct order with correct set of input variables in synchronous mode. Mka_Crypto_RandomGenerateAsync() is called from KaY unit. 128bit key algorithms are used.
Test Object: Mka_Crypto_RandomGenerateAsync in Synchronous mode.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Setting up stubs.
  
Test Execution: 
    01: Call Mka crypto unit API Mka_Crypto_RandomGenerateAsync to start RandomGenerate procedure.
    02: VP(Mka.dsn.Crypto.Api.RandomGenerateAsync.E_OK,1) Verify that Mka_DirtyFlag was changed to TRUE.
    03: Call Mka crypto unit main function Mka_Crypto_MainFunction() to run the Crypto thread.
    04: VP(Mka.dsn.Crypto.Api.RandomGenerate.CsmGranularity,1) Verify that Csm_RandomGenerate is called required number of times to get required number of random numbers. In this case it is length of Member identifier (12 bytes) / Amount of random data that Csm generates at one time (5 bytes).
    05: VP(Mka.InterAct.Crypto.RandomGenerateSync,1)
        VP(Mka.dsn.Crypto.Api.RandomGenerateAsync.SynDone,1)
        VP(Mka.8021X.MkaKeyHierarchy.16.2,1) Verify that Csm functions are called in correct order with correct input variables.
    06: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.RandomGenerateAsync.E_OK</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1531</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.RandomGenerate.CsmGranularity</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1537</internalId></provcov>
        <provcov>
          <linksto>Mka.InterAct.Crypto.RandomGenerateSync</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1116</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.RandomGenerateAsync.SynDone</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1532</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.MkaKeyHierarchy.16.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>134</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1913</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01010_KekIckGen_Async128</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>273</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that correct Csm functions are called in correct order with correct set of input variables in asynchronous mode. Mka_Crypto_IckGenerateAsync() is called from Logon unit to start Ick and then Kek generator. Mka_CsmKeyGenerateCallback is called two times asynchronously by Csm module, once for Ick and once for Kek. 128bit key algorithms are used.
Test Object: Mka_Crypto_IckGenerateAsync() in asynchronous mode.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
  
Test Execution: 
    01: Call Mka crypto unit API Mka_Crypto_IckGenerateAsync to start Ick and Kek Generate procedure.
    02: VP(Mka.dsn.Crypto.KeyGenSM.Idle_2_Preparing,1)
        VP(Mka.dsn.Crypto.KeyGenSM.Preparing_2_Requested,1) Verify that the KeyGenSM has gone from KEYGEN_IDLE to KEYGEN_PREPARING to KEYGEN_REQUESTED for Ick.
    03: VP(Mka.InterAct.Crypto.IckGenerateAsync,1)
        VP(Mka.dsn.Crypto.Api.IckGenerateAsync,1)
        VP(Mka.CP_SWS_Mka_CONSTR_00020.2,1)
        VP(Mka.dsn.Crypto.CryptoSM.CakCkn_Ready_2_Ick_Ready,1)
        VP(Mka.dsn.Crypto.KeyGenSM.Requested_2_Busy,1) Verify that Csm functions are called in correct order with correct input variables.
    04: Asynchronous callback from Csm to Crypto unit Mka_CsmKeyGenerateCallback() and call Mka_Crypto_MainFunction to process request for generation and start generating the key.
    05: VP(Mka.InterAct.Crypto.IckGenerateAsync,1)
        VP(Mka.dsn.Crypto.Api.IckGenerateAsync.E_OK,1)
        VP(Mka.dsn.Crypto.KeyGenSM.Busy_2_Idle_Ick,1)
        VP(Mka.dsn.Crypto.Api.IckGenerateAsync.AsynDone,1) Verify that Crypto unit is calling Csm functions in correct order with designated input.
    06: Call Mka crypto unit API Mka_Crypto_KekGenerateAsync to start Kek Generate procedure.
    07: VP(Mka.dsn.Crypto.KeyGenSM.Idle_2_Preparing_Kek,1)
        VP(Mka.dsn.Crypto.KeyGenSM.Preparing_2_Requested,1) Verify that the KeyGenSM has gone from KEYGEN_IDLE to KEYGEN_PREPARING to KEYGEN_REQUESTED for Kek.
    08: VP(Mka.InterAct.Crypto.KekGenerateAsync,1)
        VP(Mka.dsn.Crypto.Api.KekGenerateAsync,1)
        VP(Mka.dsn.Crypto.KeyGenSM.Requested_2_Busy,1) Verify that Csm functions are called in correct order with correct input variables.
    09: Asynchronous call from Csm to Crypton unit Mka_CsmKeyGenerateCallback().
    10: VP(Mka.InterAct.Crypto.KekGenerateAsync,1)
        VP(Mka.dsn.Crypto.Api.KekGenerateAsync.AsynDone,1)
        VP(Mka.rfc3394.KeyWrap.Indexing.3,1)
        VP(Mka.rfc3394.KeyUnwrap.Indexing.3,1)
        VP(Mka.dsn.Crypto.CryptoSM.Ick_ready_2_Kek_Ready,1)
        VP(Mka.dsn.Crypto.KeyGenSM.Busy_2_Idle_Kek,1)
        VP(Mka.dsn.Crypto.Api.KekGenerateAsync.E_OK,1) Verify that Crypto unit is calling Csm functions in correct order with designated input.
    11: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.KeyGenSM.Idle_2_Preparing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1306</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.KeyGenSM.Preparing_2_Requested</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1302</internalId></provcov>
        <provcov>
          <linksto>Mka.InterAct.Crypto.IckGenerateAsync</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1123</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.IckGenerateAsync</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1030</internalId></provcov>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_CONSTR_00020.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>337</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.CryptoSM.CakCkn_Ready_2_Ick_Ready</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1326</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.KeyGenSM.Requested_2_Busy</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1301</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.IckGenerateAsync.E_OK</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1506</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.KeyGenSM.Busy_2_Idle_Ick</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1308</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.IckGenerateAsync.AsynDone</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1508</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.KeyGenSM.Idle_2_Preparing_Kek</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1305</internalId></provcov>
        <provcov>
          <linksto>Mka.InterAct.Crypto.KekGenerateAsync</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1125</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.KekGenerateAsync</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1031</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.KekGenerateAsync.AsynDone</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1514</internalId></provcov>
        <provcov>
          <linksto>Mka.rfc3394.KeyWrap.Indexing.3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>469</internalId></provcov>
        <provcov>
          <linksto>Mka.rfc3394.KeyUnwrap.Indexing.3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>477</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.CryptoSM.Ick_ready_2_Kek_Ready</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1335</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.KeyGenSM.Busy_2_Idle_Kek</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1309</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.KekGenerateAsync.E_OK</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1512</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1914</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01011_KekIckGen_Sync128</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>390</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that correct Csm functions are called in correct order with correct set of input variables in synchronous mode. Mka_Crypto_IckGenerateAsync() is called from Logon unit to start Ick and then Kek generator. 128bit key algorithms are used.
Test Object: Mka_Crypto_IckGenerateAsync() in synchronous mode
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
  
Test Execution: 
    01: Call Mka crypto unit API Mka_Crypto_IckGenerateAsync to start Ick Generate procedure.
    02: VP(Mka.InterAct.Crypto.IckGenerateSync,1)
        VP(Mka.dsn.Crypto.Api.IckGenerateAsync.SynDone, 1)
        VP(Mka.8021X.MkaKeyHierarchy.17.1, 1) Verify that Csm functions are called in correct order with correct input variables.
    03: Call Mka crypto unit API Mka_Crypto_KekGenerateAsync to start Kek Generate procedure.
    04: VP(Mka.InterAct.Crypto.KekGenerateSync,1)
        VP(Mka.dsn.Crypto.Api.KekGenerateAsync.SynDone, 1)
        VP(Mka.8021X.MkaKeyHierarchy.17.1, 1) Verify that Csm functions are called in correct order with correct input variables.
    05: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.InterAct.Crypto.IckGenerateSync</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1122</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.IckGenerateAsync.SynDone</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1507</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.MkaKeyHierarchy.17.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>136</internalId></provcov>
        <provcov>
          <linksto>Mka.InterAct.Crypto.KekGenerateSync</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1124</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.KekGenerateAsync.SynDone</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1513</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1915</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01012_KekIckGen_Async256</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>432</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that correct Csm functions are called in correct order with correct set of input variables in asynchronous mode. Mka_Crypto_IckGenerateAsync() is called from Logon unit to start Ick and then Kek generator. Mka_CsmKeyGenerateCallback is called two times asynchronously by Csm module, once for Ick and once for Kek. 256bit key algorithms are used.
Test Object: Mka_Crypto_IckGenerateAsync() in asynchronous mode
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
  
Test Execution: 
    01: Call Mka crypto unit API Mka_Crypto_IckGenerateAsync to start Ick Generate procedure.
    02: VP(Mka.InterAct.Crypto.IckGenerateAsync,1) Verify that Csm functions are called in correct order with correct input variables.
    03: Asynchronous callback from Csm to Crypto unit Mka_CsmKeyGenerateCallback() and call Mka_Crypto_MainFunction to process request for generation and start generating the key.
    04: VP(Mka.InterAct.Crypto.IckGenerateAsync,1) Verify that Csm functions are called again (256) in correct order with correct input variables.
    05: Asynchronous callback from Csm to Crypto unit Mka_CsmKeyGenerateCallback() and call Mka_Crypto_MainFunction to process request for generation and start generating the key.
    06: VP(Mka.InterAct.Crypto.IckGenerateAsync,1) Verify that Crypto unit is calling Csm functions in correct order with designated input.
    07: Call Mka crypto unit API Mka_Crypto_KekGenerateAsync to start Kek Generate procedure.
    08: VP(Mka.InterAct.Crypto.KekGenerateAsync,1) Verify that Csm functions are called in correct order with correct input variables.
    09: Asynchronous call from Csm to Crypton unit Mka_CsmKeyGenerateCallback().
    10: VP(Mka.InterAct.Crypto.KekGenerateAsync,1) Verify that Crypto unit is calling Csm functions again (256) in correct order with designated input.
    11: Asynchronous call from Csm to Crypton unit Mka_CsmKeyGenerateCallback().
    12: VP(Mka.InterAct.Crypto.KekGenerateAsync,1) Verify that Crypto unit is calling Csm functions in correct order with designated input.
    13: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.InterAct.Crypto.IckGenerateAsync</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1123</internalId></provcov>
        <provcov>
          <linksto>Mka.InterAct.Crypto.KekGenerateAsync</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1125</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1916</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01013_KekIckGen_Sync256</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>466</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that correct Csm functions are called in correct order with correct set of input variables in synchronous mode. Mka_Crypto_IckGenerateAsync() is called from Logon unit to start Ick and then Kek generator. 256bit key algorithms are used.
Test Object: Mka_Crypto_IckGenerateAsync() in synchronous mode
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
  
Test Execution: 
    01: Call Mka crypto unit API Mka_Crypto_IckGenerateAsync to start Ick Generate procedure.
    02: VP(Mka.InterAct.Crypto.IckGenerateSync,1)
        VP(Mka.8021X.MkaKeyHierarchy.17.2, 1) Verify that Csm functions are called in correct order with correct input variables
    03: Call Mka crypto unit API Mka_Crypto_IckGenerateAsync to start Kek Generate procedure.
    04: VP(Mka.InterAct.Crypto.KekGenerateSync,1)
        VP(Mka.8021X.MkaKeyHierarchy.17.2, 1) Verify that Csm functions are called in correct order with correct input variables
    05: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.InterAct.Crypto.IckGenerateSync</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1122</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.MkaKeyHierarchy.17.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>137</internalId></provcov>
        <provcov>
          <linksto>Mka.InterAct.Crypto.KekGenerateSync</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1124</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1917</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01014_IcvGen_Async128</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>498</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that correct Csm function is called with correct set of input variables in asynchronous mode. Mka_Crypto_IcvGenerateAsync is called from RxTx unit. Mka_CsmIcvGenerateCallback is called only once from Csm module as Csm_MacGenerate() is called in SINGLECALL mode of operation. 128bit key algorithms are used.
Test Object: Mka_Crypto_IcvGenerateAsync() in asynchronous mode
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
  
Test Execution: 
    01: Call Mka_Crypto_Init().
    02: VP(Mka.dsn.Crypto.IcvGenSM.Initial_Initialization,2) Verify that Csm_KeyElementGet() is called for each participant. Also, after Mka_Crypto_Init() IcvGenSM transitions to ICVGEN_IDLE
    03: Do the asynchronous KekIckGenerate procedure to set the correct crypto state.
    04: Call Mka crypto unit API Mka_Crypto_IcvGenerateAsync to start IcvGenerate procedure.
    05: VP(Mka.dsn.Crypto.IcvGenSM.Idle_2_Requested,2)
        VP(Mka.dsn.Crypto.Api.IcvGenerateAsync,2) *
        VP(Mka.InterAct.Crypto.IcvGenerateAsync,2) Verify that Csm_MacGenerate() is called and Mka_Crypto_IcvGenerateAsync returns E_OK. This confirms the transition to ICVGEN_REQUESTED.
    06: Simulate successful IcvGen by calling Mka_CsmIcvGenerateCallback() with E_OK. Then call Mka crypto main function to process IcvGen started notification
    07: VP(Mka.dsn.Crypto.IcvGenSM.Requested_2_Notify,2)
        VP(Mka.dsn.Crypto.IcvGenSM.Notify_2_Idle,2) Verify that result is reported by calling Mka_RxTx_IcvGenerateFinished(). This also confirms the transition to ICVGEN_NOTIFY and further back to ICVGEN_IDLE
    08: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.IcvGenSM.Initial_Initialization</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1265</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.IcvGenSM.Idle_2_Requested</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1262</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.IcvGenerateAsync</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1035</internalId></provcov>
        <provcov>
          <linksto>Mka.InterAct.Crypto.IcvGenerateAsync</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1119</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.IcvGenSM.Requested_2_Notify</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1260</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.IcvGenSM.Notify_2_Idle</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1264</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1918</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01015_IcvGen_Sync128</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>546</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that correct Csm function is called with correct set of input variables in synchronous mode. Mka_Crypto_IcvGenerateAsync is called from RxTx unit. 128bit key algorithms are used.
Test Object: Mka_Crypto_IcvGenerateAsync() in synchronous mode
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
  
Test Execution: 
    01: Do the synchronous KekIckGenerate procedure to set the correct crypto state.
    02: Call Mka crypto unit API Mka_Crypto_IcvGenerateAsync to start RandomGenerate procedure.
    03: VP(Mka.InterAct.Crypto.IcvGenerateSync,2)
        VP(Mka.dsn.Crypto.Api.IcvGenerateAsync.ValidParam,1)
        VP(Mka.dsn.Crypto.Api.IcvGenerateAsync.SynDone,2) Verify that Csm functions are called in correct order with correct input variables.
    04: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.InterAct.Crypto.IcvGenerateSync</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1118</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.IcvGenerateAsync.ValidParam</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1524</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.IcvGenerateAsync.SynDone</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1525</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1919</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01016_CsmCallback_NoTaskFail</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>577</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that CsmCallback functions, when called without starting the generate procedure beforehand, exit safely and return E_NOT_OK.
Test Object: Crypto Csm Callback functions in asynchronous mode.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
  
Test Execution: 
    01: Call Mka_CsmRandomCallback with result E_OK but without generating key before it because no active RandomGen job should exist.
    02: VP(Mka.Crypto.RandomCallback_NotStarted,1) Check that no other functions have been called.
    03: Call Mka_CsmKeyGenerateCallback with result E_OK but without generating key before it and thus setting the state machine. Call with KEKGen Job ID input.
    04: VP(Mka.Crypto.KeyGenerateCallback_NotStarted,1) Check that no other functions have been called.
    05: Call Mka_CsmKeyGenerateCallback with result E_OK but without generating key before it and thus setting the state machine. Call with ICKGen Job ID input.
    06: VP(Mka.Crypto.KeyGenerateCallback_NotStarted,1) Check that no other functions have been called.
    07: Call Mka_CsmIcvGenerateCallback with result E_OK but without generating ICV before it and thus setting the state machine.
    08: VP(Mka.Crypto.IcvGenerateCallback_NotStarted,1) Check that no other functions have been called.
    09: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Crypto.RandomCallback_NotStarted</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1194</internalId></provcov>
        <provcov>
          <linksto>Mka.Crypto.KeyGenerateCallback_NotStarted</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1195</internalId></provcov>
        <provcov>
          <linksto>Mka.Crypto.IcvGenerateCallback_NotStarted</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1196</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1920</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01017_IcvGen_Async_Fail</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>611</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that the function Mka_Crypto_IcvGenerateAsync fails safely when the input parameters are incorrect and then returns E_NOT_OK.
Test Object: Mka_Crypto_IcvGenerateAsync() in asynchronous mode.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
  
Test Execution: 
    01: Call Mka_Crypto_IcvGenerateAsync before ICK is ready.
    02: VP(Mka.Crypto.IcvGen_RequestInvalidState,1) Check that the returned value is E_NOT_OK and that no other functions have been called
    03: Sanity check - Reset variables.
    04: Do the asynchronous KekIckGenerate procedure to set the correct crypto state.
    05: Call Mka_Crypto_IcvGenerateAsync to start ICV generate process.
    06: Sanity check - Check to make sure the first call returned E_OK and started the process as expected.
    07: Sanity check - Reset variables.
    08: Call Mka_Crypto_IcvGenerateAsync again while ICV generate process is ongoing.
    09: VP(Mka.Crypto.IcvGen_RequestInvalidIcvGenState,1) Check that the returned value is E_NOT_OK and that the process is not started.
    10: Sanity check - Finish previously started ICV generate process
    11: Sanity check - Reset variables.
    12: Call Mka_Crypto_IcvGenerateAsync with NULL_PTR as an input to DataPtr.
    13: Sanity check - Check that the returned value is E_NOT_OK and that no other functions have been called.
    14: Sanity check - Reset variables.
    15: Call Mka_Crypto_IcvGenerateAsync with NULL_PTR as an input to MPtr.
    16: Sanity check - Check that the returned value is E_NOT_OK and that no other functions have been called.
    17: Sanity check - Reset variables.
    18: Call Mka_Crypto_IcvGenerateAsync with BufferLength value too small.
    19: VP(Mka.Crypto.IcvGen_RequestInvalidBuffLen,1) Check that the returned value is E_NOT_OK and that no other functions have been called
    20: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Crypto.IcvGen_RequestInvalidState</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1219</internalId></provcov>
        <provcov>
          <linksto>Mka.Crypto.IcvGen_RequestInvalidIcvGenState</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1220</internalId></provcov>
        <provcov>
          <linksto>Mka.Crypto.IcvGen_RequestInvalidBuffLen</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1221</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1921</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01018_RandGen_Async_Fail</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>656</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that the function Mka_Crypto_RandomGenerateAsync fails safely when the input parameters are incorrect and then returns E_NOT_OK.
Test Object: Mka_Crypto_RandomGenerateAsync() in asynchronous mode
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
  
Test Execution: 
    01: Call Mka_Crypto_RandomGenerateAsync with too small RandomLength input parameter
    02: VP(Mka.dsn.Crypto.Api.RandomGenerateAsync,1) Check that the returned value is E_NOT_OK and that no other functions have been called
    03: Call Mka_Crypto_RandomGenerateAsync with too big RandomLength input parameter.
    04: VP(Mka.dsn.Crypto.Api.RandomGenerateAsync,1) Check that the returned value is E_NOT_OK and that no other functions have been called
    05: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.RandomGenerateAsync</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1036</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1922</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01019_CsmCallback_WrongJobID</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>678</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that CsmCallback functions, when called with incorrect JobID input parameter shall exit safely and return E_NOT_OK.
Test Object: Crypto Csm Callback functions with incorrect JobID in asynchronous mode.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
  
Test Execution: 
    01: Call Mka_CsmRandomCallback with result E_OK but with incorrect JobID.
    02: VP(Mka.Crypto.RandomCallback_NoMatch,1) Check that the call has been ignored.
    03: Call Mka_CsmKeyGenerateCallback with result E_OK but with incorrect JobID.
    04: VP(Mka.Crypto.KeyGenerateCallback_NoMatch,1) Check that the call has been ignored.
    05: Call Mka_CsmIcvGenerateCallback with result E_OK but with incorrect JobID.
    06: VP(Mka.Crypto.IcvGenerateCallback_NoMatch,1) Check that the call has been ignored.
    07: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Crypto.RandomCallback_NoMatch</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1188</internalId></provcov>
        <provcov>
          <linksto>Mka.Crypto.KeyGenerateCallback_NoMatch</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1189</internalId></provcov>
        <provcov>
          <linksto>Mka.Crypto.IcvGenerateCallback_NoMatch</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1190</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1923</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01020_RandomGen_Async128_JobFail</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>710</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when RandomGen job starts and Mka_CsmRandomCallback returns E_NOT_OK, Mka_Kay_RandomGenerateFinished is called correctly with input parameter E_NOT_OK and any further progress is terminated.
Test Object: Mka_Crypto_RandomGenerateAsync() in Asynchronous mode with Callback RetVal E_NOT_OK.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Setting up stubs.
  
Test Execution: 
    01: Call Mka crypto unit API Mka_Crypto_RandomGenerateAsync to start RandomGenerate procedure.
    02: Sanity check - Check that Random generate process has been started as expected with correct ID.
    03: Asynchronous call from Csm to Crypto unit Mka_CsmRandomCallback() with E_NOT_OK parameter.
    04: VP(Mka.Crypto.RandomGen_Async_RandomGenFail,1)
        VP(Mka.dsn.Crypto.RandomGenSM.Busy_2_Notified,1) Verify that Crypto unit is calling correct Mka_Kay_RandomGenerateFinished with result E_NOT_OK. This also confirms (failed) transition to RNG_IDLE
    05: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Crypto.RandomGen_Async_RandomGenFail</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1210</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.RandomGenSM.Busy_2_Notified</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1354</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1924</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01021_RandomGen_Async128_StartFail</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>738</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when Csm_RandomGenerate fails and returns E_NOT_OK, Mka_Kay_RandomGenerateFinished is called correctly with input parameter E_NOT_OK.
Test Object: Mka_Crypto_RandomGenerateAsync() in Asynchronous mode with Csm job fail.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
  
Test Execution: 
    01: Configure stub for Csm_RandomGenerate to return E_NOT_OK
    02: Call Mka crypto unit API Mka_Crypto_RandomGenerateAsync to start RandomGenerate procedure.
    03: VP(Mka.Crypto.RandomGen_StartGenFail,1) Verify that Mka_Crypto_RandomGenerateAsync returns E_NOT_OK.
    04: Sanity check - Check that Mka_CsmRandomCallback call was ignored.
    05: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Crypto.RandomGen_StartGenFail</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1209</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1925</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01022_RandomGen_Sync128_StartFail</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>760</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when Csm fails the RandomGen job and returns E_NOT_OK, Mka_Kay_RandomGenerateFinished is called correctly with input parameter E_NOT_OK.
Test Object: Mka_Crypto_RandomGenerateAsync() in Synchronous mode with Csm job fail.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
  
Test Execution: 
    01: Configure stub for Csm_RandomGenerate to return E_NOT_OK.
    02: Call Mka crypto unit API Mka_Crypto_RandomGenerateAsync to start RandomGenerate procedure.
    03: VP(Mka.Crypto.RandomGen_StartGenFail,1) Verify that Crypto unit is calling correct Mka_Kay_RandomGenerateFinished with result E_NOT_OK.
    04: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Crypto.RandomGen_StartGenFail</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1209</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1926</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01023_KekIckGen_Async128_JobFail</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>781</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when key generation fails and returns E_NOT_OK through Mka_CsmKeyGenerateCallback, Mka_Logon_IckGenerateFinished is called correctly with input parameter E_NOT_OK.
Test Object: Mka_Crypto_IckGenerateAsync() in Asynchronous mode with Csm job fail.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
  
Test Execution: 
    01: Call Mka crypto unit API Mka_Crypto_IckGenerateAsync to start Ick Generate procedure.
    02: Sanity check - Check that generate process is started.
    03: Asynchronous callback from Csm to Crypto unit Mka_CsmKeyGenerateCallback() and call Mka_Crypto_MainFunction to process request.
    04: VP(Mka.Crypto.KeyGen_Ick_Async_KeyGenFail,1) Verify that Crypto unit is calling only Mka_Logon_IckGenerateFinished with E_NOT_OK.
    05: Call Mka crypto unit API Mka_Crypto_IckGenerateAsync to start Ick Generate procedure.
    06: Asynchronous callback from Csm to Crypto unit Mka_CsmKeyGenerateCallback() and call Mka_Crypto_MainFunction to process request to finish ICK generate process and start the KEK generate process.
    07: Call Mka crypto unit API Mka_Crypto_IckGenerateAsync to start Kek Generate procedure.
    08: Sanity check - Check that generate process is started.
    09: Asynchronous call from Csm to Crypton unit Mka_CsmKeyGenerateCallback() and call Mka_Crypto_MainFunction to process request for KEK generate process with E_NOT_OK to indicate job fail.
    10: VP(Mka.Crypto.KeyGen_Kek_Async_KeyGenFail,1) Verify that Crypto unit is calling only Mka_KaY_KekGenerateFinished with E_NOT_OK.
    11: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Crypto.KeyGen_Ick_Async_KeyGenFail</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1202</internalId></provcov>
        <provcov>
          <linksto>Mka.Crypto.KeyGen_Kek_Async_KeyGenFail</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1203</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1927</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01024_IcvGen_Async128_JobFail</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>813</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when Csm fails the IcvGen job and returns E_NOT_OK, Mka_RxTx_IcvGenerateFinished is called correctly with input parameter E_NOT_OK.
Test Object: Mka_Crypto_IcvGenerateAsync() in Asynchronous mode with Csm job fail.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
  
Test Execution: 
    01: Do the asynchronous KekIckGenerate procedure to set the correct crypto state.
    02: Call Mka crypto unit API Mka_Crypto_IcvGenerateAsync to start IcvGenerate procedure.
    03: Call Mka crypto unit main function Mka_Crypto_MainFunction() to run the Crypto thread.
    04: Asynchronous call from Csm to Crypto unit Mka_CsmIcvGenerateCallback() with E_NOT_OK.
    05: VP(Mka.Crypto.IcvGen_Async_IcvGenFail,1)
        VP(Mka.dsn.Crypto.IcvGenSM.Requested_2_Idle,2) Verify that Crypto unit is calling Mka_RxTx_IcvGenerateFinished with input E_NOT_OK as the generating failed. This also confirms the transition back to ICVGEN_IDLE
    06: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Crypto.IcvGen_Async_IcvGenFail</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1212</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.IcvGenSM.Requested_2_Idle</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1261</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1928</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01025_IcvGen_Async128_StartFail</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>841</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when Csm_MacGenerate call returns E_NOT_OK, Crypto unit shall stop any further processing and report to the caller that the generation has failed.
Test Object: Mka_Crypto_IcvGenerateAsync() in asynchronous mode.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Do the asynchronous KekIckGenerate procedure to set the correct crypto state before ICV gen.
  
Test Execution: 
    01: Set return value of Csm_MacGenerate to E_NOT_OK to simulate failed generate.
    02: Call Mka crypto unit API Mka_Crypto_IcvGenerateAsync to prepare IcvGenerate procedure.
    03: Call Mka crypto unit main function Mka_Crypto_MainFunction() to run the Crypto thread.
    04: VP(Mka.Crypto.IcvGen_StartGenFail,2)
        VP(Mka.dsn.Crypto.IcvGenSM.Requested_2_Idle,2) Verify that Crypto unit did not continue the generating process and that it reported E_NOT_OK to the caller. This also verifies transition from ICVGEN_REQUESTED to ICVGEN_IDLE state of IcvGen SM.
    05: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Crypto.IcvGen_StartGenFail</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1211</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.IcvGenSM.Requested_2_Idle</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1261</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1929</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01026_IcvGen_Sync128_StartFail</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>869</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when Csm_MacGenerate call returns E_NOT_OK as a result if Mka_Crypto_IcvGenerateAsync() call, Crypto unit shall stop any further processing and report to the caller that the generation has failed.
Test Object: Mka_Crypto_IcvGenerateAsync() in synchronous mode.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Do the asynchronous KekIckGenerate procedure to set the correct crypto state before ICV gen.
  
Test Execution: 
    01: Set return value of Csm_MacGenerate to E_NOT_OK to simulate failed generate.
    02: Call Mka_Crypto_IcvGenerateAsync and Mka_Crypto_MainFunction to start RandomGenerate procedure.
    03: VP(Mka.Crypto.IcvGen_StartGenFail,2) Verify that failed ICV generation is reported to the caller.
    04: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Crypto.IcvGen_StartGenFail</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1211</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1930</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01027_IcvGen_Async128_GenFail</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>891</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when Mka_CsmIcvGenerateCallback returns E_NOT_OK, Crypto unit shall report to the caller that the generation has failed.
Test Object: Mka_Crypto_IcvGenerateAsync() in asynchronous mode.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Do the asynchronous KekIckGenerate procedure to set the correct crypto state before ICV gen.
  
Test Execution: 
    01: Call Mka crypto unit API Mka_Crypto_IcvGenerateAsync to prepare IcvGenerate procedure.
    02: Call Callback function with input parameter E_NOT_OK.
    03: VP(Mka.Crypto.IcvGen_Async_IcvGenFail,1) Verify that Crypto unit informed the called about failed ICV generation.
    04: Sanity check - Reset variables.
    05: Call Mka crypto unit API Mka_Crypto_IcvGenerateAsync to prepare IcvGenerate procedure.
    06: Call Callback function with input parameter E_NOT_OK.
    07: VP(Mka.Crypto.IcvGen_Async_IcvGenFail,1) Verify that Crypto unit informed the called about failed ICV generation.
    08: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Crypto.IcvGen_Async_IcvGenFail</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1212</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1931</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01028_KekIckGen_Async128_StartFail</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>917</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when Csm_MacGenerate fails to start the Kek or Ick Generate job and returns E_NOT_OK, Mka_Logon_IckGenerateFinished is called correctly with input parameter E_NOT_OK. Test is done in asynchronous mode.
Test Object: Mka_Crypto_IckGenerateAsync() in Asynchronous mode with Csm start job fail.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
  
Test Execution: 
    01: Set Csm_MacGenerate_Stub.RetVal to E_NOT_OK to simulate failed start for key generation.
    02: Call Mka crypto unit API Mka_Crypto_IckGenerateAsync to start Ick Generate procedure.
    03: VP(Mka.Crypto.KeyGen_Ick_StartGenFail,1) Verify that Crypto unit is calling Mka_Logon_IckGenerateFinished with E_NOT_OK.
    04: Set Csm_MacGenerate_Stub.RetVal to E_NOT_OK to simulate failed start for key generation.
    05: Generate Ick and prepare for Kek generation.
    06: Call Mka crypto unit API Mka_Crypto_KekGenerateAsync to start Kek Generate procedure.
    07: VP(Mka.Crypto.KeyGen_Kek_StartGenFail,1) Verify that Crypto unit is calling only Mka_Logon_IckGenerateFinished with E_NOT_OK.
    08: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Crypto.KeyGen_Ick_StartGenFail</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1200</internalId></provcov>
        <provcov>
          <linksto>Mka.Crypto.KeyGen_Kek_StartGenFail</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1201</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1932</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01029_KekIckGen_Sync128_StartFail</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>946</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when Csm_MacGenerate fails to start the KekIckGenerate job and returns E_NOT_OK, Mka_Logon_IckGenerateFinished is called correctly with input parameter E_NOT_OK. Test is done in synchronous mode.
Test Object: Mka_Crypto_IckGenerateAsync() in Synchronous mode with Csm start job fail.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
  
Test Execution: 
    01: Set Csm_MacGenerate_Stub.RetVal to E_NOT_OK to simulate failed start for ICK key generation.
    02: Call Mka crypto unit API Mka_Crypto_IckGenerateAsync to start Ick Generate procedure.
    03: VP(Mka.Crypto.KeyGen_Ick_StartGenFail,1) Verify that Crypto unit is calling only Mka_Logon_IckGenerateFinished after failed MacGenerate with E_NOT_OK.
    04: Set Csm_MacGenerate_Stub.RetVal to E_NOT_OK to simulate failed start for KEK key generation.
    05: Generate Ick and prepare for Kek generation.
    06: Call Mka crypto unit API Mka_Crypto_KekGenerateAsync to start Kek Generate procedure.
    07: VP(Mka.Crypto.KeyGen_Kek_StartGenFail,1)
        VP(Mka.dsn.Crypto.CryptoSM.Ick_Ready_2_CakCkn_Ready,1) Verify that Crypto unit is calling only Mka_KaY_KekGenerateFinished after failed MacGenerate with E_NOT_OK.
    08: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Crypto.KeyGen_Ick_StartGenFail</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1200</internalId></provcov>
        <provcov>
          <linksto>Mka.Crypto.KeyGen_Kek_StartGenFail</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1201</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.CryptoSM.Ick_Ready_2_CakCkn_Ready</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1333</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1933</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01030_KekIckGen_Async128_PrepareFail</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>980</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when Csm_KeyElementGet fails to prepare the Kek or Ick Generate job and returns E_NOT_OK, Mka_Logon_IckGenerateFinished is called correctly with input parameter E_NOT_OK. Test is done in asynchronous mode.
Test Object: Mka_Crypto_IckGenerateAsync() in Asynchronous mode with Csm start job fail.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
  
Test Execution: 
    01: Set Csm_KeyElementGet_Stub.RetVal to E_NOT_OK to simulate failed preparation for key generation.
    02: Call Mka crypto unit API Mka_Crypto_IckGenerateAsync to start Ick and Kek Generate procedure.
    03: VP(Mka.Crypto.KeyGen_PrepareIck_GetCkn_Fail,1)
        VP(Mka.dsn.Crypto.KeyGenSM.Preparing_2_Idle,1) Verify that Crypto API returned E_NOT_OK after calling Csm_KeyElementGet.
    04: Call Mka crypto unit main function Mka_Crypto_MainFunction() to run the Crypto thread.
    05: VP(Mka.Crypto.KeyGen_PrepareIck_GetCkn_Fail,1) Verify that Crypto unit is not calling any functions as it shall stop all procedures.
    06: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Crypto.KeyGen_PrepareIck_GetCkn_Fail</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1204</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.KeyGenSM.Preparing_2_Idle</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1304</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1934</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01031_KekIckGen_Sync128_PrepareFail</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>1008</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when Csm_KeyElementGet fails to prepare the KekIckGenerate job and returns E_NOT_OK, Mka_Logon_IckGenerateFinished is called correctly with input parameter E_NOT_OK. Test is done in synchronous mode.
Test Object: Mka_Crypto_IckGenerateAsync() in Synchronous mode with Csm start job fail.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
  
Test Execution: 
    01: Set Csm_KeyElementGet_Stub.RetVal to E_NOT_OK to simulate failed preparation for ICK key generation.
    02: Call Mka crypto unit API Mka_Crypto_IckGenerateAsync to start Ick and Kek Generate procedure.
    03: Call Mka crypto unit main function Mka_Crypto_MainFunction() to run the Crypto thread.
    04: VP(Mka.Crypto.KeyGen_PrepareIck_GetCkn_Fail,1) Verify that Crypto unit has stopped all further processes due to failed key preparation.
    05: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Crypto.KeyGen_PrepareIck_GetCkn_Fail</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1204</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1935</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01032_KekIckGen_Async128_SetFail</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>1030</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when Csm_KeyElementSet fails and returns E_NOT_OK, Mka_Logon_IckGenerateFinished is called correctly with input parameter E_NOT_OK and progress is stopped. Test is done in asynchronous mode.
Test Object: Mka_Crypto_IckGenerateAsync() in Asynchronous mode with Csm set job fail.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
  
Test Execution: 
    01: Set Csm_KeyElementSet_Stub.RetVal to E_NOT_OK to simulate failed key set for ICK
    02: Call Mka crypto unit API Mka_Crypto_IckGenerateAsync to start Ick and Kek Generate procedure.
    03: Asynchronous callback from Csm to Crypto unit Mka_CsmKeyGenerateCallback() to finish ICK generate process and continue the process to SET key.
    04: VP(Mka.Crypto.KeyGen_SetIck_Fail,1) Verify that Crypto unit is reporting back with E_NOT_OK and not calling any further functions as it shall stop all procedures.
    05: Set Csm_KeyElementSet_Stub.RetVal to E_NOT_OK to simulate failed key set for KEK.
    06: Generate Ick and prepare for Kek generation.
    07: Call Mka crypto unit API Mka_Crypto_KekGenerateAsync to start Ick and Kek Generate procedure.
    08: Asynchronous callback from Csm to Crypto unit Mka_CsmKeyGenerateCallback() to finish ICK generate process and continue the KEK generate process.
    09: VP(Mka.Crypto.KeyGen_SetKek_Fail,1) Verify that Crypto unit is calling Mka_Crypto_KekGenerateAsync with E_NOT_OK and stopping the rest of the process.
    10: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Crypto.KeyGen_SetIck_Fail</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1205</internalId></provcov>
        <provcov>
          <linksto>Mka.Crypto.KeyGen_SetKek_Fail</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1207</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1936</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01033_KekIckGen_Sync128_SetFail</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>1061</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when Csm_KeyElementSet fails and returns E_NOT_OK, Mka_Logon_IckGenerateFinished is called correctly with input parameter E_NOT_OK and progress is stopped. Test is done in synchronous mode.
Test Object: Mka_Crypto_IckGenerateAsync() in Synchronous mode with Csm set job fail.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
  
Test Execution: 
    01: Set Csm_KeyElementSet_Stub.RetVal to E_NOT_OK to simulate failed key set for ICK
    02: Call Mka crypto unit API Mka_Crypto_IckGenerateAsync to start Ick Generate procedure.
    03: VP(Mka.Crypto.KeyGen_SetIck_Fail,1) Verify that Crypto unit is calling Mka_Logon_IckGenerateFinished with E_NOT_OK after failed Csm_KeyElementSet for ICK.
    04: Set Csm_KeyElementSet_Stub.RetVal to E_NOT_OK to simulate failed key set for KEK
    05: Generate Ick and prepare for Kek generation.
    06: Call Mka crypto unit API Mka_Crypto_KekGenerateAsync to start Kek Generate procedure.
    07: VP(Mka.Crypto.KeyGen_SetKek_Fail,1) Verify that Crypto unit is calling Mka_KaY_KekGenerateFinished with E_NOT_OK after unsuccessfull CSM_KeyElementSet for KEK.
    08: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Crypto.KeyGen_SetIck_Fail</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1205</internalId></provcov>
        <provcov>
          <linksto>Mka.Crypto.KeyGen_SetKek_Fail</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1207</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1937</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01034_KekIckGen_Async128_ValidFail</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>1090</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when Csm_KeySetValid fails and returns E_NOT_OK, Mka_Logon_IckGenerateFinished is called correctly with input parameter E_NOT_OK and progress is stopped. Test is done in asynchronous mode.
Test Object: Mka_Crypto_IckGenerateAsync() in Asynchronous mode with Csm set job fail.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
  
Test Execution: 
    01: Set Csm_KeySetValid_Stub.RetVal to E_NOT_OK to simulate failed key set for ICK
    02: Call Mka crypto unit API Mka_Crypto_IckGenerateAsync to start Ick Generate procedure.
    03: Call Mka crypto unit main function Mka_Crypto_MainFunction() to run the Crypto thread.
    04: Asynchronous callback from Csm to Crypto unit Mka_CsmKeyGenerateCallback() to finish ICK generate process and continue the process to SET key.
    05: VP(Mka.Crypto.KeyGen_SetIckValid_Fail,1)
        VP(Mka.dsn.Crypto.KeyGenSM.Busy_2_Idle_Fail,1) Verify that Crypto unit is reporting back with E_NOT_OK and not calling any further functions as it shall stop all procedures.
    06: Set Csm_KeySetValid_Stub.RetVal to E_NOT_OK to simulate failed key set for KEK.
    07: Generate Ick and prepare for Kek generation.
    08: Call Mka crypto unit API Mka_Crypto_KekGenerateAsync to start Kek Generate procedure.
    09: Asynchronous callback from Csm to Crypto unit Mka_CsmKeyGenerateCallback() to finish KEK generate process.
    10: VP(Mka.Crypto.KeyGen_SetKekValid_Fail,1)
        VP(Mka.dsn.Crypto.KeyGenSM.Busy_2_Idle_Kek,1) Verify that Crypto unit is calling Mka_KaY_KekGenerateFinished with E_NOT_OK and stopping the rest of the process.
    11: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Crypto.KeyGen_SetIckValid_Fail</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1206</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.KeyGenSM.Busy_2_Idle_Fail</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1307</internalId></provcov>
        <provcov>
          <linksto>Mka.Crypto.KeyGen_SetKekValid_Fail</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1208</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.KeyGenSM.Busy_2_Idle_Kek</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1309</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1938</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01035_KekIckGen_Sync128_ValidFail</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>1132</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when Csm_KeySetValid fails and returns E_NOT_OK, Mka_Logon_IckGenerateFinished is called correctly with input parameter E_NOT_OK and progress is stopped. Test is done in synchronous mode.
Test Object: Mka_Crypto_IckGenerateAsync() in Synchronous mode with Csm set job fail.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
  
Test Execution: 
    01: Set Csm_KeySetValid_Stub.RetVal to E_NOT_OK to simulate failed key set for ICK
    02: Call Mka crypto unit API Mka_Crypto_IckGenerateAsync to start Ick Generate procedure.
    03: VP(Mka.Crypto.KeyGen_SetIckValid_Fail,1) Verify that Crypto unit is calling Mka_Logon_IckGenerateFinished with E_NOT_OK after failed Csm_KeySetValid for ICK.
    04: Set Csm_KeySetValid_Stub.RetVal to E_NOT_OK to simulate failed key set for KEK
    05: Generate Ick and prepare for Kek generation.
    06: Call Mka crypto unit API Mka_Crypto_KekGenerateAsync to start Kek Generate procedure.
    07: VP(Mka.Crypto.KeyGen_SetKekValid_Fail,1) Verify that Crypto unit is calling Mka_KaY_KekGenerateFinished with E_NOT_OK after unsuccessfull CSM_KeySetValid for KEK.
    08: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Crypto.KeyGen_SetIckValid_Fail</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1206</internalId></provcov>
        <provcov>
          <linksto>Mka.Crypto.KeyGen_SetKekValid_Fail</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1208</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1939</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01036_IckGen_Async128_DoublesFail</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>1161</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when another IckGen instance is already running, calling new IckGen does not start the Ick Generate job and returns E_NOT_OK, Mka_Logon_IckGenerateFinished is called with input parameter E_NOT_OK. Test is done in asynchronous mode.
Test Object: Mka_Crypto_IckGenerateAsync() in Asynchronous mode.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
  
Test Execution: 
    01: Call Mka crypto unit API Mka_Crypto_IckGenerateAsync to start Ick and Kek Generate procedure.
    02: Sanity check - Check that Mka_Crypto_IckGenerateAsync prepared gen. successfully and returned E_OK as expected.
    03: Call Mka crypto unit main function Mka_Crypto_MainFunction() to run the Crypto thread.
    04: Sanity check - Check that gen. process has been started.
    05: Call another Mka_Crypto_IckGenerateAsync to start new instance of Ick Generate procedure.
    06: VP(Mka.Crypto.KeyGen_Ick_RequestInvalidKeyGenState,1) Verify that Crypto unit returned E_NOT_OK.
    07: Sanity check - Finish ongoing ICK Generate process
    08: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Crypto.KeyGen_Ick_RequestInvalidKeyGenState</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1216</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1940</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01037_GetCknPtr_KeyNotAvailable</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>1186</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when Mka_Crypto_GetCknPtr is called when there is no existing CKN, it returns E_MKA_KEY_NOT_AVAILABLE.
Test Object: Mka_Crypto_GetCknPtr() in both sync and async mode.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
  
Test Execution: 
    01: Set Csm_KeyElementGet_Stub RetVal to E_NOT_OK.
    02: Call Mka crypto unit API Mka_Crypto_CopyCkn to try to get CKN.
    03: VP(Mka.dsn.Crypto.Api.CopyCkn.CknNotStored,1) Verify that Crypto unit returned TS_CknSize = 0 and no further processes are activated.
    04: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.CopyCkn.CknNotStored</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1540</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1941</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01038_GetCknPtr_E_OK</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>1207</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when Mka_Crypto_GetCknPtr is called and Csm_KeyElementGet returns E_OK, Crypto unit returns E_OK and correct Ckn.
Test Object: Mka_Crypto_GetCknPtr() in both sync and async mode.
Test Precondition: 
    -   Set callout function for Csm_KeyElementGet_Stub to get CKN.
    -   Module configuration and Crypto unit initialized.
  
Test Execution: 
    01: Call Mka crypto unit API Mka_Crypto_GetCknPtr to get CKN.
    02: VP(Mka.dsn.Crypto.Api.GetCknPtr.E_OK,1)
        VP(Mka.dsn.Crypto.Api.GetCknPtr,1)
        VP(Mka.8021X.MkaKeyHierarchy.3.1,1) Verify that Crypto unit returned E_OK and correct CKN parameters.
    03: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.GetCknPtr.E_OK</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1538</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.GetCknPtr</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1039</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.MkaKeyHierarchy.3.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>111</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1942</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01039_IcvVerify_Async128</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>1238</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that correct CSM functions are called in correct sequence in order to verify ICV. Before verifying ICV, we need to generate ICK and KEK to set instance to a correct state.
Test Object: Mka_Crypto_IcvVerifyAsync() in Asynchronous mode.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Reset Stubs.
    -   Do the asynchronous KekIckGenerate procedure to set the correct crypto state before ICV verification.
  
Test Execution: 
    01: Check and clear trace buffer
    02: VP(Mka.dsn.Crypto.IcvVerSM.Initial_Initialization,1) Verify that the ICVVer SM is in Idle State.
    03: Call Mka_CsmMacVerifyCallback() to simulate Csm async job finished callback before the work started.
    04: VP(Mka.Crypto.IcvVerifyCallback_NotStarted,1) Verify that Crypto unit ignored the call and didn't call any other function.
    05: Call Mka_Crypto_IcvVerifyAsync to start ICV verification process.
    06: VP(Mka.InterAct.Crypto.IcvVerifyAsync,1)
        VP(Mka.dsn.Crypto.Api.IcvVerifyAsync,1)
        VP(Mka.dsn.Crypto.IcvVerSM.Idle_2_Requested,1) Verify that the returned value is E_OK and that the ICV verification process has been requested.
    07: VP(Mka.InterAct.Crypto.IcvVerifyAsync,1)
        VP(Mka.dsn.Crypto.Api.IcvVerifyAsync.E_OK,1)
        VP(Mka.dsn.Crypto.IcvVerSM.Requested_2_Notified,1) Verify that Crypto unit called Csm_MacVerify with correct input parameters.
    08: Call Mka_CsmMacVerifyCallback() to simulate Csm async job finished callback.
    09: VP(Mka.InterAct.Crypto.IcvVerifyAsync,1)
        VP(Mka.dsn.Crypto.Api.IcvVerifyAsync.AsynDone,1)
        VP(Mka.dsn.Crypto.IcvVerSM.Notified_2_Idle,1) Verify that Crypto unit called user Mka_RxTx_IcvVerifyFinished with correct parameters.
    10: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.IcvVerSM.Initial_Initialization</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1271</internalId></provcov>
        <provcov>
          <linksto>Mka.Crypto.IcvVerifyCallback_NotStarted</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1197</internalId></provcov>
        <provcov>
          <linksto>Mka.InterAct.Crypto.IcvVerifyAsync</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1121</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.IcvVerifyAsync</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1034</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.IcvVerSM.Idle_2_Requested</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1275</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.IcvVerifyAsync.E_OK</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1518</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.IcvVerSM.Requested_2_Notified</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1269</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.IcvVerifyAsync.AsynDone</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1520</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.IcvVerSM.Notified_2_Idle</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1268</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1943</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01040_IcvVerify_Sync128</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>1305</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that correct CSM functions are called in correct sequence in order to verify ICV. Before verifying ICV, we need to generate ICK and KEK to set instance to a correct state.
Test Object: Mka_Crypto_IcvVerifyAsync() in Synchronous mode.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Do the synchronous KekIckGenerate procedure to set the correct crypto state before ICV verification.
  
Test Execution: 
    01: Call Mka_Crypto_IcvVerifyAsync to start ICV verification process.
    02: VP(Mka.InterAct.Crypto.IcvVerifySync,1)
        VP(Mka.dsn.Crypto.IcvVerSM.Idle_2_Requested,1) Verify that the returned value is E_OK and that the ICV verification process has been requested.
    03: VP(Mka.InterAct.Crypto.IcvVerifySync,1)
        VP(Mka.dsn.Crypto.Api.IcvVerifyAsync.SynDone,1)
        VP(Mka.dsn.Crypto.IcvVerSM.Requested_2_Busy,1)
        VP(Mka.dsn.Crypto.IcvVerSM.Busy_2_Notified,1) Verify that Crypto unit called Csm_MacVerify and Mka_RxTx_IcvVerifyFinished with correct input parameters.
    04: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.InterAct.Crypto.IcvVerifySync</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1120</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.IcvVerSM.Idle_2_Requested</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1275</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.IcvVerifyAsync.SynDone</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1519</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.IcvVerSM.Requested_2_Busy</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1274</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.IcvVerSM.Busy_2_Notified</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1270</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1944</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01041_IcvVerify_Async128_NoMatch</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>1347</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when Mka_CsmIcvVerifyCallback is called with incorrect Job ID, the call will be ignored.
Test Object: Mka_Crypto_IcvVerifyAsync() in Asynchronous mode.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Do the asynchronous KekIckGenerate procedure to set the correct crypto state before ICV verification.
  
Test Execution: 
    01: Call Mka_Crypto_IcvVerifyAsync to start ICV verification process.
    02: Sanity check - Check that the returned value is E_OK and that the ICV verification process has been requested.
    03: Sanity check - Check that Crypto unit started process as expected.
    04: Call Mka_CsmMacVerifyCallback() with incorrect jobID.
    05: VP(Mka.Crypto.IcvVerifyCallback_NoMatch,1) Verify that Crypto unit ignored the call and didn't call any other API.
    06: Call Mka_CsmMacVerifyCallback() to simulate Csm async job finished callback and finish tasking.
    07: Sanity check - Check that Crypto unit called user Mka_RxTx_IcvVerifyFinished to notify of finished task.
    08: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Crypto.IcvVerifyCallback_NoMatch</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1191</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1945</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01042_IcvVerify_Async128_StartVerFail</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>1373</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when Csm_MacVerify returns either RetVal or verifyPtr as E_NOT_OK, the process shall be terminated and the caller notified.
Test Object: Mka_Crypto_IcvVerifyAsync() start verification fail in Asynchronous mode.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Do the asynchronous KekIckGenerate procedure to set the correct crypto state before ICV verification.
  
Test Execution: 
    01: Set Csm_MacVerify_Stub return value and verifyPtr to E_NOT_OK.
    02: Call Mka_Crypto_IcvVerifyAsync to start ICV verification process.
    03: VP(Mka.Crypto.IcvVer_StartVerFail,1)
        VP(Mka.dsn.Crypto.IcvVerSM.Requested_2_Idle,1) Verify that Crypto unit terminated the ICV verification process and reported E_NOT_OK to the caller.
    04: Set Csm_MacVerify_Stub return value to E_NOT_OK.
    05: Call Mka_Crypto_IcvVerifyAsync to start ICV verification process.
    06: VP(Mka.Crypto.IcvVer_StartVerFail,1) Verify that Crypto unit terminated the ICV verification process and reported E_NOT_OK to the caller.
    07: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Crypto.IcvVer_StartVerFail</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1213</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.IcvVerSM.Requested_2_Idle</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1276</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1946</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01043_IcvVerify_Sync128_StartVerFail</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>1403</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when Csm_MacVerify returns either RetVal or verifyPtr as E_NOT_OK, the process shall be terminated and the caller notified.
Test Object: Mka_Crypto_IcvVerifyAsync() start verification fail in Synchronous mode.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Do the synchronous KekIckGenerate procedure to set the correct crypto state before ICV verification.
  
Test Execution: 
    01: Set Csm_MacVerify_Stub RetVal and verifyPtr parameter to return E_NOT_OK.
    02: Call Mka_Crypto_IcvVerifyAsync to start ICV verification process.
    03: VP(Mka.Crypto.IcvVer_StartVerFail,1)
        VP(Mka.dsn.Crypto.IcvVerSM.Requested_2_Idle,1) Verify that Crypto unit terminated the ICV verification process and reported E_NOT_OK to the caller.
    04: Set Csm_MacVerify_Stub return value to E_NOT_OK.
    05: Call Mka_Crypto_IcvVerifyAsync to start ICV verification process.
    06: VP(Mka.Crypto.IcvVer_StartVerFail,1) Verify that Crypto unit terminated the ICV verification process and reported E_NOT_OK to the caller.
    07: Set Csm_MacVerify_Stub verifyPtr parameter to return E_NOT_OK.
    08: Call Mka_Crypto_IcvVerifyAsync to start ICV verification process.
    09: Sanity check - Check that the returned value is E_OK and that the ICV verification process has been prepared.
    10: VP(Mka.Crypto.IcvVer_StartVerFail,1) Verify that Crypto unit terminated the ICV verification process and reported E_NOT_OK to the caller.
    11: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Crypto.IcvVer_StartVerFail</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1213</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.IcvVerSM.Requested_2_Idle</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1276</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1947</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01044_IcvVerify_Async128_IcvVerFail</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>1437</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when either Mka_CsmIcvVerifyCallback returns E_NOT_OK or Csm_MacVerify finds wrong ICV and returns verifyPtr E_NOT_OK, the process is stopped and the caller notified. Before verifying ICV, we need to generate ICK and KEK to set instance to a correct state.
Test Object: Mka_Crypto_IcvVerifyAsync() for ICV verification failed in Asynchronous mode.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Do the asynchronous KekIckGenerate procedure to set the correct crypto state before ICV verification.
  
Test Execution: 
    01: Call Mka_Crypto_IcvVerifyAsync to start ICV verification process.
    02: Sanity check - Check that the returned value is E_OK and that the ICV verification process has been requeted.
    03: Sanity check - Check that Crypto unit called Csm_MacVerify.
    04: Call Mka_CsmMacVerifyCallback() to simulate Csm async job failed callback.
    05: VP(Mka.Crypto.IcvVer_Async_IcvVerFail,1) Verify that Crypto unit called user Mka_RxTx_IcvVerifyFinished with E_NOT_OK return parameter after callback reported E_NOT_OK.
    06: Set Csm_MacVerify_Stub verifyPtr parameter to return E_NOT_OK.
    07: Call Mka_Crypto_IcvVerifyAsync to start ICV verification process.
    08: Sanity check - Check that the returned value is E_OK and that the ICV verification process has been requested.
    09: VP(Mka.Crypto.IcvVer_Async_IcvVerFail,1) Verify that Csm_MacVerify returned E_NOT_OK, but a callback to the user Mka_RxTx_IcvVerifyFinished wasn't made.
    10: Call Mka_CsmMacVerifyCallback() to simulate Csm async job failed callback.
    11: VP(Mka.Crypto.IcvVer_Async_IcvVerFail,1) Verify that Crypto unit terminated the ICV verification process and reported E_NOT_OK to the caller, but after calling Mka_CsmIcvVerifyCallback where it checked for a Result of Csm_MacVerify.
    12: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Crypto.IcvVer_Async_IcvVerFail</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1214</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1948</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01045_IcvVerify_RequestInvalidState</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>1467</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when ICK is not ready, the Crypto unit shall return E_NOT_OK when Mka_Crypto_IcvVerifyAsync is called and shall not start the verification process.
Test Object: Mka_Crypto_IcvVerifyAsync() for ICK not ready in both Synchronous and Asynchronous mode.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
  
Test Execution: 
    01: Call Mka_Crypto_IcvVerifyAsync to start ICV verification process.
    02: VP(Mka.Crypto.IcvVer_RequestInvalidState,1) Check that the ICV verification process has not been prepared as the ICK isn't ready. Mka_Crypto_IcvVerifyAsync shall return E_NOT_OK.
    03: VP(Mka.Crypto.IcvVer_RequestInvalidState,1) Verify that Crypto unit has not started ICV verification process.
    04: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Crypto.IcvVer_RequestInvalidState</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1222</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1949</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01046_IcvVerify_Async128_RequestInvalidIcvVerState</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>1488</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that if an ICV verification process is already running when a new IcvVerify is requested, that new process shall not be started as Mka_Crypto_IcvVerifyAsync shall return E_NOT_OK.
Test Object: Mka_Crypto_IcvVerifyAsync() in Asynchronous mode.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Do the asynchronous KekIckGenerate procedure to set the correct crypto state before ICV verification.
  
Test Execution: 
    01: Call Mka_Crypto_IcvVerifyAsync to start ICV verification process.
    02: Sanity check - Check that the ICV verification process has been requested.
    03: Sanity check - Check that the ICV verification process is ongoing as expected.
    04: Call Mka_Crypto_IcvVerifyAsync again to start another ICV verification process.
    05: VP(Mka.Crypto.IcvVer_RequestInvalidIcvVerState,1) Verify that Crypto unit has not started another instance of ICV verification process.
    06: Call Mka_CsmMacVerifyCallback() to finish first ICV verification tasking.
    07: Sanity check - Check that Crypto unit finished the ongoing ICV verification process as expected.
    08: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Crypto.IcvVer_RequestInvalidIcvVerState</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1223</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1950</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01047_IcvVerify_Async128_RequestInvalidDataLen</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>1514</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that if ICV verification process is requested with an incorrect DataLength value, Crypto API Mka_Crypto_IcvVerifyAsync shall return E_NOT_OK and not start the process.
Test Object: Mka_Crypto_IcvVerifyAsync() in Asynchronous mode.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Do the asynchronous KekIckGenerate procedure to set the correct crypto state before ICV verification.
  
Test Execution: 
    01: Call Mka_Crypto_IcvVerifyAsync to start ICV verification process.
    02: VP(Mka.Crypto.IcvVer_RequestInvalidDataLen,1) Verify that Crypto unit has not started ICV verification process and has returned E_NOT_OK.
    03: VP(Mka.Crypto.IcvVer_RequestInvalidDataLen,1) Verify that Crypto unit has not started ICV verification process.
    04: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Crypto.IcvVer_RequestInvalidDataLen</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1224</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1951</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01048_FindMkaId_128</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>1536</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when Mka_Crypto_FindParticipant is called with correct CKN id, the correct ParticipantIdx is returned.
Test Object: Mka_Crypto_FindParticipant() in Asynchronous mode.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
  
Test Execution: 
    01: Call Mka_Crypto_FindParticipant to start find correct Mka Id.
    02: VP(Mka.dsn.Crypto.Api.FindParticipant,1) Verify that Crypto unit has returned correct Mka Id.
    03: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.FindParticipant</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1037</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1952</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01049_IcvGen_TooSmallBuffer</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>1556</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when Mka_Crypto_IcvGenerateAsync() recives too small BufferLength, will not start procedure for generating ICV and Mka_Crypto_IcvGenerateAsync() returns E_NOT_OK.
Test Object: Mka_Crypto_IcvGenerateAsync() recives too small Buffer.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
  
Test Execution: 
    01: Do the asynchronous KekIckGenerate procedure to set the correct crypto state.
    02: Call Mka crypto unit API Mka_Crypto_IcvGenerateAsync to start IcvGenerate procedure.
    03: VP(Mka.dsn.Crypto.Api.IcvGenerateAsync.E_NOT_OK,1) Verify that Mka_Crypto_IcvGenerateAsync() returned E_NOT_OK, because there wasn't enough space in buffer.
    04: Call Mka crypto unit main function Mka_Crypto_MainFunction() to run the Crypto thread.
    05: VP(Mka.dsn.Crypto.Api.IcvGenerateAsync.E_NOT_OK,1) Verify that Csm functions aren't called because Mka_Crypto_IcvGenerateAsync() couldn't start procedure.
    06: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.IcvGenerateAsync.E_NOT_OK</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1527</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1953</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01050_SakGenWrap_Async128</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>1579</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when Mka_Crypto_SakGenWrapAsync is called, SAK generation and key wrapping procedure is starting with correct parameters and other function calls.
Test Object: Mka_Crypto_SakGenWrapAsync() in Asynchronous mode.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Do the asynchronous KekIckGenerate procedure to set the correct crypto state.
  
Test Execution: 
    01: Sanity check - Sanity Check
    02: VP(Mka.dsn.Crypto.KeyWrapSM.Initial_Initialization,1) Verify that Crypto Unit is initialized.
    03: Call Mka_Crypto_SakGenWrapAsync to start SAK gen and wrap preparation process.
    04: VP(Mka.dsn.Crypto.Api.SakGenWrapAsync,1)
        VP(Mka.dsn.Crypto.KeyWrapSM.Idle_2_Requested_Server,1) Verify that Crypto unit has prepared SAK gen and wrap process and has returned E_OK.
    05: VP(Mka.dsn.Crypto.Api.SakGenWrapAsync,1)
        VP(Mka.CP_SWS_Mka_CONSTR_00020.2,1)
        VP(Mka.CP_SWS_Mka_00007.2,1)
        VP(Mka.dsn.Crypto.KeyWrapSM.Requested_2_Busy_Server,2) Verify that Crypto unit has succesfully started the requested process.
    06: Simulate the asynchronous callout to continue the procedure.
    07: VP(Mka.dsn.Crypto.Api.SakGenWrapAsync,1)
        VP(Mka.dsn.Crypto.KeyWrapSM.Busy_2_Busy_SakGenerate,1) Verify that Crypto unit has succesfully finished the requested process.
    08: Simulate the asynchronous callout to continue the procedure.
    09: VP(Mka.dsn.Crypto.Api.SakGenWrapAsync,1)
        VP(Mka.dsn.Crypto.KeyWrapSM.Busy_2_Busy_Server,1) Verify that Crypto unit is succesfully doing the requested process.
    10: Simulate the asynchronous callout to continue the procedure.
    11: VP(Mka.dsn.Crypto.KeyWrapSM.Busy_2_Hashgen_Server,1) Verify that Hash key was generated after successful SAK gen.
    12: Call Mka_CsmHashGenerateCallback to confirm that hash has been generated (async mode).
    13: VP(Mka.InterAct.Crypto.SakGenWrapAsync,1)
        VP(Mka.dsn.Crypto.KeyWrapSM.Hashgen_2_Idle_Server,1)
        VP(Mka.dsn.Crypto.CryptoSM.Kek_Ready_2_Sak_Ready_Wrap,1) Verify that Crypto unit has finished the requested process and reported back to the caller.
    14: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.KeyWrapSM.Initial_Initialization</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1325</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.SakGenWrapAsync</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1032</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.KeyWrapSM.Idle_2_Requested_Server</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1323</internalId></provcov>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_CONSTR_00020.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>337</internalId></provcov>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00007.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>307</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.KeyWrapSM.Requested_2_Busy_Server</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1322</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.KeyWrapSM.Busy_2_Busy_SakGenerate</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1317</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.KeyWrapSM.Busy_2_Busy_Server</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1318</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.KeyWrapSM.Busy_2_Hashgen_Server</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1321</internalId></provcov>
        <provcov>
          <linksto>Mka.InterAct.Crypto.SakGenWrapAsync</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1127</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.KeyWrapSM.Hashgen_2_Idle_Server</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1324</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.CryptoSM.Kek_Ready_2_Sak_Ready_Wrap</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1337</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1954</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01051_SakGenWrap_Sync128</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>1663</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when Mka_Crypto_SakGenWrapAsync is called, SAK generation and key wrapping procedure is starting with correct parameters and other function calls.
Test Object: Mka_Crypto_SakGenWrapAsync() in Synchronous mode.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Do the KekIckGenerate procedure to set the correct crypto state.
  
Test Execution: 
    01: Call Mka_Crypto_SakGenWrapAsync to start SAK gen and wrap preparation process.
    02: VP(Mka.dsn.Crypto.Api.SakGenWrapAsync,1) Verify that Crypto unit has prepared SAK gen and wrap process and has returned E_OK.
    03: Start the main Crypto thread which shall start SAK gen and wrap process.
    04: VP(Mka.InterAct.Crypto.SakGenWrapSync,1)
        VP(Mka.CP_SWS_Mka_00007.2,1)
        VP(Mka.dsn.Crypto.CryptoSM.Kek_Ready_2_Sak_Ready_Wrap,1) Verify that Crypto unit has successfully done the requested process by following expected routine in sync mode.
    05: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.SakGenWrapAsync</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1032</internalId></provcov>
        <provcov>
          <linksto>Mka.InterAct.Crypto.SakGenWrapSync</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1126</internalId></provcov>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00007.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>307</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.CryptoSM.Kek_Ready_2_Sak_Ready_Wrap</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1337</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1955</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01052_SakGenWrap_Async256</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>1700</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when Mka_Crypto_SakGenWrapAsync is called, SAK generation and key wrapping procedure is starting with correct parameters and other function calls. This is done for 256bit keys.
Test Object: Mka_Crypto_SakGenWrapAsync() in Asynchronous mode.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Do the asynchronous KekIckGenerate procedure to set the correct crypto state.
  
Test Execution: 
    01: Sanity check - Reset stubs.
    02: Call Mka_Crypto_SakGenWrapAsync to start SAK gen and wrap preparation process.
    03: VP(Mka.dsn.Crypto.Api.SakGenWrapAsync,1) Verify that Crypto unit has prepared SAK gen and wrap process and has returned E_OK.
    04: Start the main Crypto thread which shall start SAK gen and wrap process.
    05: VP(Mka.dsn.Crypto.Api.SakGenWrapAsync,1)
        VP(Mka.CP_SWS_Mka_00007.2,1)
        VP(Mka.dsn.Crypto.Api.RandomGenerate.CsmGranularity,1) Verify that Crypto unit has succesfully started the requested process. Verify that Csm_RandomGenerate is called required number of times to get required number of random numbers. In this case it is length of SAK 256 bit(32 bytes) / Amount of random data that Csm generates at one time (5 bytes).
    06: Simulate the asynchronous callout to continue the procedure.
    07: VP(Mka.dsn.Crypto.Api.SakGenWrapAsync,1) Verify that Crypto unit has succesfully finished the requested process.
    08: Simulate the asynchronous callout to continue the procedure.
    09: VP(Mka.dsn.Crypto.Api.SakGenWrapAsync,1) Verify that Crypto unit is succesfully doing the requested process.
    10: Simulate the asynchronous callout to continue the procedure.
    11: Sanity check - Verify that Hash key was generated after successful SAK gen.
    12: Call Mka_CsmHashGenerateCallback to confirm that hash has been generated (async mode).
    13: VP(Mka.InterAct.Crypto.SakGenWrapAsync,1) Verify that Crypto unit has finished the requested process and reported back to the caller.
    14: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.SakGenWrapAsync</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1032</internalId></provcov>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00007.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>307</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.RandomGenerate.CsmGranularity</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1537</internalId></provcov>
        <provcov>
          <linksto>Mka.InterAct.Crypto.SakGenWrapAsync</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1127</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1956</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01053_SakGenWrap_Sync256</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>1746</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when Mka_Crypto_SakGenWrapAsync is called, SAK generation and key wrapping procedure is starting with correct parameters and other function calls. This is done for 256bit keys.
Test Object: Mka_Crypto_SakGenWrapAsync() in Synchronous mode.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Setting up stubs.
    -   Do the asynchronous KekIckGenerate procedure to set the correct crypto state.
  
Test Execution: 
    01: Call Mka_Crypto_SakGenWrapAsync to start SAK gen and wrap preparation process.
    02: VP(Mka.dsn.Crypto.Api.SakGenWrapAsync,1) Verify that Crypto unit has prepared SAK gen and wrap process and has returned E_OK.
    03: Start the main Crypto thread which shall start SAK gen and wrap process.
    04: VP(Mka.InterAct.Crypto.SakGenWrapSync,1)
        VP(Mka.CP_SWS_Mka_00007.2,1)
        VP(Mka.dsn.Crypto.Api.RandomGenerate.CsmGranularity,1) Verify that Crypto unit has succesfully done the requested process by doing an expected routine for sync mode. Verify that Csm_RandomGenerate is called required number of times to get required number of random numbers. In this case it is Length of SAK 256 bit(32 bytes) / Amount of random data that Csm generates at one time (5 bytes).
    05: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.SakGenWrapAsync</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1032</internalId></provcov>
        <provcov>
          <linksto>Mka.InterAct.Crypto.SakGenWrapSync</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1126</internalId></provcov>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00007.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>307</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.RandomGenerate.CsmGranularity</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1537</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1957</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01054_SakGenWrap_Async128_WrongJobId</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>1784</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when Mka_CsmKeyWrapCallback is called with incorrect Job ID, the call is ignored.
Test Object: Mka_Crypto_SakGenWrapAsync() in Asynchronous mode.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Do the asynchronous KekIckGenerate procedure to set the correct crypto state.
  
Test Execution: 
    01: Call Mka_Crypto_SakGenWrapAsync to start SAK gen and wrap preparation process.
    02: Sanity check - Verify that Crypto unit has prepared SAK gen and wrap process and has returned E_OK.
    03: Start the main Crypto thread which shall start SAK gen and wrap process.
    04: Sanity check - Verify that Crypto unit has succesfully started the requested process.
    05: Simulate the asynchronous callback with incorrect job id.
    06: VP(Mka.Crypto.KeyWrapCallback_NoMatch,1)
        VP(Mka.Crypto.KeyWrapCallback_NotStarted,1) Verify that Crypto unit ignored the call.
    07: Simulate the asynchronous callout to continue the procedure.
    08: Simulate the asynchronous callout to finish the started procedure.
    09: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Crypto.KeyWrapCallback_NoMatch</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1192</internalId></provcov>
        <provcov>
          <linksto>Mka.Crypto.KeyWrapCallback_NotStarted</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1198</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1958</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01055_SakGenWrap_Rfc3394_Async128</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>1816</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that the Encryption is done according to the rfc3394 standards.
Test Object: Mka_Crypto_SakGenWrapAsync() in Asynchronous mode.
Test Precondition: 
    -   Module configuration initialized with Mka_Init().
    -   Do the asynchronous KekIckGenerate procedure to set the correct crypto state.
  
Test Execution: 
    01: Call Mka_Crypto_SakGenWrapAsync to start SAK gen and wrap preparation process.
    02: Start the main Crypto thread which shall start SAK gen and wrap process.
    03: Simulate the asynchronous callout to continue the procedure.
    04: VP(Mka.rfc3394.KeyWrap.BlockSize,1)
        VP(Mka.rfc3394.KeyWrap.Indexing.4,1)
        VP(Mka.rfc3394.KeyWrap.Indexing.5,1)
        VP(Mka.rfc3394.KeyDataIntegrity.DefaultInitialValue,1) Verify that the plain text consists of n 64-bit bytes and that it has the correct input values.
    05: Simulate the asynchronous callout to continue the procedure.
    06: VP(Mka.dsn.Crypto.Api.SakGenWrapAsync,1)
        VP(Mka.rfc3394.KeyWrap.Indexing.1,1)
        VP(Mka.rfc3394.KeyWrap.Indexing.2,1)
        VP(Mka.rfc3394.KeyDataIntegrity.InitialValue,1) Verify that Crypto unit is correctly calculating intermediate values and calling the Csm_Encrypt with correct input parameters.
    07: Simulate the asynchronous callout to finish the procedure.
    08: Sanity check - Verify that Hash key was generated after successful SAK gen.
    09: Call Mka_CsmHashGenerateCallback to confirm that hash has been generated (async mode).
    10: Sanity check - Check that Crypto unit has finished the requested process and reported back to the caller.
    11: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.rfc3394.KeyWrap.BlockSize</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>464</internalId></provcov>
        <provcov>
          <linksto>Mka.rfc3394.KeyWrap.Indexing.4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>470</internalId></provcov>
        <provcov>
          <linksto>Mka.rfc3394.KeyWrap.Indexing.5</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>471</internalId></provcov>
        <provcov>
          <linksto>Mka.rfc3394.KeyDataIntegrity.DefaultInitialValue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>485</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.SakGenWrapAsync</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1032</internalId></provcov>
        <provcov>
          <linksto>Mka.rfc3394.KeyWrap.Indexing.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>467</internalId></provcov>
        <provcov>
          <linksto>Mka.rfc3394.KeyWrap.Indexing.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>468</internalId></provcov>
        <provcov>
          <linksto>Mka.rfc3394.KeyDataIntegrity.InitialValue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>482</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1959</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01056_SakGenWrap_Rfc3394_Sync128</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>1879</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that the Encryption is done according to the rfc3394 standards.
Test Object: Mka_Crypto_SakGenWrapAsync() in Synchronous mode.
Test Precondition: 
    -   Module configuration initialized with Mka_Init().
    -   Do the synchronous KekIckGenerate procedure to set the correct crypto state.
  
Test Execution: 
    01: Call Mka_Crypto_SakGenWrapAsync to start SAK gen and wrap preparation process.
    02: Start the main Crypto thread which shall start SAK gen and wrap process.
    03: VP(Mka.rfc3394.KeyWrap.BlockSize,1)
        VP(Mka.rfc3394.KeyWrap.Indexing.4,1)
        VP(Mka.rfc3394.KeyWrap.Indexing.5,1) Verify that the plain text consists of n 64-bit bytes and that it has the correct input values.
    04: VP(Mka.dsn.Crypto.Api.SakGenWrapAsync,1)
        VP(Mka.rfc3394.KeyWrap.Indexing.1,1)
        VP(Mka.rfc3394.KeyWrap.Indexing.2,1) Verify that Crypto unit is correctly calculating intermediate values and calling the Csm_Encrypt with correct input parameters.
    05: Sanity check - Check that Crypto unit has finished the requested process and reported back to the caller.
    06: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.rfc3394.KeyWrap.BlockSize</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>464</internalId></provcov>
        <provcov>
          <linksto>Mka.rfc3394.KeyWrap.Indexing.4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>470</internalId></provcov>
        <provcov>
          <linksto>Mka.rfc3394.KeyWrap.Indexing.5</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>471</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.SakGenWrapAsync</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1032</internalId></provcov>
        <provcov>
          <linksto>Mka.rfc3394.KeyWrap.Indexing.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>467</internalId></provcov>
        <provcov>
          <linksto>Mka.rfc3394.KeyWrap.Indexing.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>468</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1960</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01057_SakGenWrap_Rfc3394_Async256</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>1927</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that the Encryption of 256bit key is done according to the rfc3394 standards.
Test Object: Mka_Crypto_SakGenWrapAsync() in Asynchronous mode.
Test Precondition: 
    -   Module configuration initialized with Mka_Init().
    -   Do the asynchronous KekIckGenerate 256bit procedure to set the correct crypto state.
  
Test Execution: 
    01: Call Mka_Crypto_SakGenWrapAsync to start SAK gen and wrap preparation process.
    02: Start the main Crypto thread which shall start SAK gen and wrap process.
    03: Simulate the asynchronous callout to continue the procedure.
    04: VP(Mka.rfc3394.KeyWrap.BlockSize,1)
        VP(Mka.rfc3394.KeyWrap.Indexing.4,1)
        VP(Mka.rfc3394.KeyWrap.Indexing.5,1) Verify that the plain text consists of n 64-bit bytes and that it has the correct input values.
    05: Simulate the asynchronous callout to continue the procedure.
    06: VP(Mka.dsn.Crypto.Api.SakGenWrapAsync,1)
        VP(Mka.rfc3394.KeyWrap.Indexing.1,1)
        VP(Mka.rfc3394.KeyWrap.Indexing.2,1) Verify that Crypto unit is correctly calculating intermediate values and calling the Csm_Encrypt with correct input parameters.
    07: Simulate the asynchronous callout to finish the procedure.
    08: Sanity check - Verify that Hash key was generated after successful SAK gen.
    09: Call Mka_CsmHashGenerateCallback to confirm that hash has been generated (async mode).
    10: VP(Mka.rfc3394.KeyWrap.Indexing.6,1) Verify that Crypto unit has finished the requested process and returned correct SAK.
    11: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.rfc3394.KeyWrap.BlockSize</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>464</internalId></provcov>
        <provcov>
          <linksto>Mka.rfc3394.KeyWrap.Indexing.4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>470</internalId></provcov>
        <provcov>
          <linksto>Mka.rfc3394.KeyWrap.Indexing.5</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>471</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.SakGenWrapAsync</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1032</internalId></provcov>
        <provcov>
          <linksto>Mka.rfc3394.KeyWrap.Indexing.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>467</internalId></provcov>
        <provcov>
          <linksto>Mka.rfc3394.KeyWrap.Indexing.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>468</internalId></provcov>
        <provcov>
          <linksto>Mka.rfc3394.KeyWrap.Indexing.6</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>472</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1961</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01058_SakGenWrap_Rfc3394_Sync256</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>1984</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that the Encryption of 256bit key is done according to the rfc3394 standards.
Test Object: Mka_Crypto_SakGenWrapAsync() in Synchronous mode.
Test Precondition: 
    -   Module configuration initialized with Mka_Init().
    -   Do the synchronous KekIckGenerate procedure to set the correct crypto state.
  
Test Execution: 
    01: Call Mka_Crypto_SakGenWrapAsync to start SAK gen and wrap preparation process.
    02: VP(Mka.rfc3394.KeyWrap.BlockSize,1)
        VP(Mka.rfc3394.KeyWrap.Indexing.4,1)
        VP(Mka.rfc3394.KeyWrap.Indexing.5,1) Verify that the plain text consists of n 64-bit bytes and that it has the correct input values.
    03: VP(Mka.dsn.Crypto.Api.SakGenWrapAsync,1)
        VP(Mka.rfc3394.KeyWrap.Indexing.1,1)
        VP(Mka.rfc3394.KeyWrap.Indexing.2,1) Verify that Crypto unit is correctly calculating intermediate values and calling the Csm_Encrypt with correct input parameters.
    04: Sanity check - Check that Crypto unit has finished the requested process and reported back to the caller.
    05: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.rfc3394.KeyWrap.BlockSize</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>464</internalId></provcov>
        <provcov>
          <linksto>Mka.rfc3394.KeyWrap.Indexing.4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>470</internalId></provcov>
        <provcov>
          <linksto>Mka.rfc3394.KeyWrap.Indexing.5</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>471</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.SakGenWrapAsync</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1032</internalId></provcov>
        <provcov>
          <linksto>Mka.rfc3394.KeyWrap.Indexing.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>467</internalId></provcov>
        <provcov>
          <linksto>Mka.rfc3394.KeyWrap.Indexing.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>468</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1962</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01059_SakUnwrap_Async128</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>2031</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when Mka_Crypto_SakUnwrapAsync is called, SAK unwrapping procedure is started with correct parameters and other function calls. If the unwrapped IV is correct, SAK shall be saved.
Test Object: Mka_Crypto_SakUnwrapAsync() for 128bit key in Asynchronous mode.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Do the asynchronous KekIckGenerate procedure to set the correct crypto state.
  
Test Execution: 
    01: Sanity check - Sanity Check
    02: VP(Mka.dsn.Crypto.KeyUnwrapSM.Initial_Initialization,1) Verify that Crypto Unit is initialized.
    03: Call Mka_Crypto_SakUnwrapAsync to start SAK unwrap preparation process.
    04: VP(Mka.dsn.Crypto.Api.SakUnwrapAsync,1)
        VP(Mka.dsn.Crypto.KeyUnwrapSM.Idle_2_Requested,1) Verify that Crypto unit has prepared SAK gen and wrap process and has returned E_OK.
    05: VP(Mka.dsn.Crypto.Api.SakUnwrapAsync,1)
        VP(Mka.rfc3394.KeyUnwrap.Indexing.1,1)
        VP(Mka.rfc3394.KeyUnwrap.Indexing.2,1)
        VP(Mka.rfc3394.KeyUnwrap.Indexing.4,1)
        VP(Mka.rfc3394.KeyUnwrap.Indexing.5,1)
        VP(Mka.rfc3394.KeyDataIntegrity.InitialValue,1)
        VP(Mka.dsn.Crypto.KeyUnwrapSM.Requested_2_Busy,2) Verify that Crypto unit has successfully started the requested process with correct input parameters. Other input parameters are verified in Csm_Decrypt_Stub.Callout.
    06: Simulate the asynchronous callback to continue the procedure.
    07: VP(Mka.dsn.Crypto.Api.SakUnwrapAsync,1)
        VP(Mka.dsn.Crypto.KeyUnwrapSM.Busy_2_Busy,1) Verify that Crypto unit is succesfully doing the requested process.
    08: Simulate the asynchronous callout to continue the procedure.
    09: VP(Mka.dsn.Crypto.Api.SakUnwrapAsync,1)
        VP(Mka.rfc3394.KeyUnwrap.Indexing.6,1)
        VP(Mka.rfc3394.KeyUnwrap.Indexing.7,1)
        VP(Mka.rfc3394.KeyDataIntegrity.Match,1) Verify that Crypto unit has succesfully finished the requested process. Crypto unit shall save and set key as valid.
    10: Sanity check - Check that Crypto unit is succesfully doing the requested process and that SAK byte rotation input parameter is done correctly.
    11: VP(Mka.dsn.Crypto.KeyUnwrapSM.Busy_2_Hashgen,1) Verify that Hash key was generated after successful SAK gen.
    12: Call Mka_CsmHashGenerateCallback to confirm that hash has been generated (async mode).
    13: VP(Mka.InterAct.Crypto.SakUnwrapAsync,1)
        VP(Mka.dsn.Crypto.KeyUnwrapSM.Hashgen_2_Idle,1)
        VP(Mka.dsn.Crypto.CryptoSM.Kek_Ready_2_Sak_Ready_Unwrap,1) Verify that Crypto unit has finished the requested process correctly and reported back to the caller.
    14: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.KeyUnwrapSM.Initial_Initialization</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1312</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.SakUnwrapAsync</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1033</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.KeyUnwrapSM.Idle_2_Requested</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1316</internalId></provcov>
        <provcov>
          <linksto>Mka.rfc3394.KeyUnwrap.Indexing.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>475</internalId></provcov>
        <provcov>
          <linksto>Mka.rfc3394.KeyUnwrap.Indexing.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
        <provcov>
          <linksto>Mka.rfc3394.KeyUnwrap.Indexing.4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>478</internalId></provcov>
        <provcov>
          <linksto>Mka.rfc3394.KeyUnwrap.Indexing.5</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>479</internalId></provcov>
        <provcov>
          <linksto>Mka.rfc3394.KeyDataIntegrity.InitialValue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>482</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.KeyUnwrapSM.Requested_2_Busy</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1315</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.KeyUnwrapSM.Busy_2_Busy</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1313</internalId></provcov>
        <provcov>
          <linksto>Mka.rfc3394.KeyUnwrap.Indexing.6</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>480</internalId></provcov>
        <provcov>
          <linksto>Mka.rfc3394.KeyUnwrap.Indexing.7</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>481</internalId></provcov>
        <provcov>
          <linksto>Mka.rfc3394.KeyDataIntegrity.Match</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>483</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.KeyUnwrapSM.Busy_2_Hashgen</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1311</internalId></provcov>
        <provcov>
          <linksto>Mka.InterAct.Crypto.SakUnwrapAsync</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1129</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.KeyUnwrapSM.Hashgen_2_Idle</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1310</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.CryptoSM.Kek_Ready_2_Sak_Ready_Unwrap</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1338</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1963</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01060_SakUnwrap_Sync128</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>2140</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when Mka_Crypto_SakUnwrapAsync is called, SAK unwrapping procedure is started with correct parameters and other function calls. If the IV matches the expected value at the end of unwrapping, SAK key shall be accepted and saved.
Test Object: Mka_Crypto_SakGenWrapAsync() in Synchronous mode.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Do the synchronous KekIckGenerate procedure to set the correct crypto state.
  
Test Execution: 
    01: Call Mka_Crypto_SakUnwrapAsync to start SAK unwrap preparation process.
    02: VP(Mka.dsn.Crypto.Api.SakGenWrapAsync,1) Verify that Crypto unit has prepared SAK gen and wrap process and has returned E_OK.
    03: Start the main Crypto thread which shall start SAK unwrap process.
    04: VP(Mka.dsn.Crypto.Api.SakUnwrapAsync,1)
        VP(Mka.rfc3394.KeyUnwrap.Indexing.1,1)
        VP(Mka.rfc3394.KeyUnwrap.Indexing.2,1)
        VP(Mka.rfc3394.KeyUnwrap.Indexing.4,1)
        VP(Mka.rfc3394.KeyUnwrap.Indexing.5,1)
        VP(Mka.rfc3394.KeyDataIntegrity.InitialValue,1) Verify that Crypto unit has successfully started the requested process with expected input parameters. Other input parameters are checked in Csm_Decrypt_Stub.Callout.
    05: VP(Mka.dsn.Crypto.Api.SakUnwrapAsync,1) Verify that Crypto unit is succesfully doing the requested process and that SAK byte rotation input parameter is done correctly.
    06: VP(Mka.dsn.Crypto.Api.SakUnwrapAsync,1)
        VP(Mka.rfc3394.KeyUnwrap.Indexing.6,1)
        VP(Mka.rfc3394.KeyUnwrap.Indexing.7,1)
        VP(Mka.rfc3394.KeyDataIntegrity.Match,1) Verify that Crypto unit has succesfully finished the requested process. Crypto unit shall save and set key as valid.
    07: VP(Mka.InterAct.Crypto.SakUnwrapSync,1)
        VP(Mka.dsn.Crypto.CryptoSM.Kek_Ready_2_Sak_Ready_Unwrap,1) Verify that Crypto unit has finished the requested process correctly and reported back to the caller.
    08: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.SakGenWrapAsync</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1032</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.SakUnwrapAsync</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1033</internalId></provcov>
        <provcov>
          <linksto>Mka.rfc3394.KeyUnwrap.Indexing.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>475</internalId></provcov>
        <provcov>
          <linksto>Mka.rfc3394.KeyUnwrap.Indexing.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
        <provcov>
          <linksto>Mka.rfc3394.KeyUnwrap.Indexing.4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>478</internalId></provcov>
        <provcov>
          <linksto>Mka.rfc3394.KeyUnwrap.Indexing.5</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>479</internalId></provcov>
        <provcov>
          <linksto>Mka.rfc3394.KeyDataIntegrity.InitialValue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>482</internalId></provcov>
        <provcov>
          <linksto>Mka.rfc3394.KeyUnwrap.Indexing.6</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>480</internalId></provcov>
        <provcov>
          <linksto>Mka.rfc3394.KeyUnwrap.Indexing.7</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>481</internalId></provcov>
        <provcov>
          <linksto>Mka.rfc3394.KeyDataIntegrity.Match</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>483</internalId></provcov>
        <provcov>
          <linksto>Mka.InterAct.Crypto.SakUnwrapSync</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1128</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.CryptoSM.Kek_Ready_2_Sak_Ready_Unwrap</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1338</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1964</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01061_SakUnwrap_Async256</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>2219</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when Mka_Crypto_SakUnwrapAsync is called, SAK unwrapping procedure is started with correct parameters and other function calls. This is done for 256bit keys.
Test Object: Mka_Crypto_SakUnwrapAsync() in Asynchronous mode for 256bit key.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Do the asynchronous KekIckGenerate procedure for 256bit key to set the correct crypto state.
  
Test Execution: 
    01: Call Mka_Crypto_SakUnwrapAsync to start SAK unwrap preparation process.
    02: VP(Mka.dsn.Crypto.Api.SakUnwrapAsync,1) Verify that Crypto unit has prepared SAK gen and wrap process and has returned E_OK.
    03: Start the main Crypto thread which shall start SAK gen and wrap process.
    04: VP(Mka.dsn.Crypto.Api.SakUnwrapAsync,1) Verify that Crypto unit has successfully started the requested process. Other input parameters for Csm_Decrypt are checked inside its callout function.
    05: Simulate the asynchronous callback to continue the procedure.
    06: VP(Mka.dsn.Crypto.Api.SakUnwrapAsync,1) Verify that Crypto unit is succesfully doing the requested process and that SAK byte rotation input parameter is done correctly.
    07: Simulate the asynchronous callout to continue the procedure.
    08: VP(Mka.dsn.Crypto.Api.SakUnwrapAsync,1) Verify that Crypto unit has succesfully finished the requested process. Crypto unit shall save and set key as valid.
    09: Sanity check - Verify that Hash key was generated after successful SAK gen.
    10: Call Mka_CsmHashGenerateCallback to confirm that hash has been generated (async mode).
    11: VP(Mka.InterAct.Crypto.SakUnwrapAsync,1) Verify that Crypto unit has finished the requested process and reported back to the caller.
    12: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.SakUnwrapAsync</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1033</internalId></provcov>
        <provcov>
          <linksto>Mka.InterAct.Crypto.SakUnwrapAsync</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1129</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1965</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01062_SakUnwrap_Sync256</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>2253</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when Mka_Crypto_SakGenWrapAsync is called, SAK generation and key wrapping procedure is starting with correct parameters and other function calls. This is done for 256bit keys.
Test Object: Mka_Crypto_SakGenWrapAsync() in Synchronous mode.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Do the synchronous KekIckGenerate procedure for 256bit key to set the correct crypto state.
  
Test Execution: 
    01: Call Mka_Crypto_SakUnwrapAsync to start SAK unwrap preparation process.
    02: VP(Mka.dsn.Crypto.Api.SakUnwrapAsync,1) Verify that Crypto unit has prepared SAK gen and wrap process and has returned E_OK.
    03: Start the main Crypto thread which shall start SAK gen and wrap process.
    04: VP(Mka.dsn.Crypto.Api.SakUnwrapAsync,1) Verify that Crypto unit has successfully started the requested process. Other input parameters for Csm_Decrypt are checked inside its callout function.
    05: VP(Mka.dsn.Crypto.Api.SakUnwrapAsync,1) Verify that Crypto unit is succesfully doing the requested process and that SAK byte rotation input parameter is done correctly.
    06: VP(Mka.dsn.Crypto.Api.SakUnwrapAsync,1) Verify that Crypto unit has successfully finished the requested process. Crypto unit shall save and set key as valid.
    07: VP(Mka.InterAct.Crypto.SakUnwrapSync,1) Verify that Crypto unit has finished the requested process and reported back to the caller.
    08: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.SakUnwrapAsync</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1033</internalId></provcov>
        <provcov>
          <linksto>Mka.InterAct.Crypto.SakUnwrapSync</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1966</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01063_SakUnwrap_128_CC</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>2283</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when Mka_Crypto_SakUnwrapAsync is called before ICK and KEK were generated, the API returns E_NOT_OK and no further progress is done.
Test Object: Mka_Crypto_SakUnwrapAsync() for 128bit key in both Sync and Asynchronous mode.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
  
Test Execution: 
    01: Call Mka_Crypto_SakUnwrapAsync to start SAK unwrap preparation process.
    02: VP(Mka.Crypto.KeyUnwrap_RequestInvalidState,1) Verify that Crypto unit has returned E_NOT_OK as the conditions were not fulfilled because neither ICK nor KEK were generated and ready.
    03: Start the main Crypto thread which shall start SAK gen and wrap process.
    04: VP(Mka.Crypto.KeyUnwrap_RequestInvalidState,1) Verify that Crypto unit has ignored the call as the conditions were not fulfilled because neither ICK nor KEK were generated and ready.
    05: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Crypto.KeyUnwrap_RequestInvalidState</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1239</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1967</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01064_SakUnwrap_Async128_NoMatch</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>2305</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when Mka_Crypto_SakUnwrapAsync is called with wrong IV parameters, SAK will not be be saved and E_NOT_OK will be returned to the caller.
Test Object: Mka_Crypto_SakUnwrapAsync() for 128bit key in Asynchronous mode.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Do the asynchronous KekIckGenerate procedure to set the correct crypto state.
  
Test Execution: 
    01: Call Mka_Crypto_SakUnwrapAsync to start SAK unwrap preparation process.
    02: Sanity check - Check that Crypto unit has prepared SAK gen and wrap process and has returned E_OK.
    03: Start the main Crypto thread which shall start SAK gen and wrap process.
    04: Sanity check - Check that Crypto unit has successfully started the requested process with correct input parameters. Other input parameters are verified in Csm_Decrypt_Stub.Callout.
    05: Simulate the asynchronous callback to continue the procedure.
    06: Sanity check - Check that Crypto unit is succesfully doing the requested process.
    07: Simulate the asynchronous callout to continue the procedure.
    08: VP(Mka.rfc3394.KeyDataIntegrity.NoMatch,1) Verify that Crypto unit has succesfully finished the requested process. Due to unexpected IV buffer results, Crypto unit shall not save key and shall report E_NOT_OK to the KaY unit.
    09: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.rfc3394.KeyDataIntegrity.NoMatch</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>484</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1968</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01065_SakGenWrap_128_CC</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>2332</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when Mka_Crypto_SakGenWrapAsync is called without generating ICK | KEK before, the call is ignored.
Test Object: Mka_Crypto_SakGenWrapAsync() in both Sync and Asynchronous mode.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
  
Test Execution: 
    01: Call Mka_Crypto_SakGenWrapAsync to start SAK gen and wrap preparation process.
    02: Sanity check - Verify that Crypto unit hasn't started SAK gen and wrap process and has returned E_NOT_OK since ICK and KEK aren't ready.
    03: Start the main Crypto thread which shall start SAK gen and wrap process.
    04: VP(Mka.Crypto.KeyWrap_RequestInvalidState,1) Verify that Crypto unit ignored the call.
    05: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Crypto.KeyWrap_RequestInvalidState</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1237</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1969</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01066_CopyCkn_128</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>2354</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when Mka_Crypto_CopyCkn is called, Crypto unit returns correct parameters. Test is done in both synchronous and asynchronous mode.
Test Object: Mka_Crypto_CopyCkn() in both Sync and Asynchronous mode.
Test Precondition: 
    -   Set callout function for Csm_KeyElementGet_Stub to get CKN.
    -   Module configuration and Crypto unit initialized.
  
Test Execution: 
    01: Call Mka crypto unit API Mka_Crypto_CopyCkn with too small input parameter CknSize.
    02: VP(Mka.dsn.Crypto.Api.CopyCkn,1) Verify that Crypto unit returned TS_CknSize of 0, indicating that no Ckn has been copied.
    03: Call Mka crypto unit API Mka_Crypto_CopyCkn with input parameter CknSize = EBTEST_CKN_SIZE.
    04: VP(Mka.dsn.Crypto.Api.CopyCkn,1)
        VP(Mka.8021X.MkaKeyHierarchy.3.1,1) Verify that Crypto unit return correct CknPtr and TS_CknSize.
    05: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.CopyCkn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1038</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.MkaKeyHierarchy.3.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>111</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1970</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01067_SakUnwrap_Async128_CC</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>2382</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when Mka_CsmKeyUnwrapCallback is called with result E_NOT_OK, SAK unwrapping procedure shall be stopped.
Test Object: Mka_Crypto_SakUnwrapAsync() for 128bit key in Asynchronous mode.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Do the asynchronous KekIckGenerate procedure to set the correct crypto state.
    -   Setting up stubs.
  
Test Execution: 
    01: Call Mka_Crypto_SakUnwrapAsync to start SAK unwrap preparation process.
    02: Sanity check - Check that Crypto unit has prepared SAK gen and wrap process and has returned E_OK.
    03: Start the main Crypto thread which shall start SAK gen and wrap process.
    04: Sanity check - Check that Crypto unit has successfully started the requested process.
    05: Simulate the asynchronous callout with E_NOT_OK input parameter, this shall stop the process.
    06: VP(Mka.Crypto.KeyUnwrap_Sak_Async_KeyUnwrapFail,1)
        VP(Mka.dsn.Crypto.KeyUnwrapSM.Busy_2_Idle_Fail,1) Verify that Crypto unit reported back the result and no further action has been continued.
    07: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Crypto.KeyUnwrap_Sak_Async_KeyUnwrapFail</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1230</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.KeyUnwrapSM.Busy_2_Idle_Fail</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1314</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1971</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01068_RandomGen_Stop_Async128</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>2413</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that while random generation is active and Mka_Crypto_Stop is called, the process shall stop, Csm_CancelJob shall be called and Mka_KaY_RandomGenerateFinished will not be called.
Test Object: Mka_Crypto_RandomGenerateAsync() with Mka_Crypto_Stop in Asynchronous mode.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
  
Test Execution: 
    01: Call Mka crypto unit API Mka_Crypto_RandomGenerateAsync to start RandomGenerate procedure.
    02: Call Mka crypto unit main function Mka_Crypto_MainFunction() to run the Crypto thread.
    03: Sanity check - Check that RandomGenerate process has been started.
    04: Call Mka_Crypto_Stop to stop RandomGenerate process.
    05: VP(Mka.Crypto.RandomGen_Async_Stop,1)
        VP(Mka.dsn.Crypto.Api.Stop,1) Check that RandomGenerate process has been stopped and Csm_CancelJob call was made.
    06: Sanity check -
    07: Asynchronous call from Csm to Crypto unit Mka_CsmRandomCallback().
    08: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Crypto.RandomGen_Async_Stop</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1242</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.Stop</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1028</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1972</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01069_RandomGen_Stop_Sync128</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>2443</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that while random generation is active and Mka_Crypto_Stop is called, the process shall stop and Mka_KaY_RandomGenerateFinished shall not be called.
Test Object: Mka_Crypto_RandomGenerateAsync() with Mka_Crypto_Stop in Synchronous mode.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
  
Test Execution: 
    01: Set the random callout to a function that will call Mka_Crypto_Stop.
    02: Call Mka crypto unit API Mka_Crypto_RandomGenerateAsync to start RandomGenerate procedure.
    03: Sanity check - Check that RandomGenerate process has been started.
    04: Call Mka crypto unit main function Mka_Crypto_MainFunction() to run the Crypto thread.
    05: VP(Mka.Crypto.RandomGen_Stop,1) Check that RandomGenerate process has been stopped and Mka_KaY_RandomGenerateFinished has not been called.
    06: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Crypto.RandomGen_Stop</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1241</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1973</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01070_KekIckGen_Stop_Async128</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>2466</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that after Kek &amp;amp; Ick generate process has been started and Mka_Crypto_Stop is called, the process shall stop, Csm_CancelJob was called and Mka_Logon_IckGenerateFinished will not be called.
Test Object: Mka_Crypto_IckGenerateAsync() with Mka_Crypto_Stop in asynchronous mode.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
  
Test Execution: 
    01: Call Mka crypto unit API Mka_Crypto_IckGenerateAsync to start Ick Generate procedure.
    02: Sanity check - Check that the Ick generating process has been started.
    03: Call Mka_Crypto_Stop to stop Kek &amp;amp; Ick generate process.
    04: VP(Mka.Crypto.KeyGen_Async_Ick_Stop,1) Verify that generation process has been stopped, Csm_CancelJob shall be called and Mka_Logon_IckGenerateFinished shall not be called.
    05: Csm_CancelJob shall call the callback functions with result set to CRYPTO_E_JOB_CANCELED.
    06: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Crypto.KeyGen_Async_Ick_Stop</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1244</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1974</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01071_IcvGen_Stop_Async128</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>2489</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that after ICV generate process has been started and Mka_Crypto_Stop is called, the process shall stop, Csm_CancelJob shall be called and Mka_RxTx_IcvGenerateFinished shall not be called.
Test Object: Mka_Crypto_IcvGenerateAsync() with Mka_Crypto_Stop in asynchronous mode.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
  
Test Execution: 
    01: Do the asynchronous KekIckGenerate procedure to set the correct crypto state.
    02: Call Mka crypto unit API Mka_Crypto_IcvGenerateAsync to start IcvGenerate procedure.
    03: Sanity check - Check that Icv Generate process has been started.
    04: Call Mka_Crypto_Stop to stop ongoing process.
    05: VP(Mka.Crypto.IcvGen_Async_Stop,1) Verify that IcvGen process has been stopped and that Crypto unit called only Csm_CancelJob.
    06: Call Mka crypto unit main function Mka_Crypto_MainFunction() to run the Crypto thread.
    07: VP(Mka.Crypto.IcvGen_Stop,1) Verify that Mka_RxTx_IcvGenerateFinished was not called.
    08: Csm_CancelJob shall call the callback function with result set to CRYPTO_E_JOB_CANCELED.
    09: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Crypto.IcvGen_Async_Stop</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1248</internalId></provcov>
        <provcov>
          <linksto>Mka.Crypto.IcvGen_Stop</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1247</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1975</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01072_IcvVer_Stop_Async128</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>2519</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that after ICV verification process has been started and Mka_Crypto_Stop is called, the process shall stop, Csm_CancelJob shall be called and Mka_RxTx_IcvVerifyFinished shall not be called.
Test Object: Mka_Crypto_IcvVerifyAsync() with Mka_Crypto_Stop in asynchronous mode.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Do the asynchronous KekIckGenerate procedure to set the correct crypto state before ICV verification.
  
Test Execution: 
    01: Call Mka_Crypto_IcvVerifyAsync to start ICV verification process.
    02: Sanity check - Check that the returned value is E_OK and that the ICV verification process has been requested.
    03: Sanity check - Check that Crypto unit called Csm_MacVerify with correct input parameters.
    04: Call Mka_Crypto_Stop to stop the ongoing process.
    05: VP(Mka.Crypto.IcvVer_Async_Stop,1)
        VP(Mka.Crypto.IcvVer_Stop,1) Verify that the process has been stopped and only Csm_CancelJob was called.
    06: Sanity check -
    07: Csm_CancelJob shall call the callback function with result set to CRYPTO_E_JOB_CANCELED.
    08: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Crypto.IcvVer_Async_Stop</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1250</internalId></provcov>
        <provcov>
          <linksto>Mka.Crypto.IcvVer_Stop</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1249</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1976</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01073_SakGenWrap_Stop_Async128</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>2550</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when Mka_Crypto_SakGenWrapAsync is called and SAK generation and key wrapping procedure has been started with, when Mka_Crypto_Stop is called, the process shall stop and only Csm_CancelJob is called.
Test Object: Mka_Crypto_SakGenWrapAsync() with Mka_Crypto_Stop in Asynchronous mode.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Do the asynchronous KekIckGenerate procedure to set the correct crypto state.
    -   Setting up stubs.
  
Test Execution: 
    01: Call Mka_Crypto_SakGenWrapAsync to start SAK gen and wrap preparation process.
    02: VP(Mka.dsn.Crypto.Api.SakGenWrapAsync,1) Verify that Crypto unit has prepared SAK gen and wrap process and has returned E_OK.
    03: Start the main Crypto thread which shall start SAK gen and wrap process.
    04: VP(Mka.dsn.Crypto.Api.SakGenWrapAsync,1) Verify that Crypto unit has succesfully started the requested process.
    05: Simulate the asynchronous callout to continue the procedure.
    06: VP(Mka.dsn.Crypto.Api.SakGenWrapAsync,1) Verify that Crypto unit has succesfully started SAK wrapping process.
    07: Call Mka_Crypto_Stop to stop the SAK wrapping process.
    08: VP(Mka.Crypto.KeyWrap_Async_Stop,1) Verify that the process has been stopped and only Csm_CancelJob was called.
    09: Sanity check -
    10: Csm_CancelJob shall call the callback function with result set to CRYPTO_E_JOB_CANCELED.
    11: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.SakGenWrapAsync</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1032</internalId></provcov>
        <provcov>
          <linksto>Mka.Crypto.KeyWrap_Async_Stop</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1252</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1977</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01074_SakGenWrap_Stop_Sync128</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>2584</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when Mka_Crypto_SakGenWrapAsync is called and SAK generation and key wrapping procedure has been started, calling Mka_Crypto_Stop shall stop the process and no further function calls shall be made.
Test Object: Mka_Crypto_SakGenWrapAsync() with Mka_Crypto_Stop in Synchronous mode.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Do the asynchronous KekIckGenerate procedure to set the correct crypto state.
  
Test Execution: 
    01: Set the random callout to a function that will call Mka_Crypto_Stop.
    02: Call Mka_Crypto_SakGenWrapAsync to start SAK gen and wrap preparation process.
    03: VP(Mka.dsn.Crypto.Api.SakGenWrapAsync,1) Verify that Crypto unit has prepared SAK gen and wrap process and has returned E_NOT_OK.
    04: Sanity check - Check that random generate was called and key was set but wrap was stopped before encrypt is called.
    05: Start the main Crypto thread which shall start SAK gen and wrap process.
    06: VP(Mka.Crypto.KeyWrap_Stop,1) Verify that the process has been stopped and no other APIs were called.
    07: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.SakGenWrapAsync</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1032</internalId></provcov>
        <provcov>
          <linksto>Mka.Crypto.KeyWrap_Stop</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1251</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1978</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01075_SakUnwrap_Stop_Async128</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>2613</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when Mka_Crypto_SakUnwrapAsync is called and SAK unwrapping process started, calling Mka_Crypto_Stop shall stop the process and only Csm_CancelJob shall be called once.
Test Object: Mka_Crypto_SakUnwrapAsync() with Mka_Crypto_Stop in Asynchronous mode.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Do the asynchronous KekIckGenerate procedure to set the correct crypto state.
    -   Setting up stubs.
  
Test Execution: 
    01: Call Mka_Crypto_SakUnwrapAsync to start SAK unwrap preparation process.
    02: VP(Mka.dsn.Crypto.Api.SakUnwrapAsync,1) Verify that Crypto unit has prepared SAK gen and wrap process and has returned E_OK.
    03: Start the main Crypto thread which shall start SAK gen and wrap process.
    04: Sanity check - Check that Crypto unit has successfully started the requested process.
    05: Call Mka_Crypto_Stop to stop the SAK unwrapping process.
    06: VP(Mka.Crypto.KeyUnwrap_Async_Stop,1)
        VP(Mka.Crypto.KeyUnwrap_Stop,1) Verify that the process has been stopped and only Csm_CancelJob was called.
    07: Csm_CancelJob shall call the callback function with result set to CRYPTO_E_JOB_CANCELED.
    08: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.SakUnwrapAsync</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1033</internalId></provcov>
        <provcov>
          <linksto>Mka.Crypto.KeyUnwrap_Async_Stop</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1254</internalId></provcov>
        <provcov>
          <linksto>Mka.Crypto.KeyUnwrap_Stop</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1253</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1979</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01076_SakUnwrap_Stop_Sync128</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>2649</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when Mka_Crypto_SakUnwrapAsync is called and SAK unwrapping process started, calling Mka_Crypto_Stop shall stop the process and no further API calls shall be made.
Test Object: Mka_Crypto_SakUnwrapAsync() with Mka_Crypto_Stop in Synchronous mode.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Do the asynchronous KekIckGenerate procedure to set the correct crypto state.
    -   Setting up stubs.
  
Test Execution: 
    01: Set the random callout to a function that will call Mka_Crypto_Stop.
    02: Call Mka_Crypto_SakUnwrapAsync to start SAK unwrap preparation process.
    03: VP(Mka.dsn.Crypto.Api.SakUnwrapAsync,1) Verify that Crypto unit has prepared SAK gen and wrap process and has returned E_NOT_OK. Check that decrypt is called only one time.
    04: Start the main Crypto thread which shall start SAK gen and wrap process.
    05: VP(Mka.Crypto.KeyUnwrap_Async_Stop,1) Verify that the process has been stopped and no functions were called.
    06: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.SakUnwrapAsync</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1033</internalId></provcov>
        <provcov>
          <linksto>Mka.Crypto.KeyUnwrap_Async_Stop</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1254</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1980</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01084_GetCkn_128_Fail</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>2678</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when Mka_Crypto_CopyCkn or Mka_Crypto_GetCknPtr are called, but no valid Ckn exists, only CknSize = 0 shall be returned. Test is done in both synchronous and asynchronous mode.
Test Object: Mka_Crypto_CopyCkn and Mka_Crypto_GetCknPtr in both Sync and Asynchronous mode.
Test Precondition: 
    -   Set callout function for Csm_KeyElementGet_Stub to get CKN.
    -   Module configuration and Crypto unit initialized.
  
Test Execution: 
    01: Call Mka crypto unit API Mka_Crypto_GetCknPtr while there is no stored CKN.
    02: VP(Mka.dsn.Crypto.Api.GetCknPtr.E_NOT_OK,1) Verify that Crypto unit return correct E_NOT_OK.
    03: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.GetCknPtr.E_NOT_OK</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1539</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1981</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01085_CacheCkn_128</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>2699</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that during Mka_Crypto initialization phase, Ckn for each participant will be stored. Test is done in both synchronous and asynchronous mode.
Test Object: Mka_Crypto_CopyCkn and Mka_Crypto_GetCknPtr in both Sync and Asynchronous mode.
Test Precondition: 
    -   Initialize Mka configuration.
  
Test Execution: 
    01: Call Mka_Crypto_Init().
    02: VP(Mka.dsn.Crypto.CacheCkn,1) Verify that, after function call Mka_Crypto_Init(), Crypto unit called Csm_KeyElementGet() for each participant to store it's CKN.
    03: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.CacheCkn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1556</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1982</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01086_KeyGenWrap_Busy_Trans_Sync_Fail</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>2719</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when KeyWrapSM has a failure in Busy state, it moves from Busy to Idle
Test Object: Mka_CsmRandomCallback() does the transition when key generation or wrap fails.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Set Csm_Encrypt Stub to E_NOT_OK to trigger failure transition.
    -   Do the KekIckGenerate procedure to set the correct crypto state.
  
Test Execution: 
    01: Call Mka_Crypto_SakGenWrapAsync to start SAK gen and wrap preparation process.
    02: Check that Crypto unit has prepared SAK gen and wrap process and has returned E_NOT_OK which signifies that the Generate process failed.
    03: Start the main Crypto thread which shall start SAK gen and wrap process.
    04: Verify that Crypto unit has successfully done the requested process by following expected routine in sync mode.
    05: VP(Mka.dsn.Crypto.KeyWrapSM.Busy_2_Idle_Fail_Sak,1) Verify SM Transition from Busy to Idle
    06: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.KeyWrapSM.Busy_2_Idle_Fail_Sak</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1320</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1983</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01087_KeyGenWrap_Busy_Trans_Async_Wrap_Fail</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>2744</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when KeyWrapSM has a failure in generating Sak in Async mode, it moves from Busy to Idle
Test Object: Mka_CsmRandomCallback() does the transition when key generation fails.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Do the KekIckGenerate procedure to set the correct crypto state.
  
Test Execution: 
    01: Call Mka_Crypto_SakGenWrapAsync to start SAK gen and wrap preparation process.
    02: Check that Crypto unit has prepared SAK gen and wrap process and has returned E_OK.
    03: Start the main Crypto thread which shall start SAK gen and wrap process.
    04: Verify that Crypto unit has successfully done the requested process.
    05: Call Mka_CsmRandomCallback() to continue functionality.
    06: Verify that Crypto unit has succesfully finished the requested process.
    07: Simulate the asynchronous callout to continue the procedure.
    08: VP(Mka.dsn.Crypto.KeyWrapSM.Busy_2_Idle_Fail_Sak,1) Verify SM Transition from Busy to Idle
    09: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.KeyWrapSM.Busy_2_Idle_Fail_Sak</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1320</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1984</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01088_KeyGenWrap_Busy_Trans_Async_Gen_Fail</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>2771</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when KeyWrapSM has a failure in wrapping Keys in Async mode, it moves from Busy to Idle
Test Object: Mka_CsmKeyWrapCallback() does the transition when key wrap fails.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Do the KekIckGenerate procedure to set the correct crypto state.
  
Test Execution: 
    01: Call Mka_Crypto_SakGenWrapAsync to start SAK gen and wrap preparation process.
    02: Check that Crypto unit has prepared SAK gen and wrap process and has returned E_OK.
    03: Start the main Crypto thread which shall start SAK gen and wrap process.
    04: Verify that Crypto unit has successfully done the requested process.
    05: Call Mka_CsmKeyWrapCallback() to continue process.
    06: VP(Mka.dsn.Crypto.KeyWrapSM.Busy_2_Idle_Fail_Server,1) Verify SM Transition from Busy to Idle
    07: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.KeyWrapSM.Busy_2_Idle_Fail_Server</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1319</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1985</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01091_InvalidCkn</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>2796</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that invalid length CKN is reported to Mka_Crypto_FindParticipant.
Test Object: Mka_Crypto_FindParticipant in both Sync and Asynchronous mode.
Test Precondition: 
    -   Initialize Mka configuration.
  
Test Execution: 
    01: Setup Csm_KeyElementGet stub that will for count == 0 return E_NOT_OK but valid key length, for count == 2 return valid key but length 0, for count == 4 return valid key but length 33, and for all other calls return a valid key.
    02: Call Mka_Crypto_Init().
    03: VP(Mka.CP_SWS_Mka_00033,1) Verify that Mka_Logon_ReportEvent() is called to report an event that the key is missing as retrieval of of CKN failed for Participant_1 because Csm_KeyElementGet() returned E_NOT_OK.
    04: Call Mka_Crypto_FindParticipant to start find correct Mka Id for that was not correctly extracted.
    05: VP(Mka.8021X.MkaKeyHierarchy.4.1,1) Verify that Crypto unit has returned invalid ID.
    06: Call Mka_Crypto_FindParticipant to start find correct Mka Id for a valid key.
    07: VP(Mka.dsn.Crypto.Api.FindParticipant,1) Verify that Crypto unit has returned correct Mka Id.
    08: Call Mka_Crypto_FindParticipant to start find correct Mka Id for key with length 0.
    09: VP(Mka.8021X.MkaKeyHierarchy.4.1,1) Verify that Crypto unit has returned correct Mka Id.
    10: Call Mka_Crypto_FindParticipant to start find correct Mka Id for valid key.
    11: VP(Mka.dsn.Crypto.Api.FindParticipant,1) Verify that Crypto unit has returned correct Mka Id.
    12: Call Mka_Crypto_FindParticipant to start find correct Mka Id for keywith length max CKN length + 1.
    13: VP(Mka.8021X.MkaKeyHierarchy.4.1,1) Verify that Crypto unit has returned correct Mka Id.
    14: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00033</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>352</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.MkaKeyHierarchy.4.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>113</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.FindParticipant</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1037</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1986</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01092_InvalidCkn2</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>2835</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that invalid length CKN is reported to Mka_Crypto_CopyCkn.
Test Object: Mka_Crypto_CopyCkn in both Sync and Asynchronous mode.
Test Precondition: 
    -   Initialize Mka configuration.
  
Test Execution: 
    01: Setup Csm_KeyElementGet stub that will for count == 0 return E_NOT_OK but valid key length, for count == 2 return valid key but length 0, for count == 4 return valid key but length 33, and for all other calls return a valid key.
    02: Call Mka_Crypto_Init().
    03: VP(Mka.CP_SWS_Mka_00033,1) Verify that Mka_Logon_ReportEvent() is called to report an event that the key is missing as retrieval of of CKN failed for Participant_1 because Csm_KeyElementGet() returned E_NOT_OK.
    04: Call Mka crypto unit API Mka_Crypto_CopyCkn for a CKN that was not correctly extracted.
    05: VP(Mka.8021X.MkaKeyHierarchy.4.1,1) Verify that Crypto unit returned TS_CknSize of 0, indicating that no Ckn has been copied.
    06: Call Mka crypto unit API Mka_Crypto_CopyCkn with input parameter CknSize = EBTEST_CKN_SIZE.
    07: VP(Mka.dsn.Crypto.Api.CopyCkn,1) Verify that Crypto unit return correct CknPtr and TS_CknSize.
    08: Call Mka crypto unit API Mka_Crypto_CopyCkn with input parameter CknSize = EBTEST_CKN_SIZE.
    09: VP(Mka.dsn.Crypto.Api.CopyCkn,1)
        VP(Mka.8021X.MkaKeyHierarchy.3.1,1) Verify that Crypto unit return correct CknPtr and TS_CknSize.
    10: Call Mka crypto unit API Mka_Crypto_CopyCkn for CKN with length max CKN length + 1.
    11: VP(Mka.dsn.Crypto.Api.CopyCkn,1) Verify that Crypto unit returned TS_CknSize of 0, indicating that no Ckn has been copied.
    12: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00033</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>352</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.MkaKeyHierarchy.4.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>113</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.CopyCkn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1038</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.MkaKeyHierarchy.3.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>111</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1987</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01093_InvalidCkn3</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>2877</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that invalid length CKN is reported to Mka_Crypto_GetCknPtr.
Test Object: Mka_Crypto_GetCknPtr in both Sync and Asynchronous mode.
Test Precondition: 
    -   Initialize Mka configuration.
  
Test Execution: 
    01: Setup Csm_KeyElementGet stub that will for count == 0 return E_NOT_OK but valid key length, for count == 2 return valid key but length 0, for count == 4 return valid key but length 33, and for all other calls return a valid key.
    02: Call Mka_Crypto_Init().
    03: VP(Mka.CP_SWS_Mka_00033,1) Verify that Mka_Logon_ReportEvent() is called to report an event that the key is missing as retrieval of of CKN failed for Participant_1 because Csm_KeyElementGet() returned E_NOT_OK.
    04: Call Mka crypto unit API Mka_Crypto_GetCknPtr to get CKN.
    05: VP(Mka.8021X.MkaKeyHierarchy.4.1,1) Verify that Crypto unit returned E_NOT_OK and correct CKN size == 0 for key that was not extracted correctly.
    06: Call Mka crypto unit API Mka_Crypto_GetCknPtr to get CKN.
    07: VP(Mka.dsn.Crypto.Api.GetCknPtr.E_OK,1)
        VP(Mka.dsn.Crypto.Api.GetCknPtr,1) Verify that Crypto unit returned E_OK and correct CKN parameters.
    08: Call Mka crypto unit API Mka_Crypto_GetCknPtr to get CKN.
    09: VP(Mka.8021X.MkaKeyHierarchy.4.1,1) Verify that Crypto unit returned E_NOT_OK and correct CKN size == 0 for key with length 0.
    10: Call Mka crypto unit API Mka_Crypto_GetCknPtr to get CKN.
    11: VP(Mka.dsn.Crypto.Api.GetCknPtr.E_OK,1)
        VP(Mka.dsn.Crypto.Api.GetCknPtr,1) Verify that Crypto unit returned E_OK and correct CKN parameters.
    12: Call Mka crypto unit API Mka_Crypto_GetCknPtr to get CKN.
    13: VP(Mka.8021X.MkaKeyHierarchy.4.1,1) Verify that Crypto unit returned E_NOT_OK and correct CKN size == 0 for key with length max CKN length + 1.
    14: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00033</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>352</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.MkaKeyHierarchy.4.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>113</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.GetCknPtr.E_OK</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1538</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.GetCknPtr</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1039</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1988</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01094_KekIckGen_Sync_128IckGenInput</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>2922</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that correct values are passed to CSM module for 128 bit ICK generation.
Test Object: ICK generation.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
  
Test Execution: 
    01: Call Mka crypto unit API Mka_Crypto_IckGenerateAsync to start Ick Generate procedure.
    02: VP(Mka.InterAct.Crypto.IckGenerateSync,1) Verify that Csm functions are called in correct order with correct input variables.
    03: VP(Mka.8021X.MkaKeyHierarchy.9,1) Verify input data passed to Csm for ICK generation.
    04: VP(Mka.8021X.MkaKeyHierarchy.9.1,1) Verify input data passed to Csm for ICK generation is exactly 32 bytes.
    05: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.InterAct.Crypto.IckGenerateSync</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1122</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.MkaKeyHierarchy.9</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.MkaKeyHierarchy.9.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>124</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1989</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01095_KekIckGen_Sync_256IckGenInput</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>2952</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that correct values are passed to CSM module for 256 bit ICK generation.
Test Object: ICK generation.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
  
Test Execution: 
    01: Call Mka crypto unit API Mka_Crypto_IckGenerateAsync to start Ick Generate procedure.
    02: VP(Mka.InterAct.Crypto.IckGenerateSync,1) Verify that Csm functions are called in correct order with correct input variables
    03: VP(Mka.8021X.MkaKeyHierarchy.9,1) Verify input data passed to Csm for ICK generation.
    04: VP(Mka.8021X.MkaKeyHierarchy.9.1,1) Verify input data passed to Csm for ICK generation is exactly 32 bytes.
    05: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.InterAct.Crypto.IckGenerateSync</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1122</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.MkaKeyHierarchy.9</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.MkaKeyHierarchy.9.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>124</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1990</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01096_KekIckGen_Sync_128KekGenInput</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>2982</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that correct values are passed to CSM module for 128 bit KEK generation.
Test Object: ICK generation.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
  
Test Execution: 
    01: Call Mka crypto unit API Mka_Crypto_IckGenerateAsync to start Kek Generate procedure.
    02: VP(Mka.InterAct.Crypto.KekGenerateSync,1) Verify that Csm functions are called in correct order with correct input variables.
    03: VP(Mka.8021X.MkaKeyHierarchy.11,1) Verify input data passed to Csm for KEK generation.
    04: VP(Mka.8021X.MkaKeyHierarchy.11.1,1) Verify input data passed to Csm for KEK generation is exactly 32 bytes.
    05: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.InterAct.Crypto.KekGenerateSync</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1124</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.MkaKeyHierarchy.11</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>127</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.MkaKeyHierarchy.11.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1991</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01097_KekIckGen_Sync_256KekGenInput</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>3012</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that correct values are passed to CSM module for 256 bit KEK generation.
Test Object: ICK generation.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
  
Test Execution: 
    01: Call Mka crypto unit API Mka_Crypto_IckGenerateAsync to start Kek Generate procedure.
    02: VP(Mka.InterAct.Crypto.IckGenerateSync,1) Verify that Csm functions are called in correct order with correct input variables
    03: VP(Mka.8021X.MkaKeyHierarchy.11,1) Verify input data passed to Csm for KEK generation.
    04: VP(Mka.8021X.MkaKeyHierarchy.11.1,1) Verify input data passed to Csm for KEK generation is exactly 32 bytes.
    05: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.InterAct.Crypto.IckGenerateSync</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1122</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.MkaKeyHierarchy.11</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>127</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.MkaKeyHierarchy.11.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1992</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01098_KeyWrap_ReqInvalid_SM_State</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>3042</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that if Mka_Crypto_SakGenWrapAsync is called while another process is ongoing, it is ignored.
Test Object: KeyWrap SM.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Do the KekIckGenerate procedure to set the correct crypto state.
  
Test Execution: 
    01: Call Mka_Crypto_SakGenWrapAsync to start SAK gen and wrap preparation process.
    02: Check that Crypto unit has prepared SAK gen and wrap process and has returned E_OK.
    03: Start the main Crypto thread which shall start SAK gen and wrap process.
    04: Check that Crypto unit has successfully done the requested process by following expected routine in sync mode.
    05: Call Mka_Crypto_SakGenWrap_Async to send another process
    06: VP(Mka.Crypto.KeyWrap_RequestInvalidKeyWrapState,1) Verify that no job was started and that the request was ignored.
    07: Check that process was still successful.
    08: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Crypto.KeyWrap_RequestInvalidKeyWrapState</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1238</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1993</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01099_KeyWrap_SetSak_Valid_Fail</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>3068</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that if Csm_KeySetValid fails, the process stops.
Test Object: Csm_KeySetValid
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Set Csm_KeySetValid_Stub to E_NO_OK
    -   Do the KekIckGenerate procedure to set the correct crypto state.
  
Test Execution: 
    01: Call Mka_Crypto_SakGenWrapAsync to start SAK gen and wrap preparation process.
    02: Check that Crypto unit has prepared SAK gen and wrap process and has returned E_OK.
    03: Start the main Crypto thread which shall start SAK gen and wrap process.
    04: Check that Crypto unit has successfully done the requested process by following expected routine in sync mode.
    05: VP(Mka.Crypto.KeyWrap_SetSakValid_Fail,1) Verify that due to Csm_KeySetValid having a value E_NOT_OK, SM will go from Busy to Idle state.
    06: Sanity check - Sanity.
    07: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Crypto.KeyWrap_SetSakValid_Fail</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1234</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1994</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01100_KeyWrap_SetSak_Fail</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>3094</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that if Csm_KeyElementSet fails the process is stopped.
Test Object: Csm_KeyElementSet
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Set Csm_KeyElementSet to E_NO_OK
    -   Do the KekIckGenerate procedure to set the correct crypto state.
  
Test Execution: 
    01: Call Mka_Crypto_SakGenWrapAsync to start SAK gen and wrap preparation process.
    02: Check that Crypto unit has prepared SAK gen and wrap process and has returned E_OK.
    03: Start the main Crypto thread which shall start SAK gen and wrap process.
    04: Check that Crypto unit has successfully done the requested process by following expected routine in sync mode.
    05: VP(Mka.Crypto.KeyWrap_SetSak_Fail,1) Verify that due to Csm_KeySetValid having a value E_NOT_OK, SM will go from Busy to Idle state.
    06: Sanity check - Sanity.
    07: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Crypto.KeyWrap_SetSak_Fail</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1233</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1995</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01101_Sak_Async_KeyWrap_Fail</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>3120</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: Test case verifies that if Mka_CsmKeyWrapCallback reports a failure, key wrap process stops.
Test Object: Mka_CsmKeyWrapCallback
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Do the asynchronous KekIckGenerate procedure to set the correct crypto state.
  
Test Execution: 
    01: Call Mka_Crypto_SakGenWrapAsync to start SAK gen and wrap preparation process.
    02: Check that Crypto unit has prepared SAK gen and wrap process and has returned E_OK.
    03: Start the main Crypto thread which shall start SAK gen and wrap process.
    04: Check that Crypto unit has succesfully started the requested process.
    05: Simulate the asynchronous callout to continue the procedure.
    06: Check that Crypto unit has succesfully finished the requested process.
    07: Simulate the asynchronous callout to continue the procedure.
    08: VP(Mka.Crypto.KeyWrap_Sak_Async_KeyWrapFail,1) Verify Crypto Process has stopped.
    09: Sanity check -
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Crypto.KeyWrap_Sak_Async_KeyWrapFail</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1229</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1996</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01102_Sak_Async_KeyGen_Fail</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>3147</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: Test case verifies that if Mka_CsmRandomCallback returns failure, key Gen process stops.
Test Object: Mka_CsmRandomCallback
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Do the asynchronous KekIckGenerate procedure to set the correct crypto state.
  
Test Execution: 
    01: Call Mka_Crypto_SakGenWrapAsync to start SAK gen and wrap preparation process.
    02: Check that Crypto unit has prepared SAK gen and wrap process and has returned E_OK.
    03: Start the main Crypto thread which shall start SAK gen and wrap process.
    04: Check that Crypto unit has succesfully started the requested process.
    05: Simulate the asynchronous callout to continue the procedure.
    06: VP(Mka.Crypto.KeyWrap_Sak_Async_KeyGenFail,1) Verify Crypto Process has stopped.
    07: Sanity check -
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Crypto.KeyWrap_Sak_Async_KeyGenFail</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1228</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1997</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01103_Sak_StartGenFail_Async</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>3172</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: Test case verifies that if Csm_RandomGenerate reports a failure, key Gen process stops.
Test Object: Csm_RandomGenerate
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Do the asynchronous KekIckGenerate procedure to set the correct crypto state.
  
Test Execution: 
    01: set Csm_RandomGenerate_Stub to fail
    02: Call Mka_Crypto_SakGenWrapAsync to start SAK gen and wrap preparation process.
    03: VP(Mka.Crypto.KeyWrap_Sak_StartGenFail,1) Verify that the process has halted due to random generate failure.
    04: Sanity check - Sanity.
    05: Sanity check -
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Crypto.KeyWrap_Sak_StartGenFail</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1225</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1998</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01104_Sak_StartGenFail_Sync</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>3195</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that if Csm_RandomGenerate reports a failure, key Gen process stops.
Test Object: Csm_RandomGenerate
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Set Csm_RandomGenerate fails when called.
    -   Do the KekIckGenerate procedure to set the correct crypto state.
  
Test Execution: 
    01: Call Mka_Crypto_SakGenWrapAsync to start SAK gen and wrap preparation process.
    02: VP(Mka.dsn.Crypto.Api.SakGenWrapAsync,1) Verify that Crypto unit has prepared SAK gen and wrap process and has returned E_OK.
    03: Start the main Crypto thread which shall start SAK gen and wrap process.
    04: Check that Crypto unit has successfully done the requested process by following expected routine in sync mode.
    05: Sanity check - Sanity.
    06: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.SakGenWrapAsync</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1032</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1999</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01105_Sak_StartWrapFail_Async</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>3220</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that if Csm_Encrypt reports a failure, key Wrap process stops.
Test Object: Csm_Encrypt
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Set the Csm_Encrypt_Stub to fail when wrapping SaK.
    -   Do the asynchronous KekIckGenerate procedure to set the correct crypto state.
  
Test Execution: 
    01: Call Mka_Crypto_SakGenWrapAsync to start SAK gen and wrap preparation process.
    02: VP(Mka.dsn.Crypto.Api.SakGenWrapAsync,1) Verify that Crypto unit has prepared SAK gen and wrap process and has returned E_OK.
    03: Start the main Crypto thread which shall start SAK gen and wrap process.
    04: Check that Crypto unit has succesfully started the requested process.
    05: Simulate the asynchronous callout to continue the procedure.
    06: Sanity check - Check that Crypto unit has succesfully finished the requested process.
    07: VP(Mka.Crypto.KeyWrap_Sak_StartWrapFail,1)
        VP(Mka.dsn.Crypto.CryptoSM.Kek_Ready_2_CakCkn_Ready_Wrap,1) Verify that Crypto unit has finished the requested process and reported back to the caller.
    08: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.SakGenWrapAsync</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1032</internalId></provcov>
        <provcov>
          <linksto>Mka.Crypto.KeyWrap_Sak_StartWrapFail</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1226</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.CryptoSM.Kek_Ready_2_CakCkn_Ready_Wrap</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1329</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2000</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01106_Sak_StartWrapFail_Sync</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>3256</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that if Csm_Encrypt returns a failure, key Wrap process stops.
Test Object: Csm_Encrypt
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Set Csm_Encrypt to fail when called.
    -   Do the KekIckGenerate procedure to set the correct crypto state.
  
Test Execution: 
    01: Call Mka_Crypto_SakGenWrapAsync to start SAK gen and wrap preparation process.
    02: Check that Crypto unit has prepared SAK gen and wrap process and has returned E_OK.
    03: Start the main Crypto thread which shall start SAK gen and wrap process.
    04: Check that Crypto unit has successfully done the requested process by following expected routine in sync mode.
    05: VP(Mka.Crypto.KeyWrap_Sak_StartWrapFail,1)
        VP(Mka.dsn.Crypto.CryptoSM.Kek_Ready_2_CakCkn_Ready_Wrap,1) Verify that process was stopped after Csm_Encrypt Fail
    06: Sanity check - Sanity.
    07: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Crypto.KeyWrap_Sak_StartWrapFail</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1226</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.CryptoSM.Kek_Ready_2_CakCkn_Ready_Wrap</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1329</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2001</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01107_SakUnwrap_Async128_WrongJobId</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>3287</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when Mka_CsmKeyUnwrapCallback() is called with a job id that does not match any Mka job id, the call shall be ignored.
Test Object: Mka_CsmKeyUnwrapCallback().
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Do the asynchronous KekIckGenerate procedure to set the correct crypto state.
    -   Setting up stubs.
  
Test Execution: 
    01: Call Mka_Crypto_SakUnwrapAsync to start SAK unwrap preparation process.
    02: Sanity check - Check that Crypto unit has prepared SAK gen and wrap process and has returned E_OK.
    03: Start the main Crypto thread which shall start SAK gen and wrap process.
    04: Sanity check - Check that Crypto unit has successfully started the requested process.
    05: Simulate the asynchronous callback with incorrect job id.
    06: VP(Mka.Crypto.KeyUnwrapCallback_NoMatch,1) Verify call is ignored.
    07: Simulate the asynchronous callback with a valid job id.
    08: Sanity check - Check that Crypto unit is successfully doing the requested process
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Crypto.KeyUnwrapCallback_NoMatch</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1193</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2002</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01108_SakUnwrap_Async128_NotStarted</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>3314</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when Mka_CsmKeyUnwrapCallback() is called with a job id that does not have an ongoing task, the call shall be ignored.
Test Object: Mka_CsmKeyUnwrapCallback().
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Do the asynchronous KekIckGenerate procedure to set the correct crypto state.
    -   Setting up stubs.
  
Test Execution: 
    01: Simulate the asynchronous callback with a job id that does not have an ongoing task.
    02: VP(Mka.Crypto.KeyUnwrapCallback_NotStarted,1) Verify call is ignored.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Crypto.KeyUnwrapCallback_NotStarted</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1199</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2003</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01109_SakUnwrap_Async128_SetFail</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>3335</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: The test verifies that when saving the unwrapped SAK fails (Csm_KeyElementSet), the Crypto unit shall stop any further key process and report that the key unwrap has failed.
Test Object: Key unwrap when Csm_KeyElementSet() fails.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Do the asynchronous KekIckGenerate procedure to set the correct crypto state.
    -   Setting up stubs.
  
Test Execution: 
    01: Call Mka_Crypto_SakUnwrapAsync to start SAK unwrap preparation process.
    02: Sanity check - Check that Crypto unit has prepared SAK gen and wrap process and has returned E_OK.
    03: Start the main Crypto thread which shall start SAK gen and wrap process.
    04: Sanity check - Check that Crypto unit has successfully started the requested process.
    05: Simulate the asynchronous callback to continue the procedure.
    06: Sanity check - Check that Crypto unit is succesfully doing the requested process.
    07: Simulate the asynchronous callout to continue the procedure.
    08: VP(Mka.Crypto.KeyUnwrap_SetSak_Fail,1) Verify Crypto stop any further key process.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Crypto.KeyUnwrap_SetSak_Fail</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1235</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2004</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01110_SakUnwrap_Async128_ValidFail</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>3362</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: The test verifies that when setting the state of the the unwrapped SAK fails (Csm_KeySetValid), the Crypto unit shall stop any further key process and report that the key unwrap has failed.
Test Object: Key Unwrap when Csm_KeySetValid() fails.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Do the asynchronous KekIckGenerate procedure to set the correct crypto state.
    -   Setting up stubs.
  
Test Execution: 
    01: Call Mka_Crypto_SakUnwrapAsync to start SAK unwrap preparation process.
    02: Sanity check - Check that Crypto unit has prepared SAK gen and wrap process and has returned E_OK.
    03: Start the main Crypto thread which shall start SAK gen and wrap process.
    04: Sanity check - Check that Crypto unit has successfully started the requested process.
    05: Simulate the asynchronous callback to continue the procedure.
    06: Sanity check - Check that Crypto unit is succesfully doing the requested process.
    07: Simulate the asynchronous callout to continue the procedure.
    08: VP(Mka.Crypto.KeyUnwrap_SetSakValid_Fail,1) Verify Crypto stop any further key process.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Crypto.KeyUnwrap_SetSakValid_Fail</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1236</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2005</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01111_SakUnwrap_Async128_DoubleFail</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>3389</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: The test verifies that when Mka_Crypto_SakUnwrapAsync() is called while unwrapping is ongoing, the Crypto unit shall return E_NOT_OK and no process will be started.
Test Object: Mka_Crypto_SakUnwrapAsync().
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Do the asynchronous KekIckGenerate procedure to set the correct crypto state.
    -   Setting up stubs.
  
Test Execution: 
    01: Call Mka_Crypto_SakUnwrapAsync to start SAK unwrap preparation process.
    02: Sanity check - Check that Crypto unit has prepared SAK gen and wrap process and has returned E_OK.
    03: Start the main Crypto thread which shall start SAK gen and wrap process.
    04: Sanity check - Check that Crypto unit has successfully started the requested process.
    05: Simulate the asynchronous callback to continue the procedure.
    06: Sanity check - Check that Crypto unit is succesfully doing the requested process.
    07: Call Mka_Crypto_SakUnwrapAsync to start SAK unwrap preparation process.
    08: VP(Mka.Crypto.KeyUnwrap_RequestInvalidKeyUnwrapState,1) Verify that if Mka_Crypto_SakUnwrapAsync is called while unwrapping is ongoing, the Crypto unit shall return E_NOT_OK and no process will be started.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Crypto.KeyUnwrap_RequestInvalidKeyUnwrapState</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1240</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2006</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01112_SakUnwrap_StartFail</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>3416</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: The test verifies that when Csm_Decrypt() returns any result other than E_OK, the Crypto unit shall stop any further key unwrap process and report to the caller that the key unwrap has failed.
Test Object: Key Unwrap when Csm_Decrypt() fails.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Do the asynchronous KekIckGenerate procedure to set the correct crypto state.
    -   Setting up stubs.
  
Test Execution: 
    01: Call Mka_Crypto_SakUnwrapAsync to start SAK unwrap preparation process.
    02: Sanity check - Check that Crypto unit has prepared SAK gen and wrap process and has returned E_OK.
    03: Start the main Crypto thread which shall start SAK gen and wrap process.
    04: VP(Mka.Crypto.KeyUnwrap_Sak_StartUnwrapFail,1)
        VP(Mka.dsn.Crypto.CryptoSM.Kek_Ready_2_CakCkn_Ready_Unwrap,1) Verify that if Csm_Decrypt fails, the Crypto unit shall stop any further key unwrap process and report to the caller that the key unwrap has failed.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Crypto.KeyUnwrap_Sak_StartUnwrapFail</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1227</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.CryptoSM.Kek_Ready_2_CakCkn_Ready_Unwrap</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1332</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2007</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01113_RandomGen_Retry</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>3444</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that Csm_RandomGenerate will be called again, if Csm_RandomGenerate returns BUSY. After Csm_RandomGenerate returns E_OK, Crypto unit will call Mka_KaY_RandomGenerateFinished with E_OK.
Test Object: Mka_Crypto_RandomGenerateAsync() in Asynchronous mode.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Prepare stubbed value to return BUSY after first attempt, and E_OK after second.
  
Test Execution: 
    01: Call Mka crypto unit API Mka_Crypto_RandomGenerateAsync to start RandomGenerate procedure.
    02: Sanity check - Check that the returned value is E_OK and Csm_RandomGenerate has been called.
    03: Call Mka_MainFunction for main tick.
    04: Sanity check - Sanity check.
    05: VP(Mka.dsn.Crypto.Api.RandomGenerate.Retry,1)
        VP(Mka.dsn.Crypto.RandomGenSM.Busy_Retry,1) Verify that Crypto unit retried calling Csm_RandomGenerate again.
    06: Sanity check - (Synchronous mode) Check that Crypto unit called Mka_KaY_RandomGenerateFinished with E_OK after retrying call towards Csm_MacGenerate and getting E_OK after second attempt.
    07: Sanity check - Sanity check.
    08: Asynchronous call from Csm to Crypto unit Mka_CsmRandomCallback().
    09: Sanity check - (Asynchronous mode) Check that Crypto unit called Mka_KaY_RandomGenerateFinished with E_OK after retrying call towards Csm_MacGenerate and getting E_OK after second attempt.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.RandomGenerate.Retry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1534</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.RandomGenSM.Busy_Retry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1356</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2008</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01114_RandomGen_Retry_Fail</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>3476</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that Csm_RandomGenerate will be called several times (MkaCryptoRetryAttempts), if Csm_RandomGenerate returns BUSY. After Csm_RandomGenerate returns BUSY same amount of times as the value of MkaCryptoRetryAttempts, Crypto unit will call Mka_KaY_RandomGenerateFinished with E_NOT_OK.
Test Object: Mka_Crypto_RandomGenerateAsync() in Asynchronous mode.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Prepare stubbed api to return BUSY.
  
Test Execution: 
    01: Call Mka crypto unit API Mka_Crypto_RandomGenerateAsync to start RandomGenerate procedure.
    02: Sanity check - Check that the returned value is E_OK and Csm_RandomGenerate has been called.
    03: Call Mka_MainFunction for main tick.
    04: Sanity check - Sanity check.
    05: VP(Mka.dsn.Crypto.Api.RandomGenerate.Retry,1) Verify that Crypto unit retried calling Csm_RandomGenerate again.
    06: Sanity check - Sanity check.
    07: Call Mka_MainFunction for main tick.
    08: Sanity check - Sanity check.
    09: VP(Mka.dsn.Crypto.Api.RandomGenerate.Retry,1) Verify that Crypto unit retried calling Csm_RandomGenerate again. At this point, MkaCryptoRetryAttempts counter reached zero.
    10: VP(Mka.dsn.Crypto.Api.RandomGenerate.RetryAttempts,1) Verify that Crypto unit called Mka_KaY_RandomGenerateFinished with E_NOT_OK after retrying call towards Csm_MacGenerate for number of times equal to MkaCryptoRetryAttempts.
    11: Sanity check - Sanity check.
    12: Call Mka_MainFunction for main tick.
    13: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.RandomGenerate.Retry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1534</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.RandomGenerate.RetryAttempts</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1536</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2009</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01115_RandomGen_Retry_Disabled</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>3511</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that Csm_RandomGenerate will be called only once, when Csm_RandomGenerate returns BUSY, while MkaCryptoRetryAttempts is 0.
Test Object: Mka_Crypto_RandomGenerateAsync() in Asynchronous mode when MkaCryptoRetryAttempts is configured to 0.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Prepare stubbed api to return BUSY.
  
Test Execution: 
    01: Call Mka crypto unit API Mka_Crypto_RandomGenerateAsync to start RandomGenerate procedure.
    02: VP(Mka.dsn.Crypto.Api.RandomGenerate.RetryDisabled,1) Verify that Crypto unit returned E_NOT_OK because MkaCryptoRetryAttempts is configured as zero and Csm_RandomGenerate returned CRYPTO_E_BUSY.
    03: Call Mka_MainFunction for main tick.
    04: Sanity check - Sanity check.
    05: VP(Mka.dsn.Crypto.Api.RandomGenerate.RetryDisabled,1) Verify that Crypto unit did not retry a call to Csm_RandomGenerate.
    06: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.RandomGenerate.RetryDisabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1535</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2010</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01116_IcvVerify_Retry</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>3535</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that, when the configured value MkaCryptoRetryAttempts is greater than 0, if Csm_MacVerify returns BUSY, Crypto unit will retry.
Test Object: Mka_Crypto_IcvVerifyAsync()
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
  
Test Execution: 
    01: Do the asynchronous KekIckGenerate procedure to set the correct crypto state before ICV verification.
    02: Set Csm_MacVerify stub to return BUSY.
    03: Call Mka_Crypto_IcvVerifyAsync to start ICV verification process.
    04: VP(Mka.dsn.Crypto.Api.IcvVerify.Retry,1) Verify that the returned value is E_OK and that the ICV verification process has been requested.
    05: Sanity check - Check that Crypto unit called Csm_MacVerify, which returned BUSY.
    06: Start the main Crypto thread which shall start ICV verification.
    07: Start the main Crypto thread which shall start ICV verification.
    08: VP(Mka.dsn.Crypto.Api.IcvVerify.Retry,1)
        VP(Mka.dsn.Crypto.IcvVerSM.Busy,1) Verify that Crypto unit called Csm_MacVerify again, after the Csm returned BUSY in the first call.
    09: Call Mka_CsmMacVerifyCallback() to simulate Csm async job finished callback.
    10: VP(Mka.dsn.Crypto.Api.IcvVerify.Retry,1) Verify that Crypto unit called Mka_RxTx_IcvVerifyFinished, after successful ICV verification, even though it failed with BUSY between calls to Csm.
    11: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.IcvVerify.Retry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1521</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.IcvVerSM.Busy</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1273</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2011</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01117_IcvVerify_Retry_Fail</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>3568</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that, when the configured value MkaCryptoRetryAttempts is greater than 0, if Csm_MacVerify keeps returning BUSY till all the retry attempts have been exhausted, Crypto unit will return E_NOT_OK to the original caller via Mka_RxTx_IcvVerifyFinished(E_NOT_OK).
Test Object: Mka_Crypto_IcvVerifyAsync()
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
  
Test Execution: 
    01: Do the asynchronous KekIckGenerate procedure to set the correct crypto state before ICV verification.
    02: Set Csm_MacVerify stub to return BUSY.
    03: Call Mka_Crypto_IcvVerifyAsync to start ICV verification process.
    04: Sanity check - Check that Crypto unit called Csm_MacVerify, which returned BUSY.
    05: Sanity check - Check that the returned value is E_OK and that the ICV retry process is ongoing.
    06: Set Csm_MacVerify stub to return BUSY.
    07: Start the main Crypto thread which shall start ICV verification.
    08: Sanity check - Check that Crypto unit called Csm_MacVerify, which returned BUSY.
    09: Start the main Crypto thread which shall start ICV verification.
    10: VP(Mka.dsn.Crypto.Api.IcvVerify.RetryAttempts,1)
        VP(Mka.dsn.Crypto.IcvVerSM.Busy_2_Idle_Fail,1) Verify that Crypto unit called Mka_RxTx_IcvVerifyFinished with E_NOT_OK since the number of retries exceeded MkaCryptoRetryAttempts.
    11: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.IcvVerify.RetryAttempts</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1523</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.IcvVerSM.Busy_2_Idle_Fail</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1272</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2012</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01118_IcvVerify_Retry_Disabled</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>3601</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that, when the configured value MkaCryptoRetryAttempts equals 0, if Csm_MacVerify returns BUSY, Crypto unit will return E_NOT_OK to the caller.
Test Object: Mka_Crypto_IcvVerifyAsync()
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
  
Test Execution: 
    01: Do the asynchronous KekIckGenerate procedure to set the correct crypto state before ICV verification.
    02: Set Csm_MacVerify stub to return BUSY.
    03: Call Mka_Crypto_IcvVerifyAsync to start ICV verification process.
    04: Sanity check - Check that Crypto unit called Csm_MacVerify, which returned BUSY.
    05: VP(Mka.dsn.Crypto.Api.IcvVerify.RetryDisabled,1) Verify that Mka_Crypto_IcvVerifyAsync() returned E_NOT_OK. Verify that Mka_RxTx_IcvVerifyFinished(E_NOT_OK) is called because Crypto unit could not retry as MkaCryptoRetryAttempts value is zero.
    06: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.IcvVerify.RetryDisabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1522</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2013</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01119_IcvGen_Retry_Async</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>3624</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that, when MkaCryptoRetryAttempts is configured to value greater than 0, after the Csm_MacGenerate returns BUSY, Crypto unit will retry that operation in the next main function tick and, after getting E_OK from Csm_MacGenerate, it will wait for the notification Mka_CsmIcvGenerateCallback() after which it will report Mka_RxTx_IcvGenerateFinished(E_OK). The retry feature is tested for the asynchronous mode of operation.
Test Object: Mka_Crypto_IcvGenerateAsync() retry
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
  
Test Execution: 
    01: Do the asynchronous KekIckGenerate procedure to set the correct crypto state before ICV verification.
    02: Set Csm_MacGenerate stub.
    03: Call Mka crypto unit API Mka_Crypto_IcvGenerateAsync to start IcvGenerate procedure.
    04: Sanity check - Check that Mka_Crypto_IcvGenerateAsync returned E_OK.
    05: Sanity check - Check that Crypto unit called Csm_MacGenerate.
    06: Call Mka crypto unit main function Mka_Crypto_MainFunction() to run the Crypto thread.
    07: VP(Mka.dsn.Crypto.Api.IcvGenerate.Retry,1)
        VP(Mka.dsn.Crypto.IcvGenSM.Requested_2_Busy,2) Verify that Csm_MacGenerate() was called again after getting back BUSY from Csm. This also verifies the transition from ICVGEN_REQUESTED to ICVGEN_BUSY, after Csm_MacGenerate() returned BUSY.
    08: Call Mka crypto unit main function Mka_Crypto_MainFunction() to run the Crypto thread.
    09: VP(Mka.dsn.Crypto.IcvGenSM.Busy_SelfTransition,2) Verify that after Csm_MacGenerate() returned E_OK, subsequent calls to Mka_Crypto_MainFunction() do not call Csm_MacGenerate(). This also verifies self-transition in ICVGEN_BUSY state for the case when Csm_MacGenerate() returned E_OK.
    10: Asynchronous call from Csm to Crypto unit Mka_CsmIcvGenerateCallback() with E_OK.
    11: VP(Mka.dsn.Crypto.IcvGenSM.Busy_2_Notify,2)
        VP(Mka.dsn.Crypto.Api.IcvGenerateAsync.AsynDone,1) Verify that IcvGen SM has transitioned from ICVGEN_BUSY over ICVGEN_NOTIFY to ICVGEN_IDLE, as after successful retry operation of Csm_MacGenerate(), the reception of Mka_CsmIcvGenerateCallback(E_OK) notification has triggered Mka_RxTx_IcvGenerateFinished(E_OK).
    12: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.IcvGenerate.Retry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1528</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.IcvGenSM.Requested_2_Busy</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1259</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.IcvGenSM.Busy_SelfTransition</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1267</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.IcvGenSM.Busy_2_Notify</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1266</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.IcvGenerateAsync.AsynDone</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1526</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2014</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01120_IcvGen_Retry_Sync</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>3671</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that, when MkaCryptoRetryAttempts is configured to value greater than 0, after the Csm_MacGenerate returns BUSY, Crypto unit will retry that operation in next main function tick and, after getting E_OK from Csm_MacGenerate, it will report Mka_RxTx_IcvGenerateFinished(E_OK).
Test Object: Mka_Crypto_IcvGenerateAsync() retry
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
  
Test Execution: 
    01: Do the asynchronous KekIckGenerate procedure to set the correct crypto state before ICV verification.
    02: Set Csm_MacGenerate stub.
    03: Call Mka crypto unit API Mka_Crypto_IcvGenerateAsync to start IcvGenerate procedure.
    04: Sanity check - Check that Mka_Crypto_IcvGenerateAsync returned E_OK.
    05: Sanity check - Check that Crypto unit called Csm_MacGenerate.
    06: Call Mka crypto unit main function Mka_Crypto_MainFunction() to run the Crypto thread.
    07: VP(Mka.dsn.Crypto.Api.IcvGenerate.Retry,1) Verify that Csm_MacGenerate was called again after getting back BUSY from Csm.
    08: VP(Mka.dsn.Crypto.Api.IcvGenerate.Retry,1) Verify that result is reported by calling Mka_RxTx_IcvGenerateFinished() with E_OK.
    09: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.IcvGenerate.Retry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1528</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2015</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01121_IcvGen_Retry_Fail</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>3697</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that, when MkaCryptoRetryAttempts is configured to value greater than 0, after the Csm_MacGenerate returns BUSY for the same amount as MkaCryptoRetryAttempts, Crypto unit will stop the process and report Mka_RxTx_IcvGenerateFinished(E_NOT_OK).
Test Object: Mka_Crypto_IcvGenerateAsync() retry
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
  
Test Execution: 
    01: Do the asynchronous KekIckGenerate procedure to set the correct crypto state before ICV verification.
    02: Set Csm_MacGenerate stub to return BUSY.
    03: Call Mka crypto unit API Mka_Crypto_IcvGenerateAsync to start IcvGenerate procedure.
    04: Sanity check - Check that Mka_Crypto_IcvGenerateAsync returned E_OK.
    05: Sanity check - Check that Crypto unit called Csm_MacGenerate.
    06: Set Csm_MacGenerate stub to return CRYPTO_E_BUSY.
    07: Start the main Crypto thread which shall retry ICV generate.
    08: VP(Mka.dsn.Crypto.IcvGenSM.Busy_SelfTransition,2) Verify that during Mka_Crypto_MainFunction() a call to Csm_MacGenerate() has been retried. This also verifies self-transition in ICVGEN_BUSY state.
    09: VP(Mka.dsn.Crypto.Api.IcvGenerate.RetryAttempts,1)
        VP(Mka.dsn.Crypto.IcvGenSM.Busy_2_Idle,2) Verify that result is reported by calling Mka_RxTx_IcvGenerateFinished() with E_NOT_OK since the number of retries has been exhausted. This also verifies transition from ICVGEN_BUSY to ICVGEN_IDLE if IcvGen SM.
    10: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.IcvGenSM.Busy_SelfTransition</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1267</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.IcvGenerate.RetryAttempts</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1530</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.IcvGenSM.Busy_2_Idle</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1263</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2016</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01122_IcvGen_Retry_Disabled</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>3733</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that, when MkaCryptoRetryAttempts is configured to value of 0, after the Csm_MacGenerate returns BUSY, Crypto unit will stop the process and report Mka_RxTx_IcvGenerateFinished(E_NOT_OK).
Test Object: Mka_Crypto_IcvGenerateAsync() retry disabled
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
  
Test Execution: 
    01: Do the asynchronous KekIckGenerate procedure to set the correct crypto state before ICV verification.
    02: Set Csm_MacGenerate stub to return BUSY.
    03: Call Mka crypto unit API Mka_Crypto_IcvGenerateAsync to start IcvGenerate procedure.
    04: Sanity check - Check that Crypto unit called Csm_MacGenerate.
    05: VP(Mka.dsn.Crypto.Api.IcvGenerate.RetryDisabled,1) Verify that Mka_Crypto_IcvGenerateAsync() returned E_NOT_OK. Verify that Mka_RxTx_IcvGenerateFinished(E_NOT_OK) is called because Crypto unit could not retry as MkaCryptoRetryAttempts value is zero.
    06: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.IcvGenerate.RetryDisabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1529</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2017</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01123_IckGen_Stop_Sync256</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>3756</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that if Mka_Crypto_Stop is called during Ick generate process, the process shall stop.
Test Object: Mka_Crypto_IckGenerateAsync() with Mka_Crypto_Stop in synchronous mode.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
  
Test Execution: 
    01: Set Csm_MacGenerate stub to return E_OK, but also call Mka_Crypto_Stop().
    02: Call Mka crypto unit API Mka_Crypto_IckGenerateAsync to start Ick Generate procedure.
    03: VP(Mka.Crypto.KeyGen_Ick_Stop,1) Verify that Crypto return E_NOT_OK because Mka_Crypto_Stop() has been called.
    04: Sanity check - Check that the Ick generating process has been started.
    05: Call Mka crypto unit main function Mka_Crypto_MainFunction() to run the Crypto thread.
    06: VP(Mka.Crypto.KeyGen_Ick_Stop,1) Verify that generation process has been stopped. No other Csm APIs shall be called.
    07: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Crypto.KeyGen_Ick_Stop</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1243</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2018</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01124_KekGen_Stop_Sync256</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>3780</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that if Mka_Crypto_Stop is called during Kek generate process, the process shall stop.
Test Object: Mka_Crypto_KekGenerateAsync() in Synchronous mode.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
  
Test Execution: 
    01: Call Mka crypto unit API Mka_Crypto_IckGenerateAsync to start Ick Generate procedure.
    02: Sanity check - Sanity check that ICK is generated.
    03: Set Csm_MacGenerate stub to return E_OK, but also call Mka_Crypto_Stop().
    04: Call Mka crypto unit API Mka_Crypto_KekGenerateAsync to start Kek Generate procedure.
    05: VP(Mka.Crypto.KeyGen_Kek_Stop,1) Verify that Crypto unit stopped generating Kek because Mka_Crypto_Stop(1) has been called in the meantime.
    06: Call Mka crypto unit main function Mka_Crypto_MainFunction() to run the Crypto thread.
    07: VP(Mka.Crypto.KeyGen_Kek_Stop,1) Verify that generation process has been stopped. No other Csm APIs shall be called.
    08: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Crypto.KeyGen_Kek_Stop</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1245</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2019</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01125_KekGen_Stop_Async</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>3805</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that if Mka_Crypto_Stop is called during Kek Async generate process, the process shall be stopped.
Test Object: Mka_Crypto_KekGenerateAsync() in Asynchronous mode.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
  
Test Execution: 
    01: Call Mka crypto unit API Mka_Crypto_IckGenerateAsync to start Ick Generate procedure.
    02: Sanity check - Sanity check that ICK is generated.
    03: Asynchronous callback from Csm to Crypto unit Mka_CsmKeyGenerateCallback() and call Mka_Crypto_MainFunction to process request for generation and start generating the key.
    04: Sanity check - Sanity check that ICK is generated.
    05: Set Csm_MacGenerate stub to return E_OK, but also call Mka_Crypto_Stop().
    06: Call Mka crypto unit API Mka_Crypto_KekGenerateAsync to start Kek Generate procedure.
    07: Sanity check - Check that Crypto unit stopped generating Kek because Mka_Crypto_Stop(0) has been called in the meantime.
    08: Call Mka_Crypto_Stop to stop Kek generate process.
    09: VP(Mka.Crypto.KeyGen_Async_Kek_Stop,1) Verify that generation process has been stopped, Csm_CancelJob shall be called and Mka_Logon_IckGenerateFinished shall not be called.
    10: Csm_CancelJob shall call the callback functions with result set to CRYPTO_E_JOB_CANCELED.
    11: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Crypto.KeyGen_Async_Kek_Stop</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1246</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2020</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01126_IckGen_Retry</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>3833</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that, during Ick Generate process, when Csm returns BUSY, that call will be retried.
Test Object: Mka_Crypto_IckGenerateAsync() retry
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
  
Test Execution: 
    01: Set Csm stub to return BUSY on second call, but return E_OK on third call.
    02: Call Mka crypto unit API Mka_Crypto_IckGenerateAsync to start Ick Generate procedure.
    03: Sanity check - Sanity check.
    04: Asynchronous callback from Csm to Crypto unit Mka_CsmKeyGenerateCallback() and call Mka_Crypto_MainFunction to process request for generation and start generating the key.
    05: Sanity check - Sanity check.
    06: Call Main function. Crypto unit shall retry a call to Csm.
    07: Sanity check - Checkthat Crypto unit retried calling Csm API.
    08: Asynchronous callback from Csm to Crypto unit Mka_CsmKeyGenerateCallback() and call Mka_Crypto_MainFunction to process request for generation and start generating the key.
    09: VP(Mka.dsn.Crypto.Api.IckGenerate.Retry,1) Verify that Crypto unit , after getting E_OK from CSM, finished the ICK generating procedure and reported back to caller with E_OK.
    10: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.IckGenerate.Retry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1509</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2021</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01127_IckGen_Retry_Fail</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>3860</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that, during Ick Generate process, if Csm returns BUSY until configured number if MkaCryptoRetryAttempts gets exhausted, the Ick Gen procedure will fail and Crypto unit will call Mka_Logon_IckGenerateFinished with E_NOT_OK.
Test Object: Mka_Crypto_IckGenerateAsync() retry
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
  
Test Execution: 
    01: Set Csm stub to return BUSY.
    02: Call Mka crypto unit API Mka_Crypto_IckGenerateAsync to start Ick Generate procedure.
    03: Sanity check - Sanity check.
    04: Start the main Crypto thread which shall retry ICV generate.
    05: Sanity check - Check that Csm_MacGenerate was called again after getting back BUSY from Csm.
    06: VP(Mka.dsn.Crypto.Api.IckGenerate.RetryAttempts,1) Verify that Crypto unit, after getting CRYPTO_E_BUSY from CSM and exhausting the MkaCryptoRetryAttempts, finished the ICK generating procedure with E_NOT_OK.
    07: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.IckGenerate.RetryAttempts</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1511</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2022</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01128_IckGen_Retry_Disabled</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>3884</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that, during Ick Generate process, if Csm returns BUSY when configured value MkaCryptoRetryAttempts is Zero, the Ick Gen procedure will fail.
Test Object: Mka_Crypto_IckGenerateAsync() retry
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
  
Test Execution: 
    01: Set Csm stub to return BUSY.
    02: Call Mka crypto unit API Mka_Crypto_IckGenerateAsync to start Ick Generate procedure.
    03: VP(Mka.dsn.Crypto.Api.IckGenerate.RetryDisabled,1) Verify that Crypto unit called Mka_Logon_IckGenerateFinished with E_NOT_OK, indicating that IckGen failed and has been stopped.
    04: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.IckGenerate.RetryDisabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1510</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2023</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01129_KekGen_Retry</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>3905</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that, during Kek Generate process, when Csm returns BUSY, that call will be retried.
Test Object: Mka_Crypto_KekGenerateAsync() retry
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
  
Test Execution: 
    01: Reset Csm stub.
    02: Call Mka crypto unit API Mka_Crypto_IckGenerateAsync to start Ick Generate procedure.
    03: Sanity check - Sanity check that ICK is generated.
    04: Asynchronous callback from Csm to Crypto unit Mka_CsmKeyGenerateCallback() and call Mka_Crypto_MainFunction to process request for generation.
    05: Sanity check - Sanity check that ICK is generated.
    06: Asynchronous callback from Csm to Crypto unit Mka_CsmKeyGenerateCallback() and call Mka_Crypto_MainFunction to process request for generation.
    07: Sanity check - Sanity check that ICK is generated.
    08: Set Csm stub to return BUSY on second call, but return E_OK on third call.
    09: Call Mka crypto unit API Mka_Crypto_KekGenerateAsync to start Ick Generate procedure.
    10: Sanity check - Sanity check.
    11: Asynchronous callback from Csm to Crypto unit Mka_CsmKeyGenerateCallback() and call Mka_Crypto_MainFunction to process request for generation and start generating the key.
    12: Sanity check - Sanity check.
    13: Call Main function. Crypto unit shall retry a call to Csm.
    14: Sanity check - Check that Crypto unit retried calling Csm API.
    15: Asynchronous callback from Csm to Crypto unit Mka_CsmKeyGenerateCallback() and call Mka_Crypto_MainFunction to process request for generation and start generating the key.
    16: VP(Mka.dsn.Crypto.Api.KekGenerate.Retry,1) Verify that Crypto unit, after getting callback from CSM, finished the KEK generating procedure and reported back to the caller with E_OK.
    17: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.KekGenerate.Retry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1515</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2024</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01130_KekGen_Retry_Fail</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>3939</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that, during Kek Generate process, if Csm returns BUSY until configured number if MkaCryptoRetryAttempts gets exhausted, the Kek Gen procedure will fail and Crypto unit will call Mka_Logon_KekGenerateFinished with E_NOT_OK.
Test Object: Mka_Crypto_KekGenerateAsync() retry
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
  
Test Execution: 
    01: Reset Csm stub.
    02: Call Mka crypto unit API Mka_Crypto_IckGenerateAsync to start Ick Generate procedure.
    03: Sanity check - Sanity check that ICK is generated.
    04: Asynchronous callback from Csm to Crypto unit Mka_CsmKeyGenerateCallback() and call Mka_Crypto_MainFunction to process request for generation and start generating the key.
    05: Sanity check - Sanity check that ICK is generated.
    06: Asynchronous callback from Csm to Crypto unit Mka_CsmKeyGenerateCallback() and call Mka_Crypto_MainFunction to process request for generation and start generating the key.
    07: Sanity check - Sanity check that ICK is generated.
    08: Set Csm stub to return BUSY.
    09: Call Mka crypto unit API Mka_Crypto_KekGenerateAsync to start Ick Generate procedure.
    10: Sanity check - Sanity check.
    11: Start the main Crypto thread which shall retry KEK generate.
    12: Sanity check - Check that Csm_MacGenerate was called again after getting back BUSY from Csm.
    13: VP(Mka.dsn.Crypto.Api.KekGenerate.RetryAttempts,1) Verify that Crypto unit, after getting BUSY from CSM and exhausting MkaCryptoRetryAttempts, finished the KEK generating procedure with E_NOT_OK.
    14: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.KekGenerate.RetryAttempts</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1517</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2025</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01131_KekGen_Retry_Disabled</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>3970</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that, during Kek Generate process, if Csm returns BUSY when configured value MkaCryptoRetryAttempts is Zero, the Kek Gen procedure will fail.
Test Object: Mka_Crypto_KekGenerateAsync() retry
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
  
Test Execution: 
    01: Set Csm stub to return BUSY on second call, but return E_OK on third call.
    02: Call Mka crypto unit API Mka_Crypto_IckGenerateAsync to start Ick Generate procedure.
    03: Sanity check - Sanity check that ICK is generated.
    04: Asynchronous callback from Csm to Crypto unit Mka_CsmKeyGenerateCallback() and call Mka_Crypto_MainFunction to process request for generation and start generating the key.
    05: Sanity check - Sanity check that ICK is generated.
    06: Asynchronous callback from Csm to Crypto unit Mka_CsmKeyGenerateCallback() and call Mka_Crypto_MainFunction to process request for generation and start generating the key.
    07: Sanity check - Sanity check that ICK is generated.
    08: Set Csm stub to return BUSY.
    09: Call Mka crypto unit API Mka_Crypto_KekGenerateAsync to start Kek Generate procedure.
    10: VP(Mka.dsn.Crypto.Api.KekGenerate.RetryDisabled,1) Verify that Crypto unit called Mka_KaY_KekGenerateFinished with E_NOT_OK, indicating that KekGen failed and has been stopped.
    11: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.KekGenerate.RetryDisabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1516</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2026</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01132_SakGenWrap_Retry</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>3998</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when MkaCryptoRetryAttempts is configured to some value bigger than zero and, after the Mka_Crypto_SakGenWrapAsync is called, if Csm_RandomGenerate returns BUSY, the call from Crypto to Csm will be retried.
Test Object: Mka_Crypto_SakGenWrapAsync() retry.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Do the asynchronous KekIckGenerate procedure to set the correct crypto state.
  
Test Execution: 
    01: Set Csm stub to return BUSY.
    02: Call Mka_Crypto_SakGenWrapAsync to start SAK gen and wrap preparation process.
    03: VP(Mka.dsn.Crypto.Api.SakGenWrap.SakGenRetry,1) Verify that Crypto unit has prepared SAK gen and wrap process and has returned E_OK, even when Csm returned BUSY.
    04: Start the main Crypto thread which shall start SAK gen and wrap process.
    05: VP(Mka.dsn.Crypto.Api.SakGenWrap.SakGenRetry,1) Verify that Csm unit returned BUSY.
    06: Set Csm stubs.
    07: Start the main Crypto thread which shall retry SAK gen and wrap process.
    08: VP(Mka.dsn.Crypto.Api.SakGenWrap.SakGenRetry,1) Verify that Crypto unit called Csm again.
    09: Set Csm stub to return BUSY.
    10: Simulate the asynchronous callout to continue the procedure.
    11: VP(Mka.dsn.Crypto.Api.SakGenWrap.SakWrapRetry,1) Verify that Crypto unit has successfully finished the requested process and started wrapping the key, but Csm returned BUSY.
    12: Start the main Crypto thread which shall retry SAK wrap process.
    13: VP(Mka.dsn.Crypto.Api.SakGenWrap.SakWrapRetry,1) Verify that Crypto unit called Csm_Encrypt after getting BUSY from the first try.
    14: Simulate the asynchronous callout to continue the procedure.
    15: Sanity check - Check that Crypto unit called Csm_Encrypt which returned E_OK.
    16: Simulate the asynchronous callout to try to finish the procedure.
    17: VP(Mka.dsn.Crypto.Api.SakGenWrap.HashRetry,1) Verify that Hash key was generated after successful SAK gen.
    18: Simulate the asynchronous callout to finish the procedure.
    19: VP(Mka.dsn.Crypto.Api.SakGenWrap.HashRetry,1) Verify that Hash key was generated after successful SAK gen.
    20: Call Mka_CsmHashGenerateCallback to confirm that hash has been generated (async mode).
    21: VP(Mka.dsn.Crypto.Api.SakGenWrap.SakGenRetry,1)
        VP(Mka.dsn.Crypto.Api.SakGenWrap.SakWrapRetry,1)
        VP(Mka.dsn.Crypto.Api.SakGenWrap.HashRetry,1) Verify that Crypto unit has finished the requested process and reported back to the caller.
    22: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.SakGenWrap.SakGenRetry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1541</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.SakGenWrap.SakWrapRetry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1542</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.SakGenWrap.HashRetry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1543</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2027</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01133_SakGen_Retry_Fail</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>4048</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when MkaCryptoRetryAttempts is configured to some value bigger than zero and, after the Mka_Crypto_SakGenWrapAsync is called, if Csm_RandomGenerate returns BUSY, the call from Crypto to Csm will be retried. If the number of retries during the SakGen exhausts the MkaCryptoRetryAttempts, Crypto unit will stop and report E_NOT_OK to the caller.
Test Object: Mka_Crypto_SakGenWrapAsync() retry.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Do the asynchronous KekIckGenerate procedure to set the correct crypto state.
  
Test Execution: 
    01: Set Csm stub to return BUSY.
    02: Call Mka_Crypto_SakGenWrapAsync to start SAK gen and wrap preparation process.
    03: Sanity check - Check that Crypto unit has prepared SAK gen and wrap process and has returned E_OK, even when Csm returned BUSY.
    04: Start the main Crypto thread which shall start SAK gen and wrap process.
    05: Sanity check - Check that Csm unit returned BUSY.
    06: Start the main Crypto thread which shall retry SAK gen and wrap process.
    07: VP(Mka.dsn.Crypto.Api.SakGenWrap.SakGenRetryAttempts,1) Verify that Crypto unit called Csm again which returned BUSY.
    08: VP(Mka.dsn.Crypto.Api.SakGenWrap.SakGenRetryAttempts,1) Verify that Crypto unit has unsuccessfully finished the SakGen process and reported back to the caller with E_NOT_OK.
    09: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.SakGenWrap.SakGenRetryAttempts</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1547</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2028</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01134_SakWrap_Retry_Fail</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>4075</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when MkaCryptoRetryAttempts is configured to some value bigger than zero and, after the Mka_Crypto_SakGenWrapAsync is called, if Csm_RandomGenerate returns BUSY, the call from Crypto to Csm will be retried. If the number of retries during the Sak Wrap exhausts the MkaCryptoRetryAttempts, Crypto unit will stop and report E_NOT_OK to the caller.
Test Object: Mka_Crypto_SakGenWrapAsync() retry.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Do the asynchronous KekIckGenerate procedure to set the correct crypto state.
  
Test Execution: 
    01: Set Csm stub to return BUSY.
    02: Call Mka_Crypto_SakGenWrapAsync to start SAK gen and wrap preparation process.
    03: Sanity check - Check that Crypto unit has prepared SAK gen and wrap process and has returned E_OK, even when Csm returned BUSY.
    04: Start the main Crypto thread which shall start SAK gen and wrap process.
    05: Sanity check - Check that Crypto unit called Csm and that Csm returned E_OK.
    06: Simulate the asynchronous callout to continue the procedure.
    07: Sanity check - Check that Crypto unit has successfully finished the requested process and started wrapping the key, but Csm returned BUSY.
    08: Start the main Crypto thread which shall retry SAK wrap process.
    09: VP(Mka.dsn.Crypto.Api.SakGenWrap.SakWrapRetryAttempts,1) Verify that Crypto unit called Csm_Encrypt after getting BUSY from the first try.
    10: VP(Mka.dsn.Crypto.Api.SakGenWrap.SakWrapRetryAttempts,1) Verify that Crypto unit has finished the requested process and reported back to the caller.
    11: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.SakGenWrap.SakWrapRetryAttempts</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1548</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2029</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01135_HashGen_Retry_Fail</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>4104</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when MkaCryptoRetryAttempts is configured to some value bigger than zero and, after the Mka_Crypto_SakGenWrapAsync is called, if Csm_RandomGenerate returns BUSY, the call from Crypto to Csm will be retried. If the number of retries during the HashGen exhausts the MkaCryptoRetryAttempts, Crypto unit will stop and report E_NOT_OK to the caller.
Test Object: Mka_Crypto_SakGenWrapAsync() retry.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Do the asynchronous KekIckGenerate procedure to set the correct crypto state.
  
Test Execution: 
    01: Prepare stubs.
    02: Call Mka_Crypto_SakGenWrapAsync to start SAK gen and wrap preparation process.
    03: VP(Mka.dsn.Crypto.Api.SakGenWrap.SakGenRetry,1) Verify that Crypto unit has prepared SAK gen and wrap process and has returned E_OK, even when Csm returned BUSY.
    04: Start the main Crypto thread which shall start SAK gen and wrap process.
    05: Sanity check - Check that Crypto unit called Csm.
    06: Simulate the asynchronous callout to continue the procedure.
    07: VP(Mka.dsn.Crypto.Api.SakGenWrap.SakWrapRetry,1) Verify that Crypto unit has successfully finished the requested process and started wrapping the key.
    08: Simulate the asynchronous callout to continue the wrapping procedure.
    09: Sanity check - Check that Crypto unit called Csm_Encrypt which returned E_OK.
    10: Simulate the asynchronous callout to try to finish the procedure.
    11: Sanity check - Check that Csm returned BUSY for Hash Gen.
    12: Start the main Crypto thread which shall retry SAK wrap process.
    13: VP(Mka.dsn.Crypto.Api.SakGenWrap.HashRetryAttempts,1) Verify that Crypto unit retries calls to Csm for HashGen.
    14: VP(Mka.dsn.Crypto.Api.SakGenWrap.HashRetryAttempts,1) Verify that Crypto unit reported E_NOT_OK to the caller after exhausting MkaCryptoRetryAttempts during HashGen process.
    15: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.SakGenWrap.SakGenRetry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1541</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.SakGenWrap.SakWrapRetry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1542</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.SakGenWrap.HashRetryAttempts</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1549</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2030</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01136_SakGen_Retry_Disabled</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>4145</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when MkaCryptoRetryAttempts is configured to zero and, after the Mka_Crypto_SakGenWrapAsync is called, if Csm_RandomGenerate returns BUSY during SakGen, Crypto unit will stop and report E_NOT_OK to the caller.
Test Object: Mka_Crypto_SakGenWrapAsync() retry.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Do the asynchronous KekIckGenerate procedure to set the correct crypto state.
  
Test Execution: 
    01: Set Csm stub to return BUSY.
    02: Call Mka_Crypto_SakGenWrapAsync to start SAK gen and wrap preparation process.
    03: VP(Mka.dsn.Crypto.Api.SakGenWrap.SakGenRetryDisabled,1) Verify that Crypto unit has prepared SAK gen and wrap process and has returned E_NOT_OK.
    04: Sanity check - Check that Csm unit returned BUSY.
    05: VP(Mka.dsn.Crypto.Api.SakGenWrap.SakGenRetryDisabled,1) Verify that Crypto unit has unsuccessfully finished the SakGen process and reported back to the caller with E_NOT_OK.
    06: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.SakGenWrap.SakGenRetryDisabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1544</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2031</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01137_SakWrap_Retry_Disabled</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>4169</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when MkaCryptoRetryAttempts is configured to zero and, after the Mka_Crypto_SakGenWrapAsync is called, if Csm_RandomGenerate returns BUSY during SakWrap, Crypto unit will stop and report E_NOT_OK to the caller.
Test Object: Mka_Crypto_SakGenWrapAsync() retry.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Do the asynchronous KekIckGenerate procedure to set the correct crypto state.
  
Test Execution: 
    01: Prepare stubs.
    02: Call Mka_Crypto_SakGenWrapAsync to start SAK gen and wrap preparation process.
    03: VP(Mka.dsn.Crypto.Api.SakGenWrap.SakWrapRetryDisabled,1) Verify that Crypto unit has prepared SAK gen and wrap process and has returned E_OK.
    04: Start the main Crypto thread which shall start SAK gen and wrap process.
    05: Sanity check - Check that Crypto unit called Csm and that Csm returned E_OK.
    06: Simulate the asynchronous callout to continue the procedure.
    07: Sanity check - Check that Crypto unit has successfully finished the requested process and started wrapping the key, but Csm returned BUSY.
    08: VP(Mka.dsn.Crypto.Api.SakGenWrap.SakWrapRetryDisabled,1) Verify that Crypto unit has finished the requested process and reported back to the caller.
    09: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.SakGenWrap.SakWrapRetryDisabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1545</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2032</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01138_HashGen_Retry_Disabled</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>4196</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when MkaCryptoRetryAttempts is configured to zero and, after the Mka_Crypto_SakGenWrapAsync is called, if Csm_RandomGenerate returns BUSY during HashGen, Crypto unit will stop and report E_NOT_OK to the caller.
Test Object: Mka_Crypto_SakGenWrapAsync() retry.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Do the asynchronous KekIckGenerate procedure to set the correct crypto state.
  
Test Execution: 
    01: Prepare stubs.
    02: Call Mka_Crypto_SakGenWrapAsync to start SAK gen and wrap preparation process.
    03: VP(Mka.dsn.Crypto.Api.SakGenWrap.HashRetryDisabled,1) Verify that Crypto unit has prepared SAK gen and wrap process and has returned E_OK in async mode.
    04: Start the main Crypto thread which shall start SAK gen and wrap process.
    05: Sanity check - Check that Crypto unit called Csm.
    06: Simulate the asynchronous callout to continue the procedure.
    07: Sanity check - Check that Crypto unit has successfully finished the requested process and started wrapping the key.
    08: Simulate the asynchronous callout to continue the wrapping procedure.
    09: Sanity check - Check that Crypto unit called Csm_Encrypt which returned E_OK.
    10: Simulate the asynchronous callout to try to finish the procedure.
    11: Sanity check - Check that Csm returned BUSY for Hash Gen.
    12: VP(Mka.dsn.Crypto.Api.SakGenWrap.HashRetryDisabled,1) Verify that Crypto unit reported E_NOT_OK to the caller after exhausting MkaCryptoRetryAttempts during HashGen process.
    13: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.SakGenWrap.HashRetryDisabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1546</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2033</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01139_SakUnwrapHash_Retry</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>4227</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when Mka_Crypto_SakUnwrapAsync is called while MkaCryptoRetryAttempts is configured to value bigger than Zero, when Csm returns BUSY, Crypto unit should retry that call to Csm.
Test Object: Mka_Crypto_SakUnwrapAsync() retry.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Do the asynchronous KekIckGenerate procedure to set the correct crypto state.
  
Test Execution: 
    01: Prepare stubs.
    02: Call Mka_Crypto_SakUnwrapAsync to start SAK unwrap preparation process.
    03: VP(Mka.dsn.Crypto.Api.SakUnwrap.SakUnwrapRetry,1) Verify that Crypto unit has prepared SAK gen and wrap process and has returned E_OK and that Csm returned BUSY. Crypto unit shall retry the call to Csm.
    04: Start the main Crypto thread which shall retry SAK gen and wrap process.
    05: VP(Mka.dsn.Crypto.Api.SakUnwrap.SakUnwrapRetry,1) Verify that Crypto unit retried the call to Csm and the Csm returned E_OK.
    06: Simulate the asynchronous callback to continue the procedure.
    07: Sanity check - Check that Crypto unit is unwrapping the Sak.
    08: Simulate the asynchronous callout to continue the procedure.
    09: Sanity check - Check that Crypto unit successfully finished the unwrapping process.
    10: VP(Mka.dsn.Crypto.Api.SakUnwrap.HashRetry,1) Verify that Csm returned BUSY. Crypto unit should retry operation in next MainFunction tick.
    11: Start the main Crypto thread which shall retry Hash gen.
    12: VP(Mka.dsn.Crypto.Api.SakUnwrap.HashRetry,1) Verify that Crypto unit retried call to Csm for Hash gen.
    13: Call Mka_CsmHashGenerateCallback to confirm that hash has been generated (async mode).
    14: VP(Mka.dsn.Crypto.Api.SakUnwrap.SakUnwrapRetry,1)
        VP(Mka.dsn.Crypto.Api.SakUnwrap.HashRetry,1) Verify that Crypto unit finished the SAK unwrap and Hash gen, even after Csm returned BUSY several times during the process.
    15: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.SakUnwrap.SakUnwrapRetry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1550</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.SakUnwrap.HashRetry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1551</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2034</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01140_SakUnwrap_Retry_Fail</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>4265</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when Mka_Crypto_SakUnwrapAsync is called while MkaCryptoRetryAttempts is configured to value bigger than Zero, if Csm keeps returning BUSY till MkaCryptoRetryAttempts is exhausted, Crypto unit should fail and return E_NOT_OK to the caller.
Test Object: Mka_Crypto_SakUnwrapAsync() retry fail.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Do the asynchronous KekIckGenerate procedure to set the correct crypto state.
  
Test Execution: 
    01: Prepare stubs.
    02: Call Mka_Crypto_SakUnwrapAsync to start SAK unwrap preparation process.
    03: VP(Mka.dsn.Crypto.Api.SakUnwrap.SakUnwrapRetryAttempts,1) Verify that Crypto unit has prepared SAK gen and wrap process and has returned E_OK.
    04: Start the main Crypto thread which shall start SAK gen and wrap process.
    05: VP(Mka.dsn.Crypto.Api.SakUnwrap.SakUnwrapRetryAttempts,1) Verify that Crypto unit returned Busy after first call. Crypto unit will retry this call until MkaCryptoRetryAttempts is exhausted.
    06: Start the main Crypto thread which shall retry SAK gen and wrap process.
    07: VP(Mka.dsn.Crypto.Api.SakUnwrap.SakUnwrapRetryAttempts,1) Verify that Csm returned Busy, but Crypto unit retried the call to Csm.
    08: VP(Mka.dsn.Crypto.Api.SakUnwrap.SakUnwrapRetryAttempts,1) Verify that Crypto unit stopped the Sak unwrap process since Csm returned Busy too many times during Sak unwrap process.
    09: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.SakUnwrap.SakUnwrapRetryAttempts</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1554</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2035</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01141_SakUnwrap_Hash_Retry_Fail</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>4292</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when Mka_Crypto_SakUnwrapAsync is called while MkaCryptoRetryAttempts is configured to value bigger than Zero, if Csm keeps returning BUSY for Hash gen till MkaCryptoRetryAttempts is exhausted, Crypto unit should fail and return E_NOT_OK to the caller.
Test Object: Mka_Crypto_SakUnwrapAsync() retry.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Do the asynchronous KekIckGenerate procedure to set the correct crypto state.
  
Test Execution: 
    01: Prepare stubs.
    02: Call Mka_Crypto_SakUnwrapAsync to start SAK unwrap preparation process.
    03: Sanity check - Check that Crypto unit has prepared SAK gen and wrap process and has returned E_OK.
    04: Start the main Crypto thread which shall start SAK gen and wrap process.
    05: Sanity check - Check that Crypto unit has successfully started the requested process with correct input parameters.
    06: Simulate the asynchronous callback to continue the procedure.
    07: Sanity check - Check that Crypto unit is unwrapping the Sak.
    08: Simulate the asynchronous callout to continue the procedure.
    09: Sanity check - Check that Crypto unit successfully finished the unwrapping process.
    10: VP(Mka.dsn.Crypto.Api.SakUnwrap.HashRetryAttempts,1) Verify that Csm returned BUSY. Crypto unit should retry operation in next MainFunction tick.
    11: Start the main Crypto thread which shall retry Hash gen.
    12: VP(Mka.dsn.Crypto.Api.SakUnwrap.HashRetryAttempts,1) Verify that Csm returned Busy, but Crypto unit retried the call to Csm.
    13: VP(Mka.dsn.Crypto.Api.SakUnwrap.HashRetryAttempts,1) Verify that Crypto unit stopped the Sak unwrap process since Csm returned Busy too many times during Hash gen. process.
    14: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.SakUnwrap.HashRetryAttempts</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1555</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2036</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01142_SakUnwrap_Retry_Disabled</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>4324</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when Mka_Crypto_SakUnwrapAsync is called while MkaCryptoRetryAttempts is configured to Zero, when Csm returns BUSY for Sak Unwrap, Crypto unit should fail and return E_NOT_OK to the caller.
Test Object: Mka_Crypto_SakUnwrapAsync() retry fail.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Do the asynchronous KekIckGenerate procedure to set the correct crypto state.
  
Test Execution: 
    01: Prepare stubs.
    02: Call Mka_Crypto_SakUnwrapAsync to start SAK unwrap preparation process.
    03: VP(Mka.dsn.Crypto.Api.SakUnwrap.SakUnwrapRetryDisabled,1) Verify that Crypto unit has prepared SAK gen and wrap process and has returned E_OK.
    04: Start the main Crypto thread which shall start SAK gen and wrap process.
    05: VP(Mka.dsn.Crypto.Api.SakUnwrap.SakUnwrapRetryDisabled,1) Verify that Crypto unit returned Busy after first call. Crypto unit will not retry this call.
    06: VP(Mka.dsn.Crypto.Api.SakUnwrap.SakUnwrapRetryDisabled,1) Verify that Crypto unit stopped the Sak unwrap process because Csm returned Busy during Sak unwrap process.
    07: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.SakUnwrap.SakUnwrapRetryDisabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1552</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2037</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01143_SakUnwrap_Hash_Retry_Disabled</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>4349</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when Mka_Crypto_SakUnwrapAsync is called while MkaCryptoRetryAttempts is configured to Zero, when Csm returns BUSY for Hash gen, Crypto unit should fail and return E_NOT_OK to the caller.
Test Object: Mka_Crypto_SakUnwrapAsync() retry.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Do the asynchronous KekIckGenerate procedure to set the correct crypto state.
  
Test Execution: 
    01: Prepare stubs.
    02: Call Mka_Crypto_SakUnwrapAsync to start SAK unwrap preparation process.
    03: Sanity check - Check that Crypto unit has prepared SAK gen and wrap process and has returned E_OK.
    04: Start the main Crypto thread which shall start SAK gen and wrap process.
    05: Sanity check - Check that Crypto unit has successfully started the Sak unwrap process.
    06: Simulate the asynchronous callback to continue the procedure.
    07: Sanity check - Check that Crypto unit is unwrapping the Sak.
    08: Simulate the asynchronous callout to continue the procedure.
    09: Sanity check - Check that Crypto unit successfully finished the unwrapping process.
    10: VP(Mka.dsn.Crypto.Api.SakUnwrap.HashRetryDisabled,1) Verify that Csm returned BUSY. Crypto unit should not retry operation but instead stop the process.
    11: VP(Mka.dsn.Crypto.Api.SakUnwrap.HashRetryDisabled,1) Verify that Crypto unit stopped the Hash gen process because Csm returned Busy during Hash gen. process.
    12: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.SakUnwrap.HashRetryDisabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1553</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2038</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01144_KekGen_DoubleCall_Async</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>4379</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that if Mka_Crypto_KekGenerateAsync is called during another Kek Async generate process, the request will be ignored.
Test Object: Mka_Crypto_KekGenerateAsync() in Asynchronous mode.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
  
Test Execution: 
    01: Call Mka crypto unit API Mka_Crypto_KekkGenerateAsync to try to start KekGen before ICK has been generated.
    02: VP(Mka.Crypto.KeyGen_Kek_RequestInvalidState,1) Verify that Crypto unit returned E_NOT_OK and made no further progress as it shall not generate KEK before ICK is ready.
    03: Call Mka crypto unit API Mka_Crypto_IckGenerateAsync to start Ick Generate procedure.
    04: Sanity check - Sanity check that ICK is generated.
    05: Asynchronous callback from Csm to Crypto unit Mka_CsmKeyGenerateCallback() and call Mka_Crypto_MainFunction to process request for generation and start generating the key.
    06: Sanity check - Sanity check that ICK is generated.
    07: Set Csm_MacGenerate stub to return E_OK.
    08: Call Mka crypto unit API Mka_Crypto_KekGenerateAsync to start Kek Generate procedure.
    09: Sanity check - Check that Crypto unit started generating Kek.
    10: Call Mka crypto unit API Mka_Crypto_KekGenerateAsync again to try to start Kek Generate procedure. It should fail as Kek as already being generated.
    11: VP(Mka.Crypto.KeyGen_Kek_RequestInvalidKeyGenState,1) Verify that new Kek gen request has been ignored, because Kek is already being generated..
    12: Csm_CancelJob shall call the callback functions with result set to CRYPTO_E_JOB_CANCELED.
    13: VP(Mka.Crypto.KeyGen_Kek_RequestInvalidKeyGenState,1) Verify that the first Kek gen has finished.
    14: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Crypto.KeyGen_Kek_RequestInvalidState</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1217</internalId></provcov>
        <provcov>
          <linksto>Mka.Crypto.KeyGen_Kek_RequestInvalidKeyGenState</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1218</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2039</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01145_SakRekey</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>4414</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test checks the SAK rekey functionality, using the rekey timers and function calls.
Test Object: Mka_Crypto_SakGenWrapAsync().
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Do the KekIckGenerate procedure to set the correct crypto state.
    -   Set stubs to needed values.
  
Test Execution: 
    01: Call Mka_Crypto_SakGenWrapAsync to start SAK gen and wrap preparation process.
    02: Start the main Crypto thread which shall start SAK gen and wrap process.
    03: Check that Crypto unit has successfully done the requested process by following expected routine in sync mode.
    04: Start the SakGenWrapAsync again to start Rekey process.
    05: Check that we transitioned to KEK_READY state.
    06: Start the main crypto thread which starts the SAK gen and wrap process.
    07: Check that Crypto unit has successfully done the requested process by following expected routine in sync mode.
    08: VP(Mka.dsn.Crypto.CryptoSM.Sak_Ready_2_Kek_Ready_Rekey,1) Verify that we successfully transitioned from SAK_READY to KEK_READY back to SAK_READY.
    09: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.CryptoSM.Sak_Ready_2_Kek_Ready_Rekey</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1341</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2040</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01146_SakReady_Stop</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>4442</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test check the transition from SAK_READY state to CAKCKN_READY state in CryptoSM using Mka_Crypto_Stop.
Test Object: Mka_Crypto_Stop.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Do the KekIckGenerate procedure to set the correct crypto state.
    -   Set stubs to needed values.
  
Test Execution: 
    01: Call Mka_Crypto_SakGenWrapAsync to start SAK gen and wrap preparation process.
    02: Start the main Crypto thread which shall start SAK gen and wrap process.
    03: Check that Crypto unit has successfully done the requested process by following expected routine in sync mode. Crypto State Machine is in SAK_READY state.
    04: Call Mka_Crypto_Stop to stop the processing and transition to CAKCKN_READY state.
    05: Call Mka Crypto Mainfunction to check that nothing is started.
    06: VP(Mka.dsn.Crypto.CryptoSM.Sak_Ready_2_CakCkn_Ready_Stop,1) Verify that the process stopped and no further calls make, showing transition to CAKCKN_READY state.
    07: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.CryptoSM.Sak_Ready_2_CakCkn_Ready_Stop</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1327</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2041</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01147_SakRekey_Fail</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>4468</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test check the transition from SAK_READY state to CAKCKN_READY state in CryptoSM when Sak wrap fails.
Test Object: Mka_Crypto_SakGenWrapAsync().
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Do the KekIckGenerate procedure to set the correct crypto state.
    -   Set stubs to needed values.
  
Test Execution: 
    01: Call Mka_Crypto_SakGenWrapAsync to start SAK gen and wrap preparation process.
    02: Start the main Crypto thread which shall start SAK gen and wrap process.
    03: VP(Mka.dsn.Crypto.CryptoSM.Sak_Ready_2_CakCkn_Ready,1) Verify that the Wrap process failed, and therefore have transitioned to CAKCKN_READY state.
    04: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.CryptoSM.Sak_Ready_2_CakCkn_Ready</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1328</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2042</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01148_IckReady_Stop</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>4491</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: None.
Test Object: None.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
  
Test Execution: 
    01: Call Mka crypto unit API Mka_Crypto_IckGenerateAsync to start Ick Generate procedure.
    02: Check that Csm functions are called in correct order with correct input variables.
    03: Call Mka_Crypto_Stop to transition to CakCkn_Ready and Mka_Crypto_MainFunction.
    04: VP(Mka.dsn.Crypto.CryptoSM.Ick_Ready_2_CakCkn_Ready_Stop,1) Verify that no further calls were made.
    05: Sanity check -
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.CryptoSM.Ick_Ready_2_CakCkn_Ready_Stop</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1334</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2043</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01149_KekReady_Stop</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>4513</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: None.
Test Object: None.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
  
Test Execution: 
    01: Call Mka crypto unit API Mka_Crypto_IckGenerateAsync to start Ick Generate procedure.
    02: Check that Csm functions are called in correct order with correct input variables.
    03: Call Mka crypto unit API Mka_Crypto_KekGenerateAsync to start Kek Generate procedure.
    04: Check that Csm functions are called in correct order with correct input variables.
    05: Call Mka_Crypto_Stop to transition to CakCkn_Ready state. Call Mka_Crypto_MainFunction to start Crypto thread.
    06: VP(Mka.dsn.Crypto.CryptoSM.Kek_Ready_2_CakCkn_Ready_Stop,1) Verify that no further calls occured after Mka_Crypto_Stop was called.
    07: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.CryptoSM.Kek_Ready_2_CakCkn_Ready_Stop</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1331</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2044</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01150_Kek_InvalidKeyGenState</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>4537</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test checks that while Mka_Crypto_KekGenerateAsync is ongoing, additional calls will fail.
Test Object: Mka_Crypto_KekGenerateAsync().
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
  
Test Execution: 
    01: Call Mka crypto unit API Mka_Crypto_IckGenerateAsync to start Ick Generate procedure.
    02: Sanity check - Sanity check that ICK is generated.
    03: Asynchronous callback from Csm to Crypto unit Mka_CsmKeyGenerateCallback() and call Mka_Crypto_MainFunction to process request for generation.
    04: Sanity check - Sanity check that ICK is generated.
    05: Asynchronous callback from Csm to Crypto unit Mka_CsmKeyGenerateCallback() and call Mka_Crypto_MainFunction to process request for generation.
    06: Sanity check - Sanity check that ICK is generated.
    07: Reset Csm_MacGenerate stub.
    08: Call Mka crypto unit API Mka_Crypto_KekGenerateAsync to start Ick Generate procedure.
    09: Sanity check - Sanity check.
    10: Asynchronous callback from Csm to Crypto unit Mka_CsmKeyGenerateCallback() and call Mka_Crypto_MainFunction to process request for generation and start generating the key.
    11: Sanity check - Sanity check.
    12: Calling Mka_Crypto_KekGenerateAsync() to start generation of new Kek Key.
    13: VP(Mka.Crypto.KeyGen_Kek_RequestInvalidKeyGenState,1) Verify that additional request for new Kek is failed since previous Kek generation is still in progress.
    14: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Crypto.KeyGen_Kek_RequestInvalidKeyGenState</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1218</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2045</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01151_HashGen_CallbackFail</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>4568</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that the if the hash callback reports a result different than E_OK procesing will be stopped and caller will be informed about the failure.
Test Object: Mka_CsmHashGenerateCallback().
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Do the asynchronous KekIckGenerate procedure to set the correct crypto state.
  
Test Execution: 
    01: Call Mka_Crypto_SakGenWrapAsync to start SAK gen and wrap preparation process.
    02: Start the main Crypto thread which shall start SAK gen and wrap process.
    03: Simulate the asynchronous callout to continue the procedure.
    04: Simulate the asynchronous callout to continue the procedure.
    05: Simulate the asynchronous callout to continue the procedure.
    06: Sanity check - Hash key was generated after successful SAK gen.
    07: Call Mka_CsmHashGenerateCallback with result E_NOT_OK.
    08: VP(Mka.Crypto.HashGenerate_Async_Fail,1) Verify that Mka_KaY_SakGenWrapFinished was called with E_NOT_OK.
    09: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Crypto.HashGenerate_Async_Fail</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1231</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2046</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01152_HashGen_Retry_InvalidJob</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>4595</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that the call of service Mka_CsmHashGenerateCallback will be ignore if the jobId does not match any Mka jobId.
Test Object: Mka_CsmHashGenerateCallback().
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Do the asynchronous KekIckGenerate procedure to set the correct crypto state.
  
Test Execution: 
    01: Call Mka_Crypto_SakGenWrapAsync to start SAK gen and wrap preparation process.
    02: Start the main Crypto thread which shall start SAK gen and wrap process.
    03: Simulate the asynchronous callout to continue the procedure.
    04: Simulate the asynchronous callout to continue the procedure.
    05: Simulate the asynchronous callout to continue the procedure.
    06: Sanity check - Hash key was generated after successful SAK gen.
    07: Call Mka_CsmHashGenerateCallback with invalid job.
    08: VP(Mka.Crypto.HashGenerateCallback_NoMatch,1) Verify that hash callback with invalid job is ignored.
    09: Call Mka_CsmHashGenerateCallback to confirm that hash has been generated (async mode).
    10: Sanity check - Sanity Mka_KaY_SakGenWrapFinished was called with E_OK.
    11: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Crypto.HashGenerateCallback_NoMatch</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1180</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2047</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01153_HashGen_Retry_NotOk</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>4624</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when Mka_Crypto_SakUnwrapAsync is called while MkaCryptoRetryAttempts is configured to value bigger than Zero, if Csm returns E_NOT_OK, Crypto unit should fail and return E_NOT_OK to the caller.
Test Object: Mka_Crypto_SakUnwrapAsync() retry.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Do the asynchronous KekIckGenerate procedure to set the correct crypto state.
  
Test Execution: 
    01: Prepare stubs.
    02: Call Mka_Crypto_SakGenWrapAsync to start SAK gen and wrap preparation process.
    03: Sanity check - Crypto unit has prepared SAK gen and wrap process and has returned E_OK, even when Csm returned BUSY.
    04: Sanity check - Check that Crypto unit called Csm.
    05: Sanity check - Crypto unit has successfully finished the requested process and started wrapping the key.
    06: Sanity check - Check that Crypto unit called Csm_Encrypt which returned E_OK.
    07: Sanity check - Check that Csm returned BUSY for Hash Gen.
    08: Start the main Crypto thread which shall retry SAK wrap process.
    09: VP(Mka.Crypto.HashGenerate_Sync_Fail,1) Verify that Crypto unit reported E_NOT_OK to the caller.
    10: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Crypto.HashGenerate_Sync_Fail</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1232</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2048</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01154_SakHash_Stop_Async128</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>4652</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when Mka_Crypto_SakGenWrapAsync is called and SAK generation and key wrapping procedure has been started. When Mka_Crypto_Stop is called, the process shall stop and only Csm_CancelJob is called.
Test Object: Mka_Crypto_SakGenWrapAsync() with Mka_Crypto_Stop in Asynchronous mode.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Do the asynchronous KekIckGenerate procedure to set the correct crypto state.
  
Test Execution: 
    01: Prepare stubs.
    02: Call Mka_Crypto_SakGenWrapAsync to start SAK gen and wrap preparation process.
    03: Sanity check - Crypto unit has prepared SAK gen and wrap process and has returned E_OK, even when Csm returned BUSY.
    04: Start the main Crypto thread which shall start SAK gen and wrap process.
    05: Sanity check - Check that Crypto unit called Csm.
    06: Simulate the asynchronous callout to continue the procedure.
    07: Sanity check - Crypto unit has successfully finished the requested process and started wrapping the key.
    08: Simulate the asynchronous callout to continue the wrapping procedure.
    09: Sanity check - Check that Crypto unit called Csm_Encrypt which returned E_OK.
    10: Simulate the asynchronous callout to try to finish the procedure.
    11: Sanity check - Check that Csm returned BUSY for Hash Gen.
    12: Call Mka_Crypto_Stop to stop the SAK wrapping process.
    13: VP(Mka.Crypto.KeyWrap_Async_Stop,1) Verify that the process has been stopped and only Csm_CancelJob was called.
    14: Csm_CancelJob shall call the callback function with result set to CRYPTO_E_JOB_CANCELED.
    15: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Crypto.KeyWrap_Async_Stop</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1252</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2049</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01155_KeyGenRequest_Stop_Async128</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>4685</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when Mka_Crypto_Stop is called to stop ICK generation the key generate process is stopped and Mka_Logon_IckGenerateFinished is not called.
Test Object: Mka_Crypto_Stop() in Asynchronous mode.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
  
Test Execution: 
    01: Call Mka crypto unit API Mka_Crypto_IckGenerateAsync to start Ick Generate procedure.
    02: Sanity check - Csm functions are called in correct order with correct input variables.
    03: Asynchronous callback from Csm to Crypto unit Mka_CsmKeyGenerateCallback() and call Mka_Crypto_MainFunction to process request for generation and start generating the key.
    04: Call Mka_Crypto_Stop to stop key generate process. Call main function two times
    05: VP(Mka.Crypto.KeyGen_Ick_Stop,1) Verify that the process has been stopped and Mka_Logon_IckGenerateFinished was not called.
    06: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Crypto.KeyGen_Ick_Stop</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1243</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2050</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01156_IcvGenRequest_Stop_Async128</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>4708</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when Mka_Crypto_Stop is called to stop ICV generation the generate process is stopped and Mka_RxTx_IcvGenerateFinished is not called.
Test Object: Mka_Crypto_Stop() in Asynchronous mode.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
  
Test Execution: 
    01: Call Mka_Crypto_Init().
    02: Do the asynchronous KekIckGenerate procedure to set the correct crypto state.
    03: Call Mka crypto unit API Mka_Crypto_IcvGenerateAsync to start IcvGenerate procedure.
    04: Call Mka_Crypto_Stop to stop ICV generate process. Call main function two times
    05: VP(Mka.Crypto.IcvGen_Stop,1) Verify that the process has been stopped and Mka_RxTx_IcvGenerateFinished was not called.
    06: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Crypto.IcvGen_Stop</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1247</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2051</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01157_IcvVerRequest_Stop_Async128</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>4731</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when Mka_Crypto_Stop is called to stop ICV verification the verify process is stopped and Mka_RxTx_IcvVerifyFinished is not called.
Test Object: Mka_Crypto_Stop() in Asynchronous mode.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Do the asynchronous KekIckGenerate procedure to set the correct crypto state before ICV verification.
  
Test Execution: 
    01: Call Mka_Crypto_IcvVerifyAsync to start ICV verification process.
    02: Call Mka_Crypto_Stop to stop ICV verify process. Call main function two times
    03: VP(Mka.Crypto.IcvVer_Stop,1) Verify that the process has been stopped and Mka_RxTx_IcvVerifyFinished was not called.
    04: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Crypto.IcvVer_Stop</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1249</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2052</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01158_KeyWrapRequest_Stop_Async128</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>4753</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when Mka_Crypto_Stop is called to stop key wrap the wrap process is stopped and Mka_KaY_SakGenWrapFinished is not called.
Test Object: Mka_Crypto_Stop() in Asynchronous mode.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Do the asynchronous KekIckGenerate procedure to set the correct crypto state.
  
Test Execution: 
    01: Call Mka_Crypto_SakGenWrapAsync to start SAK gen and wrap preparation process.
    02: Call Mka_Crypto_Stop to stop Key wrap process. Call main function two times
    03: VP(Mka.Crypto.KeyWrap_Stop,1) Verify that the process has been stopped and Mka_KaY_SakGenWrapFinished was not called.
    04: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Crypto.KeyWrap_Stop</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1251</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2053</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01159_SakWrapUnwrapAsync_Fail_PresharedIckKek</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>4775</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that if Csm_Encrypt/Csm_Decrypt reports a failure, key Wrap/Unwrap process stops. Test is performed in a configuration where use of pre-shared ICK and KEK is enabled.
Test Object: Csm_Encrypt / Csm_Decrypt.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Set the Csm_Encrypt_Stub and to fail when wrapping SAK.
  
Test Execution: 
    01: Call Mka_Crypto_SakGenWrapAsync to start SAK gen and wrap preparation process.
    02: VP(Mka.dsn.Crypto.Api.SakGenWrapAsync,1) Verify that Crypto unit has prepared SAK gen and wrap process and has returned E_OK.
    03: Start the main Crypto thread which shall start SAK gen and wrap process.
    04: Check that Crypto unit has successfully started the requested process.
    05: Simulate the asynchronous callout to continue the procedure.
    06: Sanity check - Check that Crypto unit has successfully finished the requested process.
    07: VP(Mka.Crypto.KeyWrap_Sak_StartWrapFail,1) Verify that Crypto unit has finished the requested process and reported back to the caller.
    08: Call Mka_Crypto_SakUnwrapAsync to start SAK unwrap preparation process.
    09: Start the main Crypto thread which shall start SAK unwrap process.
    10: VP(Mka.dsn.Crypto.CryptoSM.SelfTrans.Kek_Ready,1) Verify that Csm_Decrypt() is called, which indicates that Crypto SM has remained in KEK_READY state after unsuccessful key wrap.
    11: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.SakGenWrapAsync</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1032</internalId></provcov>
        <provcov>
          <linksto>Mka.Crypto.KeyWrap_Sak_StartWrapFail</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1226</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.CryptoSM.SelfTrans.Kek_Ready</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1339</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2054</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01160_SakGenWrap_Stop_PresharedIckKek</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>4812</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when Mka_Crypto_SakGenWrapAsync is called and SAK generation and key wrapping procedure has been started with, when Mka_Crypto_Stop is called, the process shall stop and only Csm_CancelJob is called.
Test Object: Mka_Crypto_SakGenWrapAsync() with Mka_Crypto_Stop in Asynchronous mode.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Setting up stubs.
  
Test Execution: 
    01: Call Mka_Crypto_SakGenWrapAsync to start SAK gen and wrap preparation process.
    02: VP(Mka.dsn.Crypto.Api.SakGenWrapAsync,1) Verify that Crypto unit has prepared SAK gen and wrap process and has returned E_OK.
    03: Start the main Crypto thread which shall start SAK gen and wrap process.
    04: VP(Mka.dsn.Crypto.Api.SakGenWrapAsync,1) Verify that Crypto unit has succesfully started the requested process.
    05: Simulate the asynchronous callout to continue the procedure.
    06: VP(Mka.dsn.Crypto.Api.SakGenWrapAsync,1) Verify that Crypto unit has succesfully started SAK wrapping process.
    07: Call Mka_Crypto_Stop to stop the SAK wrapping process.
    08: VP(Mka.Crypto.KeyWrap_Async_Stop,1) Verify that the process has been stopped and only Csm_CancelJob was called.
    09: Sanity check -
    10: Csm_CancelJob shall call the callback function with result set to CRYPTO_E_JOB_CANCELED.
    11: Call Mka_Crypto_MainFunction() to process received notification.
    12: Call Mka_Crypto_SakGenWrapAsync again to start SAK gen and wrap preparation process after crypto was stopped.
    13: Start the main Crypto thread which shall start SAK gen and wrap process.
    14: VP(Mka.dsn.Crypto.CryptoSM.Sak_Ready_2_Kek_Ready_Stop,1) Verify that Csm_RandomGenerate was called which indicates that Mka_Crypto_Stop() transitioned Crypto SM into KEK_READY state.
    15: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.Api.SakGenWrapAsync</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1032</internalId></provcov>
        <provcov>
          <linksto>Mka.Crypto.KeyWrap_Async_Stop</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1252</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.CryptoSM.Sak_Ready_2_Kek_Ready_Stop</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1342</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2055</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01161_SakWrapAsync_Fail_PresharedIckKek</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>4853</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when Mka_Crypto_SakGenWrapAsync() fails after being called in SAK_READY state of Crypto SM, i.e. during re-kying, Crpyto SM will transit to KEK_READY state when pre-shared use of ICK and KEK is enabled.
Test Object: Mka_Crypto_SakGenWrapAsync() during re-keying.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Set the Csm_Encrypt_Stub and to fail when wrapping SAK.
  
Test Execution: 
    01: Perform SAK generation and wrapping - this will bring Crypto SM into the state SAK_READY.
    02: Call Mka_Crypto_SakGenWrapAsync to start SAK gen and wrap preparation process (rekeying).
    03: Start the main Crypto thread which shall start SAK gen and wrap process.
    04: Check that Crypto unit has successfully started the requested process.
    05: Simulate the asynchronous callout to continue the procedure.
    06: VP(Mka.Crypto.KeyWrap_Sak_StartWrapFail,1) Verify that Crypto unit has finished the requested process and reported failure to the caller.
    07: Call Mka_Crypto_SakGenWrapAsync again to start SAK generation and wrap process (re-keying).
    08: Start the main Crypto thread which shall start SAK unwrap process.
    09: VP(Mka.dsn.Crypto.CryptoSM.Sak_Ready_2_Kek_Ready_WrapUnwrapFail,1) Verify that Csm_RandomGenerate() was called, which indicates that Crypto SM has returned to KEK_READY after failed SAK generation and wrap process.
    10: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Crypto.KeyWrap_Sak_StartWrapFail</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1226</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.CryptoSM.Sak_Ready_2_Kek_Ready_WrapUnwrapFail</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1340</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2056</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01162_SakUnwrap_Fail_PresharedIckKek</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>4885</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when Mka_Crypto_SakGenWrapAsync() fails after being called in SAK_READY state of Crypto SM, i.e. during re-kying, Crpyto SM will transit to KEK_READY when pre-shared use of ICK and KEK is enabled.
Test Object: Mka_Crypto_SakGenWrapAsync() during re-keying.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Set the Csm_Encrypt_Stub and to fail when wrapping SAK.
  
Test Execution: 
    01: Perform SAK unwrapping - this will bring Crypto SM into the state SAK_READY.
    02: Call Mka_Crypto_SakUnwrapAsync again to start SAK unwrap preparation process.
    03: Start the main Crypto thread which shall start SAK unwrapping process.
    04: VP(Mka.Crypto.KeyUnwrap_Sak_StartUnwrapFail,1) Verify that Crypto unit has finished the requested process and reported failure to the caller.
    05: Call Mka_Crypto_SakUnwrapAsync again to start SAK unwrap preparation process.
    06: Start the main Crypto thread which shall start SAK unwrapping process.
    07: VP(Mka.dsn.Crypto.CryptoSM.Sak_Ready_2_Kek_Ready_WrapUnwrapFail,1) Verify that Csm_Decrypt() was called, which indicates that Crypto SM has returned to KEK_READY from SAK_READY state after failed SAK unwrapping process.
    08: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Crypto.KeyUnwrap_Sak_StartUnwrapFail</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1227</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.CryptoSM.Sak_Ready_2_Kek_Ready_WrapUnwrapFail</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1340</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2057</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01163_ValidateIckKek_PresharedIckKek</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>4915</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when validation of ICK and KEK fails during Crypto init, it shall be reported as error event.
Test Object: ICK and KEK validation / event reporting.
Test Precondition: 
    -   Initialize Mka configuration.
  
Test Execution: 
    01: Setup Csm_KeyElementGet stub to return E_NOT_OK for the first two calls (first participant).
    02: Call Mka_Crypto_Init().
    03: VP(Mka.dsn.Crypto.ValidatePresharedIckKek,1) Verify that failed ICK validation (Csm_KeySetValid() called in case of pre-shared ICK) calls Mka_Logon_ReportEvent() to report error event.
    04: VP(Mka.dsn.Crypto.ValidatePresharedIckKek,1) Verify that failed KEK validation (Csm_KeySetValid() called in case of pre-shared KEK) calls Mka_Logon_ReportEvent() to report error event.
    05: Stub clean-up
    06: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.ValidatePresharedIckKek</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1557</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2058</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01164_RandomGen_SelfTransit</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>4938</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies self transition of state RNG_BUSY when receives new request for random generate through Mka_Crypto_RandomGenerateAsync.
Test Object: Mka_Crypto_RandomGenerateAsync() in Asynchronous mode.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Setting up stubs.
  
Test Execution: 
    01: Call Mka crypto unit API Mka_Crypto_RandomGenerateAsync to start RandomGenerate procedure.
    02: Call again Mka_Crypto_RandomGenerateAsync() to request new RandomGenerate procedure.
    03: VP(Mka.dsn.Crypto.RandomGenSM.Busy_Queue,1) Verify that Crypto unit returned E_OK and didn't call any function.
    04: Asynchronous call from Csm to Crypto unit Mka_CsmRandomCallback().
    05: VP(Mka.dsn.Crypto.RandomGenSM.Notified_2_Busy,1)
        VP(Mka.dsn.Crypto.RandomGenSM.Busy_Queue,1) Verify that Crypto unit is calling correct KaY function after received callback and started new random generation from previous request. This also confirms (successful) transition from RNG_NOTIFIED to RNG_BUSY.
    06: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.RandomGenSM.Busy_Queue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1357</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.RandomGenSM.Notified_2_Busy</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1352</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2059</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01165_RandomGenGranular_Retry</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>4967</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that Csm_RandomGenerate will be called again, if Csm_RandomGenerate in granular mode returns BUSY. After Csm_RandomGenerate returns E_OK, Crypto unit will call Mka_KaY_RandomGenerateFinished with E_OK.
Test Object: Mka_Crypto_RandomGenerateAsync() in Asynchronous mode.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Prepare stubbed value to return BUSY after first attempt, and E_OK after second.
  
Test Execution: 
    01: Call Mka crypto unit API Mka_Crypto_RandomGenerateAsync to start RandomGenerate procedure.
    02: Sanity check - Check that the returned value is E_OK and Csm_RandomGenerate has been called.
    03: Call again Mka_Crypto_RandomGenerateAsync() to request new RandomGenerate procedure.
    04: VP(Mka.dsn.Crypto.RandomGenSM.GenMoreData_Queue,1) Verify that Crypto unit returned E_OK and didn't call any function.
    05: Start the main Crypto thread.
    06: VP(Mka.dsn.Crypto.RandomGenSM.GenMoreData_Retry,1) Verify that Crypto unit retried calling Csm_RandomGenerate again.
    07: Asynchronous call from Csm to Crypto unit Mka_CsmRandomCallback().
    08: VP(Mka.dsn.Crypto.RandomGenSM.GenMoreData,1) Verify that Csm_RandomGenerate is called required number of times to get required number of random numbers. In this case it is length of Member identifier (12 bytes) / Amount of random data that Csm generates at one time (5 bytes).
    09: Call Mka_Crypto_MainFunction().
    10: VP(Mka.dsn.Crypto.RandomGenSM.GenMoreData_2_Notified,1) Verify that Crypto unit called Mka_KaY_RandomGenerateFinished() with E_OK after retrying call towards Csm_MacGenerate and getting E_OK after second attempt.
    11: VP(Mka.dsn.Crypto.RandomGenSM.Notified_2_Busy,1)
        VP(Mka.dsn.Crypto.RandomGenSM.GenMoreData_Queue,1) Verify that Crypto unit is calling correct KaY function after received callback and started new random generation from previous request. This also confirms (successful) transition from RNG_NOTIFIED to RNG_BUSY.
    12: Asynchronous call from Csm to Crypto unit Mka_CsmRandomCallback().
    13: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.RandomGenSM.GenMoreData_Queue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1347</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.RandomGenSM.GenMoreData_Retry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1349</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.RandomGenSM.GenMoreData</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1348</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.RandomGenSM.GenMoreData_2_Notified</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1346</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.RandomGenSM.Notified_2_Busy</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1352</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2060</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01166_SakGenWrap_RandomRequest</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>5015</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when Mka_Crypto_SakGenWrapAsync is called, SAK generation and key wrapping procedure are in progress and Crypto receives new request for random generate. Crypto will finish generation of SAK key and after it notifies KaY unit, it will start random generate.
Test Object: Mka_Crypto_RandomGenerateAsync() request during Mka_Crypto_SakGenWrapAsync() in Asynchronous mode.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Do the asynchronous KekIckGenerate procedure to set the correct crypto state.
  
Test Execution: 
    01: Call Mka_Crypto_SakGenWrapAsync to start SAK gen and wrap preparation process.
    02: Simulate the asynchronous callout to continue the procedure.
    03: Call again Mka_Crypto_RandomGenerateAsync() to request new RandomGenerate procedure.
    04: VP(Mka.dsn.Crypto.RandomGenSM.Notified,1) Verify that Crypto unit returned E_OK and didn't call any function.
    05: Call Mka_Crypto_MainFunction() to finish random generation of SAK.
    06: VP(Mka.dsn.Crypto.RandomGenSM.Notified_2_Busy,1) Verify that Crypto called again Csm_RandomGenerate() after it finishes last random generation.
    07: Simulate the asynchronous callout to finish the procedure of random generate.
    08: Call Mka_Crypto_MainFunction() to notify KaY unit.
    09: Simulate the asynchronous callout of wrapping the SAK key.
    10: Simulate the asynchronous callout to continue the procedure.
    11: Call Mka_CsmHashGenerateCallback to confirm that hash has been generated (async mode).
    12: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.RandomGenSM.Notified</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1351</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.RandomGenSM.Notified_2_Busy</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1352</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2061</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01167_RandomGen_SakWrapRequest</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>5049</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when Mka_Crypto_RandomGenerateAsync() is called for random generate. SAK generation and key wrapping procedure is requested. Crypto will finish random generation and after it notifies KaY unit, it will start SAK generation.
Test Object: Mka_Crypto_SakGenWrapAsync() request during Mka_Crypto_RandomGenerateAsync() in Asynchronous mode.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Do the asynchronous KekIckGenerate procedure to set the correct crypto state.
  
Test Execution: 
    01: Call Mka crypto unit API Mka_Crypto_RandomGenerateAsync to start RandomGenerate procedure.
    02: Asynchronous call from Csm to Crypto unit Mka_CsmRandomCallback().
    03: Call Mka_Crypto_SakGenWrapAsync to start SAK gen and wrap preparation process.
    04: VP(Mka.dsn.Crypto.RandomGenSM.Notified,1) Verify that Crypto unit returned E_OK and didn't call any function.
    05: Call Mka_Crypto_MainFunction() to finish random generation.
    06: VP(Mka.dsn.Crypto.RandomGenSM.Notified_2_Busy,1)
        VP(Mka.dsn.Crypto.RandomGenSM.Busy_Queue,1) Verify that Crypto unit is calling correct KaY function after received callback and started new random generation from previous request. This also confirms (successful) transition from RNG_NOTIFIED to RNG_BUSY.
    07: VP(Mka.dsn.Crypto.RandomGenSM.Notified_2_Busy,1) Verify that Crypto called again Csm_RandomGenerate() after it finishes last random generation.
    08: Simulate the asynchronous callout to continue the procedure.
    09: Simulate the asynchronous callout to finish the procedure of random generate.
    10: Simulate the asynchronous callout of wrapping the SAK key.
    11: Simulate the asynchronous callout to continue the procedure.
    12: Call Mka_CsmHashGenerateCallback to confirm that hash has been generated (async mode).
    13: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.RandomGenSM.Notified</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1351</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.RandomGenSM.Notified_2_Busy</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1352</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.RandomGenSM.Busy_Queue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1357</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2062</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01168_SakGenWrap_RandomRequestFail</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>5089</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when Mka_Crypto_SakGenWrapAsync is called, SAK generation and key wrapping procedure are in progress and Crypto receives new request for random generate. Crypto will finish generation of SAK key and after it notifies KaY unit, it will start random generate and Csm_RandomGenerate() shall return E_NOT_OK.
Test Object: Mka_Crypto_RandomGenerateAsync() fails in queued process in Asynchronous mode.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
    -   Do the asynchronous KekIckGenerate procedure to set the correct crypto state.
  
Test Execution: 
    01: Call Mka_Crypto_SakGenWrapAsync to start SAK gen and wrap preparation process.
    02: Simulate the asynchronous callout to continue the procedure.
    03: Call again Mka_Crypto_RandomGenerateAsync() to request new RandomGenerate procedure.
    04: Call Mka_Crypto_MainFunction() to finish random generation of SAK.
    05: VP(Mka.dsn.Crypto.RandomGenSM.Notified_2_Busy,1) Verify that Crypto called again Csm_RandomGenerate() after it finishes last random generation, and Csm_RandomGenerate() returned E_NOT_OK.
    06: Call Mka_Crypto_MainFunction() to notify KaY unit.
    07: VP(Mka.dsn.Crypto.RandomGenSM.Notified_2_Idle,1) Verify that Crypto unit is calling correct Mka_Kay_RandomGenerateFinished with result E_NOT_OK. This also confirms (failed) transition to RNG_IDLE
    08: Call Mka_Crypto_Stop to stop the SAK generation.
    09: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.RandomGenSM.Notified_2_Busy</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1352</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.RandomGenSM.Notified_2_Idle</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1353</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2063</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01169_InvalidCak</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>5120</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that invalid CAK is reported to Mka_Crypto_FindParticipant.
Test Object: Mka_Crypto_FindParticipant in both Sync and Asynchronous mode.
Test Precondition: 
    -   Initialize Mka configuration.
  
Test Execution: 
    01: Setup Csm_KeyElementGet stub that will for count == 0 return E_NOT_OK but valid key length, for count == 2 return valid key but length 0, for count == 4 return valid key but length 33, and for all other calls return a valid key.
    02: Call Mka_Crypto_Init().
    03: VP(Mka.dsn.Logon.BypassMacSec.NoEnabledCakCkn,1) Verify that, after function call Mka_Crypto_Init(), Crypto unit called Csm_KeyElementGet() for each participant to verify it's CAK. Since no valid CAK exists for first and third participant, Crypto shall call Mka_Logon_ReportEvent to report error event.
    04: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.BypassMacSec.NoEnabledCakCkn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1618</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2064</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01170_ValidateCakCkn_Retry</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>5141</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies retry functionality for key validation of CAK and CKN.
Test Object: Key validation retry functionality.
Test Precondition: 
    -   Initialize Mka configuration.
  
Test Execution: 
    01: Configure Csm_KeyElementGet() to return E_BUSY for CAK read for Participant_0 and CKN read for Participant_2.
    02: Call Mka_Crypto_Init().
    03: VP(Mka.dsn.Crypto.CryptoSM.Initial_ValidateKeys, 1) Verify that Csm_KeyElementGet() is called to verify the keys, which verifies transition from the Initial to VALIDATE_KEYS state.
    04: Configure Csm_KeyElementGet() to return E_OK for CAK and E_BUSY for CKN read for Participant_0 and Participant_2.
    05: Call Mka_Crypto_MainFunction().
    06: VP(Mka.dsn.Crypto.ValidateKeys.Retry, 1)
        VP(Mka.dsn.Crypto.ValidateCAK, 1)
        VP(Mka.dsn.KaY.PeerSM.SelfTrans.ValidateKeys, 1) Verify that that CAK and CKN access is repeated for Participant_0 and 2. This also verifies self-transition in VALIDATE_KEYS state.
    07: Configure Csm_KeyElementGet() to return E_OK and CKN access for Participant_0 and Participant_2.
    08: Call Mka_Crypto_MainFunction().
    09: VP(Mka.dsn.Crypto.ValidateKeys.Retry, 1) Verify that that CAK and CKN access is repeated for Participant_0 and 2.
    10: Call Mka_Crypto_MainFunction().
    11: VP(Mka.dsn.Crypto.ValidateKeys.Retry, 1) Verify that that CAK and CKN access is not repeated as all keys are validated.
    12: Call Mka_Crypto_IckGenerateAsync() to initiate
    13: VP(Mka.dsn.Crypto.ValidateKeys.Retry, 1) Verify that key validation of Participant_0 was successful, as ICK generation was accepted.
    14: Call Mka_Crypto_IckGenerateAsync() to initiate
    15: VP(Mka.dsn.Crypto.ValidateKeys.Retry, 1)
        VP(Mka.dsn.Crypto.CryptoSM.ValidateKeys_CakCkn_Ready, 1) Verify that key validation of Participant_2 was successful, as ICK generation was accepted. This also verifies state transition of Crypto SM from the state VALIDATE_KEYS to the state CAKCKN_READY.
    16: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.CryptoSM.Initial_ValidateKeys</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1345</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.ValidateKeys.Retry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1560</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.ValidateCAK</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1558</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.PeerSM.SelfTrans.ValidateKeys</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1344</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.CryptoSM.ValidateKeys_CakCkn_Ready</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1330</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2065</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01171_ValidateCakCkn_RetryFail</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>5193</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies retry functionality for key validation of CAK and CKN - the case where retry threshold is exceeded.
Test Object: Key validation retry functionality.
Test Precondition: 
    -   Initialize Mka configuration.
  
Test Execution: 
    01: Configure Csm_KeyElementGet() to return E_BUSY for CAK read for Participant_0 and CKN read for Participant_2.
    02: Call Mka_Crypto_Init().
    03: Configure Csm_KeyElementGet() to return E_BUSY for Participant_0 and Participant_2.
    04: Call Mka_Crypto_MainFunction().
    05: VP(Mka.dsn.Crypto.ValidateKeys.Retry, 1) Verify that that CAK and CKN read access is repeated for Participant_0 and 2.
    06: Call Mka_Crypto_MainFunction() one more time.
    07: VP(Mka.dsn.Crypto.ValidateKeys.Retry, 1) Verify that that CAK and CKN access is repeated for Participant_0 and 2.
    08: VP(Mka.dsn.Crypto.ValidateKeys.RetryDisabled, 1) Verify that KEY_NOT_PRESENT event is raised for Participant_0 as retry threshold is exceeded.
    09: VP(Mka.dsn.Crypto.ValidateKeys.RetryDisabled, 1) Verify that KEY_NOT_PRESENT event is raised for Participant_0 as retry threshold is exceeded.
    10: Call Mka_Crypto_MainFunction() one more time.
    11: VP(Mka.dsn.Crypto.ValidateKeys.RetryDisabled, 1) Verify that key validation has not been retried as retry threshold have been exceeded.
    12: Call Mka_Crypto_IckGenerateAsync() to initiate
    13: VP(Mka.dsn.Crypto.ValidateKeys.RetryDisabled, 1)
        VP(Mka.dsn.Crypto.CryptoSM.ValidateKeys_Idle, 1) Verify that key validation of Participant_0 was successful, as retry is disabled and ICK generation was not accepted. This also implicitly verifies transition from the state VALIDATE_KEYS to the state IDLE
    14: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.ValidateKeys.Retry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1560</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.ValidateKeys.RetryDisabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1561</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.CryptoSM.ValidateKeys_Idle</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1336</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2066</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01172_ValidateIckKek_Retry</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>5233</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies retry functionality for key validation of ICK and KEK.
Test Object: Key validation.
Test Precondition: 
    -   Initialize Mka configuration.
  
Test Execution: 
    01: Configure Csm_KeyElementGet() to return E_BUSY for ICK validation for Participant_0 and KEK validation for Participant_2.
    02: Call Mka_Crypto_Init().
    03: Configure Csm_KeySetValid() to return E_OK for ICK and E_BUSY for KEK validation for Participant_0 and Participant_2.
    04: Call Mka_Crypto_MainFunction().
    05: VP(Mka.dsn.Crypto.ValidateKeys.Retry, 1)
        VP(Mka.dsn.KaY.PeerSM.SelfTrans.ValidateKeys, 1) Verify that that ICK and KEK validation is repeated for Participant_0 and 2. This also verifies self-transition in VALIDATE_KEYS state.
    06: Configure Csm_KeySetValid() to return E_OK for KEK validation for Participant_0 and Participant_2.
    07: Call Mka_Crypto_MainFunction().
    08: VP(Mka.dsn.Crypto.ValidateKeys.Retry, 1) Verify that that ICK and KEK validation is repeated for Participant_0 and 2.
    09: Call Mka_Crypto_MainFunction().
    10: VP(Mka.dsn.Crypto.ValidateKeys.Retry, 1) Verify that that ICK and KEK validation is not repeated as all keys are validated.
    11: Call Mka_Crypto_SakGenWrapAsync to start SAK gen and wrap preparation process.
    12: VP(Mka.dsn.Crypto.CryptoSM.ValidateKeys_KekReady, 1) Verify that Mka_Crypto_SakGenWrapAsync() was accepted, which indicates transition from the state VALIDATE_KEYS to KEK_READY
    13: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Crypto.ValidateKeys.Retry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1560</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.PeerSM.SelfTrans.ValidateKeys</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1344</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Crypto.CryptoSM.ValidateKeys_KekReady</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1343</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2067</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01173_DuplicatedCkn</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>5272</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that participant with duplicated CKNs on the same PAE are successfully detected and an event is raised.
Test Object: Key validation .
Test Precondition: 
    -   Initialize Mka configuration.
  
Test Execution: 
    01: Configure Csm_KeyElementGet_Stub() to return the same CKN for all participants.
    02: Call Mka_Crypto_Init().
    03: VP(Mka.CP_SWS_Mka_00005.2,1) Verify that for participants 2 and 4 duplicated CKN is detected as an event KEY_NOT_PRESENT is raised.
    04: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00005.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>302</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2068</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01174_IckKekGen_KEY_NOT_PRESENT</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>5293</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when Csm_MacGenerate() fails during ICK or KEK generation with an error code indicating that CAK is missing, Crypto shall raise KEY_NOT_PRESENT event and notify Logon that key derivation failed. Test is done in asynchronous mode.
Test Object: Mka_Crypto_IckGenerateAsync() in Asynchronous mode with Csm start job fail.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
  
Test Execution: 
    01: Set Csm_MacGenerate_Stub.RetVal to CRYPTO_E_KEY_NOT_AVAILABLE to simulate that CAK is missing.
    02: Call Mka crypto unit API Mka_Crypto_IckGenerateAsync to start Ick Generate procedure.
    03: VP(Mka.CP_SWS_Mka_00033,1) Verify that Mka_Logon_ReportEvent() is called to report KEY_NOT_PRESENT event indicating that CAK is missing.
    04: VP(Mka.Crypto.KeyGen_Ick_StartGenFail,1) Verify that Crypto unit is calling Mka_Logon_IckGenerateFinished with E_NOT_OK.
    05: Initialized Crypto unit to unlock Crypto SM for Participant_0.
    06: Set Csm_MacGenerate_Stub.RetVal to CRYPTO_E_KEY_EMPTY to simulate that CAK is missing.
    07: Call Mka crypto unit API Mka_Crypto_IckGenerateAsync to start Ick Generate procedure.
    08: VP(Mka.CP_SWS_Mka_00033,1) Verify that Mka_Logon_ReportEvent() is called to report KEY_NOT_PRESENT event indicating that CAK is missing.
    09: VP(Mka.Crypto.KeyGen_Ick_StartGenFail,1) Verify that Crypto unit is calling Mka_Logon_IckGenerateFinished with E_NOT_OK.
    10: Initialized Crypto unit to unlock Crypto SM for Participant_0.
    11: Set Csm_MacGenerate_Stub.RetVal to CRYPTO_E_KEY_NOT_AVAILABLE for the second call to indicate CAK is missing.
    12: Simulate successful ICK generation and prepare for KEK generation.
    13: Call Mka crypto unit API Mka_Crypto_KekGenerateAsync to start Kek Generate procedure.
    14: VP(Mka.CP_SWS_Mka_00033,1) Verify that Mka_Logon_ReportEvent() is called to report KEY_NOT_PRESENT event indicating that CAK is missing.
    15: VP(Mka.Crypto.KeyGen_Kek_StartGenFail,1) Verify that Crypto unit is calling only Mka_Logon_IckGenerateFinished with E_NOT_OK.
    16: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00033</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>352</internalId></provcov>
        <provcov>
          <linksto>Mka.Crypto.KeyGen_Ick_StartGenFail</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1200</internalId></provcov>
        <provcov>
          <linksto>Mka.Crypto.KeyGen_Kek_StartGenFail</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1201</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2069</internalId></specobject>
    <specobject>
      <id>Mka_Crypto_UnitTest01175_IckKekGen_KEY_NOT_PRESENT_CsmCallback</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Crypto/TestSpec_Generated.h</sourcefile>
      <sourceline>5334</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when Csm_MacGenerate() fails during ICK or KEK generation with an error code indicating that CAK is missing, and failure is reported with Mka_CsmKeyGenerateCallback(), Crypto shall raise KEY_NOT_PRESENT event and notify Logon that key derivation failed.
Test Object: Mka_Crypto_IckGenerateAsync() in Asynchronous mode with Csm start job fail.
Test Precondition: 
    -   Module configuration and Crypto unit initialized.
  
Test Execution: 
    01: Call Mka Crypto unit API Mka_Crypto_IckGenerateAsync to start ICK generate procedure.
    02: VP(Mka.CP_SWS_Mka_00033,1) Verify that Mka_Logon_ReportEvent() is called to report KEY_NOT_PRESENT event indicating that CAK is missing.
    03: VP(Mka.Crypto.KeyGen_Ick_StartGenFail,1) Verify that Crypto unit is calling Mka_Logon_IckGenerateFinished with E_NOT_OK.
    04: Initialized Crypto unit to unlock Crypto SM for Participant_0.
    05: Call Mka Crypto unit API Mka_Crypto_IckGenerateAsync to start Ick Generate procedure.
    06: VP(Mka.CP_SWS_Mka_00033,1) Verify that Mka_Logon_ReportEvent() is called to report KEY_NOT_PRESENT event indicating that CAK is missing.
    07: VP(Mka.Crypto.KeyGen_Ick_StartGenFail,1) Verify that Crypto unit is calling Mka_Logon_IckGenerateFinished with E_NOT_OK.
    08: Initialized Crypto unit to unlock Crypto SM for Participant_0.
    09: Call Mka crypto unit API Mka_Crypto_IckGenerateAsync to start Ick Generate procedure.
    10: VP(Mka.CP_SWS_Mka_00033,1) Verify that Mka_Logon_ReportEvent() is called to report KEY_NOT_PRESENT event indicating that CAK is missing.
    11: VP(Mka.Crypto.KeyGen_Ick_StartGenFail,1) Verify that Crypto unit is calling Mka_Logon_IckGenerateFinished with E_NOT_OK.
    12: Initialized Crypto unit to unlock Crypto SM for Participant_0.
    13: Call Mka crypto unit API Mka_Crypto_IckGenerateAsync to start Ick Generate procedure.
    14: Call Mka crypto unit API Mka_Crypto_KekGenerateAsync to start Kek Generate procedure.
    15: VP(Mka.CP_SWS_Mka_00033,1) Verify that Mka_Logon_ReportEvent() is called to report KEY_NOT_PRESENT event indicating that CAK is missing.
    16: VP(Mka.Crypto.KeyGen_Kek_StartGenFail,1) Verify that Crypto unit is calling only Mka_Logon_IckGenerateFinished with E_NOT_OK.
    17: Sanity check -
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00033</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>352</internalId></provcov>
        <provcov>
          <linksto>Mka.Crypto.KeyGen_Ick_StartGenFail</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1200</internalId></provcov>
        <provcov>
          <linksto>Mka.Crypto.KeyGen_Kek_StartGenFail</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1201</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2070</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>Mka_KaY_UnitTest01001_Initialization</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>9</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that EthIf_GetPhysAddr() is called for each controlled port to obtain it's MAC address, which forms the first part of SCI field.
Test Object: KaY unit initialization.
Test Precondition: 
    -   Module configuration initialized with Mka_Init().
  
Test Execution: 
    01: Call Mka_KaY_Init() to initialize KaY unit.
    02: VP(Mka.dsn.KaY.InstSM.Initial_2_Disabled,1)
        VP(Mka.dsn.KaY.Api.Init,1) Verify that KaY unit initialized successfully.
    03: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.InstSM.Initial_2_Disabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1280</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.Api.Init</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>989</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2071</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01002_CreateParticipant</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>34</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies MKA instance creation with Mka_KaY_CreateParticipant().
Test Object: MKA participant creation.
Test Precondition: 
    -   KaY unit initialized. Stubs initialized.
  
Test Execution: 
    01: Call Mka_KaY_CreateParticipant(MKA_0) to create specified Mka participant.
    02: VP(Mka.dsn.KaY.Api.CreateParticipant.E_OK,1)
        VP(Mka.dsn.KaY.Api.CreateParticipant,1) Verify that Mka_KaY_CreateParticipant() returned E_OK, since MKA_0 instance was disabled.
    03: VP(Mka.dsn.KaY.Api.CreateParticipant.E_OK,1) Verify that Mka_Crypto_RandomGenerateAsync() was called to request generation of Member identifier for MKA_0.
    04: Call Mka_KaY_CreateParticipant(MKA_0) to create MKA_0 again.
    05: VP(Mka.dsn.KaY.Api.CreateParticipant.E_NOT_OK,1) Verify that Mka_KaY_CreateParticipant() returned E_NOT_OK, since MKA_0 instance was already created.
    06: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.Api.CreateParticipant.E_OK</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1563</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.Api.CreateParticipant</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>990</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.Api.CreateParticipant.E_NOT_OK</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1562</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2072</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01003_DeleteInstance</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>66</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies MKA instance deletion with Mka_KaY_DeleteParticipant() when the PeerSM is Live.
Test Object: MKA instance deletion.
Test Precondition: 
    -   KaY unit initialized.
  
Test Execution: 
    01: Activate Participant_0.
    02: Create MKPDU from a peer Participant_3 that proves liveliness to Participant_0.
    03: Call Mka_KaY_DeleteParticipant(MKA_0) to delete specified Mka instance.
    04: VP(Mka.dsn.KaY.Api.DeleteParticipant,2) Verify that EcuC_Timers_StopTimer() is called to stop timer for deleted Mka instance, indicating successful deletion of specified instance.
    05: Call Mka_KaY_DeleteParticipant(MKA_0) to try to delete specified Mka instance again.
    06: VP(Mka.dsn.KaY.Api.DeleteParticipant,2) Verify that Mka_KaY_DeleteParticipant() did nothing since instance is already deleted.
    07: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.Api.DeleteParticipant</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>991</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2073</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01004_SetPrincipalActor</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>90</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies setting an MKA participant as principal actor - i.e. getting the ability to control SecY.
Test Object: Setting an MKA participant as principal actor.
Test Precondition: 
    -   KaY unit initialized. Stubs initialized.
  
Test Execution: 
    01: Call Mka_KaY_SetPrincipalActor(MKA_0) to set specified participant as principal actor.
    02: VP(Mka.dsn.KaY.Api.SetPrincipalActor.E_NOT_OK,1)
        VP(Mka.dsn.KaY.Api.SetPrincipalActor,1) Verify that Mka_KaY_SetPrincipalActor() returned E_NOT_OK since MKA_0 participant was not created.
    03: Notify KaY that link state is active before Mka_Crypto_RandomGenerateAsync has finished and Mka_KaY_RandomGenerateFinished notification has not yet arrived.
    04: Call Mka_KaY_SetPrincipalActor(MKA_0) again.
    05: VP(Mka.dsn.KaY.Api.SetPrincipalActor.E_NOT_OK,1) Verify that Mka_KaY_SetPrincipalActor() returned E_NOT_OK since Participant_0 has InstanceSM in Disabled state.
    06: Activate Participant_0.
    07: Create MKPDU from a peer Participant_3 that proves liveness to Participant_0.
    08: Receive created MKPDU from a peer - this will bring participant's PeerSM into LIVE state.
    09: VP(Mka.EB.RunTimeEvent.BitFieldDefinition,1)
        VP(Mka.EB.RunTimeEvent.TriggeredEventParticipant,1) Verify that, after Mka Peer became live, a bit for that event has been set for the selected Participant.
    10: Call Mka_KaY_SetPrincipalActor(MKA_0) again.
    11: VP(Mka.EB.RunTimeEvent.BitFieldDefinition,1)
        VP(Mka.EB.RunTimeEvent.TriggeredEventParticipant,1) Verify that, after Mka actor became principal, a bit for that event has been set for the selected Participant.
    12: VP(Mka.dsn.KaY.Api.SetPrincipalActor.E_OK,1)
        VP(Mka.dsn.KaY.Api.SetPrincipalActor,1) Verify that Mka_KaY_SetPrincipalActor() returned E_OK indicating successful setting of a participant as principal actor.
    13: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.Api.SetPrincipalActor.E_NOT_OK</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1565</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.Api.SetPrincipalActor</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>992</internalId></provcov>
        <provcov>
          <linksto>Mka.EB.RunTimeEvent.BitFieldDefinition</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1478</internalId></provcov>
        <provcov>
          <linksto>Mka.EB.RunTimeEvent.TriggeredEventParticipant</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1479</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.Api.SetPrincipalActor.E_OK</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1564</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2074</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01005_RandomGenerateFinished_E_OK</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>140</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies generation of Member Identifier and setting message number to 1 with Mka_KaY_RandomGenerateFinished(), when is called with Result == E_OK.
Test Object: Mka_KaY_RandomGenerateFinished() called with Result == E_OK.
Test Precondition: 
    -   KaY unit initialized. Test stubs initialized.
  
Test Execution: 
    01: Create new MKA instance.
    02: VP(Mka.dsn.KaY.InstSM.WaitFirstMemberId,1)
        VP(Mka.InterAct.KayInteractions,1) Verify that InstanceSM transitioned to KAY_INSTANCE_WAIT_FIRST_MEMBER_ID by checking that Mka_Crypto_RandomGenerateAsync was called.
    03: Notify KaY that link state is active before Mka_Crypto_RandomGenerateAsync has finished and Mka_KaY_RandomGenerateFinished notification has not yet arrived.
    04: VP(Mka.dsn.KaY.InstSM.WaitFirstMemberId,1) Verify that when Mka_KaY_LinkStateActive is called before Mka_KaY_RandomGenerateFinished InstanceSM self transitioned to KAY_INSTANCE_WAIT_FIRST_MEMBER_ID (stayed in the same state) and no call has been made, otherwise Mka_KaY_LinkStateActive would start sending MKPDUs.
    05: Call Mka_KaY_RandomGenerateFinished() with RetVal == E_OK.
    06: VP(Mka.dsn.KaY.Api.RandomGenerateFinished.Result_E_OK.MI,1)
        VP(Mka.dsn.KaY.Api.RandomGenerateFinished,1) Verify that Mka_KaY_RandomGenerateFinished() is copied number provided with RandomDataPtr as instance Member identifier.
    07: VP(Mka.dsn.KaY.Api.RandomGenerateFinished.Result_E_OK.MN,1) Verify that Mka_KaY_RandomGenerateFinished() was set message number to 1.
    08: VP(Mka.dsn.KaY.Api.RandomGenerateFinished.Result_E_OK.FirstCall,1)
        VP(Mka.InterAct.TxMkpdu,1)
        VP(Mka.InterAct.KayInteractions,1)
        VP(Mka.InterAct.MkpduQueuing,1) Verify that when was Mka_KaY_RandomGenerateFinished() called for first time after Mka_KaY_CreateParticipant, KaY will prepare and transmit the first MKPDU and start periodic timer. Also verify that queued MKPDU for transmission has been sent at the end of Mka_MainFunction loop. This is verified if Mka_Cp_FillSakUse and Mka_RxTx_TxBufferReady is called.
    09: VP(Mka.8021X.MkaParticipantTimerValues.2,1)
        VP(Mka.InterAct.KayInteractions,1) Verify that participant reinitialized timer after every transmission.
    10: Sanity check - Sanity check.
    11: Sanity check - Verify that first part of SCI contains MAC address obtained with Mka_Lib_GetSciPtr().
    12: Call Mka_KaY_RandomGenerateFinished() with RetVal == E_OK for second time after Mka_KaY_CreateParticipant().
    13: VP(Mka.dsn.KaY.Api.RandomGenerateFinished.Result_E_OK.FirstCall,1) Verify that when was Mka_KaY_RandomGenerateFinished() subsequently called, it will skip operations.
    14: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.InstSM.WaitFirstMemberId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1285</internalId></provcov>
        <provcov>
          <linksto>Mka.InterAct.KayInteractions</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1109</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.Api.RandomGenerateFinished.Result_E_OK.MI</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1566</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.Api.RandomGenerateFinished</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>996</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.Api.RandomGenerateFinished.Result_E_OK.MN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1567</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.Api.RandomGenerateFinished.Result_E_OK.FirstCall</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1568</internalId></provcov>
        <provcov>
          <linksto>Mka.InterAct.TxMkpdu</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1103</internalId></provcov>
        <provcov>
          <linksto>Mka.InterAct.MkpduQueuing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1079</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.MkaParticipantTimerValues.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>97</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2075</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01006_RandomGenerateFinished_E_NOT_OK</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>209</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that was instance disabled, stopped the timer and notified Logon unit, when was Mka_KaY_RandomGenerateFinished() called with Result == E_NOT_OK.
Test Object: Mka_KaY_RandomGenerateFinished() called with Result == E_NOT_OK.
Test Precondition: 
    -   KaY unit initialized. Stubs initialized.
  
Test Execution: 
    01: Create new MKA instance.
    02: Call Mka_KaY_RandomGenerateFinished() with RetVal == E_NOT_OK.
    03: VP(Mka.EB.RunTimeEvent.BitFieldDefinition,1)
        VP(Mka.EB.RunTimeEvent.TriggeredEventParticipant,1) Verify that, after Random generate failed, a bit for that event has been set for the selected Participant.
    04: VP(Mka.dsn.KaY.Api.RandomGenerateFinished.Result_E_NOT_OK,1) Call Mka_KaY_DeleteParticipant() and verify that it did call Mka_Crypto_Stop, which indicates that the instance was already deleted with Mka_KaY_RandomGenerateFinished().
    05: VP(Mka.dsn.KaY.Api.RandomGenerateFinished.Result_E_NOT_OK,1) Verify that when Mka_KaY_RandomGenerateFinished() was called with RetVal == E_NOT_OK, Logon unit is notified.
    06: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.RunTimeEvent.BitFieldDefinition</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1478</internalId></provcov>
        <provcov>
          <linksto>Mka.EB.RunTimeEvent.TriggeredEventParticipant</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1479</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.Api.RandomGenerateFinished.Result_E_NOT_OK</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1569</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2076</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01007_KaYTransmitMKPDU</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>241</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that KaY can create MKA instance and transmit MKPDU message with TxMkpdu timeout.
Test Object: Properly filled MKPDU.
Test Precondition: 
    -   Mka_Init() initialized. KaY unit initialized.
  
Test Execution: 
    01: start KaY State Machine.
    02: Call EbTest_KaY_TickTimer_TX_MKPDU to fill TxMkpdu
    03: VP(Mka.8021X.Eapol.7.1,1) Check if Protocol version is conforming to MKA specification.
    04: VP(Mka.8021X.Eapol.7.2,1) Check if Packet type is conforming to MKA specification.
    05: VP(Mka.8021X.Eapol.7.3,1) Check if Packet Body Length field has expected value.
    06: VP(Mka.8021X.Eapol.15,1)
        VP(Mka.8021X.Eapol.28.1,1) Check if MKA Version Identifier is as standard specifies and it is in position as specified.
    07: VP(Mka.8021X.Eapol.26,1)
        VP(Mka.8021X.Eapol.28.1,1)
        VP(Mka.8021X.KeyServerElection.4.1,1) Check if Key Server Priority field has configured value and it is in position as specified.
    08: VP(Mka.8021X.Eapol.26,1)
        VP(Mka.8021X.Eapol.28.1,1) Check if Key Server field has expected value and it is in position as specified.
    09: VP(Mka.8021X.Eapol.26,1)
        VP(Mka.8021X.Eapol.28.1,1) Check if MACsec desired field has expected value and it is in position as specified.
    10: VP(Mka.8021X.Eapol.26,1)
        VP(Mka.8021X.Eapol.28.1,1) Check if MACsec capability field has configured value and it is in position as specified.
    11: VP(Mka.8021X.Eapol.26,1)
        VP(Mka.8021X.Eapol.28.1,1) Check if Parameter set body length has the correct size and it is in position as specified.
    12: VP(Mka.8021X.Eapol.26,1)
        VP(Mka.8021X.Eapol.28.1,1)
        VP(Mka.8021X.MkaTransport.25.2,1) Check if SCI field has expected value and it is in position as specified.
    13: VP(Mka.8021X.Eapol.26,1)
        VP(Mka.8021X.Eapol.28.1,1)
        VP(Mka.8021X.MkaTransport.25.3,1) Check if Actor's Member Identifier has expected value and it is in position as specified.
    14: VP(Mka.8021X.Eapol.26,1)
        VP(Mka.8021X.Eapol.28.1,1)
        VP(Mka.8021X.MkaTransport.25.3,1) Check if Actor's Message Number has expected value for the first MKPDU transmitted and it is in position as specified.
    15: VP(Mka.8021X.Eapol.26,1)
        VP(Mka.8021X.MkaKeyHierarchy.28,1)
        VP(Mka.8021X.Eapol.28.1,1)
        VP(Mka.8021X.MkaKeyHierarchy.8,1) Check if Algorithm Agility has expected value and it is in position as specified.
    16: VP(Mka.8021X.Eapol.26,1)
        VP(Mka.8021X.Eapol.11,1)
        VP(Mka.8021X.Eapol.28.1,1)
        VP(Mka.8021X.MkaTransport.25.1,1) Check if CAK Name has expected value and it is in position as specified. This and previous verification points verify existence of Basic parameter set as the first set in Packet body.
    17: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.7.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>38</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.Eapol.7.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>39</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.Eapol.7.3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>40</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.Eapol.15</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>57</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.Eapol.28.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>78</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.Eapol.26</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>68</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.4.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>199</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.MkaTransport.25.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>183</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.MkaTransport.25.3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>184</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.MkaKeyHierarchy.28</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>149</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.MkaKeyHierarchy.8</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>122</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.Eapol.11</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>53</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.MkaTransport.25.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>182</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2077</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01009_NoBuffer</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>342</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that KaY will not transmit MKPDU message if Mka_RxTx_GetTxBuffer() can't return buffer.
Test Object: Mka_RxTx_GetTxBuffer() can't return buffer.
Test Precondition: 
    -   KaY unit initialized.
  
Test Execution: 
    01: Create new MKA instance.
    02: Call Mka_KaY_RandomGenerateFinished() to simulate random generation of Actor's member identifier.
    03: VP(Mka.dsn.KaY.TxMkpdu.GetTxBuffer.E_NOT_OK,1) Verify that when Mka_RxTx_GetTxBuffer() return E_NOT_OK, KaY will stop preparing the first MKPDU for transmit.
    04: VP(Mka.EB.RunTimeEvent.BitFieldDefinition,1)
        VP(Mka.EB.RunTimeEvent.TriggeredEventParticipant,1) Verify that, after Mka_RxTx_GetTxBuffer failed to prepare a Tx buffer, a bit for that event has been set for the selected Participant.
    05: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.TxMkpdu.GetTxBuffer.E_NOT_OK</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1570</internalId></provcov>
        <provcov>
          <linksto>Mka.EB.RunTimeEvent.BitFieldDefinition</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1478</internalId></provcov>
        <provcov>
          <linksto>Mka.EB.RunTimeEvent.TriggeredEventParticipant</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1479</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2078</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01011_BufferNotReady</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>373</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that KaY will not transmit MKPDU message if Mka_RxTx_TxBufferReady() returns E_NOT_OK which indicates that MKPDU isn't available in buffer.
Test Object: Mka_RxTx_TxBufferReady() returns E_NOT_OK.
Test Precondition: 
    -   KaY unit initialized.
  
Test Execution: 
    01: Create participant that is principal actor and switch Instance SM to KAY_INSTANCE_RUNNING.
    02: Call RandomGenerateFinished to indicate finished gen.of MI.
    03: VP(Mka.dsn.KaY.TxMkpdu.TxBufferReady.E_NOT_OK,1) Verify that when Mka_RxTx_TxBufferReady() return E_NOT_OK, KaY will not transmit MKPDU.
    04: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.TxMkpdu.TxBufferReady.E_NOT_OK</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1571</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2079</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01012_KeySM_Invalid_WrapUnwrap</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>394</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that if the APIs of KaY are called before the state machine reached the designated state, the call will be ignored.
Test Object: KaY SAK Wrap and Unwrap, invalid call.
Test Precondition: 
    -   KaY unit initialized.
  
Test Execution: 
    01: Activate Participant_0.
    02: Call Mka_KaY_SakGenWrapFinished before the KeySM reached the state KAY_KEYSM_GENERATE_NEW_SAK.
    03: VP(Mka.KaY.KeyWrap_Invalid,1) Verify that KaY unit ignored the call.
    04: Call Mka_KaY_SakUnwrapFinished before the KeySM reached the state KAY_KEYSM_WAIT_SAK_UNWRAP.
    05: VP(Mka.KaY.KeyUnwrap_Invalid,1) Verify that KaY unit ignored the call.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.KaY.KeyWrap_Invalid</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1581</internalId></provcov>
        <provcov>
          <linksto>Mka.KaY.KeyUnwrap_Invalid</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1582</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2080</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01013_NoTransmit_InstanceDisabled</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>420</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that KaY will not prepare and transmit MKPDU message if instance is disabled.
Test Object: Mka_KaY_TimerCallback_TxMkpdu() didn't enable transmit for instance.
Test Precondition: 
    -   KaY unit initialized.
  
Test Execution: 
    01: Activate Participant_0.
    02: Activate Participant_1.
    03: VP(Mka.dsn.KaY.Api.TimerCallback_TxMkpdu,1) Verify that was transmitted MKPDU for both instances.
    04: Call Mka_KaY_DeleteParticipant(EBTEST_PARTICIPANT_IDX_1) to delete specified Mka instance.
    05: Call Mka_KaY_TimerCallback_TxMkpdu() to simulate timeout for sending MKPDU.
    06: VP(Mka.dsn.KaY.Api.TimerCallback_TxMkpdu,1) Verify that was transmitted MKPDU only for first instance, but for second disabled instance was not transmitted MKPDU.
    07: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.Api.TimerCallback_TxMkpdu</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1002</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2081</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01014_InstSM_Disabled2WaitFirstMemberId</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>444</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies transitions between instances of KaY instance state machine. Tested transition is from KAY_INSTANCE_DISABLED to KAY_INSTANCE_WAIT_FIRST_MEMBER_ID.
Test Object: KaY instance state machine.
Test Precondition: 
    -   Module configuration initialized with Mka_Init().
  
Test Execution: 
    01: VP(Mka.dsn.KaY.InstSM.Initial_2_Disabled,1) Verify that we are in initial state, KAY_INSTANCE_DISABLED state. Verification is made with function call Mka_KaY_DeleteParticipant(), because when KaY unit is in KAY_INSTANCE_DISABLED state delete shall do nothing.
    02: Call Mka_KaY_CreateParticipant() to transit from KAY_INSTANCE_DISABLED to KAY_INSTANCE_WAIT_FIRST_MEMBER_ID state.
    03: VP(Mka.dsn.KaY.InstSM.Disabled_2_WaitFirstMemberId,1) Verify that we transitioned from KAY_INSTANCE_DISABLED state to KAY_INSTANCE_WAIT_FIRST_MEMBER_ID state. Verification is that Mka_KaY_CreateParticipant() returned E_OK and it is called function Mka_Crypto_RandomGenerateAsync() for generation of Member identifier.
    04: VP(Mka.dsn.KaY.InstSM.ANY_2_Disabled_DeleteParticipant,1) Verify that when we delete instance in any other state expect KAY_INSTANCE_DISABLED, Mka_KaY_DeleteParticipant() will call Mka_Crypto_Stop() and state machine is returned to KAY_INSTANCE_DISABLED state.
    05: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.InstSM.Initial_2_Disabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1280</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.InstSM.Disabled_2_WaitFirstMemberId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1277</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.InstSM.ANY_2_Disabled_DeleteParticipant</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1279</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2082</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01015_InstSM_WaitFirstMemberId2Disabled_Result_NOT_OK</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>474</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies transitions between instances of KaY instance state machine. Tested transition is from KAY_INSTANCE_WAIT_FIRST_MEMBER_ID to KAY_INSTANCE_DISABLED when Mka_KaY_RandomGenerateFinished() is called with Result = E_NOT_OK.
Test Object: KaY instance state machine.
Test Precondition: 
    -   Module configuration initialized with Mka_Init().
  
Test Execution: 
    01: Call Mka_KaY_CreateParticipant() to transit from KAY_INSTANCE_DISABLED to KAY_INSTANCE_WAIT_FIRST_MEMBER_ID state.
    02: Call Mka_KaY_RandomGenerateFinished() with Result = E_NOT_OK to transit from WAIT_FIRST_MEMBER_ID to DISABLED state.
    03: VP(Mka.dsn.KaY.InstSM.WaitFirstMemberId_2_Disabled_Result_NOT_OK,1) Verify that InstSM transitioned from KAY_INSTANCE_WAIT_FIRST_MEMBER_ID state to KAY_INSTANCE_DISABLED state. Mka_Logon_Participant_Disabled() traces verify the transition to MKA_INSTANCE_STATE_DISABLED state.
    04: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.InstSM.WaitFirstMemberId_2_Disabled_Result_NOT_OK</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1282</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2083</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01016_InstSM_WaitFirstMemberId2Disabled_RetVal_NOT_OK</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>495</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies transitions between instances of KaY instance state machine. Tested transition is from KAY_INSTANCE_WAIT_FIRST_MEMBER_ID to KAY_INSTANCE_DISABLED when Mka_Crypto_RandomGenerateAsync() returns E_NOT_OK.
Test Object: KaY instance state machine.
Test Precondition: 
    -   Mka_Init() initialized. KaY unit initialized. Stubs initialized.
  
Test Execution: 
    01: Call Mka_KaY_CreateParticipant() to transit from KAY_INSTANCE_DISABLED to KAY_INSTANCE_WAIT_FIRST_MEMBER_ID state.
    02: VP(Mka.dsn.KaY.InstSM.WaitFirstMemberId_2_Disabled_RetVal_NOT_OK,1) Verify that InstSM transitioned from KAY_INSTANCE_WAIT_FIRST_MEMBER_ID state to KAY_INSTANCE_DISABLED state. If function Mka_Crypto_RandomGenerateAsync() is called, that means InstSM is in KAY_INSTANCE_WAIT_FIRST_MEMBER_ID state, but if return value of Mka_KaY_CreateParticipant() is E_NOT_OK, that confirms we returned to KAY_INSTANCE_DISABLED state and function calls of Mka_Crypto_Stop() and Mka_Logon_Participant_Disabled.
    03: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.InstSM.WaitFirstMemberId_2_Disabled_RetVal_NOT_OK</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1278</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2084</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01017_InstSM_WaitFirstMemberId2Running</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>515</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies transitions between instances of KaY instance state machine. Tested transition is from KAY_INSTANCE_WAIT_FIRST_MEMBER_ID to KAY_INSTANCE_RUNNING when Mka_KaY_RandomGenerateFinished() is called with Result = E_OK.
Test Object: KaY instance state machine.
Test Precondition: 
    -   Mka_Init() initialized. KaY unit initialized. Stubs initialized.
  
Test Execution: 
    01: Notify KaY that link state is active before instance is created and Mka_Crypto_RandomGenerateAsync has finished and Mka_KaY_RandomGenerateFinished notification has not yet arrived.
    02: VP(Mka.dsn.KaY.Api.LinkStateActive,1) Verify that Mka_KaY_LinkStateActive did not start sending MKPDUs it just set flag that link is active.
    03: Call Mka_KaY_CreateParticipant() to transit from KAY_INSTANCE_DISABLED to KAY_INSTANCE_WAIT_FIRST_MEMBER_ID state.
    04: VP(Mka.8021X.MkaTransport.9,1) Verify that the MI was generated.
    05: Call Mka_KaY_RandomGenerateFinished() with Result = E_OK for transition from KAY_INSTANCE_WAIT_FIRST_MEMBER_ID state to KAY_INSTANCE_RUNNING state.
    06: VP(Mka.dsn.KaY.InstSM.WaitFirstMemberId_2_InstanceRunning,1) {Mka.dsn.KaY.Api.LinkStateActive,1} Verify that we transitioned from KAY_INSTANCE_WAIT_FIRST_MEMBER_ID state to KAY_INSTANCE_RUNNING state. If function Mka_KaY_RandomGenerateFinished() is called with Result = E_OK, and link state is active (Mka_KaY_LinkStateActive called and link active flag was set) KaY will transit to the KAY_INSTANCE_RUNNING state and immediately transmit first MKPDU and start periodic TX MKPDU timer.
    07: Sanity check - Sanity Check Verify that the same Member Identifier is present in both EbTest_TxBuffer and MkpduBuffer
    08: VP(Mka.dsn.KaY.InstSM.ANY_2_Disabled_DeleteParticipant,1) Verify the return to KAY_INSTANCE_DISABLED from KAY_INSTANCE_RUNNING state when was called Mka_KaY_DeleteParticipant().
    09: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.Api.LinkStateActive</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>993</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.MkaTransport.9</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>159</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.InstSM.WaitFirstMemberId_2_InstanceRunning</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1286</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.InstSM.ANY_2_Disabled_DeleteParticipant</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1279</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2085</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01018_InstSM_RunningSelfTransition</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>553</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies transitions between instances of KaY instance state machine. Tested transition is from KAY_INSTANCE_RUNNING to KAY_INSTANCE_RUNNING when new MKPDU is received and partner's Member identifier is not repeated.
Test Object: KaY instance state machine.
Test Precondition: 
    -   KaY unit initialized.
  
Test Execution: 
    01: Call Mka_KaY_CreateParticipant() to transit from KAY_INSTANCE_DISABLED to KAY_INSTANCE_WAIT_FIRST_MEMBER_ID state.
    02: Call Mka_KaY_RandomGenerateFinished() with Result = E_OK for transition from KAY_INSTANCE_WAIT_FIRST_MEMBER_ID state to KAY_INSTANCE_RUNNING state.
    03: Create RxMkpdu for test.
    04: Call Mka_KaY_RxMkpdu() with valid MKPDU, but a too small input size parameter
    05: VP(Mka.EB.RunTimeEvent.BitFieldDefinition,1)
        VP(Mka.EB.RunTimeEvent.TriggeredEventParticipant,1) Verify that, after Mkpdu parsing failed, a bit for that event has been set for the selected Participant.
    06: VP(Mka.8021X.Eapol.27.2,1) Received Mkpdu shall be discarded since the given size is too small, less than 32bytes.
    07: Call Mka_KaY_RxMkpdu() with MKPDU that contains new Member Identifier and this new Member identifier and Message number tuple should be placed in Live Peer list.
    08: Increase the message number for RxMkpdu.
    09: Verify that the state is KAY_INSTANCE_RUNNING.
    10: VP(Mka.dsn.KaY.InstSM.SelfTrans.NewMemberId,1)
        VP(Mka.dsn.KaY.Api.RxMkpdu,1) Verify that we transitioned from KAY_INSTANCE_RUNNING state to KAY_INSTANCE_RUNNING state when KaY unit send MKPDU with new Member Identifier. When KaY unit self transit in KAY_INSTANCE_RUNNING state, he starts Peer state machine. In this test we send new Potential member that was putted in Potential Peer list and accordingly is started timer.
    11: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.RunTimeEvent.BitFieldDefinition</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1478</internalId></provcov>
        <provcov>
          <linksto>Mka.EB.RunTimeEvent.TriggeredEventParticipant</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1479</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.Eapol.27.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>71</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.InstSM.SelfTrans.NewMemberId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1289</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.Api.RxMkpdu</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1000</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2086</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01019_InstSM_Running2WaitNewMemberId_SameMi</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>599</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies transitions between instances of KaY instance state machine. Tested transition is from KAY_INSTANCE_RUNNING to KAY_INSTANCE_WAIT_NEW_MEMBER_ID when new MKPDU is received and partner's Member identifier is same as our own. When transition is done, KaY unit call Mka_Crypto_RandomGenerateAsync() for generation of new Member identifier, but Mka_Crypto_RandomGenerateAsync() returns E_NOT_OK and KaY unit transit to the KAY_INSTANCE_DISABLED state.
Test Object: KaY instance state machine.
Test Precondition: 
    -   KaY unit initialized.
  
Test Execution: 
    01: Activate Participant_0
    02: Create RxMkpdu for test.
    03: Call Mka_KaY_RxMkpdu() with MKPDU that contains same Member Identifier for transitions to KAY_INSTANCE_WAIT_NEW_MEMBER_ID state.
    04: VP(Mka.dsn.KaY.InstSM.Running_2_WaitNewMemberId,1) Verify that we transitioned from KAY_INSTANCE_RUNNING state to KAY_INSTANCE_WAIT_NEW_MEMBER_ID state. When KaY unit enters in KAY_INSTANCE_WAIT_NEW_MEMBER_ID state, momentarily calls Mka_Crypto_RandomGenerateAsync() for generation of new Member identifier.
    05: VP(Mka.dsn.KaY.InstSM.WaitNewMemberId_2_Disabled_Result_NOT_OK,1) Verify that InstSM transitioned from KAY_INSTANCE_WAIT_NEW_MEMBER_ID state to KAY_INSTANCE_DISABLED state, as Crypto operations and TX_MKPDU timer are stopped and Logon notified about an error with Mka_Logon_Participant_Disabled().
    06: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.InstSM.Running_2_WaitNewMemberId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1284</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.InstSM.WaitNewMemberId_2_Disabled_Result_NOT_OK</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1281</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2087</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01020_InstSM_Running2WaitNewMemberId_MnThreshold</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>626</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies transitions between instances of KaY instance state machine. Tested transition is from KAY_INSTANCE_RUNNING to KAY_INSTANCE_WAIT_NEW_MEMBER_ID when new MKPDU is received and its own Message number has reached threshold. When transition is done, KaY unit call Mka_Crypto_RandomGenerateAsync() for generation of new Member identifier.
Test Object: KaY instance state machine.
Test Precondition: 
    -   KaY Unit Initialized.
  
Test Execution: 
    01: Activate Participant_0
    02: Create Mkpdu for testing
    03: Increate RxMkpdu's message number beyond the expected threshold.
    04: Call Mka_KaY_RxMkpdu() with MKPDU that contains Message number with larger number than it should be.
    05: VP(Mka.dsn.KaY.InstSM.Running_2_WaitNewMemberId,1) Verify that we transitioned from KAY_INSTANCE_RUNNING state to KAY_INSTANCE_WAIT_NEW_MEMBER_ID state when KaY unit send MKPDU with larger Message number than it should be. When KaY unit enters in KAY_INSTANCE_WAIT_NEW_MEMBER_ID state, momentarily calls Mka_Crypto_RandomGenerateAsync() for generation of new Member identifier.
    06: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.InstSM.Running_2_WaitNewMemberId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1284</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2088</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01021_InstSM_WaitNewMemberId2Disabled</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>649</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies transitions between instances of KaY instance state machine. Tested transition is from KAY_INSTANCE_WAIT_NEW_MEMBER_ID to KAY_INSTANCE_DISABLED when new MKPDU is received and partner's Member identifier is same as our own. When transition is done, we call Mka_KaY_RandomGenerateFinished() with E_NOT_OK which indicates that generation of new Member identifier is failed.
Test Object: KaY instance state machine.
Test Precondition: 
    -   KaY Unit Initialized.
  
Test Execution: 
    01: Activate Participant_0.
    02: Create RxMkpdu for test.
    03: Call Mka_KaY_RxMkpdu() with MKPDU that contains same Member Identifier for transitions to KAY_INSTANCE_WAIT_NEW_MEMBER_ID state.
    04: Call Mka_KaY_RandomGenerateFinished() with E_NOT_OK for transition to KAY_INSTANCE_DISABLED state.
    05: VP(Mka.dsn.KaY.InstSM.WaitNewMemberId_2_Disabled_Result_NOT_OK,1) Verify that we transitioned from KAY_INSTANCE_WAIT_NEW_MEMBER_ID state to KAY_INSTANCE_DISABLED state. KaY unit enters in KAY_INSTANCE_DISABLED state, because Mka_KaY_RandomGenerateFinished() couldn't generate new Member identifier and notify Logon unit.
    06: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.InstSM.WaitNewMemberId_2_Disabled_Result_NOT_OK</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1281</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2089</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01022_InstSM_DeleteWaitNewMemberId</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>672</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies transitions between instances of KaY instance state machine. Tested transition is from KAY_INSTANCE_WAIT_NEW_MEMBER_ID to KAY_INSTANCE_DISABLED when we call function Mka_KaY_DeleteParticipant().
Test Object: KaY instance state machine.
Test Precondition: 
    -   KaY Unit Initialized.
  
Test Execution: 
    01: Activate Participant_0.
    02: Create RxMkpdu for Test.
    03: Call Mka_KaY_RxMkpdu() with MKPDU that contains same Member Identifier for transitions to KAY_INSTANCE_WAIT_NEW_MEMBER_ID state.
    04: Call Mka_KaY_DeleteParticipant() for transition to KAY_INSTANCE_DISABLED state.
    05: VP(Mka.dsn.KaY.InstSM.ANY_2_Disabled_DeleteParticipant,1) Verify that we transitioned from KAY_INSTANCE_WAIT_NEW_MEMBER_ID state to KAY_INSTANCE_DISABLED state. KaY unit enters in KAY_INSTANCE_DISABLED state, because Mka_KaY_DeleteParticipant() deleted instance and stopped Crypto operations and the timer.
    06: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.InstSM.ANY_2_Disabled_DeleteParticipant</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1279</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2090</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01023_InstSM_WaitNewMemberId2Running</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>695</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies transitions between instances of KaY instance state machine. Tested transition is from KAY_INSTANCE_WAIT_NEW_MEMBER_ID to KAY_INSTANCE_RUNNING when we call Mka_KaY_RandomGenerateFinished() with E_OK which indicates that generation of new Member identifier is done.
Test Object: KaY instance state machine.
Test Precondition: 
    -   KaY unit initialized.
  
Test Execution: 
    01: Activate Participant_0
    02: Create RxMkpdu for test.
    03: Call Mka_KaY_RxMkpdu() with MKPDU that contains same Member Identifier for transitions to KAY_INSTANCE_WAIT_NEW_MEMBER_ID state.
    04: Call Mka_KaY_RxMkpdu() again to confirm that KaY unit is in KAY_INSTANCE_WAIT_NEW_MEMBER_ID state.
    05: VP(Mka.dsn.KaY.InstSM.Running_2_WaitNewMemberId,1) Verify that we are in KAY_INSTANCE_WAIT_NEW_MEMBER_ID state with function call of Mka_KaY_RxMkpdu() and that should do nothing.
    06: Call Mka_KaY_RandomGenerateFinished() with E_OK for transition to KAY_INSTANCE_RUNNING state.
    07: VP(Mka.dsn.KaY.InstSM.WaitNewMemberId_2_Running,1) Verify that we transitioned from KAY_INSTANCE_WAIT_NEW_MEMBER_ID state to KAY_INSTANCE_RUNNING state. Verification is performed with same function Mka_KaY_RxMkpdu() call for transition to KAY_INSTANCE_WAIT_NEW_MEMBER_ID. If KaY unit is in KAY_INSTANCE_RUNNING, it will transit to KAY_INSTANCE_WAIT_NEW_MEMBER_ID state and call Mka_Crypto_RandomGenerateAsync() for new generation of Member identifier, if isn't in KAY_INSTANCE_RUNNING state, nothing will happen.
    08: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.InstSM.Running_2_WaitNewMemberId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1284</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.InstSM.WaitNewMemberId_2_Running</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1283</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2091</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01024_PeerSM_Init2Undetected2Potent2Live</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>724</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies natural transition of Peer State Machine from Peer_Undetected state after initialization to Peer_Potential and finally to Peer_Live. After this, the state has to be cleaned-up so the transition to Peer_Undetected is made.
Test Object: Software
Test Precondition: 
    -   Mka_Init() initialized.
  
Test Execution: 
    01: Call for Mka_KaY_TimerCallback_PeerLifeTimeout() while InstanceSM is Disabled shall be ignored.
    02: Sanity check - Check that the call for Mka_KaY_TimerCallback_PeerLifeTimeout when InstanceSM was Disabled was ignored.
    03: Switch Instance SM to KAY_INSTANCE_RUNNING.
    04: Create RxMkpdu for test that has a different MI than Participant_0
    05: Call for Mka_KaY_TimerCallback_PeerLifeTimeout() while no peer is detected.
    06: VP(Mka.dsn.KaY.Api.TimerCallback_PeerLifeTimeout,1) Check that the call for Mka_KaY_TimerCallback_PeerLifeTimeout when InstanceSM is not Disabled, but no peer has been detected, was ignored.
    07: Call Mka_KaY_RxMkpdu() with MemberID in Peer list that is different than ours to change state from Peer_Undetected to Peer_Potential.
    08: VP(Mka.dsn.KaY.PeerSM.Undetected_2_Potential,1)
        VP(Mka.dsn.KaY.PeerSM.Initial_2_Undetected,1)
        VP(Mka.8021X.MkaParticipantTimerValues.3,1) Verify that Peer SM transitioned to state Peer_Potential as it shall call EcuC_Timers_StartTimerInternal. For this to happen, the Peer state should already be in Peer_Undetected to which the SM transitioned after calling Mka_KaY_Init().
    09: Call Mka_MainFunction() to process all changed and send new MKPDU.
    10: VP(Mka.dsn.KaY.ImmediatePeerResponse.PeerSM,1) Verify that when Peer SM transitioned to state Peer_Potential, it immediately sent an mkpdu because Immediate Response is enabled.
    11: Sanity check - Sanity check.
    12: Create RxMkpdu for test. Change to member identifier to known participant. Increase MN.
    13: Call Mka_KaY_RxMkpdu() again with corresponding MemberID in the Peer list to change state from Peer_Potential to Peer_Live.
    14: VP(Mka.dsn.KaY.PeerSM.SelfTrans.Potential,1) Verify that Peer SM self-transitioned to state Peer_Potential by checking that it started PEER_LIFETIME timer.
    15: Create RxMkpdu for test. Change the member identifier to known participant and put the Potential Peer list into the RxMkpdu. Increase MN.
    16: Call Mka_KaY_RxMkpdu() again with corresponding MemberID in the Peer list to change state from Peer_Potential to Peer_Live.
    17: VP(Mka.dsn.KaY.PeerSM.Potential_2_Live,1) Verify that Peer SM transitioned to state Peer_Live by checking that it restarted PEER_LIFETIME timer.
    18: Call Mka_MainFunction() to process all changed and send new MKPDU.
    19: VP(Mka.dsn.KaY.ImmediatePeerResponse.PeerSM,1) Verify that when Peer SM transitioned to state Peer_Live, it immediately sent an mkpdu because Immediate Response is enabled.
    20: Call for Mka_KaY_TimerCallback_PeerLifeTimeout() shall change PeerSM from Peer_Live to state Peer_Undetected.
    21: VP(Mka.dsn.KaY.PeerSM.Any_2_Undetected,1)
        VP(Mka.8021X.MkaParticipantTimerValues.3,1)
        VP(Mka.dsn.KaY.Api.TimerCallback_PeerLifeTimeout,1) Verify that Peer SM transitioned to state Peer_Undetected after a call indicating that PEER_LIFETIME timer expired, by checking that EthIf was requested to delete RX security channel.
    22: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.Api.TimerCallback_PeerLifeTimeout</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1003</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.PeerSM.Undetected_2_Potential</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1292</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.PeerSM.Initial_2_Undetected</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1293</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.MkaParticipantTimerValues.3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>98</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.ImmediatePeerResponse.PeerSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1578</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.PeerSM.SelfTrans.Potential</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1298</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.PeerSM.Potential_2_Live</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1296</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.PeerSM.Any_2_Undetected</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1290</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2092</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01025_PeerSM_Undetected2Potent2Undetected</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>795</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies transition of Peer State Machine from Peer_Undetected state to Peer_Potential where it stays since no expected update to the Peer List is made after calling Mka_KaY_RxMkpdu second time. Finally, the state is set back to Peer_Undetected by a simulated Peer Life Timeout call. Live peer is not achieved in this test.
Test Object: Software
Test Precondition: 
    -   KaY unit initialized.
    -   Switch Instance SM to KAY_INSTANCE_RUNNING.
    -   Create RxMkpdu and assign an unknown MI to it.
  
Test Execution: 
    01: Call Mka_KaY_RxMkpdu() to change state from Peer_Undetected to Peer_Potential.
    02: Sanity check - Check that Peer SM transitioned to state Peer_Potential as it shall call EcuC_Timers_StartTimerInternal.
    03: Call Mka_MainFunction() to process all changed and send new MKPDU.
    04: Sanity check - Check that when Peer SM transitioned to state Peer_Potential from Peer_Undetected, it immediately sent an mkpdu because Immediate Response is enabled.
    05: Create second peer, assign it the appropriate unknown member id and increment msg number
    06: Call Mka_KaY_RxMkpdu() with an MKPDU from the peer other then the registered one. The MKPDU shall be silently discarded.
    07: VP(Mka.dsn.KaY.ImmediatePeerResponse.PeerSM,1) Verify that Peer SM stayed in the same state since the conditions for transition were not met - the received MKPDU is not from the registered partner. Verify that, when Mka optimization with Mka Immediate Response is enabled, no immediate MKPDU has been sent during PeerSm_Potential self transition.
    08: Call for Mka_KaY_TimerCallback_PeerLifeTimeout() shall change PeerSM to state Peer_Undetected.
    09: Call Mka_KaY_RxMkpdu() with an MKPDU from the peer other then the previously registered one.
    10: VP(Mka.dsn.KaY.PeerSM.Any_2_Undetected,1)
        VP(Mka.8021X.MkaTransport.21,1) Verify that EcuC_Timers_StartTimerInternal was called which indicates that PeerSM has accepted new partner. This is an implicit tests that PeerSM was in Peer_Undetected state, because new registration is possible only in this state.
    11: Call Mka_MainFunction() to process all changed and send new MKPDU.
    12: Sanity check - Check that when Peer SM transitioned to state Peer_Potential from Peer_Undetected, it immediately sent an mkpdu because Immediate Response is enabled.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.ImmediatePeerResponse.PeerSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1578</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.PeerSM.Any_2_Undetected</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1290</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.MkaTransport.21</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>177</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2093</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01026_PeerSM_Undetected2Live2Undetected</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>835</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies transition of Peer State Machine from Peer_Undetected to Peer_Live, self transition in Peer_Live state and transition back from Peer_Live to Peer_Undetected due to peer lifetime timer expiry..
Test Object: Software
Test Precondition: 
    -   KaY unit initialized.
    -   Switch Instance SM to KAY_INSTANCE_RUNNING.
  
Test Execution: 
    01: Call Mka_KaY_RxMkpdu() with actors member ID in the Peer List to change state from Peer_Undetected to Peer_Live.
    02: VP(Mka.dsn.KaY.PeerSM.Undetected_2_Live,1) Verify that after Peer SM transitioned to state Peer_Live, it called EcuC_Timers_StartTimerInternal to set the peer life timeout timer.
    03: Sanity check - Sanity.
    04: clear out trace
    05: Call Mka_KaY_RxMkpdu() with same expected member id in the Peer List. Peer SM should stay in the Peer_Live state and it shall reset the Peer Life Timeout timer.
    06: VP(Mka.dsn.KaY.PeerSM.SelfTrans.Live,1) Verify that Peer SM stayed in the same state as it shall make an API call to reset the Peer Life Timeout timer.
    07: Call for Mka_KaY_TimerCallback_PeerLifeTimeout() shall change PeerSM to state Peer_Undetected.
    08: VP(Mka.dsn.KaY.PeerSM.Any_2_Undetected,1)
        VP(Mka.8021X.MkaTransport.21,1) Verify that Peer SM transitioned to state Peer_Undetected after a call indicating that PEER_LIFETIME timer expired, by checking that EthIf was requested to delete RX security channel.
    09: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.PeerSM.Undetected_2_Live</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1291</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.PeerSM.SelfTrans.Live</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1295</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.PeerSM.Any_2_Undetected</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1290</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.MkaTransport.21</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>177</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2094</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01027_Peer_LowMI</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>875</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that any MKPDU of an authenticated MI, but with same or lower MN compared with the last msg received, shall be discarded.
Test Object: Software
Test Precondition: 
    -   KaY unit initialized
    -   Switch Instance SM to KAY_INSTANCE_RUNNING and create Mkpdu for test.
  
Test Execution: 
    01: Call Mka_KaY_RxMkpdu() with actors member ID in the Peer List to change state from Peer_Undetected to Peer_Live.
    02: Call Mka_KaY_RxMkpdu() with lower MN than the last sent mkpdu. The message should be discarded.
    03: VP(Mka.8021X.MkaTransport.11,1) Verify that MKPDU was discarded, hence the timer hasn't been reset.
    04: Call Mka_KaY_RxMkpdu() with same MN like the last accepted mkpdu. The message should be discarded.
    05: VP(Mka.8021X.MkaTransport.11,1) Verify that MKPDU was discarded, hence the timer hasn't been reset.
    06: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.MkaTransport.11</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>163</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2095</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01028_Peer_RepeatedMI</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>899</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when MKPDU with same MI as the recipient is received, the new MI shall be generated and the communication will be continued.
Test Object: Software
Test Precondition: 
    -   Kay unit initialized.
    -   Switch Instance SM to KAY_INSTANCE_RUNNING an create Mkpdu.
  
Test Execution: 
    01: Call Mka_KaY_RxMkpdu() with same MI as the recipient.
    02: VP(Mka.8021X.MkaTransport.16.1,1) Verify that the new MI is being generated, Mka_Crypto_RandomGenerateAsync shall be called.
    03: Create Mkpdu with different Peer.
    04: Set Message number of live Peer.
    05: Call Mka_KaY_RandomGenerateFinished with newly generated ID .
    06: Call Mka_KaY_RxMkpdu(). The message should not be discarded now as new ID has been generated. That newly generated ID is now inside the potential peer list of the Mkpdu (TestMkpdu_2) that the actor is receiving, State should transition to Peer_Live.
    07: VP(Mka.8021X.MkaTransport.16.1,1) Verify that MKPDU was accepted and that the state transitioned to Peer_Live.
    08: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.MkaTransport.16.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>169</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2096</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01029_Peer_HighMI</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>925</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when the MI same as receivers in the Peer List has a MN that is bigger than the receivers, a new MI shall be generated.
Test Object: Software
Test Precondition: 
    -   KaY unit initialized.
    -   Switch Instance SM to KAY_INSTANCE_RUNNING and create MKPDUs.
    -   Set RxMkpdu message number.
  
Test Execution: 
    01: Call Mka_KaY_RxMkpdu() with bigger MN in the Peer List than the receivers MN for same MI that belongs to the receiver.
    02: VP(Mka.8021X.MkaTransport.16.2,1) Verify that the new MI is being generated, Mka_Crypto_RandomGenerateAsync shall be called.
    03: Create Mkpdu with different Peer.
    04: Set Message number of live Peer.
    05: Call Mka_KaY_RandomGenerateFinished with newly generated ID .
    06: Call Mka_KaY_RxMkpdu(). The message should be not be discarded as new ID has been generated. State should transition to Peer_Live.
    07: Sanity check - Check that MKPDU was accepted and that the state transitioned to Peer_Live.
    08: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.MkaTransport.16.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>170</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2097</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01030_Peer_SendPeerList</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>952</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that the newly generated and sent Mkpdu has correctly generated its Peer List.
Test Object: Software
Test Precondition: 
    -   KaY unit initialized
  
Test Execution: 
    01: Activate Participant 0.
    02: Create MKPDUs for Test.
    03: Move PeerSM to Peer Live.
    04: Sanity check - Check that the Potential Peer has been successfully set thus the timer has been reset.
    05: VP(Mka.8021X.MkaTransport.8,1) Verify that the PotentialPeer Mkpdu has known CKN value.
    06: Order the actor to send the Mkpdu.
    07: VP(Mka.EB.Eapol.30,1)
        VP(Mka.8021X.Eapol.28.4,1)
        VP(Mka.8021X.MkaTransport.25.5,1)
        VP(Mka.EB.MkaTransport.20,1)
        VP(Mka.8021X.MkaTransport.19,1)
        VP(Mka.EB.MkaTransport.19,1)
        VP(Mka.8021X.MkaTransport.18,1) Actor shall keep an up-to-date Potential peer list of peers that haven't proved their liveness (there is no actor member ID with corresponding MN in their peer list). Sent Mkpdu shall have a correct member ID and MN in its potential peer list. Verification that the participant maintains and advertises its peer list.
    08: VP(Mka.8021X.MkaTransport.8,1) Verify that the CKN hasn't changed in transmit.
    09: Call EbTest_KaY_PeerSM_Live with Mkpdu that has actors member ID in its peer list. Actor shall put it in the live peer list. The change made on the global variable EbTest_Mkpdu_BasicLive_KnownMI is to reflect actor's MN update.
    10: Order the actor to send the Mkpdu
    11: VP(Mka.EB.Eapol.30,1)
        VP(Mka.8021X.MkaTransport.25.4,1)
        VP(Mka.8021X.MkaTransport.19,1)
        VP(Mka.EB.MkaTransport.19,1)
        VP(Mka.8021X.MkaTransport.18,1) Actor shall keep an up-to-date Live peer list of peers that have proved their liveness (actor member ID with corresponding MN is in their peer list). Sent Mkpdu shall have a correct member ID and MN in its potential peer list. Verification that the participant maintains and advertises its peer list.
    12: VP(Mka.EB.Eapol.30,1)
        VP(Mka.8021X.Eapol.28.3,1) Verify that the second octet of transmitted live peer list has correct Key Server SSCI.
    13: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.MkaTransport.8</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>158</internalId></provcov>
        <provcov>
          <linksto>Mka.EB.Eapol.30</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>95</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.Eapol.28.4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>81</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.MkaTransport.25.5</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>186</internalId></provcov>
        <provcov>
          <linksto>Mka.EB.MkaTransport.20</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>176</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.MkaTransport.19</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>173</internalId></provcov>
        <provcov>
          <linksto>Mka.EB.MkaTransport.19</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>174</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.MkaTransport.18</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>172</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.MkaTransport.25.4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>185</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.Eapol.28.3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>80</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2098</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01031_MkpduCheckParameterSetTypeOrder</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>1029</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies if MKPDU is filled in correct order for parameter set type.
Test Object: KaY unit filled MKPDU paramets set in correct order.
Test Precondition: 
    -   KaY unit initialized.
  
Test Execution: 
    01: Activate Participant_2.
    02: Create MKPDU from a peer Participant_3 that proves liveness to Participant_0.
    03: Check that Potential Peer List and Announcement Parameter reserved bits are zeros.
    04: Call Mka_KaY_RxMkpdu() with MKPDU that contains new Member Identifier and this new Member identifier and Message number tuple should be placed in Potential Peer list.
    05: Trigger TX_MKPDU timeout for Participant_0 and parse transmitted MKPDU.
    06: VP(Mka.8021X.Eapol.28.2,1) Verify if was MKPDU filled with correct order, Basic parameter set and Potential parameter set.
    07: VP(Mka.8021X.Eapol.22,1) Verify that Potential Peer List and Announcement Parameter reserved bits still have zeros.
    08: VP(Mka.EB.KeyServerElection.36,1)
        VP(Mka.dsn.KaY.FillCipherAnnouncement.KeyServerState,2) Verify if participant send Announcement parameter set to advertise ALL configured Cipher Suites.
    09: Create MKPDU from a peer Participant_3 that proves liveness to Participant_0.
    10: Receive created MKPDU from a peer - this will bring participant's PeerSM into LIVE state.
    11: Trigger TX_MKPDU timeout for Participant_0 and parse transmitted MKPDU.
    12: VP(Mka.8021X.Eapol.28.2,1) Verify if was MKPDU filled in correct order, Basic parameter set, Live parameter set and Announcement parameter set.
    13: VP(Mka.8021X.Eapol.22,1) Verify Live Peer List Parameters are still zero.
    14: VP(Mka.EB.KeyServerElection.36,1)
        VP(Mka.dsn.KaY.FillCipherAnnouncement.KeyServerState,2) Verify if participant stopped sending Announcement parameter set, after key server is elected.
    15: Indicate that KEK is generated.
    16: Indicate that SAK is generated and wrapped and trigger MKPDU transmission.
    17: VP(Mka.8021X.Eapol.28.2,1) Verify if was MKPDU filled in correct order, Basic parameter set, Live parameter set, SAK Use and Distributed SAK.
    18: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.28.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>79</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.Eapol.22</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>64</internalId></provcov>
        <provcov>
          <linksto>Mka.EB.KeyServerElection.36</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>239</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.FillCipherAnnouncement.KeyServerState</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1574</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2099</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01032_BasicParSet_29_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>1078</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that Basic Parameter set from MKPDU is correctly decoded and all parameters are correctly accessed.
Test Object: Mka_Lib_ParSet_ValidateMkaPduData function, MKA_LIB_GET_BASIC_PARSET_xxx macros
Test Precondition: 
  
Test Execution: 
    01: Add Basic parameter set to test Mkpdu.
    02: Sanity check - Parameter set appended OK.
    03: Call Mka_Lib_ParSet_ValidateMkaPduData() decode MKPDU into MkaPdu structure.
    04: VP(Mka.8021X.Eapol.29.1, 1) Verify that MKPDU was decoded successfully and BasicParSetPtr was set correctly, also verify that MKA_LIB_GET_BASIC_PARSET_xxx macros are accessing correct (expected) data.
    05: Change basic parameter set length to invalid (less than MKA_BASIC_PARSET_MIN_BODY_LENGTH).
    06: Call Mka_Lib_ParSet_ValidateMkaPduData() decode MKPDU into MkaPdu structure.
    07: VP(Mka.8021X.Eapol.29.1, 1) Verify that MKPDU was not decoded successfully and BasicParSetPtr was set to NULL_PTR because of invalid basic parameter set length.
    08: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.29.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>84</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2100</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01033_LivePeerList_29_2_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>1102</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies functionality of parsing MKPDU that contains Live peer list and accessing Live peer list parameters with MKA_LIB_GET_LIVE_PEER_LIST_xxx macros.
Test Object: Mka_Lib_ParSet_ValidateMkaPduData function, MKA_LIB_GET_LIVE_PEER_LIST_xxx macros.
Test Precondition: 
  
Test Execution: 
    01: Add Basic parameter set to Mkpdu.
    02: Sanity check - Parameter set appended OK.
    03: Add Live peer list parameter set to Mkpdu.
    04: Sanity check - Parameter set appended OK.
    05: Call Mka_Lib_ParSet_ValidateMkaPduData() with valid MKPDU that contains Basic and Live Parameter sets to decode MKPDU into MkaPdu structure.
    06: VP(Mka.8021X.Eapol.29.2.1, 1)
        VP(Mka.dsn.Lib.Api.ParSet_ValidateMkaPduData, 1) Verify that MKPDU was decoded successfully and LivePeerListPtr was set correctly, also verify that MKA_LIB_GET_LIVE_PEER_LIST_xxx macros are accessing correct (expected) data.
    07: Change size of Live peer list length to invalid length (not divisible by 16).
    08: Call Mka_Lib_ParSet_ValidateMkaPduData() with MKPDU that contains valid Basic and invalid Live Parameter sets (body length invalid) to decode MKPDU into MkaPdu structure.
    09: VP(Mka.8021X.Eapol.29.2.6, 1) Verify that MKPDU was decoded successfully and BasicParSetPtr was set correctly and LivePeerListPtr is NULL because of invalid body length of Live peer list parameter set.
    10: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.29.2.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>86</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Lib.Api.ParSet_ValidateMkaPduData</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1078</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.Eapol.29.2.6</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>91</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2101</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01034_PotentialPeerList_29_2_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>1137</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies functionality of parsing MKPDU that contains Potential peer list and accessing Potential peer list parameters with MKA_LIB_GET_POTENTIAL_PEER_LIST_xxx macros.
Test Object: Mka_Lib_ParSet_ValidateMkaPduData function, MKA_LIB_GET_POTENTIAL_PEER_LIST_xxx macros
Test Precondition: 
  
Test Execution: 
    01: Add Basic parameter set to Mkpdu.
    02: Sanity check - Parameter set appended OK.
    03: Add Potential parameter set to Mkpdu.
    04: Sanity check - Parameter set appended OK.
    05: Call Mka_Lib_ParSet_ValidateMkaPduData() with valid MKPDU that contains Basic and Live Parameter sets to decode MKPDU into MkaPdu structure.
    06: VP(Mka.8021X.Eapol.29.2.1, 1) Verify that MKPDU was decoded successfully and PotentialPeerListPtr was set correctly, also verify that MKA_LIB_GET_POTENTIAL_PEER_LIST_xxx macros are accessing correct (expected) data.
    07: Change size of Live peer list length to invalid length (not divisible by 16).
    08: Call Mka_Lib_ParSet_ValidateMkaPduData() with MKPDU that contains valid Basic and invalid Potential Parameter sets (body length invalid) to decode MKPDU into MkaPdu structure.
    09: VP(Mka.8021X.Eapol.29.2.6, 1) Verify that MKPDU was decoded successfully and BasicParSetPtr was set correctly and PotentialPeerListPtr is NULL because of invalid body length of Potential peer list parameter set.
    10: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.29.2.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>86</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.Eapol.29.2.6</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>91</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2102</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01035_MACsecSAKUse_29_2_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>1167</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that MACsec Use parameter set from MKPDU is correctly decoded and all parameters are correctly accessed.
Test Object: Mka_Lib_ParSet_ValidateMkaPduData function, MKA_LIB_GET_MACSEC_SAK_USE_xxx macros
Test Precondition: 
  
Test Execution: 
    01: Add Basic parameter set to Mkpdu.
    02: Sanity check - Parameter set appended OK.
    03: Add MACsec SAK use parameter set with body length of 40 to Mkpdu.
    04: Sanity check - Parameter set appended OK.
    05: Call Mka_Lib_ParSet_ValidateMkaPduData() with valid MKPDU that contains Basic and MACsec SAK Use Parameter sets to decode MKPDU into MkaPdu structure.
    06: VP(Mka.8021X.Eapol.29.2.2, 1) Verify that MKPDU was decoded successfully and MacSecSakUsePtr was set correctly since MACSEC SAK Use body length is 40 octets, also verify that MKA_LIB_GET_MACSEC_SAK_USE_xxx macros are accessing correct (expected) data.
    07: Change body size of MACsec SAK use parameter set to 0 octets.
    08: Call Mka_Lib_ParSet_ValidateMkaPduData() with MACsec SAK use parameter body length 0 (MACsec Not supported) to decode MKPDU into MkaPdu structure.
    09: VP(Mka.8021X.Eapol.29.2.2, 1) Verify that MKPDU was decoded successfully and MacSecSakUsePtr was set correctly when MACSEC SAK Use body length is 0 octets
    10: Change body size of MACsec SAK use parameter set to invalid value (not 0 or 40)
    11: Call Mka_Lib_ParSet_ValidateMkaPduData() with MKPDU that contains valid Basic and invalid MACsec SAK use parameter sets (body length invalid) to decode MKPDU into MkaPdu structure.
    12: VP(Mka.8021X.Eapol.29.2.6, 1) Verify that MKPDU was decoded successfully and BasicParSetPtr was set correctly and MacSecSakUsePtr is NULL because of invalid body length of MACsec SAK use parameter set.
    13: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.29.2.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>87</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.Eapol.29.2.6</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>91</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2103</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01036_DistributedSAK1_29_2_3</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>1200</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies Distributed SAK Parameter set from MKPDU is correctly decoded and all parameters are correctly accessed for parameter set that has body length of 36 octets.
Test Object: Mka_Lib_ParSet_ValidateMkaPduData function, MKA_LIB_GET_DISTRIBUTED_SAK_xxx macros
Test Precondition: 
  
Test Execution: 
    01: Add Basic parameter set to Mkpdu.
    02: Sanity check - Parameter set appended OK.
    03: Add Distributed SAK parameter set to Mkpdu.
    04: Sanity check - Parameter set appended OK.
    05: Call Mka_Lib_ParSet_ValidateMkaPduData() with valid MKPDU that contains Basic and Distributed SAK Parameter set with cipher suite specified to decode MKPDU into MkaPdu structure.
    06: VP(Mka.8021X.Eapol.29.2.3, 1) Verify that MKPDU was decoded successfully and DistributedSAKPtr was set correctly, also verify that MKA_LIB_GET_DISTRIBUTED_SAK_xxx macros are accessing correct (expected) data.
    07: Set invalid parameter set length.
    08: Call Mka_Lib_ParSet_ValidateMkaPduData() to parse Mkpdu.
    09: VP(Mka.8021X.Eapol.29.2.6, 1) Verify that parameter set is ignored because of invalid length.
    10: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.29.2.3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>88</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.Eapol.29.2.6</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>91</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2104</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01037_DistributedSAK2_29_2_3</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>1230</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies Distributed SAK Parameter set from MKPDU is correctly decoded and all parameters are correctly accessed for parameter set that has body length of 28 octets.
Test Object: Mka_Lib_ParSet_ValidateMkaPduData function, MKA_LIB_GET_DISTRIBUTED_SAK_xxx macros
Test Precondition: 
  
Test Execution: 
    01: Add Basic parameter set to Mkpdu.
    02: Sanity check - Parameter set appended OK.
    03: Add Distributed SAK parameter set to Mkpdu.
    04: Sanity check - Parameter set appended OK.
    05: Add MACsec SAK use parameter set with body length of 40 to Mkpdu.
    06: Sanity check - Parameter set appended OK.
    07: Call Mka_Lib_ParSet_ValidateMkaPduData() with valid MKPDU that contains Basic and Distributed SAK Parameter set without cipher suite specified to decode MKPDU into MkaPdu structure.
    08: VP(Mka.8021X.Eapol.29.2.3, 1) Verify that MKPDU was decoded successfully and DistributedSAKPtr was set correctly, also verify that MKA_LIB_GET_DISTRIBUTED_SAK_xxx macros are accessing correct (expected) data.
    09: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.29.2.3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>88</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2105</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01038_DistributedSAK3_29_2_3</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>1255</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies Distributed SAK Parameter set from MKPDU is correctly decoded and all parameters are correctly accessed for parameter set that has body length of 0 octets.
Test Object: Mka_Lib_ParSet_ValidateMkaPduData function, MKA_LIB_GET_DISTRIBUTED_SAK_xxx macros
Test Precondition: 
  
Test Execution: 
    01: Add Basic parameter set to Mkpdu.
    02: Sanity check - Parameter set appended OK.
    03: Add Distributed SAK parameter set to Mkpdu.
    04: Sanity check - Parameter set appended OK.
    05: Call Mka_Lib_ParSet_ValidateMkaPduData() with valid MKPDU that contains Basic and Distributed SAK Parameter set with no cipher suite specified to decode MKPDU into MkaPdu structure.
    06: VP(Mka.8021X.Eapol.29.2.3, 1) Verify that MKPDU was decoded successfully and DistributedSAKPtr was set correctly, also verify that MKA_LIB_GET_DISTRIBUTED_SAK_xxx macros are accessing correct (expected) data.
    07: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.29.2.3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>88</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2106</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01039_ICV_Indicator_29_3</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>1278</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that if the ICV Indicator is present, i.e., its initial octet is present where a parameter set type is expected, all further parameter sets in the MKPDU (if any) are ignored.
Test Object: Mka_Lib_ParSet_ValidateMkaPduData function
Test Precondition: 
  
Test Execution: 
    01: Add Basic parameter set to Mkpdu.
    02: Sanity check - Parameter set appended OK.
    03: Add Live peer list parameter set to Mkpdu.
    04: Sanity check - Parameter set appended OK.
    05: Add ICV Indicator parameter set to Mkpdu.
    06: Sanity check - Parameter set appended OK.
    07: Add Potential parameter set to Mkpdu.
    08: Sanity check - Parameter set appended OK.
    09: Add MACsec SAK use parameter set with body length of 40 to Mkpdu.
    10: Sanity check - Parameter set appended OK.
    11: Add Distributed SAK parameter set to Mkpdu.
    12: Sanity check - Parameter set appended OK.
    13: Call Mka_Lib_ParSet_ValidateMkaPduData() with valid MKPDU that contains all supported parameter set but with ICV Indicator placed after Live peer list parameter set to decode MKPDU into MkaPdu structure.
    14: VP(Mka.8021X.Eapol.29.3, 1) Verify that MKPDU was decoded successfully and that Basic and Live Peer list parameter sets are decoded correctly and that no other parameter set is decoded because ICV Indicator was present after Live peer list.
    15: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.29.3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>92</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2107</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01040_ParSetAdditionalOccurrences1_29_4</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>1309</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that when multiple Live peer list and Potential peer parameter sets of same type are present in Mkpdu, only first occurrence will be used .
Test Object: Mka_Lib_ParSet_ValidateMkaPduData function, MKA_LIB_GET_BASIC_PARSET_xxx macros
Test Precondition: 
  
Test Execution: 
    01: Add Basic parameter set to Mkpdu.
    02: Sanity check - Parameter set appended OK.
    03: Add Live peer list parameter set to Mkpdu.
    04: Sanity check - Parameter set appended OK.
    05: Change Member Identifier in first element of peer list
    06: Add Live peer list parameter set with original member identifier to Mkpdu.
    07: Sanity check - Parameter set appended OK.
    08: Add Potential peer list parameter set to Mkpdu.
    09: Sanity check - Parameter set appended OK.
    10: Change Member Identifier in first element of peer list
    11: Add Potential peer list parameter set with original member identifier to Mkpdu.
    12: Sanity check - Sanity check.
    13: Call Mka_Lib_ParSet_ValidateMkaPduData() to parse and validate Mkpdu.
    14: VP(Mka.8021X.Eapol.29.4, 1) Verify that MKPDU was decoded successfully and that only first instance of Live peer list parameter set is used in accessing parameters by verifing that MkaPdu.LivePeerListPtr points to correct data and by testing that member identifier accessed by MKA_LIB_GET_LIVE_PEER_LIST_MEMBER_IDENTIFIER matches member identifier of first added instance.
    15: VP(Mka.8021X.Eapol.29.4, 1) Verify that MKPDU was decoded successfully and that only first instance of Potential peer list parameter set is used in accessing parameters by verifing that MkaPdu.PotentialPeerListPtr points to correct data and by testing that member identifier accessed by MKA_LIB_GET_POTENTIAL_PEER_LIST_MEMBER_IDENTIFIER matches member identifier of first added instance.
    16: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.29.4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>93</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2108</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01041_ParSetAdditionalOccurrences2_29_4</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>1341</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that when multiple Distributed SAK and MACsec SAK Use parameter sets of same type are present in Mkpdu, only first occurrence will be used .
Test Object: Mka_Lib_ParSet_ValidateMkaPduData function, MKA_LIB_GET_BASIC_PARSET_xxx macros
Test Precondition: 
  
Test Execution: 
    01: Add Basic parameter set to Mkpdu.
    02: Sanity check - Parameter set appended OK.
    03: Add MACsec SAK Use parameter set to Mkpdu.
    04: Sanity check - Parameter set appended OK.
    05: Change LKI in parameter set.
    06: Add MACsec SAK Use parameter set with original LKI to Mkpdu.
    07: Sanity check - Parameter set appended OK.
    08: Add Distributed SAK With no Cypher (Body length == 0) parameter set to Mkpdu.
    09: Add Distributed SAK With default Cypher specifed (Body length == 28) parameter set to Mkpdu.
    10: Sanity check - Parameter set appended OK.
    11: Call Mka_Lib_ParSet_ValidateMkaPduData() to parse and validate Mkpdu.
    12: VP(Mka.8021X.Eapol.29.4, 1) Verify that MKPDU was decoded successfully and that only first instance of MACsec SAK Use parameter set is used in accessing parameters and other instance is ignored by testing that LKI of parameter set instance matches LKI of first added instance.
    13: VP(Mka.8021X.Eapol.29.4, 1) Verify that MKPDU was decoded successfully and that only first instance of Distributed SAK parameter set is used in accessing parameters and other instance is ignored by testing that body length of parameter set instance matches body length of first added instance.
    14: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.29.4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>93</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2109</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01042_KeySm_Disabled2GenerateNewSak</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>1371</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies transitions between states of Key state machine. Tested transitions are for the case when we are elected server and principal actor. Tested state transitions are: KAY_KEYSM_DISABLED -&amp;gt; KAY_KEYSM_GENERATE_KEK -&amp;gt; KAY_KEYSM_GENERATE_NEW_SAK -&amp;gt; KAY_KEYSM_DELAY_NEW_SAK -&amp;gt; KAY_KEYSM_WAIT_NEW_SAK_REQ -&amp;gt; KAY_KEYSM_GENERATE_NEW_SAK.
Test Object: KaY Key state machine.
Test Precondition: 
    -   KaY unit initialized.
  
Test Execution: 
    01: Activate Participant 0.
    02: Create MKPDU for Test. Check that MacSecSakUsePtr has zero in reserved bits.
    03: Call Mka_KaY_RxMkpdu() with MKPDU that contains new Member Identifier and this new Member identifier and Message number tuple should be placed in Live Peer list and accordingly start Key server election and if Key server elected is True, start generation of SAK key.
    04: VP(Mka.EB.KeyServerElection.3,1)
        VP(Mka.InterAct.KayInteractions,1) Verify that lib unit was called to start new timer which indicates that Key server was elected.
    05: VP(Mka.dsn.KaY.KeySM.Disabled_2_GenerateKek,2)
        VP(Mka.dsn.KaY.KeySM.Initial_2_Disabled,1) Verify that Mka_Crypto_KekGenerateAsync() was called, indicating that participant has become principal actor, and KeySM has transitioned from KAY_KEYSM_DISABLED to KAY_KEYSM_GENERATE_KEK. This transition also confirms that we were in state KAY_KEYSM_DISABLED after Mka_KaY_Init().
    06: Call Mka_KaY_KekGenerateFinished() with Result == E_OK to indicate successful generation of KEK.
    07: VP(Mka.dsn.KaY.KeySM.GenerateKek_2_GenerateNewSak,1)
        VP(Mka.InterAct.KayInteractions,1) Verify that Mka_Crypto_SakGenWrapAsync() was called which indicates KeySM transition from KAY_KEYSM_GENERATE_KEK to KAY_KEYSM_GENERATE_NEW_SAK.
    08: Call Mka_KaY_TimerCallback_NewSakDelay() to indicate timeout of timer. Since KeySM is not in the state KAY_KEYSM_DELAY_NEW_SAK, the call shall be ignored.
    09: Call Mka_KaY_SakGenWrapFinished() with Result == E_OK to simulate generation of SAK key. If generation is successful, Key state machine should transit to new state KAY_KEYSM_DELAY_NEW_SAK.
    10: VP(Mka.dsn.KaY.KeySM.GenerateNewSak_2_DelayNewSak,1)
        VP(Mka.dsn.KaY.Api.SakGenWrapFinished,1)
        VP(Mka.InterAct.KayInteractions,1) Verify if CP unit was called to be notified about new SAK via function Mka_Cp_NewSak() and if Lib unit was called to start new timers. Both function calls indicates that new SAK key was generated and Key State machine transitioned from KAY_KEYSM_GENERATE_NEW_SAK to KAY_KEYSM_DELAY_NEW_SAK.
    11: Call Mka_KaY_TimerCallback_NewSakDelay() to indicate timeout of timer. When timeout is processed, Key state machine should transit to KAY_KEYSM_WAIT_NEW_SAK_REQ.
    12: Call Mka_KaY_PnExhausted() to signal that PN has become exhausted. This shall initiate transition to KAY_KEYSM_GENERATE_NEW_SAK and start generation of new SAK.
    13: VP(Mka.dsn.KaY.KeySM.DelayNewSak_2_WaitNewSakReq,1)
        VP(Mka.dsn.KaY.KeySM.WaitNewSakReq_2_GenerateNewSak,1)
        VP(Mka.dsn.KaY.Api.PnExhausted,1) Verify if Mka_Crypto_SakGenWrapAsync() was called which indicates that Key state machine transitioned from KAY_KEYSM_WAIT_NEW_SAK_REQ to KAY_KEYSM_GENERATE_NEW_SAK. This transition also confirms that after function call Mka_KaY_TimerCallback_NewSakDelay(), Key state machine transitioned from KAY_KEYSM_DELAY_NEW_SAK to KAY_KEYSM_WAIT_NEW_SAK_REQ.
    14: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.KeyServerElection.3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>197</internalId></provcov>
        <provcov>
          <linksto>Mka.InterAct.KayInteractions</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1109</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.KeySM.Disabled_2_GenerateKek</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1424</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.KeySM.Initial_2_Disabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1415</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.KeySM.GenerateKek_2_GenerateNewSak</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1423</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.KeySM.GenerateNewSak_2_DelayNewSak</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1414</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.Api.SakGenWrapFinished</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>998</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.KeySM.DelayNewSak_2_WaitNewSakReq</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1412</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.KeySM.WaitNewSakReq_2_GenerateNewSak</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1427</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.Api.PnExhausted</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1006</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2110</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01043_KeySm_Disabled2WaitSakDistribution</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>1445</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies transitions between states of Key state machine. Tested transitions are for case when partner was elected for key server and principal actor and we wait that partner distributes SAK key. Tested state transitions are: KAY_KEYSM_DISABLED -&amp;gt; KAY_KEYSM_GENERATE_KEK -&amp;gt; KAY_KEYSM_WAIT_SAK_DISTRIBUTION -&amp;gt; KAY_KEYSM_WAIT_SAK_UNWRAP -&amp;gt; KAY_KEYSM_WAIT_SAK_DISTRIBUTION.
Test Object: KaY Key state machine.
Test Precondition: 
    -   Module configuration initialized with Mka_Init().
  
Test Execution: 
    01: Activate Participant 0.
    02: Initialize Mkpdu with Basic and Live Parameter sets.
    03: Call Mka_KaY_RxMkpdu() with MKPDU that contains new Member Identifier. This new MI and MN tuple shall be placed in Live Peer list and accordingly start Key server election.
    04: VP(Mka.EB.KeyServerElection.3,1)
        VP(Mka.InterAct.KayInteractions,1) Verify that lib unit was called to start new timer which indicates that Key server was elected.
    05: VP(Mka.dsn.KaY.KeySM.Disabled_2_GenerateKek,2)
        VP(Mka.dsn.KaY.KeySM.Initial_2_Disabled,1) Verify that Mka_Crypto_KekGenerateAsync() was called, indicating that participant has become principal actor, and KeySM has transitioned from KAY_KEYSM_DISABLED to KAY_KEYSM_GENERATE_KEK. This transition also confirms that we were in state KAY_KEYSM_DISABLED after Mka_KaY_Init().
    06: Call Mka_KaY_KekGenerateFinished() to indicate that KEK is successfully generated.
    07: VP(Mka.dsn.KaY.KeySM.GenerateKek_2_WaitSakDistribution,1) Verify that KeySM transitioned from KAY_KEYSM_GENERATE_KEK to KAY_KEYSM_WAIT_SAK_DISTRIBUTION, because neither Mka_Crypto_SakGenWrapAsync() nor Mka_Crypto_SakUnwrapAsync were called. KeySM did not progress to KAY_KEYSM_WAIT_SAK_UNWRAP since Distributed SAK was not yet received.
    08: Add Sak use and Distributed Sak parameter set to RxMkpdu.
    09: Call Mka_KaY_RxMkpdu() with MKPDU that contains Live Peer list, SAK Use and Distributed SAK parameter set and accordingly start process of unwrapping SAK key.
    10: Sanity check - Sanity check.
    11: VP(Mka.dsn.KaY.KeySM.WaitSakDistribution_2_WaitSakUnwrap,1)
        VP(Mka.InterAct.KayInteractions,1) Verify if Mka_Crypto_SakUnwrapAsync() was called which indicates that Key State machine transitioned from KAY_KEYSM_WAIT_SAK_DISTRIBUTION to KAY_KEYSM_WAIT_SAK_UNWRAP. This transition also confirms that we were in state KAY_KEYSM_WAIT_SAK_DISTRIBUTION.
    12: Call Mka_KaY_SakUnwrapFinished() to simulate that unwrapping was finished. When SAK is unwrapped, Key state machine should transit to KAY_KEYSM_WAIT_SAK_DISTRIBUTION.
    13: VP(Mka.dsn.KaY.KeySM.WaitSakUnwrap_2_WaitSakDistribution_CryptoOk,1)
        VP(Mka.dsn.KaY.Api.SakUnwrapFinished,1)
        VP(Mka.InterAct.KayInteractions,1) Verify if Cp unit was called to notify him about new SAK with function call Mka_Cp_NewSak(). This function call indicates that was unwrapped new SAK key and Key State machine transitioned from KAY_KEYSM_WAIT_SAK_UNWRAP to KAY_KEYSM_WAIT_SAK_DISTRIBUTION.
    14: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.KeyServerElection.3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>197</internalId></provcov>
        <provcov>
          <linksto>Mka.InterAct.KayInteractions</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1109</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.KeySM.Disabled_2_GenerateKek</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1424</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.KeySM.Initial_2_Disabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1415</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.KeySM.GenerateKek_2_WaitSakDistribution</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1418</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.KeySM.WaitSakDistribution_2_WaitSakUnwrap</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1417</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.KeySM.WaitSakUnwrap_2_WaitSakDistribution_CryptoOk</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1420</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.Api.SakUnwrapFinished</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>997</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2111</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01044_KeySm_Disabled2WaitSakUnwrap</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>1509</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Tested transition is for case when partner was elected key server and principal actor. KaY unit will receive MKPDU from partner that contains distributed SAK. Key state machine will call Crypto function for unwrapping SAK key, but will return E_NOT_OK and Key state machine will transit to state KAY_KEYSM_WAIT_SAK_DISTRIBUTION. Tested state transitions are: KAY_KEYSM_DISABLED -&amp;gt; KAY_KEYSM_WAIT_SAK_UNWRAP -&amp;gt; KAY_KEYSM_WAIT_SAK_DISTRIBUTION.
Test Object: KaY Key state machine.
Test Precondition: 
    -   KaY unit initialized.
  
Test Execution: 
    01: Activate Participant_0.
    02: Create MKPDU from a peer Participant_1 that proves liveness to Participant_0.
    03: Call Mka_KaY_RxMkpdu() with MKPDU that contains new Member Identifier. This new MI and MN tuple shall be placed in Live Peer list and accordingly start Key server election.
    04: Call Mka_KaY_KekGenerateFinished() to indicate that KEK is successfully generated.
    05: VP(Mka.dsn.KaY.KeySM.WaitSakUnwrap_2_WaitSakDistribution_CryptoNotOk,1) Verify if lib unit was called to start new timer which indicates that Key server was elected and right after is called function Mka_Crypto_SakUnwrapAsync(). These function calls indicate that Key state machine transitioned from KAY_KEYSM_DISABLED to KAY_KEYSM_WAIT_SAK_UNWRAP, because Mka_Crypto_SakGenWrapAsync() returned E_NOT_OK, Logon unit is notified and instance is disabled.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.KeySM.WaitSakUnwrap_2_WaitSakDistribution_CryptoNotOk</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1421</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2112</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01045_KeySm_SelfTransit_GenerateNewSak</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>1531</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies self transitions of states in Key state machine KAY_KEYSM_GENERATE_NEW_SAK.
Test Object: KaY Key state machine.
Test Precondition: 
    -   KaY unit initialized.
  
Test Execution: 
    01: Activate Participant_0.
    02: Create MKPDU from a peer Participant_3 that proves liveness to Participant_0.
    03: Call Mka_KaY_RxMkpdu() to transit in state KAY_KEYSM_GENERATE_NEW_SAK.
    04: Call Mka_KaY_KekGenerateFinished() to indicate that KEK is successfully generated.
    05: VP(Mka.dsn.KaY.KeySM.SelfTrans.GenerateNewSak,1) Verify if Mka_Crypto_SakGenWrapAsync() was called and returned E_NOT_OK, Key state machine will self transit in KAY_KEYSM_GENERATE_NEW_SAK and notify Logon unit that instance shall be disabled.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.KeySM.SelfTrans.GenerateNewSak</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1426</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2113</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01046_KeySm_SelfTransit_DelayNewSak_WaitNewSakReq</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>1553</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies self transitions of states in Key state machine. Tested transition is for case when we are elected server and principal actor. Tested state transitions are: KAY_KEYSM_DISABLED -&amp;gt; KAY_KEYSM_GENERATE_NEW_SAK -&amp;gt; KAY_KEYSM_DELAY_NEW_SAK -&amp;gt; KAY_KEYSM_WAIT_NEW_SAK_REQ -&amp;gt; KAY_KEYSM_GENERATE_NEW_SAK.
Test Object: KaY Key state machine.
Test Precondition: 
    -   KaY unit initialized.
  
Test Execution: 
    01: Activate Participant_0.
    02: Create MKPDU from a peer Participant_3 that proves liveness to Participant_0.
    03: Receive created MKPDU from a peer - this will bring participant's PeerSM into LIVE state.
    04: Indicate that KEK is successfully generated.
    05: Indicate that SAK is generated and wrapped.
    06: Add SAK Use parameter set to MKPDU.
    07: Call Mka_KaY_RxMkpdu() with MKPDU that contains SAK use parameter set with Latest key rx = true.
    08: VP(Mka.dsn.KaY.KeySM.SelfTrans.DelayNewSak,1) Verify if Mka_KaY_RxMkpdu() was called with MKPDU that contain SAK use parameter set with Latest key rx set to true, Key state machine self transit to state KAY_KEYSM_DELAY_NEW_SAK.
    09: Call Mka_KaY_TimerCallback_NewSakDelay() that Key state machine transit to KAY_KEYSM_WAIT_NEW_SAK_REQ.
    10: Call Mka_KaY_RxMkpdu() with MKPDU that contains SAK use parameter set with Latest key rx = true.
    11: VP(Mka.dsn.KaY.KeySM.SelfTrans.WaitNewSakReq,1) Verify if Mka_KaY_RxMkpdu() was called with MKPDU that contain SAK use parameter set with Latest key rx set to true, Key state machine self transit to state KAY_KEYSM_WAIT_NEW_SAK_REQ.
    12: Call Mka_KaY_PnExhausted() to signal that PN has become exhausted.
    13: VP(Mka.dsn.KaY.KeySM.SelfTrans.DelayNewSak,1)
        VP(Mka.dsn.KaY.KeySM.SelfTrans.WaitNewSakReq,1) Verify if Mka_Crypto_SakGenWrapAsync() was called which indicates that Key state machine was transitioned from KAY_KEYSM_WAIT_NEW_SAK_REQ to KAY_KEYSM_GENERATE_NEW_SAK. This transition confirms that previous self transitions were successful.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.KeySM.SelfTrans.DelayNewSak</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1413</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.KeySM.SelfTrans.WaitNewSakReq</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1428</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2114</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01047_KeySm_SelfTransit_WaitSakUnwrap</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>1588</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies self transitions of states in Key state machine. Tested transition is for case when we are elected server and principal actor. Tested state transitions are: KAY_KEYSM_DISABLED -&amp;gt; KAY_KEYSM_WAIT_SAK_UNWRAP -&amp;gt; KAY_KEYSM_WAIT_SAK_DISTRIBUTION.
Test Object: KaY Key state machine.
Test Precondition: 
    -   KaY unit initialized.
  
Test Execution: 
    01: Activate Participant_0.
    02: Create MKPDU from a peer Participant_1 that proves liveness to Participant_0.
    03: Call Mka_KaY_KekGenerateFinished() to indicate that KEK is successfully generated.
    04: Send MKPDU with new Distributed SAK to stop old SAK unwrapping and start new one.
    05: VP(Mka.dsn.KaY.KeySM.SelfTrans.WaitSakUnwrap,1) Verify if Crypto unit was stopped and started new unwrapping.
    06: Call Mka_KaY_SakUnwrapFinished() to simulate that was unwrapping finished. When SAK is unwrapped, Key state machine should transit to KAY_KEYSM_WAIT_SAK_DISTRIBUTION.
    07: VP(Mka.dsn.KaY.KeySM.SelfTrans.WaitSakUnwrap,1) Verify if Cp unit was called to notify him about new SAK with function call Mka_Cp_NewSak(). This function call indicates previous self transition was successful.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.KeySM.SelfTrans.WaitSakUnwrap</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1429</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2115</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01048_KeySm_GenerateNewSak2Disabled</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>1612</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies transitions between states of Key state machine. Tested transition is for case when we are elected server and principal actor. Tested state transitions are: KAY_KEYSM_DISABLED -&amp;gt; KAY_KEYSM_GENERATE_NEW_SAK -&amp;gt; KAY_KEYSM_DISABLED.
Test Object: KaY Key state machine.
Test Precondition: 
    -   KaY unit initialized.
  
Test Execution: 
    01: Activate Participant_0.
    02: Create MKPDU from a peer Participant_3 that proves liveness to Participant_0.
    03: Transit KeySM to KAY_KEYSM_GENERATE_NEW_SAK.
    04: Call Mka_KaY_TimerCallback_PeerLifeTimeout() to simulate peer life timeout and consequently KeySM will transition to state KAY_KEYSM_DISABLED.
    05: VP(Mka.InterAct.KayInteractions.PeerLifeTimeout,1) Verify that Peer Life Timeout process interacts with other units as described in requirement.
    06: VP(Mka.dsn.KaY.KeySM.ANY_2_Disabled,2)
        VP(Mka.InterAct.KayInteractions.PeerLifeTimeout,1) Verify that KeySM transitioned from any state to state KAY_KEYSM_DISABLED, since Crypto is stopped.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.InterAct.KayInteractions.PeerLifeTimeout</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1110</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.KeySM.ANY_2_Disabled</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1416</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2116</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01049_KeySm_DelayNewSak2Disabled</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>1640</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies transitions between states of Key state machine. Tested transition is for case when we are elected server and principal actor. Tested state transitions are: KAY_KEYSM_DISABLED -&amp;gt; KAY_KEYSM_GENERATE_NEW_SAK -&amp;gt; KAY_KEYSM_DELAY_NEW_SAK -&amp;gt; KAY_KEYSM_DISABLED.
Test Object: KaY Key state machine.
Test Precondition: 
    -   KaY unit initialized.
  
Test Execution: 
    01: Activate Participant_0.
    02: Create MKPDU from a peer Participant_3 that proves liveness to Participant_0.
    03: Transit KeySM into KAY_KEYSM_GENERATE_NEW_SAK state and PeerSM into LIVE state.
    04: Indicate that KEK is successfully generated.
    05: Indicate that SAK is generated and wrapped.
    06: Call Mka_KaY_TimerCallback_PeerLifeTimeout() to simulate peer life timeout and consequently KeySM will trasition to state KAY_KEYSM_DISABLED.
    07: VP(Mka.dsn.KaY.KeySM.ANY_2_Disabled,2) Verify that KeySM transitioned from any state to state KAY_KEYSM_DISABLED, as timer for SAK delay was canceled.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.KeySM.ANY_2_Disabled</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1416</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2117</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01050_KeySm_WaitNewSakReq2Disabled</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>1664</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies transitions between states of Key state machine. Tested transition is for case when we are elected server and principal actor. Tested state transitions are: KAY_KEYSM_DISABLED -&amp;gt; KAY_KEYSM_GENERATE_NEW_SAK -&amp;gt; KAY_KEYSM_DELAY_NEW_SAK -&amp;gt; KAY_KEYSM_WAIT_NEW_SAK_REQ -&amp;gt; KAY_KEYSM_DISABLED.
Test Object: KaY Key state machine.
Test Precondition: 
    -   KaY unit initialized.
  
Test Execution: 
    01: Activate Participant_0.
    02: Create MKPDU from a peer Participant_3 that proves liveness to Participant_0.
    03: Transit KeySM to KAY_KEYSM_GENERATE_NEW_SAK.
    04: Indicate that KEK is successfully generated.
    05: Indicate that SAK is generated and wrapped.
    06: Transit KeySM to KAY_KEYSM_WAIT_NEW_SAK_REQ.
    07: Call Mka_KaY_TimerCallback_PeerLifeTimeout() to simulate peer life timeout and consequently KeySM will transition to state KAY_KEYSM_DISABLED.
    08: VP(Mka.dsn.KaY.KeySM.ANY_2_Disabled,2) Verify that KeySM transitioned from any state to state KAY_KEYSM_DISABLED, as timer for SAK delay was canceled.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.KeySM.ANY_2_Disabled</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1416</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2118</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01051_KeySm_WaitSakDistribution2Disabled</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>1689</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies transitions of KeySM: KAY_KEYSM_DISABLED -&amp;gt; KAY_KEYSM_GENERATE_KEK -&amp;gt; KAY_KEYSM_DISABLED and KAY_KEYSM_DISABLED -&amp;gt; KAY_KEYSM_WAIT_SAK_DISTRIBUTION -&amp;gt; KAY_KEYSM_DISABLED.
Test Object: KaY Key state machine.
Test Precondition: 
    -   KaY unit initialized.
  
Test Execution: 
    01: Activate Participant_0.
    02: Create MKPDU from a peer Participant_1 that proves liveness to Participant_0.
    03: Call Mka_KaY_RxMkpdu() with created MKPDU to initiate Key server election.
    04: VP(Mka.dsn.KaY.KeySM.Disabled_2_GenerateKek,2) Verify that Mka_Crypto_KekGenerateAsync() was called, indicating that KeySM has transitioned from KAY_KEYSM_DISABLED to KAY_KEYSM_GENERATE_KEK.
    05: Call Mka_KaY_TimerCallback_PeerLifeTimeout() to simulate peer life timeout and consequently KeySM will transition to state KAY_KEYSM_DISABLED.
    06: VP(Mka.dsn.KaY.KeySM.ANY_2_Disabled,2) Verify that KeySM transitioned from states KAY_KEYSM_GENERATE_KEK or KAY_KEYSM_WAIT_SAK_DISTRIBUTION (based on use of pres-hared KEK) to state KAY_KEYSM_DISABLED, as timer for SAK delay was canceled.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.KeySM.Disabled_2_GenerateKek</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1424</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.KeySM.ANY_2_Disabled</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1416</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2119</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01052_KeySm_WaitSakUnwrap2Disabled</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>1716</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies transitions between states of Key state machine. Tested transition is for case when we are elected server and principal actor. Tested state transitions are: KAY_KEYSM_DISABLED -&amp;gt; KAY_KEYSM_WAIT_SAK_DISTRIBUTION -&amp;gt; KAY_KEYSM_WAIT_SAK_UNWRAP -&amp;gt; KAY_KEYSM_DISABLED.
Test Object: KaY Key state machine.
Test Precondition: 
    -   KaY unit initialized.
  
Test Execution: 
    01: Activate Participant_0.
    02: Create MKPDU from a peer Participant_1 that proves liveness to Participant_0.
    03: Receive created MKPDU from a peer - this will bring participant's PeerSM into LIVE state.
    04: Call Mka_KaY_KekGenerateFinished() to indicate that KEK is successfully generated.
    05: Add Sak use and Distributed Sak parameter set..
    06: Receive created MKPDU from a peer - this will bring participant's KeySM into KAY_KEYSM_WAIT_SAK_UNWRAP state.
    07: Call Mka_KaY_TimerCallback_PeerLifeTimeout() to simulate peer life timeout and consequently KeySM will transition to state KAY_KEYSM_DISABLED.
    08: VP(Mka.dsn.KaY.KeySM.ANY_2_Disabled,2) Verify that KeySM transitioned from any state to state KAY_KEYSM_DISABLED, as timer for SAK delay was canceled.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.KeySM.ANY_2_Disabled</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1416</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2120</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01053_SakGenWrap_Fail_CC</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>1741</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that after SAK Gen and Wrap has been started and when Mka_KaY_SakGenWrapFinished with input parameter Result = E_NOT_OK, instance shall be disabled.
Test Object: KaY Mka_KaY_SakGenWrapFinished failed.
Test Precondition: 
    -   KaY unit initialized.
  
Test Execution: 
    01: Activate Participant_0.
    02: Create MKPDU from a peer Participant_3 that proves liveness to Participant_0.
    03: Receive created MKPDU from a peer - this will bring participant's PeerSM into LIVE state.
    04: Indicate that KEK is successfully generated.
    05: Call Mka_KaY_SakGenWrapFinished() with Result == E_NOT_OK to failed simulate generation of SAK key.
    06: VP(Mka.EB.RunTimeEvent.BitFieldDefinition,1)
        VP(Mka.EB.RunTimeEvent.TriggeredEventParticipant,1) Verify that, after Sak Gen and Wrap failed, a bit for that event has been set for the selected Participant.
    07: VP(Mka.dsn.KaY.KeySM.SelfTrans.GenerateNewSak,1) Verify that the following instance has been disabled after Sak Gen and Wrap has failed.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.RunTimeEvent.BitFieldDefinition</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1478</internalId></provcov>
        <provcov>
          <linksto>Mka.EB.RunTimeEvent.TriggeredEventParticipant</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1479</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.KeySM.SelfTrans.GenerateNewSak</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1426</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2121</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01054_SakUnwrap_CC</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>1774</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that after a unsuccessfull SAK unwrapping, the process is stopped and instance is disabled.
Test Object: KaY Sak Unwrap E_NOT_OK.
Test Precondition: 
    -   KaY unit initialized.
  
Test Execution: 
    01: Activate Participant_0.
    02: Create MKPDU from a peer Participant_1 that proves liveness to Participant_0.
    03: Receive created MKPDU from a peer - this will bring participant's PeerSM into LIVE state.
    04: Add Sak use and Distributed Sak parameter sets.
    05: Call Mka_KaY_KekGenerateFinished() to indicate that KEK is successfully generated.
    06: Receive created MKPDU from a peer - this will bring participant's KeySM into KAY_KEYSM_WAIT_SAK_UNWRAP state.
    07: Call Mka_KaY_SakUnwrapFinished() to simulate that unwrapping was finished. When SAK is unwrapped, Key state machine should transit to KAY_KEYSM_WAIT_SAK_DISTRIBUTION.
    08: VP(Mka.EB.RunTimeEvent.BitFieldDefinition,1)
        VP(Mka.EB.RunTimeEvent.TriggeredEventParticipant,1) Verify that, after Sak unwrapping failed, a bit for that event has been set for the selected Participant.
    09: VP(Mka.dsn.KaY.KeySM.WaitSakUnwrap_2_WaitSakDistribution_CryptoNotOk,1) Verify that Mka_Logon_Participant_Disabled was called which indicates that instance is being disabled.
    10: VP(Mka.CP_SWS_Mka_00034,1) Verify that Mka_Logon_ReportEvent_Stub was called with correct parameters, which indicates that SAK could not be unwrapped.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.RunTimeEvent.BitFieldDefinition</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1478</internalId></provcov>
        <provcov>
          <linksto>Mka.EB.RunTimeEvent.TriggeredEventParticipant</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1479</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.KeySM.WaitSakUnwrap_2_WaitSakDistribution_CryptoNotOk</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1421</internalId></provcov>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00034</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>353</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2122</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01055_KeyServerFlagAndPriority_PriorityBased</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>1814</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that KaY correctly encodes Key server and Key server priority fields of Basic parameter set in the following configuration:
Test Object: Software
Test Precondition: 
    -   KaY unit initialized.
  
Test Execution: 
    01: Activate Participant_0.
    02: Parse transmitted MKPDU.
    03: VP(Mka.8021X.KeyServerElection.4.2,1) Verify that Key server field is 1 in the initial MKPDU transmission, since MkaRole for Participant_0 is PRIORITY_BASED.
    04: VP(Mka.8021X.KeyServerElection.4.1,1)
        VP(Mka.CP_SWS_Mka_00011.1,1) Verify that Key server priority is encoded in MKPDU and set according to configured value.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.4.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>200</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.4.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>199</internalId></provcov>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00011.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>319</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2123</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01056_KeyServerFlagAndPriority_KeyServer</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>1844</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that KaY correctly encodes Key server and Key server priority fields of Basic parameter set in the following configuration:
Test Object: Software
Test Precondition: 
    -   KaY unit initialized.
  
Test Execution: 
    01: Activate Participant_1.
    02: Parse transmitted MKPDU.
    03: VP(Mka.8021X.KeyServerElection.4.2,1) Verify that Key server field is 1, since MkaRole for Participant_1 is MKA_KEY_SERVER.
    04: VP(Mka.8021X.KeyServerElection.4.1,1)
        VP(Mka.CP_SWS_Mka_00011.1,1) Verify that Key server priority is encoded in MKPDU and set to 0 since MkaRole is MKA_PEER.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.4.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>200</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.4.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>199</internalId></provcov>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00011.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>319</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2124</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01057_KeyServerFlagAndPriority_Peer</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>1874</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that KaY correctly encodes Key server and Key server priority fields of Basic parameter set in the following configuration:
Test Object: Software
Test Precondition: 
    -   KaY unit initialized.
  
Test Execution: 
    01: Activate Participant_3.
    02: Parse transmitted MKPDU.
    03: VP(Mka.8021X.KeyServerElection.4.2,1) Verify that Key server field is 0, since MkaRole for Participant_3 is set to MKA_PEER.
    04: VP(Mka.8021X.KeyServerElection.4.1,1)
        VP(Mka.CP_SWS_Mka_00011.2,1) Verify that Key server priority is encoded in MKPDU and set according to 255 since MkaRole is MKA_PEER.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.4.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>200</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.4.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>199</internalId></provcov>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00011.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>320</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2125</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01058_EqualKeyServerPrioAndSci_NotElected</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>1904</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when participant, who wants to be a key server, receives MKPDU with equal Key server flag (1), Key server priority and SCI, key server will not be elected. Consequently SAK will not be generated and distributed.
Test Object: Key server election.
Test Precondition: 
    -   KaY unit initialized.
  
Test Execution: 
    01: Activate Participant_0.
    02: Create MKPDU from a peer that has equal Key server field, key server priority and SCI - different MemberId.
    03: Call Mka_KaY_RxMkpdu() to receive MKPDU to transit PeerSM into LIVE state.
    04: VP(Mka.8021X.KeyServerElection.6,1)
        VP(Mka.8021X.MkaTransport.15,1) Verify that SAK is not generated and distributed since Key Server is not elected because the Peers and Participants SCI are the same so the MKPDU has been ignored.
    05: Trigger TX_MKPDU timeout for Participant_0 and parse transmitted MKPDU.
    06: VP(Mka.8021X.KeyServerElection.6,1) Verify that participant did not distributed SAK (Distributed SAK). Verify that participant continued transmitting Announcement parameter set, indicating that key server election has not been elected. This consequently verifies that SAK generation, installation and distribution is suppressed key server is elected.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.6</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>203</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.MkaTransport.15</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>167</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2126</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01059_KeyServerElection_LowerSci</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>1932</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when participant, who wants to be a key server, receives MKPDU with equal Key server flag (1) and Key server priority but numerically lower SCI, the peer will be elected as key server. Consequently participant will not generate SAK, and will encode Key server bit to 0, indicating it has elected partner for a key server.
Test Object: Key server election.
Test Precondition: 
    -   KaY unit initialized.
  
Test Execution: 
    01: Activate Participant_0.
    02: Create MKPDU from a peer that has equal Key server field, key server priority but lower SCI.
    03: Call Mka_KaY_RxMkpdu() to receive MKPDU to transit PeerSM into LIVE state.
    04: VP(Mka.8021X.KeyServerElection.7,1) Verify that Key Server is elected since Logon unit is notified that participant has become successful actor (found a partner and elected a key server).
    05: Call Mka_KaY_KekGenerateFinished() to indicate that KEK is successfully generated.
    06: VP(Mka.8021X.KeyServerElection.7,1) Verify that participant has elected a partner for a key server since SAK generation is not requested.
    07: Trigger TX_MKPDU timeout for Participant_0 and parse transmitted MKPDU.
    08: VP(Mka.8021X.KeyServerElection.4.2,1) Verify that participant has elected a partner for a key server since Key server field is 0.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.7</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>204</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.4.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>200</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2127</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01060_KeyServerElection_HigherSci</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>1961</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when participant, who wants to be a key server, receives MKPDU with equal Key server flag (1) and Key server priority but numerically higher SCI, participant will elect self for key server and generate SAK.
Test Object: Key server election.
Test Precondition: 
    -   KaY unit initialized.
  
Test Execution: 
    01: Activate Participant_0.
    02: Create MKPDU from a peer that has equal Key server field, key server priority but lower SCI.
    03: Call Mka_KaY_RxMkpdu() to receive MKPDU to transit PeerSM into LIVE state.
    04: VP(Mka.8021X.KeyServerElection.7,1) Verify that Key Server is elected since Logon unit is notified that participant has become successful actor.
    05: Call Mka_KaY_KekGenerateFinished() to indicate that KEK is successfully generated.
    06: VP(Mka.8021X.KeyServerElection.7,1) Verify that participant has self for a key server since SAK generation is requested.
    07: Trigger TX_MKPDU timeout for Participant_0 and parse transmitted MKPDU.
    08: VP(Mka.8021X.KeyServerElection.4.2,1) Verify that participant has elected self for a key server since Key server field is 1.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.7</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>204</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.4.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>200</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2128</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01061_NotPrincipalActor_NoSak</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>1990</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when actor is elected to be a Key server, it will not generate or distribute SAK until it becomes a principal actor.
Test Object: SAK generation and distribution.
Test Precondition: 
    -   KaY unit initialized.
  
Test Execution: 
    01: disable participant to become principal instance
    02: Create participant that is not a principal actor..
    03: Simulate call from Crypto unti which provides member identifier.
    04: Create MKPDU from a peer Participant_3 that proves liveness to Participant_0.
    05: Receive created MKPDU from a peer - this will bring participant's PeerSM into LIVE state.
    06: VP(Mka.8021X.KeyServerElection.12,1) Verify that actor did not initiate SAK generation, since it is not principal actor.
    07: Trigger TX_MKPDU timeout for Participant_0 and parse transmitted MKPDU.
    08: VP(Mka.8021X.KeyServerElection.12,1) Verify that participant did not distributed SAK (Distributed SAK). Verify that participant stopped transmitting Announcement parameter set, which implicitly indicates that key server election was performed. This consequently verifies that SAK generation, installation and distribution is suppressed until elected key server becomes principal actor.
    09: Call Mka_KaY_SetPrincipalActor() to set Participant_0 as principal actor.
    10: VP(Mka.8021X.KeyServerElection.12,1) Verify after participant has become principal actor KEK generation is requested.
    11: Indicate that KEK is successfully generated.
    12: Indicate that SAK is generated and wrapped and trigger MKPDU transmission.
    13: VP(Mka.8021X.KeyServerElection.12,1) Verify after participant has become principal actor and SAK generation, installation and distribution are performed.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.12</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>208</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2129</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01062_AnnouncementParSet_9_6</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>2020</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies functionality of parsing MKPDU that contains Announcement parameter set and accessing parameter set data with MKA_LIB_GET_ANNOUNCEMENT_xxx macros.
Test Object: Mka_Lib_ParSet_ValidateMkaPduData function, MKA_LIB_GET_ANNOUNCEMENT_xxx macros.
Test Precondition: 
  
Test Execution: 
    01: Add Basic parameter set to Mkpdu.
    02: Sanity check - Parameter set appended OK.
    03: Add Announcement parameter set to Mkpdu.
    04: Sanity check - Parameter set appended OK.
    05: Call Mka_Lib_ParSet_ValidateMkaPduData() with valid MKPDU that contains Announcement set to decode MKPDU into MkaPdu structure.
    06: VP(Mka.CP_SWS_Mka_00008.6, 1) Verify that MKPDU was decoded successfully and Announcement parameter set was set correctly, also verify that MKA_LIB_GET_ANNOUNCEMENT_xxx macros are accessing correct (expected) data.
    07: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00008.6</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>314</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2130</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01063_AnnouncementParSet_9_6_Invalid</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>2043</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies functionality of parsing MKPDU that contains Announcement parameter set and accessing parameter set data with MKA_LIB_GET_ANNOUNCEMENT_xxx macros In all invalid cases.
Test Object: Mka_Lib_ParSet_ValidateMkaPduData function, MKA_LIB_GET_ANNOUNCEMENT_xxx macros.
Test Precondition: 
  
Test Execution: 
    01: Add Basic parameter set to Mkpdu.
    02: Sanity check - Parameter set appended OK.
    03: Add Announcement parameter set to Mkpdu.
    04: Sanity check - Parameter set appended OK.
    05: Call Mka_Lib_ParSet_ValidateMkaPduData() with valid MKPDU that contains Announcement set to decode MKPDU into MkaPdu structure.
    06: Sanity check - Parameter set validated OK.
    07: Set first Invalid cipher suite code Id only last part (only 1-4 is allowed).
    08: Set first Invalid cipher suite code Id first part (only 0x00U,0x80U,0xC2U,0x00U,0x01U,0x00U,0x00U allowed).
    09: Call Mka_Lib_ParSet_ValidateMkaPduData() with valid MKPDU that contains Announcement set to decode MKPDU into MkaPdu structure.
    10: Sanity check - Parameter set validated OK.
    11: VP(Mka.CP_SWS_Mka_CONSTR_00019.5, 1) Verify that no cipher shall be allowed because code id of each cipher is invalid.
    12: Set TLV_StringLength that is not divisible by 10 and is larger than 10.
    13: Change size of announcement parameter set body length to match new TLV_StringLength.
    14: Call Mka_Lib_ParSet_ValidateMkaPduData() with valid MKPDU that contains Announcement set to decode MKPDU into MkaPdu structure.
    15: VP(Mka.dsn.Lib.ParseMkpdu.Announcement.TlvStringLength, 1) Verify that Announcement parameter set is discarded because TLV string length is not multiple of 10.
    16: Return size of announcement parameter set body length to correct length.
    17: Set TLV_StringLength that is less than minimum (10).
    18: Call Mka_Lib_ParSet_ValidateMkaPduData() with valid MKPDU that contains Announcement set to decode MKPDU into MkaPdu structure.
    19: VP(Mka.dsn.Lib.ParseMkpdu.Announcement.TlvStringLength, 1) Verify that Announcement parameter set is discarded because TLV string length is less than one cipher info.
    20: Set TLV_Type to other than 112.
    21: Fix TLV_StringLength to correct value.
    22: Call Mka_Lib_ParSet_ValidateMkaPduData() with valid MKPDU that contains Announcement set to decode MKPDU into MkaPdu structure.
    23: VP(Mka.CP_SWS_Mka_00009, 1) Verify that Announcement parameter set is discarded because TLV type is not 112 (MACsec cipher suites).
    24: Change size of announcement parameter set body length to invalid length less than minimum allowed.
    25: Call Mka_Lib_ParSet_ValidateMkaPduData() with MKPDU that contains valid Basic and invalid Announcement parameter sets (body length invalid) to decode MKPDU into MkaPdu structure.
    26: VP(Mka.dsn.Lib.ParseMkpdu.Announcement.MinimumBodyLength, 1) Verify that MKPDU was decoded successfully and BasicParSetPtr was set correctly and AnnouncementPtr is NULL because of invalid body length of announcement parameter set.
    27: Add Basic parameter set to Mkpdu.
    28: Sanity check - Parameter set appended OK.
    29: Add Announcement parameter set to Mkpdu.
    30: Sanity check - Parameter set appended OK.
    31: Set cipher suite code Id if first announcement set EBTEST_GCM_AES_XPN_128 to make it supported .
    32: Add second Announcement parameter set to Mkpdu.
    33: Call Mka_Lib_ParSet_ValidateMkaPduData() with MKPDU that contains two valid Announcement parameter sets. First Announcement parameter set has EBTEST_GCM_AES_XPN_128 cipher supported and second one does not.
    34: VP(Mka.8021X.Eapol.29.2.6, 1) Verify that MKPDU was decoded successfully, AnnouncementPtr is set to first correct announcement parameter set in incoming Mkpdu. Test that EBTEST_GCM_AES_XPN_128 is supported which confirms that first correct parameter set is decoded.
    35: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_CONSTR_00019.5</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>334</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Lib.ParseMkpdu.Announcement.TlvStringLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1597</internalId></provcov>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00009</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>316</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Lib.ParseMkpdu.Announcement.MinimumBodyLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1596</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.Eapol.29.2.6</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>91</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2131</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01064_XPNParSet_9_7</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>2110</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies functionality of parsing MKPDU that contains XPN and accessing XPN parameters with MKA_LIB_GET_XPN_xxx macros.
Test Object: Mka_Lib_ParSet_ValidateMkaPduData function, MKA_LIB_GET_XPN_xxx macros.
Test Precondition: 
  
Test Execution: 
    01: Add Basic parameter set to Mkpdu.
    02: Sanity check - Parameter set appended OK.
    03: Add Announcement parameter set to Mkpdu.
    04: Sanity check - Parameter set appended OK.
    05: Call Mka_Lib_ParSet_ValidateMkaPduData() with valid MKPDU that contains Announcement set to decode MKPDU into MkaPdu structure.
    06: VP(Mka.CP_SWS_Mka_00008.7, 1) Verify that MKPDU was decoded successfully and Announcement parameter set was set correctly, also verify that MKA_LIB_GET_XPN_xxx macros are accessing correct (expected) data.
    07: Set invalid XPN parameter set body length (!=8).
    08: Call Mka_Lib_ParSet_ValidateMkaPduData() with MKPDU that contains valid Basic and invalid XPN parameter sets (body length invalid) to decode MKPDU into MkaPdu structure.
    09: VP(Mka.dsn.Lib.ParseMkpdu.XPN.BodyLength, 1) Verify that MKPDU was decoded successfully and BasicParSetPtr was set correctly and XPNPtr is NULL because of invalid body length of XPN parameter set.
    10: Return XPN parameter set body length to correct value(8) .
    11: Change LLPN in parameter set to identify it.
    12: Add another correct Announcement parameter set to Mkpdu.
    13: Call Mka_Lib_ParSet_ValidateMkaPduData() with MKPDU that contains two valid XPN parameter sets with different LLPN-s.
    14: VP(Mka.8021X.Eapol.29.2.6, 1) Verify that MKPDU was decoded successfully and that only first XPN parameter set is used by checking LLPN of decoded parameter set.
    15: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00008.7</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>315</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Lib.ParseMkpdu.XPN.BodyLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1598</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.Eapol.29.2.6</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>91</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2132</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01065_KaY_FillCipherAnnouncement</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>2149</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies functionality of adding Announcement parameter set to mkpdu using KaY_FillCipherAnnouncement.
Test Object: KaY_FillCipherAnnouncement function.
Test Precondition: 
    -   Mka_Init() initialized. KaY unit initialized.
  
Test Execution: 
    01: Create instance that is not principal actor and switch Instance SM to KAY_INSTANCE_RUNNING.
    02: Sanity check - Sanity check.
    03: Simulate call from Crypto unit which provides member identifier.
    04: Sanity check - Sanity check.
    05: Call Mka_KaY_TimerCallback_TxMkpdu() to simulate timeout for sending MKPDU.
    06: Call Mka_Lib_ParSet_ValidateMkaPduData() with valid MKPDU that contains Announcement set to decode MKPDU into MkaPdu structure.
    07: Sanity check - Sanity check Mkpdu was validated successfully.
    08: VP(Mka.CP_SWS_Mka_CONSTR_00019.5, 1)
        VP(Mka.CP_SWS_Mka_00008.6, 1) Verify that Announcement parameter was sent, MKPDU was decoded successfully and Announcement parameter set was set correctly
    09: VP(Mka.CP_SWS_Mka_00009.1, 1)
        VP(Mka.8021X.KeyServerElection.36, 1) Verify that only supported cipher suites are added to announcement parameter set.
    10: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_CONSTR_00019.5</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>334</internalId></provcov>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00008.6</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>314</internalId></provcov>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00009.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>317</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.36</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>238</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2133</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01066_SakReKey_LkPnExhaustion</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>2190</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that when participant is key server and receive MKPDU from peer that has inside of SAK Use parameter set Latest Lowest Acceptable PN equal the constant PendingPNExhaustion. When MKPDU is received, Key server shall start generating new SAK key.
Test Object: Rekey of SAK key when received Lowest Acceptable PN equal or exceeds the constant PendingPNExhaustion.
Test Precondition: 
    -   KaY unit initialized.
  
Test Execution: 
    01: Activate Participant_0.
    02: Create MKPDU from a peer Participant_3 that proves liveness to Participant_0.
    03: Receive created MKPDU from a peer - this will bring participant's PeerSM into LIVE state.
    04: Indicate that KEK is successfully generated.
    05: Indicate that SAK is generated and wrapped and trigger MKPDU transmission.
    06: Call Mka_KaY_TimerCallback_NewSakDelay() to indicate timeout of timer.
    07: Call Mka_KaY_PnExhausted() to signal that PN has become exhausted.
    08: VP(Mka.8021X.KeyServerElection.41,1)
        VP(Mka.dsn.KaY.Api.TimerCallback_NewSakDelay,1) Verify if Mka_Crypto_SakGenWrapAsync() was called which indicates that Key state machine started generating new SAK key.
    09: Indicate that SAK is generated and wrapped and trigger MKPDU transmission.
    10: VP(Mka.8021X.KeyServerElection.41,1) Verify that Distributed SAK contains new SAK key, increased AN and Key number.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.41</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>244</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.Api.TimerCallback_NewSakDelay</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1004</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2134</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01067_SakReKey_OkPnExhaustion</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>2222</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that when participant is key server and receive MKPDU from peer that has inside of SAK Use parameter set Old Lowest Acceptable PN equal the constant PendingPNExhaustion. When MKPDU is received, Key server shall start generating new SAK key.
Test Object: Rekey of SAK key when received Lowest Acceptable PN equal or exceeds the constant PendingPNExhaustion.
Test Precondition: 
    -   KaY unit initialized.
  
Test Execution: 
    01: Activate Participant_0.
    02: Create MKPDU from a peer Participant_3 that proves liveness to Participant_0.
    03: Receive created MKPDU from a peer - this will bring participant's PeerSM into LIVE state.
    04: Indicate that KEK is successfully generated.
    05: Indicate that SAK is generated and wrapped and trigger MKPDU transmission.
    06: Call Mka_KaY_TimerCallback_NewSakDelay() to indicate timeout of timer.
    07: Call Mka_KaY_PnExhausted() to signal that PN has become exhausted.
    08: VP(Mka.8021X.KeyServerElection.41,1)
        VP(Mka.8021X.KeyServerElection.42,1) Verify if Mka_Crypto_SakGenWrapAsync() was called which indicates that Key state machine started generating new SAK key after it received Lowest acceptable PN equal PendingPNExhaustion for 32-bit PNs (0xC000 0000).
    09: Indicate that SAK is generated and wrapped and trigger MKPDU transmission.
    10: VP(Mka.8021X.KeyServerElection.41,1) Verify that Distributed SAK contains new SAK key, increased AN and Key number.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.41</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>244</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.42</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>245</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2135</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01068_IncrementAn</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>2254</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that with every distribution of new SAK key increments AN and key number.
Test Object: AN increments as specified.
Test Precondition: 
    -   KaY unit initialized.
  
Test Execution: 
    01: Activate Participant_0.
    02: VP(Mka.8021X.MkaTransport.10.1,1) Verify that the message number has been set to one in RxMkpdu.
    03: Create MKPDU from a peer Participant_3 that proves liveness to Participant_0.
    04: Receive created MKPDU from a peer - this will bring participant's PeerSM into LIVE state.
    05: Call Mka_KaY_KekGenerateFinished() to indicate that KEK is successfully generated.
    06: VP(Mka.EB.KeyServerElection.43.1,1) Verify if Mka_Crypto_SakGenWrapAsync() was called which indicates that Key state machine started generating new SAK key when Live peer is found.
    07: Indicate that SAK is generated and wrapped and trigger MKPDU transmission.
    08: VP(Mka.8021X.MkaTransport.10.1,1) Verify that the message number has been set to one in RxMkpdu.
    09: VP(Mka.8021X.MkaTransport.10.1,1) Verify that the message number has been increase to 2 in TxMkpdu.
    10: Call Mka_KaY_TimerCallback_NewSakDelay() to indicate timeout of timer.
    11: Call Mka_KaY_PnExhausted() to signal that PN has become exhausted. This shall initiate transition to KAY_KEYSM_GENERATE_NEW_SAK and start generation of new SAK.
    12: Indicate that SAK is generated and wrapped and trigger MKPDU transmission.
    13: VP(Mka.EB.KeyServerElection.60,1) Verify that Distributed SAK has increased AN and Key number.
    14: Call Mka_KaY_TimerCallback_NewSakDelay() to indicate timeout of timer.
    15: Call Mka_KaY_PnExhausted() to signal that PN has become exhausted. This shall initiate transition to KAY_KEYSM_GENERATE_NEW_SAK and start generation of new SAK.
    16: Indicate that SAK is generated and wrapped and trigger MKPDU transmission.
    17: VP(Mka.EB.KeyServerElection.60,1) Verify that Distributed SAK has increased AN and Key number.
    18: Call Mka_KaY_TimerCallback_NewSakDelay() to indicate timeout of timer.
    19: Call Mka_KaY_PnExhausted() to signal that PN has become exhausted. This shall initiate transition to KAY_KEYSM_GENERATE_NEW_SAK and start generation of new SAK.
    20: Indicate that SAK is generated and wrapped and trigger MKPDU transmission.
    21: VP(Mka.EB.KeyServerElection.60,1) Verify that Distributed SAK has increased AN and Key number.
    22: Call Mka_KaY_TimerCallback_NewSakDelay() to indicate timeout of timer.
    23: Call Mka_KaY_PnExhausted() to signal that PN has become exhausted. This shall initiate transition to KAY_KEYSM_GENERATE_NEW_SAK and start generation of new SAK.
    24: Indicate that SAK is generated and wrapped and trigger MKPDU transmission.
    25: VP(Mka.EB.KeyServerElection.60,1) Verify that Distributed SAK has increased AN and Key number.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.MkaTransport.10.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>161</internalId></provcov>
        <provcov>
          <linksto>Mka.EB.KeyServerElection.43.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>248</internalId></provcov>
        <provcov>
          <linksto>Mka.EB.KeyServerElection.60</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>273</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2136</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01069_DistributedSak_CipherSuite_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>2304</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when participant receives MKPDU with our MI in its LivePeerList, but no announcement parameter set, behaviour will depend on configured value MkaAllowMissingAnnouncementParameterSet. If MkaAllowMissingAnnouncementParameterSet is set to FALSE, key server will be chosen and participant shall be deleted. If MkaAllowMissingAnnouncementParameterSet is set to TRUE, elected key server will chose Cipher suite that is configured with highest priority.
Test Object: Cipher Suite selection.
Test Precondition: 
    -   KaY unit initialized.
  
Test Execution: 
    01: Activate Participant_0.
    02: Create MKPDU from a peer Participant_3 that proves liveness to Participant_0.
    03: Call Mka_KaY_RxMkpdu() with MKPDU that doesn't have Announcement param.set.
    04: VP(Mka.dsn.KaY.CipherSuiteSelection.AnnouncementMissing,1) Verify that when MkaAllowMissingAnnouncementParameterSet is set to true and Announcement parameter set hasn't been received, participant chose CipherId with highest priority.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.CipherSuiteSelection.AnnouncementMissing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1575</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2137</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01070_DistributedSak_CipherSuite_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>2325</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when participant is elected to be a Key server, it will select cipher suite AES256 and encode this information in Distributed SAK parameter set.
Test Object: Distributed cipher suite in Distributed SAK.
Test Precondition: 
    -   KaY unit initialized.
  
Test Execution: 
    01: Activate Participant_0.
    02: Create MKPDU from a peer Participant_3 that proves liveness to Participant_0.
    03: Receive created MKPDU from a peer - this will bring participant's PeerSM into LIVE state.
    04: Indicate that KEK is successfully generated.
    05: Indicate that SAK is generated and wrapped and trigger MKPDU transmission.
    06: VP(Mka.8021X.KeyServerElection.33.1,1)
        VP(Mka.8021X.KeyServerElection.29,1)
        VP(Mka.CP_SWS_Mka_CONSTR_00019.2,1) Verify that participant filled distributed SAK with configured Cipher suite (MKA_GCM_AES_256). Participant choose Cipher Suite with lower priority, because Peer's MacSecCapability is equal or greater then key server's capability.
    07: VP(Mka.8021X.KeyServerElection.33.2,2) Verify that participant did distributed SAK (Distributed SAK). Verify that participant filled distributed SAK with configured Confidentiality Offset (MKA_CONFIDENTIALITY_OFFSET_0).
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.33.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>234</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.29</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>229</internalId></provcov>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_CONSTR_00019.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>331</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.33.2</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>235</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2138</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01071_DistributedSak_CipherSuite_3</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>2363</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when participant is elected to be a Key server, it will select cipher suite and encode this information in Distributed SAK parameter set.
Test Object: Distributed cipher suite in Distributed SAK.
Test Precondition: 
    -   KaY unit initialized.
  
Test Execution: 
    01: Activate Participant_2.
    02: Create MKPDU from a peer Participant_3 that proves liveness to Participant_2.
    03: Receive created MKPDU from a peer - this will bring participant's PeerSM into LIVE state.
    04: Indicate that KEK is successfully generated.
    05: Indicate that SAK is generated and wrapped and trigger MKPDU transmission.
    06: VP(Mka.8021X.KeyServerElection.33.1,1)
        VP(Mka.8021X.KeyServerElection.29,1) Verify that participant filled distributed SAK with configured Cipher suite (MKA_GCM_AES_XPN_128). Participant choose Cipher Suite with lower priority, because Peer's MacSecCapability is equal or greater then key server's capability.
    07: VP(Mka.8021X.KeyServerElection.33.2,2) Verify that participant did distributed SAK (Distributed SAK). Verify that participant filled distributed SAK with configured Confidentiality Offset (MKA_CONFIDENTIALITY_OFFSET_30).
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.33.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>234</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.29</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>229</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.33.2</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>235</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2139</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01072_CipherSuiteSelection_NoMatch</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>2396</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when participant is elected to be the Key server and receives Announcement parameter set with unsupported Cipher suite, the Key server shall reject that CipherSuite and delete the participant.
Test Object: Distributed cipher suite selection.
Test Precondition: 
    -   KaY unit initialized.
  
Test Execution: 
    01: Activate Participant_2.
    02: Create MKPDU from a peer Participant_3 that proves liveness to Participant_0.
    03: Call Mka_KaY_RxMkpdu() with MKPDU that doesn't have supported Cipher suite in Announcement param.set.
    04: VP(Mka.CP_SWS_Mka_00035,1) Verify that Mka_Logon_ReportEvent_Stub was called with correct parameters, which indicates that cipher suite were incompatible.
    05: VP(Mka.dsn.KaY.CipherSuiteSelection.NoMatch,2) Verify that participant was deleted since it couldn't find suitable Cipher.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00035</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>354</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.CipherSuiteSelection.NoMatch</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1576</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2140</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01073_CipherSuiteSelection_HighestPriority</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>2422</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when participant is elected to be a Key server and receives Announcement parameter set with multiple supported Cipher suites (all 4), it will choose Cipher suite with highest priority.
Test Object: Distributed cipher suite selection.
Test Precondition: 
    -   KaY unit initialized.
  
Test Execution: 
    01: Activate Participant_2.
    02: Create MKPDU from a peer Participant_3 that proves liveness to Participant_0.
    03: Receive created MKPDU from a peer - this will bring participant's PeerSM into LIVE state.
    04: Indicate that KEK is successfully generated.
    05: Indicate that SAK is generated and wrapped and trigger MKPDU transmission.
    06: VP(Mka.CP_SWS_Mka_CONSTR_00020.1,1)
        VP(Mka.8021X.KeyServerElection.29,1) Verify that participant filled distributed SAK with highest priority Cipher suite (MKA_GCM_AES_XPN_128).
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_CONSTR_00020.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>336</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.29</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>229</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2141</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01074_PnExhausted</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>2450</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when participant is elected to be a Key server and function Mka_KaY_PnExhausted() is called, generation of new SAK key is initiated.
Test Object: Mka_KaY_PnExhausted().
Test Precondition: 
    -   KaY unit initialized.
  
Test Execution: 
    01: Call Mka_KaY_PnExhausted() when there is no PrincipalActor on the selected PAE. Call shall be ignored.
    02: VP(Mka.dsn.KaY.Api.GetPrincipalActor.InvalidParticipant,1) Verify that the call was ignored because there is no PrincipalActor on the selected PAE.
    03: Activate Participant_0.
    04: Create MKPDU from a peer Participant_2 that will be the key server and prove liveness to Participant_0.
    05: Receive created MKPDU from a peer - this will bring participant's PeerSM into LIVE state.
    06: Call Mka_KaY_PnExhausted() to notify KaY unit, that our LowestPn reached value of PNExhaustion.
    07: Sanity check - Check that no further progress has been made since we are not the key server.
    08: Call for Mka_KaY_TimerCallback_PeerLifeTimeout() shall change PeerSM from Peer_Live to state Peer_Undetected.
    09: Activate Participant_0.
    10: Create MKPDU from a peer Participant_3 that will be the key server and prove liveness to Participant_0.
    11: Receive created MKPDU from a peer - this will bring participant's PeerSM into LIVE state.
    12: Indicate that KEK is successfully generated.
    13: Indicate that SAK is generated and wrapped.
    14: Call Mka_KaY_TimerCallback_NewSakDelay() to enable generation of new SAK.
    15: Call Mka_KaY_PnExhausted() to notify KaY unit, that our LowestPn reached value of PNExhaustion.
    16: VP(Mka.8021X.KeyServerElection.41,1) Verify that when Mka_KaY_PnExhausted() is called, when we are key server, generation of new SAK is started.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.Api.GetPrincipalActor.InvalidParticipant</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1584</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.41</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>244</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2142</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01075_LivePartnerRefreshedMI</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>2487</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that after our live partner changed it's MI, a new SAK was distributed.
Test Object: New SAK.
Test Precondition: 
    -   KaY unit initialized.
  
Test Execution: 
    01: Activate Participant_0.
    02: Create MKPDU from a peer Participant_3 that proves liveliness to Participant_0.
    03: Receive created MKPDU from a peer - this will bring participant's PeerSM into LIVE state.
    04: Indicate that KEK is successfully generated.
    05: Indicate that SAK is generated and wrapped and trigger MKPDU transmission.
    06: Add SAK Use parameter set to MKPDU.
    07: Call Mka_KaY_RxMkpdu() with MKPDU that contains SAK use parameter set and MN of 0xFFFFFFFF.
    08: Call Mka_KaY_TimerCallback_NewSakDelay() to indicate timeout of timer.
    09: Call Mka_KaY_RxMkpdu() with MKPDU that contains SAK use parameter set, MN that equals 0x01 and new MI.
    10: VP(Mka.EB.KeyServerElection.43.2,1) KaY unit shall recognize that peer changed it's MI after it's MN crossed the upper limit and it shall start generating new SAK.
    11: Indicate that SAK is generated and wrapped and trigger MKPDU transmission.
    12: Sanity check - Check that Distributed SAK has increased AN and Key number.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.KeyServerElection.43.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>249</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2143</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01076_TimerSakRekey</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>2516</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that after Mka Sak Rekey timer expires, a new Sak shall be generated.
Test Object: New SAK.
Test Precondition: 
    -   KaY unit initialized.
  
Test Execution: 
    01: Activate Participant_0.
    02: Create MKPDU from a peer Participant_3 that proves liveliness to Participant_0.
    03: Receive created MKPDU from a peer - this will bring participant's PeerSM into LIVE state.
    04: Indicate that KEK is successfully generated.
    05: Indicate that SAK is generated and wrapped and trigger MKPDU transmission.
    06: Add SAK Use parameter set to MKPDU.
    07: Call Mka_KaY_RxMkpdu() with MKPDU that contains SAK use parameter set.
    08: Call Mka_KaY_TimerCallback_NewSakDelay() so that the Key state machine transitions to KAY_KEYSM_WAIT_NEW_SAK_REQ.
    09: Call Mka_KaY_TimerCallback_MkaSakRekeyTimeSpan to simulate Sak Rekey timer expiration.
    10: VP(Mka.CP_SWS_Mka_00013,1)
        VP(Mka.dsn.KaY.Api.TimerCallback_MkaSakRekeyTimeSpan,1)
        VP(Mka.dsn.KaY.Api.GetPrincipalActor,1) Verify that the expiration of Sak Rekey timer triggered Sak Generation and Mka_Crypto_SakGenWrapAsync was called.
    11: VP(Mka.CP_SWS_Mka_00013,1) Verify that new SAK was generated after SakRekeyTimer expired and that correct Timers were started.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00013</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>322</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.Api.TimerCallback_MkaSakRekeyTimeSpan</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1005</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.Api.GetPrincipalActor</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1583</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2144</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01077_ParticipantRefreshedMi</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>2554</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that after MN exceeds maximum value (became 0U), participant will generate new MI.
Test Object: Refreshing MI.
Test Precondition: 
    -   KaY unit initialized.
  
Test Execution: 
    01: Activate Participant_0.
    02: Create MKPDU from a peer Participant_3 that proves liveness to Participant_0.
    03: Receive created MKPDU from a peer - this will bring participant's PeerSM into LIVE state.
    04: Call Mka_MainFunction() to process all changed and send new MKPDU.
    05: VP(Mka.dsn.KaY.ImmediatePeerResponse.PeerSM,1) Verify that when Peer SM transitioned to state Peer_Live, it immediately sent an mkpdu because Immediate Response is enabled.
    06: Set-up MessageNumber to 0xFFFFFFFF.
    07: Trigger MKPDU transmission.
    08: Call Mka_MainFunction() to process all changed and send new MKPDU.
    09: VP(Mka.8021X.MkaParticipantTimerValues.2,1) Verify that participant reinitialize timer after every transmission.
    10: VP(Mka.8021X.MkaTransport.13,1) Verify that participant initiate generating new MI when MN reaches its upper limit.
    11: Simulate that generation of MI is finished.
    12: Trigger MKPDU transmission.
    13: VP(Mka.8021X.MkaTransport.13,1) Verify that participant sent new MKPDU with new MI and MN set to 1. Check that key server continue to work uninterrupted.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.ImmediatePeerResponse.PeerSM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1578</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.MkaParticipantTimerValues.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>97</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.MkaTransport.13</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>165</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2145</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01078_KeyServerNewMi</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>2592</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies event when participant receives SAK Use and Distributed SAK from Key server with one MI. After participant receives new SAK Use from Key server with new MI, it continues normally.
Test Object: Refreshing MI.
Test Precondition: 
    -   KaY unit initialized.
  
Test Execution: 
    01: Activate Participant_0.
    02: Create MKPDU from a peer Participant_1 that proves liveness to Participant_0.
    03: Call Mka_KaY_RxMkpdu() to receive MKPDU to transit PeerSM into LIVE state.
    04: Call Mka_KaY_KekGenerateFinished() to indicate that KEK is successfully generated.
    05: Call Mka_KaY_SakUnwrapFinished() to simulate that was unwrapping finished.
    06: Call Mka_KaY_RxMkpdu() to receive MKPDU.
    07: VP(Mka.8021X.MkaTransport.13,1) Verify that KaY continues working uninterrupted when Key server changed its MI. KaY unit will re-start timer for PEER_LIFETIME and notify CP that key server is transmitting.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.MkaTransport.13</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>165</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2146</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01079_CheckSsci_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>2616</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that SSCI is correctly calculated when peer has greater SCI and XPN Cipher Suite is used. Test case also verifies that SSCI is sent only when MKPDU contains Distributed SAK parameter set.
Test Object: SSCI.
Test Precondition: 
    -   KaY unit initialized.
  
Test Execution: 
    01: Activate Participant_2.
    02: Create MKPDU from a peer Participant_3 that proves liveness to Participant_2.
    03: Receive created MKPDU from a peer - this will bring participant's PeerSM into LIVE state.
    04: Indicate that KEK is successfully generated.
    05: Indicate that SAK is generated and wrapped and trigger MKPDU transmission.
    06: VP(Mka.8021X.KeyServerElection.70,1) Verify that participant didn't fill SSCI when SAK isn't distributed.
    07: Indicate that SAK is generated and wrapped and trigger MKPDU transmission.
    08: Sanity check - Check that is chose Cipher suite AES-XPN-128.
    09: VP(Mka.8021X.KeyServerElection.70,1)
        VP(Mka.8021X.KeyServerElection.68,1)
        VP(Mka.8021X.KeyServerElection.72,1)
        VP(Mka.8021X.KeyServerElection.73,1)
        VP(Mka.CP_SWS_Mka_CONSTR_00019.4,1) Verify that participant filled SSCI when SAK is distributed. Verify that SSCI is equal to 2, because Participant_3 have greater SCI than Participant_2.
    10: VP(Mka.8021X.KeyServerElection.81,1) Verify that Live peer list is correctly encoded when using a XPN.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.70</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>283</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.68</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>281</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.72</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>284</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.73</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>285</internalId></provcov>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_CONSTR_00019.4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>333</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.81</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>293</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2147</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01080_CheckSsci_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>2667</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that SSCI is correctly calculated when participant has greater SCI and XPN Cipher Suite is used. Test case also verifies that SSCI is sent only when MKPDU contains Distributed SAK parameter set.
Test Object: SSCI.
Test Precondition: 
    -   KaY unit initialized.
  
Test Execution: 
    01: Activate Participant_2.
    02: Create MKPDU from a peer Participant_0 that proves liveness to Participant_2.
    03: Receive created MKPDU from a peer - this will bring participant's PeerSM into LIVE state.
    04: Indicate that KEK is successfully generated.
    05: Indicate that SAK is generated and wrapped and trigger MKPDU transmission.
    06: VP(Mka.8021X.KeyServerElection.70,1) Verify that participant didn't fill SSCI when SAK isn't distributed.
    07: Indicate that SAK is generated and wrapped and trigger MKPDU transmission.
    08: Sanity check - Check that is chose Cipher suite AES-XPN-128.
    09: VP(Mka.8021X.KeyServerElection.68,1)
        VP(Mka.8021X.KeyServerElection.70,1)
        VP(Mka.8021X.KeyServerElection.72,1)
        VP(Mka.8021X.KeyServerElection.73,1)
        VP(Mka.CP_SWS_Mka_CONSTR_00019.3,1) Verify that participant filled SSCI when SAK is distributed. Verify that SSCI is equal to 1, because Participant_3 have greater SCI than Participant_2.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.70</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>283</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.68</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>281</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.72</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>284</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.73</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>285</internalId></provcov>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_CONSTR_00019.3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>332</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2148</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01081_CheckSsci_3</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>2713</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that SSCI is 0 when XPN Cipher Suite is not used.
Test Object: SSCI.
Test Precondition: 
    -   KaY unit initialized.
  
Test Execution: 
    01: Activate Participant_1.
    02: Create MKPDU from a peer Participant_0 that proves liveness to Participant_1.
    03: Receive created MKPDU from a peer - this will bring participant's PeerSM into LIVE state.
    04: Indicate that KEK is successfully generated.
    05: Indicate that SAK is generated and wrapped and trigger MKPDU transmission.
    06: VP(Mka.8021X.KeyServerElection.70,1) Verify that participant didn't fill SSCI when SAK isn't distributed.
    07: Indicate that SAK is generated and wrapped and trigger MKPDU transmission.
    08: Sanity check - Check that default Cipher suite is chosen.
    09: VP(Mka.8021X.KeyServerElection.70,1)
        VP(Mka.8021X.KeyServerElection.68,1)
        VP(Mka.8021X.KeyServerElection.72,1)
        VP(Mka.8021X.KeyServerElection.73,1) Verify that participant filled SSCI when SAK is distributed. Verify that SSCI is equal to 0, because XPN isn't used.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.70</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>283</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.68</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>281</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.72</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>284</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.73</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>285</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2149</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01082_ImmediateResponse_SakGenerated</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>2754</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that Participant will immediate send response MKPDU after Sak was generated.
Test Object: Immediate Peer Response.
Test Precondition: 
    -   KaY unit initialized.
  
Test Execution: 
    01: Activate Participant_2.
    02: Create MKPDU from a peer Participant_3 that proves liveness to Participant_2.
    03: Receive created MKPDU from a peer - this will bring participant's PeerSM into LIVE state.
    04: Call Mka_MainFunction() to process all changed and send new MKPDU.
    05: Sanity check - Check that when Peer SM transitioned to state Peer_Live, it immediately sent an mkpdu because Immediate Response is enabled.
    06: Indicate that KEK is successfully generated.
    07: Indicate that SAK is generated and wrapped and trigger MKPDU transmission.
    08: VP(Mka.ECUC_Mka_00024,1) Verify that, since the Sak Rekey Timespan is set to zero in permutation P1, the timer for Sak Rekey shall not been started.
    09: Call Mka_MainFunction() to procces all changed and send new MKPDU.
    10: VP(Mka.dsn.KaY.ImmediatePeerResponse.SakGenerated,1) Verify that immediate MKPDU has been sent after Sak was generated because Mka Immediate Response is enabled.
    11: Sanity check - Check that is chose Cipher suite AES-XPN-128.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.ECUC_Mka_00024</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>415</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.ImmediatePeerResponse.SakGenerated</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1579</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2150</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01083_XpnSakUse</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>2786</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that if participant receive SAK Use with chosen Xpn Cipher suite and Mka_Cp_XLPn_Recovery() return Pn that is greater or equal than 0xC000000000000000 (64bit Pn Exhaustion), it will start generation of new SAK.
Test Object: 64bit Pn Exhaustion.
Test Precondition: 
    -   KaY unit initialized.
  
Test Execution: 
    01: Activate Participant_1.
    02: Create MKPDU from a peer Participant_0 that proves liveness to Participant_1.
    03: Receive created MKPDU from a peer - this will bring participant's PeerSM into LIVE state.
    04: Indicate that KEK is successfully generated.
    05: Indicate that SAK is generated and wrapped and trigger NewSakDelay timer.
    06: Add SAK Use in MKPDU and set-up stub callout for Mka_Cp_XLPn_Recovery().
    07: Call Mka_KaY_RxMkpdu() to receive MKPDU.
    08: Call Mka_KaY_PnExhausted() to simulate PN exhaustion.
    09: VP(Mka.CP_SWS_Mka_00014.2,1)
        VP(Mka.8021X.KeyServerElection.42,1)
        VP(Mka.CP_SWS_Mka_CONSTR_00019.3,1) Verify that KaY unit starts generating new SAK key, when transmitting PN is equal or greater than 64bit PN Exhaustion.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00014.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>325</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.42</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>245</internalId></provcov>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_CONSTR_00019.3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>332</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2151</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01084_InstSM_WaitFirstMemberId2WaitLinkActive</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>2822</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies transitions between instances of KaY instance state machine. Tested transition is from KAY_INSTANCE_WAIT_FIRST_MEMBER_ID to KAY_INSTANCE_WAIT_LINK_ACTIVE when Mka_KaY_RandomGenerateFinished() is called with Result == E_OK. and KAY_INSTANCE_WAIT_LINK_ACTIVE to KAY_INSTANCE_RUNNING when Mka_KaY_LinkStateActive() is called after Mka_KaY_RandomGenerateFinished().
Test Object: KaY instance state machine.
Test Precondition: 
    -   Mka_Init() initialized. KaY unit initialized. Stubs initialized.
  
Test Execution: 
    01: Call Mka_KaY_CreateParticipant() to transit from KAY_INSTANCE_DISABLED to KAY_INSTANCE_WAIT_FIRST_MEMBER_ID state.
    02: Call Mka_KaY_RandomGenerateFinished() with Result = E_OK for transition from KAY_INSTANCE_WAIT_FIRST_MEMBER_ID state to KAY_INSTANCE_WAIT_LINK_ACTIVE state.
    03: VP(Mka.dsn.KaY.InstSM.WaitFirstMemberId_2_WaitLinkActive,1) Verify that Mka_KaY_RandomGenerateFinished did not start sending MKPDUs and not made any function calls, it just transitioned to state KAY_INSTANCE_WAIT_LINK_ACTIVE, because link was not active before Mka_KaY_RandomGenerateFinished was called.
    04: Notify KaY that link state is active after Mka_KaY_RandomGenerateFinished notification has arrived to Transition from KAY_INSTANCE_WAIT_LINK_ACTIVE state to KAY_INSTANCE_RUNNING.
    05: VP(Mka.dsn.KaY.InstSM.WaitLinkActive_2_InstanceRunning,1) Verify that we transitioned from KAY_INSTANCE_WAIT_LINK_ACTIVE state to KAY_INSTANCE_RUNNING state. If function Mka_KaY_LinkStateActive() is called and instance is in state KAY_INSTANCE_WAIT_LINK_ACTIVE KaY will transit to the KAY_INSTANCE_RUNNING state and immediately transmit first MKPDU and start periodic TX MKPDU timer.
    06: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.InstSM.WaitFirstMemberId_2_WaitLinkActive</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1287</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.InstSM.WaitLinkActive_2_InstanceRunning</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1288</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2152</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01085_GetParticipantStatus</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>2849</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that MKA_LIB_GETConnectionStatus() returns correct ConnectionStatus and MKA_LIB_GETCknPeerSci encodes correctly Ckn and Ckn length, depending on states of PeerSM and InstanceSM.
Test Object: MKA_LIB_GETConnectionStatus() and MKA_LIB_GETCknPeerSci.
Test Precondition: 
    -   KaY unit initialized.
  
Test Execution: 
    01: Notify KaY that link state is active.
    02: Call MKA_LIB_GETConnectionStatus() to get status.
    03: VP(Mka.dsn.KaY.Api.GetConnectionStatus,1) Verify that MKA_LIB_GETConnectionStatus set status MKA_STATUS_UNDEFINED, because link state is active, but InstanceSM is still in disabled state.
    04: Activate Participant_0.
    05: Call MKA_LIB_GETConnectionStatus() to get status and CKN.
    06: VP(Mka.dsn.KaY.Api.GetConnectionStatus,1) Verify that MKA_LIB_GETConnectionStatus set status MKA_STATUS_WAITING_PEER, because link state is active, InstanceSM is running but we don't have any peer.
    07: Create MKPDU from a peer Participant_0 that proves liveness to Participant_1.
    08: Receive created MKPDU from a peer - this will bring participant's PeerSM into LIVE state.
    09: Call MKA_LIB_GETConnectionStatus() to get status and CKN.
    10: VP(Mka.dsn.KaY.Api.GetCknPeerSci,1) Verify that MKA_LIB_GETCknPeerSci set status MKA_STATUS_IN_PROGRESS, because link state is active, InstanceSM is running and we have live peer.
    11: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.Api.GetConnectionStatus</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>994</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.Api.GetCknPeerSci</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>995</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2153</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01086_DistributedSak_NoMatch</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>2881</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when participant receives MKPDU that has unsupported CipherSuite in it's DistributedSak parameter set, the key will not be installed and the participant shall be deleted.
Test Object: Cipher Suite selection.
Test Precondition: 
    -   KaY unit initialized.
  
Test Execution: 
    01: Activate Participant_0.
    02: Create MKPDU from a peer Participant_2 that proves liveliness to Participant_0.
    03: Add Announcement parameter set to Mkpdu with supported CipherSuite.
    04: Call Mka_KaY_RxMkpdu().
    05: Create MKPDU that has unsupported (XPN) CipherSuite in it's DistributedSak param. set.
    06: Increase the message number for RxMkpdu.
    07: Call Mka_KaY_RxMkpdu() to receive MKPDU that containst unsupported Cipher Suite in its DistributedSak param.set.
    08: VP(Mka.CP_SWS_Mka_00035,1) Verify that, after receiving Distributed Sak with unsupported CipherSuite, the event error has been reported by calling Mka_Logon_ReportEvent with MKA_E_ALGO_MISMATCH_INSTANCE.
    09: VP(Mka.dsn.KaY.DistributedCipherSuite.NoMatch,1) Verify that participant was deleted since the CipherSuite in the DistributedSak param.set is not supported.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00035</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>354</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.DistributedCipherSuite.NoMatch</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1577</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2154</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01087_EbTest_Peer_Announcement_Bits_NegativeCase</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>2911</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that the Potential, Live and Announcement parameter sets ignore the reserved bits when set to ones. Expected result is that the reserved bits are zero once transmitted.
Test Object: Potential, Live and Announcement Parameter Sets.
Test Precondition: 
    -   KaY unit initialized.
  
Test Execution: 
    01: Activate Participant_2.
    02: Create MKPDU from a peer Participant_3 that proves liveness to Participant_0.
    03: Set and Verify that Potential and Announcement Parameter reserved bits are set to one.
    04: Call Mka_KaY_RxMkpdu() with MKPDU that contains new Member Identifier and this new Member identifier and Message number tuple should be placed in Potential Peer list.
    05: VP(Mka.8021X.Eapol.22,1) Verify that reserved bits were ignored even though they're set to one.
    06: Trigger TX_MKPDU timeout for Participant_0 and parse transmitted MKPDU.
    07: VP(Mka.8021X.Eapol.22,1) Verify that Potential and Announcement Parameter reserved bits still have zeros.
    08: Create MKPDU from a peer Participant_3 that proves liveness to Participant_0.
    09: Set and Check that Live Peer List Parameters are zero.
    10: Receive created MKPDU from a peer - this will bring participant's PeerSM into LIVE state.
    11: Trigger TX_MKPDU timeout for Participant_0 and parse transmitted MKPDU.
    12: VP(Mka.8021X.Eapol.22,1) Verify Live Peer List Parameters are still zero.
    13: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.22</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>64</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2155</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01088_EbTest_Dist_SAK_Reserved_Bits_NegativeCase</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>2941</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies the Distributed SAK parameter set ignore the reserved bits when set to ones. Expected behavior is that transmitted parameter set contains zeros.
Test Object: Distributed SAK Parameter Set.
Test Precondition: 
    -   KaY unit initialized.
  
Test Execution: 
    01: Activate Participant_0.
    02: Create MKPDU from a peer Participant_1 that proves liveness to Participant_0. Participant_0 is PeerMessageNumber abd Participant 1 is Key Server.
    03: Call Mka_KaY_KekGenerateFinished() to indicate that KEK is successfully generated.
    04: Set and Verify that Dist SAK Parameter set has reserved bits set to ones.
    05: Call Mka_KaY_SakUnwrapFinished() to simulate that was unwrapping finished. When SAK is unwrapped, Key state machine should transit to KAY_KEYSM_WAIT_SAK_DISTRIBUTION.
    06: VP(Mka.8021X.Eapol.22,1) Verify if Cp unit was called to notify him about new SAK with function call Mka_Cp_NewSak(). This function call indicates previous self transition was successful, and that Dist Sak was correct.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.22</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>64</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2156</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01089_EbTest_Dist_SAK_Reserved_Bits_PositiveCase</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>2964</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies the Distributed SAK parameter are zero before and after transmission. Expected behavior is that transmitted parameter set contains zeros. Partner is elected key server and principal actor.
Test Object: Distributed SAK Parameter Set.
Test Precondition: 
    -   KaY unit initialized.
  
Test Execution: 
    01: Activate Participant_0.
    02: Create MKPDU from a peer Participant_1 that proves liveness to Participant_0. Participant_0 is PeerMessageNumber abd Participant 1 is Key Server.
    03: Call Mka_KaY_KekGenerateFinished() to indicate that KEK is successfully generated.
    04: Check that Dist SAK Parameter set has reserved bits set to zero.
    05: Call Mka_KaY_SakUnwrapFinished() to simulate that was unwrapping finished. When SAK is unwrapped, Key state machine should transit to KAY_KEYSM_WAIT_SAK_DISTRIBUTION.
    06: VP(Mka.8021X.Eapol.22,1) Verify if Cp unit was called to notify him about new SAK with function call Mka_Cp_NewSak(). This function call indicates previous self transition was successful, and that Dist Sak was correct.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.22</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>64</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2157</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01090_DeleteInstance_Potential</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>2987</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies MKA instance deletion with Mka_KaY_DeleteParticipant() when the PeerSM is Potential.
Test Object: MKA instance deletion.
Test Precondition: 
    -   KaY unit initialized.
    -   Switch Instance SM to KAY_INSTANCE_RUNNING.
  
Test Execution: 
    01: Create RxMkpdu for test that has a different MI than Participant_0.
    02: Call Mka_KaY_RxMkpdu() to change the state of Peer SM from Peer_Undetected to Peer_Potential.
    03: Call Mka_KaY_SetPrincipalActor(MKA_0).
    04: Call Mka_KaY_DeleteParticipant(MKA_0) to delete specified Mka instance.
    05: VP(Mka.dsn.KaY.Api.DeleteParticipant,2) Verify that EcuC_Timers_StopTimer() were called to stop all timers for deleted Mka instance indicating successful deletion of specified instance.
    06: Call Mka_KaY_DeleteParticipant(MKA_0) to try to delete specified Mka instance again.
    07: VP(Mka.dsn.KaY.Api.DeleteParticipant,2) Verify that Mka_KaY_DeleteParticipant() did nothing since instance is already deleted.
    08: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.Api.DeleteParticipant</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>991</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2158</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01091_PeerSM_Live2Undetected</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>3013</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies transition of Peer State Machine from Peer_Live to Peer_Undetected due to EthIf_MacSecInitRxSc returning E_NOT_OK.
Test Object: Software
Test Precondition: 
    -   KaY unit initialized.
  
Test Execution: 
    01: Activate Participant_0.
    02: Create MKPDU from a peer Participant_3 that proves liveness to Participant_0.
    03: Set EthIf_MacSecInitRxSc stub to return E_NOT_OK.
    04: Receive created MKPDU from a peer - this will try to bring participant's PeerSM into LIVE state, but fail due to EthIf_MacSecInitRxSc returning E_NOT_OK.
    05: VP(Mka.dsn.KaY.PeerSM.Any_2_Undetected,1) Verify that Peer SM transitioned to state Peer_Undetected after a call to EthIf_MacSecInitRxSc failed with E_NOT_OK.
    06: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.PeerSM.Any_2_Undetected</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1290</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2159</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01092_PeerSm_Live2Undetected_ResetRxSc_E_NOT_OK</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>3036</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that, if during the transition from Peer_Live to Peer_Undetected, a call to the EthIf_MacSecResetRxSc failed with E_NOT_OK, KaY unit shall disable this participant and call Mka_Logon_Participant_Disabled.
Test Object: KaY Peer State machine.
Test Precondition: 
    -   KaY unit initialized.
  
Test Execution: 
    01: Activate Participant_0.
    02: Create MKPDU from a peer Participant_3 that proves liveness to Participant_0.
    03: Transit KeySM to KAY_KEYSM_GENERATE_NEW_SAK.
    04: Set EthIf_MacSecResetRxSc stub to return E_NOT_OK.
    05: Call Mka_KaY_TimerCallback_PeerLifeTimeout() to simulate peer life timeout and consequently KeySM will transition to state KAY_KEYSM_DISABLED.
    06: VP(Mka.dsn.KaY.Api.PeerSM.Live2Undetected.EthIf_E_NOT_OK,1) Verify that, after EthIf_MacSecResetRxSc returned E_NOT_OK, participant was disabled.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.Api.PeerSM.Live2Undetected.EthIf_E_NOT_OK</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1580</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2160</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01093_MessageNumber_TooLow</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>3059</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when the received MKPDU has too low MessageNumber, it is discarded.
Test Object: Low MessageNumber.
Test Precondition: 
    -   KaY unit initialized.
  
Test Execution: 
    01: Activate Participant_0.
    02: Create MKPDU from a peer Participant_3 that proves liveness to Participant_0.
    03: Receive created MKPDU from a peer - this will bring participant's PeerSM into LIVE state.
    04: Trigger TxMkpdu timer several times to transmit several MKPDUs and increase participant's MessageNumber.
    05: Create new MKPDU with DistributedSak parameter set and unsupported Cipher suite.
    06: VP(Mka.8021X.MkaTransport.11,1) Verify that the MKPDU has been ignored since the MessageNumber in the peer list is too low compared to our participant's MN.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.MkaTransport.11</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>163</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2161</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01094_ParticipantPeer_SamePriority</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>3082</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when participant (role is peer) receives MKPDU with equal Key server flag (1), Key server priority and SCI, key server will not be elected. Consequently SAK will not be generated and distributed.
Test Object: Key server and Key server priority encoding.
Test Precondition: 
    -   KaY unit initialized.
  
Test Execution: 
    01: Activate Participant_3.
    02: Create MKPDU from a peer that has equal Key server field, key server priority and SCI - different MemberId.
    03: Call Mka_KaY_RxMkpdu() to receive MKPDU to transit PeerSM into LIVE state.
    04: VP(Mka.8021X.KeyServerElection.6,1) Verify that SAKs is not generated and distributed since Key Server is not elected, and it isn't called Mka_Cp_InitRxSc(). Accordingly, Instance is deleted.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.6</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>203</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2162</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01095_DistributedSak_InvalidCipherSuite</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>3103</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when participant receives MKPDU with DistributedSak that has invalid CipherSuite, KaY unit shall delete that participant.
Test Object: Cipher Suite selection.
Test Precondition: 
    -   KaY unit initialized.
  
Test Execution: 
    01: Activate Participant_0.
    02: Create MKPDU from a peer Participant_2 that proves liveliness to Participant_0.
    03: Add Announcement parameter set to Mkpdu with supported CipherSuite.
    04: Call Mka_KaY_RxMkpdu().
    05: Create MKPDU with invalid CipherSuit.
    06: Call Mka_KaY_RxMkpdu() to receive MKPDU.
    07: VP(Mka.8021X.KeyServerElection.35,2) Verify that participant has been deleted since it received invalid CipherSuite.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.35</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>237</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2163</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01096_DistributedSak_NoAesKeyWrap</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>3127</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when participant receives MKPDU with DistributedSak that has no CipherSuite and AesKeyWrap, it shall ignore it.
Test Object: Empty Distributed Sak.
Test Precondition: 
    -   KaY unit initialized.
  
Test Execution: 
    01: Activate Participant_0.
    02: Create MKPDU from a peer Participant_2 that proves liveliness to Participant_0.
    03: Add Announcement parameter set to Mkpdu with supported CipherSuite.
    04: Call Mka_KaY_RxMkpdu().
    05: Create MKPDU with Distributed Sak that has no CipherSuite nor Aes Key wrap.
    06: Call Mka_KaY_RxMkpdu() to receive MKPDU with no Aes Key wrap.
    07: VP(Mka.8021X.KeyServerElection.35,2) Verify that participant ignored the received Distributed Sak parameter set.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.35</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>237</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2164</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01097_KeySm_SelfTransit_GenerateKek</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>3151</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies self transition of KeySM in the state KAY_KEYSM_GENERATE_KEK.
Test Object: KaY Key state machine.
Test Precondition: 
    -   Module configuration initialized with Mka_Init().
  
Test Execution: 
    01: Activate Participant 0.
    02: Initialize Mkpdu with Basic and Live Parameter sets.
    03: Configure Mka_Crypto_KekGenerateAsync stub to return E_NOT_OK.
    04: Call Mka_KaY_RxMkpdu() with prepared MKPDU.
    05: Sanity check - Sanity check.
    06: VP(Mka.dsn.KaY.KeySM.Disabled_2_GenerateKek,2) Verify that Mka_Crypto_KekGenerateAsync() was called, indicating that participant has become principal actor, and KeySM has transitioned from KAY_KEYSM_DISABLED to KAY_KEYSM_GENERATE_KEK.
    07: VP(Mka.dsn.KaY.KeySM.SelfTrans.GenerateKek,1) Verify that Mka_Logon_Participant_Disabled() was called indicating self-transition in the state KAY_KEYSM_GENERATE_KEK, due to the fact that Mka_Crypto_KekGenerateAsync() returned E_NOT_OK.
    08: Activate Participant 0.
    09: Call Mka_KaY_RxMkpdu() with prepared MKPDU.
    10: Sanity check - Sanity check.
    11: Call Mka_KaY_KekGenerateFinished() with E_NOT_OK indicating that KEK generation has failed.
    12: VP(Mka.EB.RunTimeEvent.BitFieldDefinition,1)
        VP(Mka.EB.RunTimeEvent.TriggeredEventParticipant,1) Verify that, after Kek generate failed, a bit for that event has been set for the selected Participant.
    13: VP(Mka.dsn.KaY.KeySM.SelfTrans.GenerateKek,1) Verify that Mka_Logon_Participant_Disabled() was called indicating self-transition in the state KAY_KEYSM_GENERATE_KEK, due to the fact that Mka_KaY_KekGenerateFinished() reported E_NOT_OK.
    14: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.KeySM.Disabled_2_GenerateKek</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1424</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.KeySM.SelfTrans.GenerateKek</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1422</internalId></provcov>
        <provcov>
          <linksto>Mka.EB.RunTimeEvent.BitFieldDefinition</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1478</internalId></provcov>
        <provcov>
          <linksto>Mka.EB.RunTimeEvent.TriggeredEventParticipant</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1479</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2165</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01098_KaY_NewInfo</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>3195</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies the function of the Mka_KaY_NewInfo() functionality.
Test Object: Mka_KaY_NewInfo().
Test Precondition: 
    -   KaY unit initialized
  
Test Execution: 
    01: Activate Participant 0.
    02: Set the principal instance to the Pae of Participant 0.
    03: Sanity check - Sanity.
    04: Call Mka_KaY_NewInfo to trigger sending of Mkpdu.
    05: Call Mka_MainFunction() to process all changes and send new MKPDU.
    06: VP(Mka.dsn.KaY.Api.NewInfo,1) Verify that SendMkpdu was triggered.
    07: Call Mka_KaY_NewInfo() with non principal participant. No message queuing shall be done.
    08: Call Mka_MainFunction() to process all changes and send new MKPDU if queued by Mka_KaY_NewInfo.
    09: VP(Mka.dsn.KaY.Api.NewInfo,1) Verify that SendMkpdu was NOT triggered. Only unit main functions are processed and no transmit is done.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.Api.NewInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1001</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2166</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01099_PeerSM_KaYPrincipalActor</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>3221</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies both transition to and self transition of PeerSM in the state KAY_PEER_LIVE_PRINICIPAL.
Test Object: KaY Peer state machine.
Test Precondition: 
    -   Mka_Init() initialized.
  
Test Execution: 
    01: Switch Instance SM to KAY_INSTANCE_RUNNING.
    02: Create RxMkpdu for test that has a different MI than Participant_0
    03: Receive created MKPDU from a peer - this will bring participant's PeerSM into LIVE state.
    04: Sanity check - Sanity.
    05: Set Participant 0 to be principal actor.
    06: VP(Mka.dsn.KaY.PeerSM.Live_2_LivePrincipal,1) Verify that Mka_Cp_InitRxSc was call to confirm transition.
    07: Call Mka_KaY_RxMkpdu() to receive MKPDU.
    08: VP(Mka.dsn.KaY.PeerSM.SelfTrans.LivePrincipal.RxMkpdu,1) Verify that the received Mkpdu caused the self-transition in KAY_PEER_LIVE_PRINCIPAL.
    09: Call for Mka_KaY_TimerCallBack_PeerLifeTimeout() shall change PeerSM from Peer_Live to state Peer_Undetected.
    10: VP(Mka.EB.RunTimeEvent.BitFieldDefinition,1)
        VP(Mka.EB.RunTimeEvent.TriggeredEventParticipant,1) Verify that, after Peer Lifetime expired, a bit for that event has been set for the selected Participant.
    11: VP(Mka.dsn.KaY.PeerSM.Any_2_Undetected,1) Verify that the transition from Live to Undetected occurred.
    12: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.PeerSM.Live_2_LivePrincipal</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1294</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.PeerSM.SelfTrans.LivePrincipal.RxMkpdu</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1300</internalId></provcov>
        <provcov>
          <linksto>Mka.EB.RunTimeEvent.BitFieldDefinition</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1478</internalId></provcov>
        <provcov>
          <linksto>Mka.EB.RunTimeEvent.TriggeredEventParticipant</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1479</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.PeerSM.Any_2_Undetected</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1290</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2167</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01100_GetTxSaNextPn_Fail</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>3267</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that, if Mka_Cp_FillSakUse fails and returns E_NOT_OK, KaY unit will not continue to send the MKPDU.
Test Object: KaY MKPDU.
Test Precondition: 
    -   Mka_Init() initialized. KaY unit initialized. Stubs initialized.
  
Test Execution: 
    01: Call Mka_KaY_CreateParticipant() to transit from KAY_INSTANCE_DISABLED to KAY_INSTANCE_WAIT_FIRST_MEMBER_ID state.
    02: Call Mka_KaY_RandomGenerateFinished() with Result = E_OK for transition from KAY_INSTANCE_WAIT_FIRST_MEMBER_ID state to KAY_INSTANCE_WAIT_LINK_ACTIVE state.
    03: Set Mka_Cp_FillSakUse stub to return E_NOT_OK.
    04: Notify KaY that link state is active after Mka_KaY_RandomGenerateFinished notification has arrived to Transition from KAY_INSTANCE_WAIT_LINK_ACTIVE state to KAY_INSTANCE_RUNNING.
    05: Create MKPDU from a peer Participant_3 that proves liveness to Participant_0.
    06: Receive created MKPDU from a peer - this will bring participant's PeerSM into LIVE state.
    07: Call Mka_KaY_TimerCallback_TxMkpdu() for a Participant_0 to simulate timeout for sending MKPDU.
    08: Sanity check - Sanity check.
    09: VP(Mka.dsn.KaY.Retry.GetTxSaNextPn,1) Verify that, when the call to EthIf_MacSecGetTxSaNextPn fails (which is done in Cp unit when the Mka_Cp_FillSakUse is called and indicated by Mka_Cp_FillSakUse returning E_NOT_OK), the KaY unit will not send the MKPDU. This means that KaY unit will not call Mka_RxTx_TxBufferReady.
    10: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.Retry.GetTxSaNextPn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1585</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2168</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01101_KekGenerateFinished_Ignored</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>3294</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that, if Mka_KaY_KekGenerateFinished() is not called from KAY_KEYSM_GENERATE_KEK, the call will be ignored.
Test Object: KeySM.
Test Precondition: 
    -   KaY unit initialized. Stubs initialized.
  
Test Execution: 
    01: Call Mka_KaY_KekGenerateFinished() from an unexpected state, KAY_KEYSM_DISABLED.
    02: VP(Mka.dsn.KaY.KeySM.KekGenerateFinished.UnexpectedState,1) Verify that call to Mka_KaY_KekGenerateFinished() was ignored.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.KeySM.KekGenerateFinished.UnexpectedState</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1587</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2169</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01102_PeerLive_IgnoredMkpdu</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>3313</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that, if Mka_KaY_RxMkpdu() is called from KAY_PEER_LIVE state with an MKPUD from another (non-registered) partner, the call will be ignored.
Test Object: Mka_KaY_RxMkpdu().
Test Precondition: 
    -   Stubs initialized. KaY unit initialized.
    -   Create RxMkpdu with known MI
    -   Switch Instance SM to KAY_INSTANCE_RUNNING.
    -   Call Mka_KaY_RxMkpdu() with actors member ID in the Peer List to change state from Peer_Undetected to Peer_Live.
  
Test Execution: 
    01: Sanity check - Verify that after Peer SM transitioned to state Peer_Live, it called EcuC_Timers_StartTimerInternal to set the peer life timeout timer.
    02: Update RxMkpdu with an unknown SCI and member identifier.
    03: VP(Mka.dsn.KaY.PeerSM.SelfTrans.Live.PeerNotRegistered,1) Verify that Peer SM stayed in the same state and call was ignored.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.PeerSM.SelfTrans.Live.PeerNotRegistered</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1588</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2170</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01103_SendQueuedMkpdus_EmptyQueue</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>3336</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that, if MkaEnableImmediatePeerResponse is enabled and there are no queued MKPDUs, the call will be ignored.
Test Object: Mka_KaY_SendQueuedMkpdus().
Test Precondition: 
    -   KaY unit initialized. Stubs initialized.
  
Test Execution: 
    01: Call to Mka_MainFunction() which in turn calls Mka_KaY_SendQueuedMkpdus(), with no queued MKPDUs.
    02: VP(Mka.dsn.KaY.Api.SendQueuedMkpdus,1) Verify that call to Mka_KaY_SendQueuedMkpdus() from Mka_MainFunction() without queued MKPDUs didn't call any external function.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.Api.SendQueuedMkpdus</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1008</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2171</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01104_AllReceiving_Unexpected</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>3355</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that if Mka_KaY_AllReceiving() is called from an unexpected state (neither KAY_KEYSM_DELAY_NEW_SAK or KAY_KEYSM_WAIT_NEW_SAK_REQ) or without a principal actor, the call is ignored.
Test Object: Mka_KaY_AllReceiving.
Test Precondition: 
    -   KaY unit initialized. Stubs initialized.
  
Test Execution: 
    01: Set DistributeSak to TRUE to validate against change from Mka_KaY_AllReceiving().
    02: Set KeySM to state required by Mka_KaY_AllReceiving() but without a principal actor.
    03: Call Mka_KaY_AllReceiving() without principal actor.
    04: VP(Mka.dsn.KaY.Api.AllReceiving.UnexpectedState,1) Verify that unexpected call to Mka_KaY_AllReceiving() without a principal actor did not update DistributeSak property.
    05: Set KeySM to state required by Mka_KaY_AllReceiving() but without a principal actor.
    06: Call Mka_KaY_AllReceiving() without principal actor.
    07: VP(Mka.dsn.KaY.Api.AllReceiving.UnexpectedState,1) Verify that unexpected call to Mka_KaY_AllReceiving() without a principal actor did not update DistributeSak property.
    08: Set KeySM to invalid state for Mka_KaY_AllReceiving() but with a principal actor.
    09: Call Mka_KaY_AllReceiving() with a principal actor but not correct KeySM state.
    10: VP(Mka.dsn.KaY.Api.AllReceiving.UnexpectedState,1) Verify that unexpected call to Mka_KaY_AllReceiving() with a principal actor but not correct KeySM state did not update DistributeSak property.
    11: Set KeySM to invalid state for Mka_KaY_AllReceiving() but with a principal actor.
    12: Call Mka_KaY_AllReceiving() with a principal actor but not correct KeySM state.
    13: VP(Mka.dsn.KaY.Api.AllReceiving.UnexpectedState,1) Verify that unexpected call to Mka_KaY_AllReceiving() with a principal actor but not correct KeySM state did not update DistributeSak property.
    14: Set KeySM to invalid state for Mka_KaY_AllReceiving() but with a principal actor.
    15: Call Mka_KaY_AllReceiving() with a principal actor but not correct KeySM state.
    16: VP(Mka.dsn.KaY.Api.AllReceiving.UnexpectedState,1) Verify that unexpected call to Mka_KaY_AllReceiving() with a principal actor but not correct KeySM state did not update DistributeSak property.
    17: Set KeySM to state required by Mka_KaY_AllReceiving() and with a principal actor.
    18: Call Mka_KaY_AllReceiving() in the expected state.
    19: Sanity check - Check call to Mka_KaY_AllReceiving() with a principal actor and the correct KeySM state updated DistributeSak property.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.Api.AllReceiving.UnexpectedState</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1589</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2172</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01105_PeerPlainText_ParticipantIsNull</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>3391</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that if Mka_KaY_PeerPlainText is called with participant that is not the principal participant that the call is ignored.
Test Object: Mka_KaY_PeerPlainText.
Test Precondition: 
    -   KaY unit initialized
  
Test Execution: 
    01: Move Participant 0 into Instance Running state.
    02: Create Mkpdu.
    03: Call Mka_Kay_RxMkpdu to process changes.
    04: Sanity check - Sanity Check.
    05: Call Mka_KaY_PeerPlainText() with a Pae with no principal idx.
    06: VP(Mka.dsn.KaY.Api.PeerPlainText,1) Verify that no further calls were made since there is not a principal actor on Pae 2.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.Api.PeerPlainText</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1009</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2173</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01106_PeerPlainText_ParticipantNotKeyServer</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>3414</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that when Mka_KaY_PeerPlainText is called for a Pae Instance without a principal participant that is also the key server, the call is ignored.
Test Object: Mka_KaY_PeerPlainText.
Test Precondition: 
    -   KaY unit initialized
  
Test Execution: 
    01: Move Participant 0 into Instance Running state.
    02: Create Mkpdu.
    03: Call Mka_Kay_RxMkpdu to process changes.
    04: Sanity check - Sanity Check.
    05: Call Mka_KaY_PeerPlainText() with a Pae with no principal idx.
    06: VP(Mka.dsn.KaY.Api.PeerPlainText,1) Verify that no further calls were made since there is not a principal actor who is also a key server on Pae 0.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.Api.PeerPlainText</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1009</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2174</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01107_RxMkpdu_ElectedPartner_MacSecDisabled</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>3437</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that if empty parameter sets are not supported, and participant is not key server, the participant is not set as a successful actor.
Test Object: Mka_KaY_RxMkpdu.
Test Precondition: 
  
Test Execution: 
    01: Call Mka_KaY_RandomGenerateFinished() with Result = E_OK for transition from KAY_INSTANCE_WAIT_FIRST_MEMBER_ID state to KAY_INSTANCE_RUNNING state.
    02: Create RxMkpdu for test.
    03: Call Mka_KaY_RxMkpdu() with valid MKPDU.
    04: Sanity check - Sanity Check.
    05: VP(Mka.dsn.KaY.Api.RxMkpdu,1) Verify that since MacSec is enabled and empty parameter sets are not supported, Mka_Logon_Participant_SuccessfulActor is called in Kay_PeerSM_Entry_PEER_LIVE function with CipherId MKA_INVALID_CIPHER_SUITE_ID.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.Api.RxMkpdu</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1000</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2175</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01108_RxMkpdu_CheckPeerListMN_Failure</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>3458</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that if the participant message number is out of sync with the peer, the state machine is restarted.
Test Object: Mka_KaY_RxMkpdu.
Test Precondition: 
    -   KaY unit initialized.
  
Test Execution: 
    01: Call Mka_KaY_CreateParticipant() to transit from KAY_INSTANCE_DISABLED to KAY_INSTANCE_WAIT_FIRST_MEMBER_ID state.
    02: Call Mka_KaY_RandomGenerateFinished() with Result = E_OK for transition from KAY_INSTANCE_WAIT_FIRST_MEMBER_ID state to KAY_INSTANCE_RUNNING state.
    03: Create RxMkpdu for test.
    04: Modify the KaY Participant Message Number.
    05: Call Mka_KaY_RxMkpdu() with MKPDU that contains a much larger Message Number.
    06: Sanity check - Sanity Check.
    07: VP(Mka.dsn.KaY.Api.RxMkpdu,1) Verify that the Peer SM begins again since KaY Message Number was outside of threshold.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.Api.RxMkpdu</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1000</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2176</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01109_Capability_3</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>3482</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that when MkaMacSecCapability is set to MKA_INTEGRITY_AND_CONFIDENTIALITY, and MkaMacSecConfidentialityOffset is set to MKA_CONFIDENTIALITY_OFFSET_50, and a Tx Mkpdu is sent, it has the expected capability field set.
Test Object: KaY_CalculateConfidentialityOffset.
Test Precondition: 
    -   KaY unit initialized.
  
Test Execution: 
    01: Activate Participant_0.
    02: Create MKPDU from a peer Participant_3 that proves liveness to Participant_0.
    03: Receive created MKPDU from a peer - this will bring participant's PeerSM into LIVE state.
    04: Indicate that KEK is successfully generated.
    05: Indicate that SAK is generated and wrapped and trigger MKPDU transmission.
    06: VP(Mka.EB.KeyServerElection.27.1,1) Check if MACsec capability field has the value for integrity and confidentiality with selectable offset.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.KeyServerElection.27.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>225</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2177</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01110_VerifyConfidentiality_NoConfidentiality</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>3505</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that when Principal actor receives Distributed SAK from KeyServer that has lower capability, that SAK will be accepted.
Test Object: KaY_VerifyConfidentialityOffset.
Test Precondition: 
    -   KaY unit initialized.
  
Test Execution: 
    01: Activate Participant_3.
    02: Create MKPDU from a peer Participant_2 that proves liveliness to Participant_3.
    03: Receive created MKPDU from a peer - this will bring participant's PeerSM into LIVE state.
    04: Indicate that KEK is successfully generated.
    05: Add Distributed SAK in MKPDU.
    06: Call Mka_KaY_RxMkpdu() to receive MKPDU.
    07: VP(Mka.8021X.KeyServerElection.33.2,2) Verify that participant processed Distributed SAK and accepted lower capability than its own. Proof that Distributed SAK is accepted is function call Mka_Crypto_SakUnwrapAsync.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.33.2</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>235</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2178</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01111_VerifyConfidentiality_Confidentiality50</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>3529</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that when Principal actor receives Distributed SAK from KeyServer that has same capability 3, that SAK will be accepted.
Test Object: KaY_VerifyConfidentialityOffset.
Test Precondition: 
    -   KaY unit initialized.
  
Test Execution: 
    01: Activate Participant_3.
    02: Create MKPDU from a peer Participant_0 that proves liveliness to Participant_3.
    03: Receive created MKPDU from a peer - this will bring participant's PeerSM into LIVE state.
    04: Indicate that KEK is successfully generated.
    05: Add Distributed SAK in MKPDU.
    06: Call Mka_KaY_RxMkpdu() to receive MKPDU.
    07: VP(Mka.8021X.KeyServerElection.33.2,2) Verify that participant processed Distributed SAK and accepted lower capability than its own. Proof that Distributed SAK is accepted is function call Mka_Crypto_SakUnwrapAsync.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.KeyServerElection.33.2</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>235</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2179</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01112_MacSecDesired_Capability_0</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>3553</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that when received MKPDU contain flag for MacSecDesired True, but Capability is zero, MKDPU is discarded.
Test Object: KaY_CheckMacSecUsage.
Test Precondition: 
    -   KaY unit initialized.
  
Test Execution: 
    01: Activate Participant_3.
    02: Create MKPDU from a peer Participant_2 that proves liveliness to Participant_3.
    03: Call Mka_KaY_RxMkpdu() to receive MKPDU.
    04: VP(Mka.dsn.KaY.MacSecDesired.Discard,1) Verify that MKPDU is discarded, because of mismatch between MacSecDesired and Capability.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.MacSecDesired.Discard</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1591</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2180</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01113_TxSakUse_PrincipalOnly</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>3574</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies SAK Use parameter set is transmitted by principal participant only.
Test Object: SAK Use transmission
Test Precondition: 
    -   KaY unit initialized.
  
Test Execution: 
    01: Activate Participant_1 and Participant_2 located at PAEINSTANCE_1.
    02: Create MKPDU from a peer Participant_3 that proves liveness to Participant_1.
    03: Receive created MKPDU from a peer - this will bring Participant_1 PeerSM into LIVE state.
    04: Create MKPDU from a peer Participant_4 that proves liveness to Participant_2.
    05: Receive created MKPDU from a peer - this will bring Participant_2 PeerSM into LIVE state.
    06: Indicate that KEK is successfully generated for Participant_1 (principal participant).
    07: Indicate that SAK is generated and wrapped.
    08: Trigger txMkpdu timer for Participant_1.
    09: VP(Mka.dsn.KaY.TxSakUse_PrincipalOnly, 1) Verify that SAK Use parameter set is transmitted for Participant_1 as it is a principal actor.
    10: Trigger txMkpdu timer for Participant_2.
    11: VP(Mka.dsn.KaY.TxSakUse_PrincipalOnly, 1) Verify that SAK Use parameter set is not transmitted for Participant_2 as it is not principal actor.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.TxSakUse_PrincipalOnly</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1586</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2181</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01114_Rekeying_KeyServerChangesMi</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>3602</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that key server generates new SAK after it has changed its MI.
Test Object: New SAK.
Test Precondition: 
    -   KaY unit initialized.
  
Test Execution: 
    01: Activate Participant_0.
    02: Create MKPDU from a peer Participant_3 that proves liveliness to Participant_0.
    03: Receive created MKPDU from a peer - this will bring participant's PeerSM into LIVE state.
    04: Indicate that KEK is successfully generated.
    05: Indicate that SAK is generated and wrapped and trigger MKPDU transmission.
    06: Add SAK Use parameter set to MKPDU.
    07: Call Mka_KaY_RxMkpdu() with MKPDU that contains SAK use parameter set.
    08: Call Mka_KaY_TimerCallback_NewSakDelay() so that the Key state machine transitions to KAY_KEYSM_WAIT_NEW_SAK_REQ.
    09: Set-up key server's Message Number to 0xFFFFFFFF.
    10: Trigger MKPDU transmission.
    11: Call Mka_MainFunction() to process all changed and send new MKPDU.
    12: VP(Mka.8021X.MkaTransport.13,1) Verify that participant initiate generating new MI when MN reaches its upper limit.
    13: Simulate that generation of MI has finished.
    14: VP(Mka.dsn.KaY.Rekeying.KeyServerChangesMi,1) Verify that generation of a new SAK was requested because key server has changed its MI.
    15: VP(Mka.dsn.KaY.Rekeying.KeyServerChangesMi,1) Verify that new SAK was generated and CP unit informed about it because key server has changed its MI.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.MkaTransport.13</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>165</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.Rekeying.KeyServerChangesMi</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1593</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2182</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01115_KeySm_Disabled2GenerateNewSak_PresharedKek</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>3638</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies transitions of KeySM for elected key server in case pre-shared KEK is used: KAY_KEYSM_DISABLED -&amp;gt; KAY_KEYSM_GENERATE_NEW_SAK -&amp;gt; KAY_KEYSM_DELAY_NEW_SAK -&amp;gt; KAY_KEYSM_WAIT_NEW_SAK_REQ -&amp;gt; KAY_KEYSM_GENERATE_NEW_SAK.
Test Object: KaY Key state machine.
Test Precondition: 
    -   KaY unit initialized.
  
Test Execution: 
    01: Activate Participant 0.
    02: Create MKPDU sent from a participant with a lower key server priority then Participant_0.
    03: Call Mka_KaY_RxMkpdu() to receive created MKPDU to Participant_0 to initiate key server election.
    04: VP(Mka.dsn.KaY.KeySM.Disabled_2_GenerateNewSak,1) Verify that Mka_Crypto_SakGenWrapAsync() was called which indicates direct KeySM transition from KAY_KEYSM_DISABLED to KAY_KEYSM_GENERATE_NEW_SAK, as derivation of KEK is disabled.
    05: Call Mka_KaY_TimerCallback_NewSakDelay() to indicate timer expiration. Since KeySM is not in the state KAY_KEYSM_DELAY_NEW_SAK, the call shall be ignored.
    06: Call Mka_KaY_SakGenWrapFinished() with Result == E_OK to indicate successful generation of SAK.
    07: VP(Mka.dsn.KaY.KeySM.GenerateNewSak_2_DelayNewSak,1) Verify that Mka_Cp_NewSak() was called to notify CP unit about the new SAK and timers NEW_SAK_DELAY and SAK_REKEY are started which indicates transition from KAY_KEYSM_GENERATE_NEW_SAK to KAY_KEYSM_DELAY_NEW_SAK.
    08: Call Mka_KaY_TimerCallback_NewSakDelay() to indicate timer expiration. When timeout is processed, Key state machine should transit to KAY_KEYSM_WAIT_NEW_SAK_REQ.
    09: Call Mka_KaY_PnExhausted() to signal that PN has become exhausted. This shall initiate transition to KAY_KEYSM_GENERATE_NEW_SAK and start generation of new SAK.
    10: VP(Mka.dsn.KaY.KeySM.DelayNewSak_2_WaitNewSakReq,1)
        VP(Mka.dsn.KaY.KeySM.WaitNewSakReq_2_GenerateNewSak,1)
        VP(Mka.dsn.KaY.Api.PnExhausted,1) Verify that Mka_Crypto_SakGenWrapAsync() was called which indicates that Key state machine transitioned from KAY_KEYSM_WAIT_NEW_SAK_REQ to KAY_KEYSM_GENERATE_NEW_SAK. This transition also confirms that after function call Mka_KaY_TimerCallback_NewSakDelay(), Key state machine transitioned from KAY_KEYSM_DELAY_NEW_SAK to KAY_KEYSM_WAIT_NEW_SAK_REQ.
    11: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.KeySM.Disabled_2_GenerateNewSak</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1425</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.KeySM.GenerateNewSak_2_DelayNewSak</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1414</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.KeySM.DelayNewSak_2_WaitNewSakReq</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1412</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.KeySM.WaitNewSakReq_2_GenerateNewSak</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1427</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.Api.PnExhausted</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1006</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2183</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01116_KeySm_Disabled2WaitSakDistribution_PresharedKek</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>3684</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies transitions of KeySM for a participant which is NOT elected key server in case pre-shared KEK is used: KAY_KEYSM_DISABLED -&amp;gt; KAY_KEYSM_WAIT_SAK_DISTRIBUTION -&amp;gt; KAY_KEYSM_WAIT_SAK_UNWRAP -&amp;gt; KAY_KEYSM_WAIT_SAK_DISTRIBUTION.
Test Object: KaY Key state machine.
Test Precondition: 
    -   Module configuration initialized with Mka_Init().
  
Test Execution: 
    01: Activate Participant 0.
    02: Create MKPDU sent from a participant with a higher key server priority then Participant_0.
    03: Call Mka_KaY_RxMkpdu() to receive created MKPDU to Participant_0 to initiate key server election.
    04: VP(Mka.dsn.KaY.KeySM.Disabled_2_WaitSakDistribution,1) Verify that KeySM transitioned from KAY_KEYSM_DISABLED directly to KAY_KEYSM_WAIT_SAK_DISTRIBUTION, because neither Mka_Crypto_SakGenWrapAsync() nor Mka_Crypto_SakUnwrapAsync()were called. KeySM did not progress to KAY_KEYSM_WAIT_SAK_UNWRAP since Distributed SAK was not yet received.
    05: Add SAK Use use and Distributed SAK parameter set to RxMkpdu.
    06: Call Mka_KaY_RxMkpdu() with MKPDU that contains Live Peer list, SAK Use and Distributed SAK parameter sets and accordingly start process of unwrapping SAK key.
    07: Sanity check - Sanity check.
    08: VP(Mka.dsn.KaY.KeySM.WaitSakDistribution_2_WaitSakUnwrap,1) Verify if Mka_Crypto_SakUnwrapAsync() was called which indicates that Key State machine transitioned from KAY_KEYSM_WAIT_SAK_DISTRIBUTION to KAY_KEYSM_WAIT_SAK_UNWRAP. This transition also confirms that we were previously in the state KAY_KEYSM_WAIT_SAK_DISTRIBUTION.
    09: Call Mka_KaY_SakUnwrapFinished() to indicate that key unwrapping was finished. When SAK is unwrapped, Key state machine should transit to KAY_KEYSM_WAIT_SAK_DISTRIBUTION.
    10: VP(Mka.dsn.KaY.KeySM.WaitSakUnwrap_2_WaitSakDistribution_CryptoOk,1)
        VP(Mka.dsn.KaY.Api.SakUnwrapFinished,1) Verify that Mka_Cp_NewSak() was called to notify Cp unit about the new SAK, which verifies transition from KAY_KEYSM_WAIT_SAK_UNWRAP to KAY_KEYSM_WAIT_SAK_DISTRIBUTION.
    11: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.KeySM.Disabled_2_WaitSakDistribution</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1419</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.KeySM.WaitSakDistribution_2_WaitSakUnwrap</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1417</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.KeySM.WaitSakUnwrap_2_WaitSakDistribution_CryptoOk</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1420</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.Api.SakUnwrapFinished</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>997</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2184</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01117_PeerSM_LivePrincipal2Potential</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>3725</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies transition of PeerSM from the state KAY_PEER_LIVE_PRINICIPAL to KAY_PEER_POTENTIAL.
Test Object: KaY Peer state machine.
Test Precondition: 
    -   Mka_Init() initialized.
  
Test Execution: 
    01: Switch Instance SM to KAY_INSTANCE_RUNNING.
    02: Create RxMkpdu for test that has a different MI than Participant_0
    03: Progressing PeerSM to KAY_PEER_LIVE_PRINCIPAL.
    04: Call Mka_KaY_RxMkpdu() to receive MKPDU.
    05: Sanity check - Check that the received Mkpdu caused the self-transition in KAY_PEER_LIVE_PRINCIPAL.
    06: Call Mka_KaY_SakUnwrapFinished() to indicate that key unwrapping was finished. When SAK is unwrapped, Key state machine should transit to KAY_KEYSM_WAIT_SAK_DISTRIBUTION.
    07: Sanity check - Check that Mka_Cp_NewSak() was called to notify Cp unit about the new SAK, which verifies transition from KAY_KEYSM_WAIT_SAK_UNWRAP to KAY_KEYSM_WAIT_SAK_DISTRIBUTION.
    08: Call Mka_KaY_RxMkpdu() to receive MKPDU.
    09: VP(Mka.dsn.KaY.PeerSM.KeyServerReset,1)
        VP(Mka.dsn.KaY.PeerSM.LivePrincipal_2_Potential,1) Verify that, after the KeyServer got restarted (changed MI, but still the same SCI) and removed our MI from it's peer list, that we transitioned to KAY_PEER_POTENTIAL correctly.
    10: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.PeerSM.KeyServerReset</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1594</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.PeerSM.LivePrincipal_2_Potential</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1299</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2185</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01118_PeerSM_LivePrinciapl2Live</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>3757</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies transition of PeerSM from the state KAY_PEER_LIVE_PRINICIPAL to KAY_PEER_LIVE.
Test Object: KaY Peer state machine.
Test Precondition: 
    -   Mka_Init() initialized.
  
Test Execution: 
    01: Switch Instance SM to KAY_INSTANCE_RUNNING.
    02: Create RxMkpdu for test that has a different MI than Participant_0
    03: Progressing PeerSM to KAY_PEER_LIVE_PRINCIPAL.
    04: Call Mka_KaY_RxMkpdu() to receive MKPDU.
    05: Sanity check - Check that the received Mkpdu caused the self-transition in KAY_PEER_LIVE_PRINCIPAL.
    06: Call Mka_KaY_SakUnwrapFinished() to indicate that key unwrapping was finished. When SAK is unwrapped, Key state machine should transit to KAY_KEYSM_WAIT_SAK_DISTRIBUTION.
    07: Sanity check - Check that Mka_Cp_NewSak() was called to notify Cp unit about the new SAK, which verifies transition from KAY_KEYSM_WAIT_SAK_UNWRAP to KAY_KEYSM_WAIT_SAK_DISTRIBUTION.
    08: Call Mka_KaY_RxMkpdu() to receive MKPDU.
    09: VP(Mka.dsn.KaY.PeerSM.LivePrincipal_2_Live,1)
        VP(Mka.dsn.KaY.PeerSM.KeyServerReset,1) Verify that, after the KeyServer got restarted (changed MI, but still the same SCI) but didn't remove our MI from it's peer list, that we transitioned to KAY_PEER_LIVE correctly.
    10: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.PeerSM.LivePrincipal_2_Live</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1297</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.PeerSM.KeyServerReset</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1594</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2186</internalId></specobject>
    <specobject>
      <id>Mka_KaY_UnitTest01119_AnnouncementNotStopped</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_KaY/TestSpec_Generated.h</sourcefile>
      <sourceline>3789</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that transmission of Announcement parameter set does not stop after cipher suite is selected, when MkaStopTxAnnouncementAfterCipherSelected is disabled.
Test Object: MKPDU transmission.
Test Precondition: 
    -   KaY unit initialized.
  
Test Execution: 
    01: Activate Participant_2.
    02: Create MKPDU from a peer Participant_3 that proves liveness to Participant_0.
    03: Call Mka_KaY_RxMkpdu() to receive MKPDU that contains PPL with our Member identified.
    04: Trigger TX_MKPDU timeout for Participant_0 and parse transmitted MKPDU.
    05: VP(Mka.EB.KeyServerElection.36,1)
        VP(Mka.dsn.KaY.FillCipherAnnouncement.KeyServerState,2) Verify if participant send Announcement parameter set to advertise ALL configured Cipher Suites.
    06: Create MKPDU from a peer Participant_3 that proves liveness to Participant_0.
    07: Receive created MKPDU from a peer - this will bring participant's PeerSM into LIVE state and initiate cipher suite selection.
    08: Trigger TX_MKPDU timeout for Participant_0 and parse transmitted MKPDU.
    09: VP(Mka.EB.KeyServerElection.36,1)
        VP(Mka.dsn.KaY.FillCipherAnnouncement.KeyServerState,2) Verify if participant did not stop sending Announcement although cipher suite selection was performed as MkaStopTxAnnouncementAfterCipherSelected is disabled.
    10: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.KeyServerElection.36</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>239</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.KaY.FillCipherAnnouncement.KeyServerState</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1574</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2187</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>Mka_Lib_UnitTest01000_FirstTest</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Lib/TestSpec_Generated.h</sourcefile>
      <sourceline>9</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This is a test case template. This test tests for existence of Lib unit external (external only to module units) api-s.
Test Object: Mka_Lib unit external api and macro like functions existence.
Test Precondition: 
  
Test Execution: 
    01: Init Mka.
    02: Call Mka_Lib_ProcessTimers().
    03: VP(Mka.dsn.Lib.Api.ProcessTimers,1) Verify that Mka_Lib_ProcessTimers() called function EcuC_Timers_ProcessTimerTimeout().
    04: Call Mka_Lib_TimerCallback_General().
    05: VP(Mka.dsn.Lib.Api.TimerCallback_General,1) Verify existence of function Mka_Lib_TimerCallback_General().
    06: Call MKA_GET16().
    07: Call MKA_GET32().
    08: Call MKA_SET16().
    09: Call MKA_SET32().
    10: Sanity check - Sanity check
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Lib.Api.ProcessTimers</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1075</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Lib.Api.TimerCallback_General</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1076</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2188</internalId></specobject>
    <specobject>
      <id>Mka_Lib_UnitTest01001_CorrectlyCalledFunction</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Lib/TestSpec_Generated.h</sourcefile>
      <sourceline>39</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that all functions are called correctly.
Test Object: Mka_Lib unit external api and macro like functions existence.
Test Precondition: 
  
Test Execution: 
    01: Init Mka.
    02: Call Mka_Lib_Init().
    03: VP(Mka.dsn.Lib.SciBuffer_Init,1)
        VP(Mka.8021X.Eapol.8.1,1) Verify that Lib init filled the buffer containing SCIs for each Pae.
    04: VP(Mka.dsn.Lib.Api.Init,1) Check if Mka_Lib_Init() is called with correct timer pointer.
    05: Call Mka_Lib_StartTimer().
    06: VP(Mka.dsn.Lib.Api.StartTimer,1) Check if Mka_Lib_StartTimer() is recived correct input parameters.
    07: Call Mka_Lib_PauseTimer().
    08: VP(Mka.dsn.Lib.Api.PauseTimer,1) Check if Mka_Lib_PauseTimer() is called with correct parameters
    09: Call Mka_Lib_ResumeTimer().
    10: VP(Mka.dsn.Lib.Api.ResumeTimer,1) Check if Mka_Lib_ResumeTimer() is called with correct parameters.
    11: Call Mka_Lib_StopTimer().
    12: VP(Mka.dsn.Lib.Api.StopTimer,1) Check if Mka_Lib_StopTimer() is called with correct parameters.
    13: Call Mka_Lib_StartTimerAutorepeat().
    14: VP(Mka.dsn.Lib.Api.StartTimerAutorepeat,1) Check if Mka_Lib_StartTimerAutorepeat() is called with correct parameters.
    15: Call Mka_Lib_IsTimerStarted().
    16: VP(Mka.dsn.Lib.Api.IsTimerStarted,1) Verify that Mka_Lib_IsTimerStarted is called with correct parameters and it returned E_OK.
    17: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Lib.SciBuffer_Init</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1595</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.Eapol.8.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>43</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Lib.Api.Init</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1068</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Lib.Api.StartTimer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1070</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Lib.Api.PauseTimer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1073</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Lib.Api.ResumeTimer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1074</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Lib.Api.StopTimer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1072</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Lib.Api.StartTimerAutorepeat</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1071</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Lib.Api.IsTimerStarted</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1077</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2189</internalId></specobject>
    <specobject>
      <id>Mka_Lib_UnitTest01002_GetSciPtr</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Lib/TestSpec_Generated.h</sourcefile>
      <sourceline>105</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that API Mka_Lib_GetSciPtr returns correct value.
Test Object: Mka_Lib_GetSciPtr.
Test Precondition: 
  
Test Execution: 
    01: Init Mka and Lib.
    02: VP(Mka.dsn.Lib.Api.GetSciPtr,1) Verify that Mka_Lib_GetSciPtr returned the corrected and expected SCI for the given port (PaeIdx).
    03: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Lib.Api.GetSciPtr</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1069</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2190</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>Mka_Logon_UnitTest01001_LogonInit</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Logon/TestSpec_Generated.h</sourcefile>
      <sourceline>9</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that Mka_Logon_Init() shall call Mka_Crypto_IckGenerateAsync for each configured controlled port.
Test Object: Mka_Logon_Init().
Test Precondition: 
    -   Logon unit configuration initialized.
  
Test Execution: 
    01: Call Mka_Logon_Init() to initialize MKA Logon and Cp unit.
    02: VP(Mka.InterAct.Logon.Init,1)
        VP(Mka.dsn.Logon.Api.Init,1)
        VP(Mka.dsn.Logon.NvmSM.Init,1)
        VP(Mka.dsn.Logon.ParticipantSM.Init_2_GenerateIck_Auto,1) Verify that Mka_Crypto_IckGenerateAsync() was called for each configured controlled port.
    03: Sanity check - Sanity check
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.InterAct.Logon.Init</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1111</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Logon.Api.Init</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1041</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Logon.NvmSM.Init</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1400</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Logon.ParticipantSM.Init_2_GenerateIck_Auto</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1360</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2191</internalId></specobject>
    <specobject>
      <id>Mka_Logon_UnitTest01002_LogonIckGenerateFinished_Principal</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Logon/TestSpec_Generated.h</sourcefile>
      <sourceline>44</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that when Mka_Logon_IckGenerateFinished() API is called after Logon initialization, it shall call Mka_KaY_CreateParticipant() to create KaY Participant as principal actor for specified controlled port.
Test Object: Mka_Logon_IckGenerateFinished() after init.
Test Precondition: 
    -   Logon unit configuration initialized.
  
Test Execution: 
    01: Call Mka_Logon_IckGenerateFinished() for each configured controlled port.
    02: VP(Mka.dsn.Logon.Api.IckGenerateFinished,1)
        VP(Mka.CP_SWS_Mka_00002,1) Verify that Mka_KaY_CreateParticipant() is called with correct ParticipantIdx for controlled port, and principal is set to FALSE. Verify that this is done through all ports simultaneously.
    03: Sanity check - Link was active before Mka_Logon_IckGenerateFinished so Mka_KaY_LinkStateActive was called.
    04: Sanity check - Sanity check
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.Api.IckGenerateFinished</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1046</internalId></provcov>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>296</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2192</internalId></specobject>
    <specobject>
      <id>Mka_Logon_UnitTest01003_ParticipantSuccsessfulActor_DisableNonPrincipalParticipantsOn</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Logon/TestSpec_Generated.h</sourcefile>
      <sourceline>70</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that Mka_Logon_Participant_SuccessfulActor() shall set participant as principal and stop other participants if configured to do so with MKA_DISABLE_NON_PRINCIPAL_PARTICIPANTS.
Test Object: Mka_Logon_Participant_SuccessfulActor() after participant was created.
Test Precondition: 
    -   Logon unit configuration initialized.
  
Test Execution: 
    01: Call Mka_Logon_IckGenerateFinished() for each configured controlled port.
    02: VP(Mka.dsn.Logon.ParticipantSM.GenerateIck_2_Active,1) Verify that the transition to LOGON_PARTICIPANT_SM_ACTIVE occurred after Logon received Mka_Logon_IckGenerateFinished. Verify that Logon called Mka_KaY_CreateParticipant.
    03: Call Mka_Logon_Participant_SuccessfulActor() notify that participant has became successful actor and cipherId is selected meaning that participant is KeyServer and knows cipher suite at this stage.
    04: VP(Mka.dsn.Logon.ParticipantsRestartDisabled,1)
        VP(Mka.dsn.Logon.Api.ParticipantSuccessfulActor,2)
        VP(Mka.dsn.Logon.ParticipantSM.Active_2_SuccessfulActor,1) Verify that Mka_Logon_Participant_SuccessfulActor() shall call Mka_KaY_SetPrincipalActor() when there is no principal actor on configured controlled port.
    05: VP(Mka.dsn.Logon.Nvm.SetChangedStatus,1)
        VP(Mka.dsn.Logon.Api.ParticipantSuccessfulActor,2) Verify that when there are any change in Mka Nv memory, Mka shall mark memory block as changed with NvM_SetRamBlockStatus.
    06: Call Mka_Logon_Participant_SuccessfulActor() notify that participant has became successful actor and cipherId is not set (MKA_INVALID_CIPHER_SUITE_ID) meaning that participant is Peer and does not know cipher suite at this stage.
    07: VP(Mka.dsn.Logon.Api.ParticipantSuccessfulActor,2)
        VP(Mka.dsn.Logon.ParticipantSM.Active_2_SuccessfulActor,1) Verify that Mka_Logon_Participant_SuccessfulActor() shall call Mka_KaY_SetPrincipalActor() when there is no principal actor on configured controlled port.
    08: VP(Mka.dsn.Logon.ParticipantsRestartDisabled, 1)
        VP(Mka.dsn.Logon.ParticipantSM.Active_2_Disabled,1)
        VP(Mka.CP_SWS_Mka_00017, 1) Verify that if PAE has multiple participants, when one becomes principal participant, other participants are stopped and disabled if configured so MKA_DISABLE_NON_PRINCIPAL_PARTICIPANTS
    09: Call Mka_Logon_MainFunction() to check if disabled participants are not restarted.
    10: VP(Mka.dsn.Logon.ParticipantsRestartDisabled, 1) Verify that if PAE has multiple participants, when one becomes principal participant, other participants remain stopped if configured so MKA_DISABLE_NON_PRINCIPAL_PARTICIPANTS
    11: Sanity check - Sanity check
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.ParticipantSM.GenerateIck_2_Active</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1371</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Logon.ParticipantsRestartDisabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1601</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Logon.Api.ParticipantSuccessfulActor</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1042</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Logon.ParticipantSM.Active_2_SuccessfulActor</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1369</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Logon.Nvm.SetChangedStatus</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1610</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Logon.ParticipantSM.Active_2_Disabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1370</internalId></provcov>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00017</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>328</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2193</internalId></specobject>
    <specobject>
      <id>Mka_Logon_UnitTest01004_ParticipantSuccsessfulActor_DisableNonPrincipalParticipantsOff</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Logon/TestSpec_Generated.h</sourcefile>
      <sourceline>128</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that Mka_Logon_Participant_SuccessfulActor() shall set participant as principal and stop other participants if configured to do so with MKA_DISABLE_NON_PRINCIPAL_PARTICIPANTS.
Test Object: Mka_Logon_Participant_SuccessfulActor() after participant was created.
Test Precondition: 
    -   Logon unit configuration initialized.
  
Test Execution: 
    01: Call Mka_Logon_IckGenerateFinished() for each configured controlled port.
    02: Sanity check - Sanity check
    03: Call Mka_Logon_Participant_SuccessfulActor() for each configured controlled port to notify that participant has became successful actor.
    04: VP(Mka.dsn.Logon.ParticipantsRestartDisabled,1)
        VP(Mka.dsn.Logon.Api.ParticipantSuccessfulActor,2)
        VP(Mka.InterAct.Logon.Participant.Successful,1) Verify that Mka_Logon_Participant_SuccessfulActor() shall call Mka_KaY_SetPrincipalActor() when there is no principal actor on configured controlled port.
    05: VP(Mka.dsn.Logon.Nvm.SetChangedStatus,1)
        VP(Mka.dsn.Logon.Api.ParticipantSuccessfulActor,2) Verify that when there are any change in Mka Nv memory, Mka shall mark memory block as changed with NvM_SetRamBlockStatus.
    06: VP(Mka.dsn.Logon.ParticipantsRestartDisabled, 1) Verify that if PAE has multiple participants, when one becomes principal participant, other participants shall continue to work as before (no Mka_KaY_DeleteParticipant and no Mka_Crypto_Stop calls for other participants) if configured so MKA_DISABLE_NON_PRINCIPAL_PARTICIPANTS
    07: Sanity check - Sanity check
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.ParticipantsRestartDisabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1601</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Logon.Api.ParticipantSuccessfulActor</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1042</internalId></provcov>
        <provcov>
          <linksto>Mka.InterAct.Logon.Participant.Successful</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1115</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Logon.Nvm.SetChangedStatus</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1610</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2194</internalId></specobject>
    <specobject>
      <id>Mka_Logon_UnitTest01005_LogonIckGenerateFinished_PrincipalFalse</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Logon/TestSpec_Generated.h</sourcefile>
      <sourceline>167</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that when Mka_Logon_IckGenerateFinished() API is called after Logon initialization with E_NOT_OK it shall reset KaY Participant to default (disabled, Principal -&amp;gt; False) and not call any other API.
Test Object: Mka_Logon_IckGenerateFinished() after init.
Test Precondition: 
    -   Logon unit configuration initialized.
  
Test Execution: 
    01: Call Mka_Logon_IckGenerateFinished() for each configured controlled port to disable the participant.
    02: VP(Mka.dsn.Logon.Api.IckGenerateFinished,1)
        VP(Mka.dsn.Logon.ParticipantSM.GenerateIck_2_Init,1) Verify that no API was called as the participant is disabled and principal is set to False.
    03: VP(Mka.EB.RunTimeEvent.BitFieldDefinition,1)
        VP(Mka.EB.RunTimeEvent.TriggeredEventParticipant,1) Verify that, after Ick generate failed, a bit for that event has been set for the selected Participant.
    04: Call Mka_Logon_IckGenerateFinished again with E_OK to confirm that the participant has been disable. Mka_Logon_IckGenerateFinished shall not call Mka_KaY_CreateParticipant if the participant is disabled.
    05: VP(Mka.dsn.Logon.Api.IckGenerateFinished,1) Verify that Mka_KaY_CreateParticipant wasn't called as the participant is deleted, crypto operations stopped since call was unexpected.
    06: Sanity check - Sanity check
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.Api.IckGenerateFinished</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1046</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Logon.ParticipantSM.GenerateIck_2_Init</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1367</internalId></provcov>
        <provcov>
          <linksto>Mka.EB.RunTimeEvent.BitFieldDefinition</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1478</internalId></provcov>
        <provcov>
          <linksto>Mka.EB.RunTimeEvent.TriggeredEventParticipant</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1479</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2195</internalId></specobject>
    <specobject>
      <id>Mka_Logon_UnitTest01006_ParticipantDisabled_ParticipantRestarted</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Logon/TestSpec_Generated.h</sourcefile>
      <sourceline>204</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: This test verifies that when participant is stopped it will restart (create new participant).
Test Object: Mka_Logon_Participant_Disabled()
Test Precondition: 
    -   Logon unit configuration initialized.
  
Test Execution: 
    01: Call Mka_Logon_IckGenerateFinished() for each configured controlled port.
    02: Sanity check - Sanity check
    03: Call Mka_Logon_Participant_Disabled() To stop and restart Participant.
    04: VP(Mka.dsn.Logon.Api.ParticipantDisabled, 1)
        VP(Mka.dsn.Logon.ParticipantSM.ParticipantDisabled,1)
        VP(Mka.InterAct.Logon.Participant.Disabled,1)
        VP(Mka.dsn.Logon.ParticipantSM.ParticipantStop,1) Verify that participant stopped and deleted.
    05: Call Mka_MainFunction() to restart participant.
    06: VP(Mka.dsn.Logon.ParticipantsRestart, 1) Verify that participant is restarted within next Main function call.
    07: Sanity check - Sanity check
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.Api.ParticipantDisabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1043</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Logon.ParticipantSM.ParticipantDisabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1365</internalId></provcov>
        <provcov>
          <linksto>Mka.InterAct.Logon.Participant.Disabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1113</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Logon.ParticipantSM.ParticipantStop</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1366</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Logon.ParticipantsRestart</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1600</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2196</internalId></specobject>
    <specobject>
      <id>Mka_Logon_UnitTest01007_LogonSetCknStatus</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Logon/TestSpec_Generated.h</sourcefile>
      <sourceline>247</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that call to Mka_Logon_SetCknStatus shall set Participant status for given CAK name and Pae Index, to Enable = FALSE since default value is TRUE.
Test Object: Mka_Logon_SetCknStatus().
Test Precondition: 
    -   Logon unit configuration initialized.
  
Test Execution: 
    01: Sanity check - Participant 0 is enabled by default in Nv memory.
    02: Call Mka_Logon_SetCknStatus().
    03: VP(Mka.dsn.Logon.Api.SetCknStatus, 1) Verify that correct Participant status for given PAE and CKN is now disabled in Nv memory buffer and that memory is marked for write.
    04: Sanity check - Participant 0 is enabled by default in Nv memory.
    05: Call Mka_Logon_SetCknStatus() to Enabled.
    06: VP(Mka.dsn.Logon.Api.SetCknStatus, 1) Verify that correct Participant status for given PAE and CKN is not changed in Nv memory buffer and that memory is not marked for write.
    07: Sanity check - Sanity check
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.Api.SetCknStatus</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1047</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2197</internalId></specobject>
    <specobject>
      <id>Mka_Logon_UnitTest01008_ParticipantsRestart_MainFunction</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Logon/TestSpec_Generated.h</sourcefile>
      <sourceline>271</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that participant will be restarted with next call of main function, when is in INIT state.
Test Object: Participant will be restarted with Mka_Logon_MainFunction() if in INIT state.
Test Precondition: 
    -   Logon unit configuration initialized.
  
Test Execution: 
    01: Call EbTest_Logon_ParticipantSuccesfulActor() to make participant EBTEST_PARTICIPANT_IDX_1 principal actor, and EBTEST_PARTICIPANT_IDX_2 a successful actor.
    02: Call Mka_Logon_Participant_Disabled() to put participant into INIT state, because Mka_Crypto_IckGenerateAsync shall fail.
    03: Call Mka_Logon_MainFunction() to restart Participants.
    04: VP(Mka.dsn.Logon.ParticipantsRestart,1)
        VP(Mka.dsn.Logon.ParticipantSM.GenerateIck_2_Init,1) Verify that participant is restarted within Mka_Logon_MainFunction() call.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.ParticipantsRestart</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1600</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Logon.ParticipantSM.GenerateIck_2_Init</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1367</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2198</internalId></specobject>
    <specobject>
      <id>Mka_Logon_UnitTest01009_LogonReinit_StartPreviouslyPrincipalActor</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Logon/TestSpec_Generated.h</sourcefile>
      <sourceline>297</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that when participant becomes principal actor it is written to Nv memory. When Logon is re-initialized, it will start from previously successful principal actor that is stored in Nv memory
Test Object: Logon first starts participant that is stored in Nv memory as successful principal actor.
Test Precondition: 
    -   Logon unit configuration initialized.
  
Test Execution: 
    01: Call EbTest_Logon_ParticipantPrincipalActor() to make participant EBTEST_PARTICIPANT_IDX_2 principal actor, and to store this principal in Nv memory for next start.
    02: Mka configuration re-initialized.
    03: Logon unit re-initialized and MainFunction ticked.
    04: VP(Mka.dsn.Logon.ParticipantSM.Initialization,1) Verify that Logon unit called NvM during initialization.
    05: VP(Mka.dsn.Logon.PaeLastSuccessfulPrincipal,1)
        VP(Mka.dsn.Logon.ParticipantSM.Init_2_GenerateIck_Auto,1) Verify that Logon shall first start Participant that was previously principal actor.
    06: Mka_Logon_LinkStateChange to indicate that Link is active for PAE 1, and since we already have saved last principal participant in Nv memory to set its respective cipher suite .
    07: VP(Mka.dsn.Logon.PaeLastSuccessfulPrincipal,1) Verify that if there is participant that was previously principal actor, last used cipher suite is set that was uses by that participant.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.ParticipantSM.Initialization</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1364</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Logon.PaeLastSuccessfulPrincipal</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1603</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Logon.ParticipantSM.Init_2_GenerateIck_Auto</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1360</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2199</internalId></specobject>
    <specobject>
      <id>Mka_Logon_UnitTest01010_LogonReinit_StartPreviouslyPrincipalActor_Failed</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Logon/TestSpec_Generated.h</sourcefile>
      <sourceline>330</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that when participant becomes principal actor it is written to Nv memory. When during Logon's re-initialization Mka_Cp_SetCipherSuite() fails, PAE will be started as if there was no last principal participant stored in Nv memory.
Test Object: Logon first starts participant that is stored in Nv memory as successful principal actor.
Test Precondition: 
    -   Logon unit configuration initialized.
  
Test Execution: 
    01: Call EbTest_Logon_ParticipantPrincipalActor() to make participant EBTEST_PARTICIPANT_IDX_2 principal actor.
    02: Mka configuration re-initialized.
    03: Logon unit re-initialized.
    04: Mka_Logon_LinkStateChange to indicate that Link is active for PAE 1, and since we already have saved last principal participant in Nv memory to set its respective cipher suite .
    05: VP(Mka.dsn.Logon.PaeLastSuccessfulPrincipalFailed,1) Verify that during link state change to active, if Mka_Cp_SetCipherSuite fails participant shall be stopped and restarted in next main function.
    06: Call Mka_Logon_Main() to restart stopped participant.
    07: VP(Mka.dsn.Logon.ParticipantSM.SuccessfulActor_2_Init,1) Verify that, after Mka_Cp_SetCipherSuite returned E_NOT_OK, Logon restarted the Participants.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.PaeLastSuccessfulPrincipalFailed</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1604</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Logon.ParticipantSM.SuccessfulActor_2_Init</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1368</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2200</internalId></specobject>
    <specobject>
      <id>Mka_Logon_UnitTest01011_NextSuccessfulParticipantAsPrincipal</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Logon/TestSpec_Generated.h</sourcefile>
      <sourceline>358</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that when participant becomes principal actor and when is stopped, other successful actor will become principal actor.
Test Object: Principal actor is stopped and other successful actor on PAE become principal actor.
Test Precondition: 
    -   Logon unit configuration initialized.
  
Test Execution: 
    01: Call EbTest_Logon_ParticipantPrincipalActor() to make first participant on PAE 1 principal actor.
    02: Call EbTest_Logon_ParticipantSuccessfulActor() to make second participant on PAE 1 successful actor.
    03: Stop first (principal) participant on PAE 1.
    04: VP(Mka.dsn.Logon.NextSuccessfulParticipantAsPrincipal,1)
        VP(Mka.CP_SWS_Mka_00017,1) Verify that when participant actor is disabled, other successful actor will become principal actor in next main function call.
    05: Call Mka_MainFunction to start next principal instance.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.NextSuccessfulParticipantAsPrincipal</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1606</internalId></provcov>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00017</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>328</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2201</internalId></specobject>
    <specobject>
      <id>Mka_Logon_UnitTest01012_ReenableDisabledParticipants</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Logon/TestSpec_Generated.h</sourcefile>
      <sourceline>385</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that when principal actor is disabled and all participants are disabled on same PAE, all participants shall be restarted in next main call.
Test Object: Mka_Logon_MainFunction() restarts all participants on PAE 1 when they all become disabled.
Test Precondition: 
    -   Logon unit configuration initialized.
  
Test Execution: 
    01: Call EbTest_Logon_ParticipantPrincipalActor() to make first participant on PAE 1 principal actor.
    02: Stop first participant on PAE 1.
    03: Call Mka_Logon_MainFunction() to restart all Participants on PAE 1.
    04: VP(Mka.dsn.Logon.ReenableDisabledParticipants,1) Verify that Mka_Logon_MainFunction() shall enable and restart all participants on PAE 1 when all of them are disabled.
    05: Call EbTest_Logon_ParticipantPrincipalActor() to make first participant on PAE 1 principal actor.
    06: Call Mka_Logon_Participant_Actor() for Participant that is already principal, so that Logon restart Principal actor.
    07: Configure Mka_KaY_SetPrincipalActor() to return E_NOT_OK.
    08: Call Mka_Logon_MainFunction() to find new Principal actor.
    09: VP(Mka.dsn.Logon.ReenableDisabledParticipants,1) Verify that Mka_Logon_MainFunction() shall restart disabled participants on PAE 1 when new Principal actor can't be found.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.ReenableDisabledParticipants</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1607</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2202</internalId></specobject>
    <specobject>
      <id>Mka_Logon_UnitTest01013_MainFunction_RestartParticipant</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Logon/TestSpec_Generated.h</sourcefile>
      <sourceline>411</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that when crypto is failed to generate Kek and Ick, Participant shall be in Init state After function call Mka_Logon_MainFuction(), Participant is started again and Dirty flag is set to FALSE.
Test Object: Mka_Logon_MainFunction() restart participant in INIT state.
Test Precondition: 
    -   Logon unit configuration initialized.
  
Test Execution: 
    01: Call Mka_Logon_IckGenerateFinished() with E_NOT_OK for first participant on PAE 1.
    02: Call Mka_Logon_MainFunction() to restart Participant.
    03: VP(Mka.dsn.Logon.Api.MainFunction,1) Verify that when Mka_Logon_MainFuction() is called, Participant is started again and Mka_DirtyFlag isn't set to TRUE.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.Api.MainFunction</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1040</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2203</internalId></specobject>
    <specobject>
      <id>Mka_Logon_UnitTest01014_AutoStart</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Logon/TestSpec_Generated.h</sourcefile>
      <sourceline>431</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that Logon will start all enabled participants from PAE if it has configured MkaAutoStart = TRUE.
Test Object: MkaAutoStart.
Test Precondition: 
    -   Initialize MKA.
  
Test Execution: 
    01: Call Mka_Logon_Init() to initialize MKA Logon.
    02: VP(Mka.dsn.Logon.PaeMkaAutoStart,1)
        VP(Mka.CP_SWS_Mka_00005.1,1) Verify that when Mka_Logon_Init() is called, all participants are started if PAE has MkaAutoStart = TRUE.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.PaeMkaAutoStart</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1602</internalId></provcov>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00005.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>301</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2204</internalId></specobject>
    <specobject>
      <id>Mka_Logon_UnitTest01015_StartPae</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Logon/TestSpec_Generated.h</sourcefile>
      <sourceline>455</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that function call Mka_Logon_StartPae() will do nothing when called for PAE that is configured MkaAutoStart = True, but for PAR that is configured MkaAutoStart = False, it starts participants from PAE.
Test Object: Mka_Logon_StartPae().
Test Precondition: 
    -   Logon unit configuration initialized.
  
Test Execution: 
    01: Call Mka_Logon_StartPae() for PAE that is configured MkaAutoStart = TRUE.
    02: VP(Mka.CP_SWS_Mka_01004,1)
        VP(Mka.dsn.Logon.Api.StartPae,1) Verify that Mka_Logon_StartPae() did nothing when called for PAE that has MkaAutoStart = TRUE.
    03: Call Mka_Logon_StartPae() for PAE that is configured MkaAutoStart = FALSE.
    04: VP(Mka.CP_SWS_Mka_00029,1) Verify that Mka_Logon_StartPae() called Mka_Lib_StartTimer() for Permissive timer when LinkState is already up.
    05: VP(Mka.CP_SWS_Mka_01004,1)
        VP(Mka.dsn.Logon.Api.StartPae,1) Verify that Mka_Logon_StartPae() started participants for PAE that has MkaAutoStart = FALSE.
    06: VP(Mka.ECUC_Mka_00049,1) Verify that Mka_Logon_StartPae() started participants that have MkaParticipantActivate = TRUE, and it didn't start Participant_2, because it has MkaParticipantActivate = FALSE.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_01004</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>387</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Logon.Api.StartPae</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1052</internalId></provcov>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00029</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>347</internalId></provcov>
        <provcov>
          <linksto>Mka.ECUC_Mka_00049</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>443</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2205</internalId></specobject>
    <specobject>
      <id>Mka_Logon_UnitTest01016_MemoryInit</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Logon/TestSpec_Generated.h</sourcefile>
      <sourceline>492</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies when Logon is first time initialized it will fill Nv configuration memory with Post build parameters and default values and for next time.
Test Object: Mka_Logon_Init().
Test Precondition: 
    -   Reset Nv memory.
  
Test Execution: 
    01: initialize Logon unit.
    02: VP(Mka.CP_SWS_Mka_00027,1) Verify that Mka_Init() for first time filled Nv memory with Post build parameters and default values.
    03: VP(Mka.CP_SWS_Mka_00027,1) Verify that Nv memory is filled with default values for Enable parameter for every participant. Default value is configured value MkaParticipantActivate for every participant.
    04: VP(Mka.CP_SWS_Mka_00027,1) Verify that Nv memory is filled with Post build parameters. Default values are that PAE is enabled and MkaOnFailPermissiveMode is MKA_NEVER for every PAE.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00027</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>343</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2206</internalId></specobject>
    <specobject>
      <id>Mka_Logon_UnitTest01017_NvmGetStatus_ValidMemoryBlock</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Logon/TestSpec_Generated.h</sourcefile>
      <sourceline>513</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that when Nv memory block is valid, configuration shall be read during Mka_Init and used until next Mka restart.
Test Object: Nv memory.
Test Precondition: 
    -   Logon unit configuration initialized.
  
Test Execution: 
    01: Configure Nv memory - disable second participant on PAE 1.
    02: Call Mka_Logon_Init() to initialize MKA Logon.
    03: VP(Mka.dsn.Logon.Nvm.GetStatus,1)
        VP(Mka.dsn.Logon.NvmSM.Unknown_2_Valid_OK,1)
        VP(Mka.CP_SWS_Mka_00027.1,1) Verify that Logon read Nv memory block and NvM_GetErrorStatus returned NVM_REQ_OK and NvM_SetRamBlockStatus will return FALSE, that means that memory is valid, and it should not be rewritten. Logon only activated first participant from PAE 1.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.Nvm.GetStatus</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1609</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Logon.NvmSM.Unknown_2_Valid_OK</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1399</internalId></provcov>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00027.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>344</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2207</internalId></specobject>
    <specobject>
      <id>Mka_Logon_UnitTest01018_NvmGetStatus_InvalidMemoryBlock</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Logon/TestSpec_Generated.h</sourcefile>
      <sourceline>543</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that when Nv memory block is valid, configuration shall be read during Mka_Init and if PBcfgSignature does not match, Mka will fill Nv memory block with configured default values.
Test Object: Nv memory.
Test Precondition: 
  
Test Execution: 
    01: Clean Nv memory, all set to zero.
    02: Call Mka_Logon_Init() to initialize MKA Logon.
    03: VP(Mka.dsn.Logon.Nvm.GetStatus,1)
        VP(Mka.EB.MkaPostBuildConfigurationHash_Conf,1) Verify that Logon read Nv memory block and since PBcfgSignature does not match, Logon will fill Nv memory block with configured default values. Mka shall mark memory block as changed with NvM_SetRamBlockStatus.
    04: Sanity check - Check that are started all participants.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.Nvm.GetStatus</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1609</internalId></provcov>
        <provcov>
          <linksto>Mka.EB.MkaPostBuildConfigurationHash_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1449</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2208</internalId></specobject>
    <specobject>
      <id>Mka_Logon_UnitTest01019_NvmGetStatus_NvmReqNotOk</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Logon/TestSpec_Generated.h</sourcefile>
      <sourceline>568</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that when Nv memory block is valid, configuration shall be read during Mka_Init and when NvM_GetErrorStatus returns NVM_REQ_NOT_OK, Mka shall reset configuration to default values.
Test Object: Nv memory.
Test Precondition: 
  
Test Execution: 
    01: Call Mka_Logon_Init() to initialize MKA Logon.
    02: VP(Mka.dsn.Logon.Nvm.GetStatus,1)
        VP(Mka.dsn.Logon.NvmSM.Unknown_2_Valid_NOT_OK,1) Verify that Logon read Nv memory block and calls NvM_GetErrorStatus and receives Error status NVM_REQ_NOT_OK, Mka shall mark memory block as changed with NvM_SetRamBlockStatus.
    03: Sanity check - Check that are started all participants.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.Nvm.GetStatus</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1609</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Logon.NvmSM.Unknown_2_Valid_NOT_OK</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1398</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2209</internalId></specobject>
    <specobject>
      <id>Mka_Logon_UnitTest01020_SetCknStatus_DisableParticipant</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Logon/TestSpec_Generated.h</sourcefile>
      <sourceline>592</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that when configuration is changed with function call Mka_SetCknStatus() and participant continues to work normally until next initialization.
Test Object: Mka_SetCknStatus().
Test Precondition: 
    -   Logon unit configuration initialized.
  
Test Execution: 
    01: Call Mka_Logon_GetCknStatus() to get status of participant in Nv memory before it's disabled.
    02: VP(Mka.dsn.Logon.Api.GetCknStatus,1) Verify that Mka_Logon_GetCknStatus() returned right value for participant, TRUE.
    03: Call Mka_SetCknStatus() to disable second participant on PAE 1.
    04: VP(Mka.CP_SWS_Mka_01001,1) Verify that correct Participant status for given PAE and CKN is now disabled in Nv memory buffer and that memory is marked for write.
    05: Call Mka_Logon_GetCknStatus() to get status of participant in Nv memory after it's disabled.
    06: VP(Mka.dsn.Logon.Api.GetCknStatus,1) Verify that Mka_Logon_GetCknStatus() returned right value for participant, FALSE.
    07: Call Mka_Logon_IckGenerateFinished() for second participant on PAE 1.
    08: VP(Mka.CP_SWS_Mka_01001,1) Verify that disabled participant continues to work normally until next initialization.
    09: Re-init Logon unit.
    10: VP(Mka.CP_SWS_Mka_01001,1) Verify that disabled participant shall not be started in next initialization process.
    11: Call Mka_Logon_GetCknStatus() to get status of participant in Nv memory after re-init.
    12: VP(Mka.dsn.Logon.Api.GetCknStatus,1) Verify that Mka_Logon_GetCknStatus() returned right value for participant, FALSE.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.Api.GetCknStatus</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1048</internalId></provcov>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_01001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>378</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2210</internalId></specobject>
    <specobject>
      <id>Mka_Logon_UnitTest01021_SetCknStatus_EnableParticipant</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Logon/TestSpec_Generated.h</sourcefile>
      <sourceline>625</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that when configuration is changed with function call Mka_SetCknStatus() and participant don't work until next initialization.
Test Object: Mka_SetCknStatus().
Test Precondition: 
    -   Configure Nv memory - disable second participant on PAE 1.
  
Test Execution: 
    01: Logon unit configuration initialized.
    02: VP(Mka.CP_SWS_Mka_01001,1) Verify that disabled participant isn't initialized.
    03: Call Mka_Logon_GetCknStatus() to get status of participant in Nv memory before it's enabled.
    04: VP(Mka.dsn.Logon.Api.GetCknStatus,1) Verify that Mka_Logon_GetCknStatus() returned right value for participant, FALSE.
    05: Call Mka_SetCknStatus() to enable second participant on PAE 1.
    06: VP(Mka.CP_SWS_Mka_01001,1) Verify that correct Participant status for given PAE and CKN is now disabled in Nv memory buffer and that memory is marked for write.
    07: Call Mka_Logon_GetCknStatus() to get status of participant in Nv memory after it's enabled.
    08: VP(Mka.dsn.Logon.Api.GetCknStatus,1) Verify that Mka_Logon_GetCknStatus() returned right value for participant, TRUE.
    09: Re-init Logon unit.
    10: VP(Mka.CP_SWS_Mka_01001,1) Verify that disabled participant shall not be started in next initialization process.
    11: Call Mka_Logon_GetCknStatus() to get status of participant in Nv memory after re-init.
    12: VP(Mka.dsn.Logon.Api.GetCknStatus,1) Verify that Mka_Logon_GetCknStatus() returned right value for participant, FALSE.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_01001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>378</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Logon.Api.GetCknStatus</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1048</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2211</internalId></specobject>
    <specobject>
      <id>Mka_Logon_UnitTest01022_SetEnable_DisablePae</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Logon/TestSpec_Generated.h</sourcefile>
      <sourceline>658</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that when configuration is changed with function call Mka_SetEnable() and PAE continues to work normally until next initialization.
Test Object: Mka_SetEnable().
Test Precondition: 
    -   Logon unit configuration initialized.
  
Test Execution: 
    01: Call Mka_Logon_GetEnable() to get status of PAE in Nv memory before it's disabled.
    02: VP(Mka.dsn.Logon.Api.GetEnable,1) Verify that Mka_Logon_GetEnable() returned right value for PAE, TRUE.
    03: Call Mka_SetEnable() to disable PAE 1.
    04: VP(Mka.CP_SWS_Mka_01002,1) Verify that correct PAE status for given PAE is now disabled in Nv memory buffer and that memory is marked for write.
    05: Call Mka_Logon_GetEnable() to get status of PAE in Nv memory after it's disabled.
    06: VP(Mka.dsn.Logon.Api.GetEnable,1) Verify that Mka_Logon_GetEnable() returned right value for PAE, FALSE.
    07: Call Mka_Logon_IckGenerateFinished() for second participant on PAE 1.
    08: VP(Mka.CP_SWS_Mka_01002,1) Verify that disabled PAE continues to work normally until next initialization.
    09: Re-init Logon unit.
    10: VP(Mka.CP_SWS_Mka_01002,1) Verify that disabled participant shall not be started in next initialization process.
    11: Call Mka_Logon_GetEnable() to get status of PAE in Nv memory after re-init.
    12: VP(Mka.dsn.Logon.Api.GetEnable,1) Verify that Mka_Logon_GetEnable() returned right value for PAE, FALSE.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.Api.GetEnable</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1050</internalId></provcov>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_01002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>381</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2212</internalId></specobject>
    <specobject>
      <id>Mka_Logon_UnitTest01023_SetEnable_EnablePae</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Logon/TestSpec_Generated.h</sourcefile>
      <sourceline>691</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that when configuration is changed with function call Mka_SetEnable() and PAE don't work until next initialization.
Test Object: Mka_SetEnable().
Test Precondition: 
    -   Configure Nv memory - disable second participant on PAE 1.
  
Test Execution: 
    01: Logon unit configuration initialized.
    02: VP(Mka.CP_SWS_Mka_01002,1) Verify that disabled PAE isn't initialized.
    03: Call Mka_Logon_GetEnable() to get status of PAE in Nv memory before it's enabled.
    04: VP(Mka.dsn.Logon.Api.GetEnable,1) Verify that Mka_Logon_GetEnable() returned right value for PAE, FALSE.
    05: Call Mka_SetEnable() to enable PAE 1.
    06: VP(Mka.CP_SWS_Mka_01002,1) Verify that correct PAE status for given PAE is now enabled in Nv memory buffer and that memory is marked for write.
    07: Call Mka_Logon_GetEnable() to get status of PAE in Nv memory after it's enabled.
    08: VP(Mka.dsn.Logon.Api.GetEnable,1) Verify that Mka_Logon_GetEnable() returned right value for PAE, TRUE.
    09: Re-init Logon unit.
    10: VP(Mka.CP_SWS_Mka_01002,1) Verify that enabled participant shall be started in next initialization process.
    11: Call Mka_Logon_GetEnable() to get status of PAE in Nv memory after re-init.
    12: VP(Mka.dsn.Logon.Api.GetEnable,1) Verify that Mka_Logon_GetEnable() returned right value for PAE, TRUE.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_01002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>381</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Logon.Api.GetEnable</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1050</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2213</internalId></specobject>
    <specobject>
      <id>Mka_Logon_UnitTest01024_SetPaePermissiveMode</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Logon/TestSpec_Generated.h</sourcefile>
      <sourceline>724</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that when Nv memory block is valid, configuration shall be read during Mka_Init and when NvM_GetErrorStatus returns NVM_REQ_NOT_OK, Mka shall reset configuration to default values.
Test Object: Mka_Logon_SetPaePermissiveMode().
Test Precondition: 
    -   Logon unit configuration initialized.
  
Test Execution: 
    01: VP(Mka.dsn.Logon.Api.SetPaePermissiveMode,1) Verify that default configuration has MkaOnFailPermissiveMode = FALSE for both PAE.
    02: Call Mka_Logon_SetPaePermissiveMode() to set MkaOnFailPermissiveMode = TRUE for PAE 0 in Nv memory.
    03: VP(Mka.dsn.Logon.Api.SetPaePermissiveMode,1) Verify that when function Mka_Logon_SetPaePermissiveMode() is called with MKA_TIMEOUT for PermissiveMode, Mka will set in Nv memory that PAE is in permissive mode and mark Nv memory block for write.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.Api.SetPaePermissiveMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1051</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2214</internalId></specobject>
    <specobject>
      <id>Mka_Logon_UnitTest01025_ManualPaeStart</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Logon/TestSpec_Generated.h</sourcefile>
      <sourceline>744</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that function call Mka_Logon_StartPae() do nothing when called for PAE that has Autostart disabled and has activation status in Nv memory set as disabled, but if is enabled, it will start its all participants.
Test Object: Mka_Logon_StartPae().
Test Precondition: 
    -   Logon unit configuration initialized.
  
Test Execution: 
    01: Call Mka_Logon_StartPae() for PAE that has Autostart disabled and has activation status in Nv memory set as enabled.
    02: VP(Mka.dsn.Logon.ManualPaeStart,1)
        VP(Mka.dsn.Logon.ParticipantSM.Init_2_GenerateIck_Manual,1) Verify that Mka_Logon_StartPae() started PAE when PAE is enabled and has Autostart disabled.
    03: VP(Mka.ECUC_Mka_00049,1) Verify that Mka_Logon_StartPae() started participants that have MkaParticipantActivate = TRUE, and it didn't start Participant_2, because it has MkaParticipantActivate = FALSE.
    04: Call EbTest_Logon_SetEnable() to disable PAE 2.
    05: Re-init Logon.
    06: Call Mka_Logon_StartPae() for PAE that has Autostart disabled and has activation status in Nv memory set as disabled.
    07: VP(Mka.dsn.Logon.ManualPaeStart,1) Verify that Mka_Logon_StartPae() didn't start PAE when PAE is disabled and has Autostart disabled.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.ManualPaeStart</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1605</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Logon.ParticipantSM.Init_2_GenerateIck_Manual</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1361</internalId></provcov>
        <provcov>
          <linksto>Mka.ECUC_Mka_00049</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>443</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2215</internalId></specobject>
    <specobject>
      <id>Mka_Logon_UnitTest01026_LogonGetCknStatus</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Logon/TestSpec_Generated.h</sourcefile>
      <sourceline>777</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that call to Mka_Logon_GetCknStatus shall get configuration value (Enabled - True/False) for given Ckn-Participant from Nv memory
Test Object: Mka_Logon_GetCknStatus().
Test Precondition: 
    -   Logon unit configuration initialized.
  
Test Execution: 
    01: Sanity check - Participant 0 is enabled by default in Nv memory.
    02: Call Mka_Logon_GetCknStatus() to get status of participant in Nv memory.
    03: VP(Mka.dsn.Logon.Api.GetCknStatus,1) Verify that Mka_Logon_GetCknStatus() returned right value for participant, TRUE.
    04: Call Mka_SetCknStatus() to disable participant on PAE 0.
    05: Call Mka_Logon_GetCknStatus() to get status of participant in Nv memory.
    06: VP(Mka.dsn.Logon.Api.GetCknStatus,1) Verify that Mka_Logon_GetCknStatus() returned right value for participant, FALSE.
    07: Sanity check - Sanity check
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.Api.GetCknStatus</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1048</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2216</internalId></specobject>
    <specobject>
      <id>Mka_Logon_UnitTest01027_LogonSetEnable</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Logon/TestSpec_Generated.h</sourcefile>
      <sourceline>801</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that call to Mka_Logon_SetEnable shall set configuration value (Enabled - True/False) for given MkaPaeIdx in Nv memory and mark Nv memory block for write
Test Object: Mka_Logon_SetEnable().
Test Precondition: 
    -   Logon unit configuration initialized.
  
Test Execution: 
    01: Sanity check - PAE 0 configuration is enabled by default in Nv memory.
    02: Call Mka_Logon_SetEnable() to disable PAE 0 configuration.
    03: VP(Mka.dsn.Logon.Api.SetEnable,1) Verify Verify that given PAE configuration is now disabled and that memory is marked for write.
    04: Call Mka_Logon_SetEnable() to enable PAE 0 configuration.
    05: VP(Mka.dsn.Logon.Api.SetEnable,1) Verify Verify that given PAE configuration is now enabled and that memory is marked for write.
    06: Sanity check - Sanity check
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.Api.SetEnable</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1049</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2217</internalId></specobject>
    <specobject>
      <id>Mka_Logon_UnitTest01028_LogonGetEnable</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Logon/TestSpec_Generated.h</sourcefile>
      <sourceline>824</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that call to Mka_Logon_GetEnable shall get configuration value (Enabled - True/False) for given MkaPaeIdx from Nv memory
Test Object: Mka_Logon_GetEnable().
Test Precondition: 
    -   Logon unit configuration initialized.
  
Test Execution: 
    01: Sanity check - PAE 0 is enabled by default in Nv memory.
    02: Call Mka_Logon_GetEnable() to get PAE 0 configuration.
    03: VP(Mka.dsn.Logon.Api.GetEnable,1) Verify that Mka_Logon_GetEnable() returned right value for PAE, TRUE.
    04: Call Mka_SetEnable() to disable PAE 0.
    05: Call Mka_Logon_GetEnable() to get PAE 0 configuration.
    06: VP(Mka.dsn.Logon.Api.GetEnable,1) Verify that Mka_Logon_GetEnable() returned right value for PAE, FALSE.
    07: Sanity check - Sanity check
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.Api.GetEnable</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1050</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2218</internalId></specobject>
    <specobject>
      <id>Mka_Logon_UnitTest01029_LogonSetPaePermissiveMode</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Logon/TestSpec_Generated.h</sourcefile>
      <sourceline>848</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that call to Mka_SetPaePermissiveMode shall set permissive mode for given MkaPaeIdx in Nv memory and mark Nv memory block for write
Test Object: Mka_SetPaePermissiveMode().
Test Precondition: 
    -   Logon unit configuration initialized.
  
Test Execution: 
    01: Sanity check - PAE 0 permissive mode is MKA_NEVER by default in Nv memory.
    02: Call Mka_Logon_SetPaePermissiveMode() to set PAE 0 permissive mode to MKA_TIMEOUT.
    03: VP(Mka.dsn.Logon.Api.SetPaePermissiveMode,1) Verify that given PAE permissive mode is now set to MKA_TIMEOUT and that memory is marked for write.
    04: Call Mka_Logon_SetPaePermissiveMode() to set PAE 0 permissive mode to MKA_NEVER.
    05: VP(Mka.dsn.Logon.Api.SetPaePermissiveMode,1) Verify that given PAE permissive mode is now set to MKA_NEVER and that memory is marked for write.
    06: Sanity check - Sanity check
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.Api.SetPaePermissiveMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1051</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2219</internalId></specobject>
    <specobject>
      <id>Mka_Logon_UnitTest01030_GetPaeStatus</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Logon/TestSpec_Generated.h</sourcefile>
      <sourceline>871</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that Logon shall check PAE status and return correct MKA status.
Test Object: Mka_Logon_GetPaeStatus().
Test Precondition: 
    -   Logon unit configuration initialized.
  
Test Execution: 
    01: Call Mka_Logon_GetPaeStatus() to get a status for PAE 1.
    02: VP(Mka.dsn.Logon.Api.GetPaeStatus,1) Verify that Mka_Logon_GetPaeStatus() returned status MKA_STATUS_UNDEFINED for PAE 1.
    03: Call Mka_Logon_GetPaeStatus() to get a status for PAE 1 and bring link state to DOWN.
    04: VP(Mka.dsn.Logon.Api.GetPaeStatus,1) Verify that Mka_Logon_GetPaeStatus() returned status MKA_STATUS_WAITING_PEER_LINK for PAE 1.
    05: Configure Mka_KaY_GetConnectionStatus_Stub to return MKA_STATUS_IN_PROGRESS.
    06: Call Mka_Logon_GetPaeStatus() to get a status for PAE 1 and bring link state to UP.
    07: VP(Mka.dsn.Logon.Api.GetPaeStatus,1) Verify that Mka_Logon_GetPaeStatus() returned status MKA_STATUS_IN_PROGRESS for PAE 1.
    08: Configure Mka_KaY_GetConnectionStatus_Stub to return MKA_STATUS_WAITING_PEER.
    09: Call Mka_Logon_GetPaeStatus() to get a status for PAE 1.
    10: VP(Mka.dsn.Logon.Api.GetPaeStatus,1) Verify that Mka_Logon_GetPaeStatus() returned status MKA_STATUS_WAITING_PEER for PAE 1.
    11: Configure Mka_KaY_GetConnectionStatus_Stub to return MKA_STATUS_WAITING_PEER, Mka_RxTx_IsIcvErrorPresent_Stub returns TRUE.
    12: Call Mka_Logon_GetPaeStatus() to get a status for PAE 1.
    13: VP(Mka.dsn.Logon.Api.GetPaeStatus,1) Verify that Mka_Logon_GetPaeStatus() returned status MKA_STATUS_AUTH_FAIL_UNKNOWN_PEER for PAE 1, when Mka_RxTx_IsIcvErrorPresent_Stub returns TRUE and Mka_KaY_GetConnectionStatus_Stub returns MKA_STATUS_WAITING_PEER.
    14: Re-init Logon unit,make first participant on PAE 1 principal actor and indicate to Logon that MacSec is Operational.
    15: Sanity check - Sanity check
    16: Call Mka_Logon_GetPaeStatus() to get a status for PAE 1.
    17: VP(Mka.dsn.Logon.Api.GetPaeStatus,1)
        VP(Mka.dsn.Logon.Api.MacSecOperational,1) Verify that Mka_Logon_GetPaeStatus() returned status MKA_STATUS_MACSEC_RUNNING for PAE 1, when on PAE exist principal actor.
    18: Call Mka_Logon_GetPaeStatus() to get a status for PAE 2.
    19: VP(Mka.dsn.Logon.Api.GetPaeStatus,1) Verify that Mka_Logon_GetPaeStatus() returned status MKA_STATUS_UNDEFINED and CknLength 0 for PAE 2, because PAE 2 is disabled.
    20: Sanity check - Sanity check
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.Api.GetPaeStatus</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1053</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Logon.Api.MacSecOperational</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1055</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2220</internalId></specobject>
    <specobject>
      <id>Mka_Logon_UnitTest01031_PermissiveMode_StartTimer</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Logon/TestSpec_Generated.h</sourcefile>
      <sourceline>913</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that Logon will start timer MkaOnFailPermissiveModeTimeout if PermissiveMode is set to MKA_TIMEOUT. Logon will stop timer MkaOnFailPermissiveModeTimeout when one participant became principal actor on PAE.
Test Object: PermissiveMode timer.
Test Precondition: 
    -   Logon unit configuration initialized.
  
Test Execution: 
    01: Call Mka_Logon_StartPae() for PAE that has Autostart disabled and has activation status in Nv memory set as enabled.
    02: Call Mka_Logon_LinkStateChange() to put LinkState to Down, so it can be brough to Active.
    03: Call Mka_Logon_LinkStateChange() to activate LinkState.
    04: VP(Mka.CP_SWS_Mka_00029,1) Verify that timer for MkaOnFailPermissiveModeTimeout is started after LinkState became active.
    05: Call EbTest_Logon_IckGenerateFinished() for participant.
    06: Call Mka_Logon_Participant_SuccessfulActor() to notify that participant has became successful actor.
    07: VP(Mka.dsn.Logon.Api.ParticipantSuccessfulActor,2) Verify that Mka_Logon_Participant_SuccessfulActor() will not call Mka_Cp_SetCipherSuite() when received Cipher suite is already configured.
    08: Configure stub EcuC_Timers_IsTimerStarted to return E_NOT_OK, which indicate that participant reached MacSecOperational and stopped the timer.
    09: Stop first (principal) participant on PAE 2.
    10: VP(Mka.dsn.Logon.PermissiveMode.ResetTimer,1) Verify that timer for MkaOnFailPermissiveModeTimeout is restarted after principal actor got disabled.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00029</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>347</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Logon.Api.ParticipantSuccessfulActor</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1042</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Logon.PermissiveMode.ResetTimer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1614</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2221</internalId></specobject>
    <specobject>
      <id>Mka_Logon_UnitTest01032_PermissiveMode_TimerExpires</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Logon/TestSpec_Generated.h</sourcefile>
      <sourceline>948</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that when timer MkaOnFailPermissiveModeTimeout expires, Logon will call Cp unit to disable MacSec.
Test Object: PermissiveMode timer expires.
Test Precondition: 
    -   Logon unit configuration initialized.
  
Test Execution: 
    01: Call Mka_Logon_StartPae() for PAE that has Autostart disabled and has activation status in Nv memory set as enabled.
    02: Call EbTest_Logon_IckGenerateFinished() for participant.
    03: Call Mka_Logon_TimerCallback_PermissiveMode() for participant.
    04: VP(Mka.CP_SWS_Mka_00028,1)
        VP(Mka.dsn.Logon.Api.TimerCallback_PermissiveMode,1)
        VP(Mka.dsn.Logon.ParticipantSM.Any_2_Disabled,1) Verify that when timer MkaOnFailPermissiveModeTimeout expires, Cp unit is called to disable MacSec and stop all participants.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00028</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>345</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Logon.Api.TimerCallback_PermissiveMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1054</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Logon.ParticipantSM.Any_2_Disabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1373</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2222</internalId></specobject>
    <specobject>
      <id>Mka_Logon_UnitTest01033_PermissiveMode_LinkStateUpAndDown</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Logon/TestSpec_Generated.h</sourcefile>
      <sourceline>979</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that Logon will start timer MkaOnFailPermissiveModeTimeout if PermissiveMode is set to MKA_TIMEOUT and LinkState is up. When LinkState goes down, timer MkaOnFailPermissiveModeTimeout is stopped, and again bring it to LinkState up, it will start timer.
Test Object: PermissiveMode timer.
Test Precondition: 
    -   Logon unit configuration initialized.
  
Test Execution: 
    01: Call Mka_Logon_StartPae() for PAE that has Autostart disabled and has activation status in Nv memory set as enabled.
    02: Call Mka_Logon_LinkStateChange() to put LinkState to Down, so it can be brough to Active.
    03: Call Mka_Logon_LinkStateChange() to activate LinkState.
    04: VP(Mka.CP_SWS_Mka_00029,1) Verify that timer for MkaOnFailPermissiveModeTimeout is started after LinkState became active.
    05: Call Mka_Logon_LinkStateChange() to deactivate LinkState.
    06: VP(Mka.CP_SWS_Mka_00029,1)
        VP(Mka.dsn.Logon.ParticipantSM.LinkStateDown,1)
        VP(Mka.InterAct.LinkStateChange,1) Verify that timer for MkaOnFailPermissiveModeTimeout is stopped after LinkState became active.
    07: Call Mka_Logon_LinkStateChange() to activate LinkState.
    08: VP(Mka.CP_SWS_Mka_00029,1)
        VP(Mka.CP_SWS_Mka_00030,1) Verify that timer for MkaOnFailPermissiveModeTimeout is started after LinkState became active again, after it was already brought down.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00029</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>347</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Logon.ParticipantSM.LinkStateDown</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1363</internalId></provcov>
        <provcov>
          <linksto>Mka.InterAct.LinkStateChange</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1080</internalId></provcov>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00030</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>348</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2223</internalId></specobject>
    <specobject>
      <id>Mka_Logon_UnitTest01034_PermissiveMode_Disabled</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Logon/TestSpec_Generated.h</sourcefile>
      <sourceline>1019</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that Logon will not start timer MkaOnFailPermissiveModeTimeout if PermissiveMode is set to MKA_NEVER.
Test Object: PermissiveMode timer.
Test Precondition: 
    -   Logon unit configuration initialized.
  
Test Execution: 
    01: Call Mka_Logon_LinkStateChange() to put LinkState to Down, so it can be brough to Active.
    02: Call Mka_Logon_LinkStateChange() to activate LinkState on PAE 0.
    03: VP(Mka.CP_SWS_Mka_00029,1) Verify that timer for MkaOnFailPermissiveModeTimeout isn't started after LinkState became active, because PAE 0 has disabled PermissiveMode.
    04: Call Mka_Logon_LinkStateChange() to activate LinkState on PAE 1.
    05: VP(Mka.CP_SWS_Mka_00029,1)
        VP(Mka.CP_SWS_Mka_91012,1) Verify that timer for MkaOnFailPermissiveModeTimeout isn't started after LinkState became active, because PAE 1 has disabled PermissiveMode.
    06: Call Mka_Logon_StartPae() for PAE that has Autostart disabled and has enabled PermissiveMod.
    07: Call Mka_Logon_LinkStateChange() to activate LinkState PAE 2 to check if will start timer MkaOnFailPermissiveModeTimeout.
    08: VP(Mka.CP_SWS_Mka_00029,1)
        VP(Mka.CP_SWS_Mka_91012,1) Verify that timer for MkaOnFailPermissiveModeTimeout is started after LinkState became active, because PAE 2 has enabled PermissiveMode.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00029</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>347</internalId></provcov>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_91012</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>370</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2224</internalId></specobject>
    <specobject>
      <id>Mka_Logon_UnitTest01035_Dem_SetEventStatus</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Logon/TestSpec_Generated.h</sourcefile>
      <sourceline>1050</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that reporting Dem errors behaves as expected. After the error status gets changed, so it shall be reported via API Dem_SetEventStatus.
Test Object: Dem_SetEventStatus.
Test Precondition: 
    -   Logon unit configuration initialized.
  
Test Execution: 
    01: Call Mka_Logon_ReportEvent() for multiple participants to report multiple errors.
    02: VP(Mka.dsn.Logon.Api.ReportEvent,1) Verify that Logon called Dem_SetEventStatus only for PaeInstance 0, after Mka_Logon_ReportEvent.
    03: VP(Mka.EB.MkaReportEventCallout,1)
        VP(Mka.EB.MkaReportEventCallout_EventType,1) Verify that Logon called User_ReportEvent callout with correct parameters to report error event.
    04: VP(Mka.EB.MkaReportEventCallout,1)
        VP(Mka.EB.MkaReportEventCallout_EventType,1) Verify that Logon called User_ReportEvent callout with correct parameters to report error event.
    05: VP(Mka.EB.MkaReportEventCallout,1)
        VP(Mka.EB.MkaReportEventCallout_EventType,1) Verify that Logon called User_ReportEvent callout with correct parameters to report error event.
    06: VP(Mka.EB.MkaReportEventCallout,1)
        VP(Mka.EB.MkaReportEventCallout_EventType,1) Verify that Logon called User_ReportEvent callout with correct parameters to report error event.
    07: Call Mka_Logon_ReportEvent() with incorrect EventID
    08: VP(Mka.dsn.Logon.Api.ReportEvent,1) Verify that Logon has not made any API calls.
    09: Call Mka_Logon_MacSecOperational to indicate to Logon that MacSec is now operational on selected port.
    10: VP(Mka.EB.MkaReportEventCallout,1) Verify that Logon called User_ReportEvent callout with correct parameters to report error event.
    11: VP(Mka.EB.MkaReportEventCallout,1) Verify that Logon called User_ReportEvent callout with correct parameters to report error event.
    12: VP(Mka.CP_SWS_Mka_00036,1)
        VP(Mka.dsn.Logon.Api.MacSecOperational,1) Verify that Logon unit called Dem_SetEventStatus with DEM_EVENT_STATUS_PASSED for events that were previously reported on the PaeIdx that now transitioned to MacSec Operational.
    13: Call Mka_Logon_ReportEvent while MacSec is Operational. Logon shall ignore this call.
    14: Sanity check - Check that no API calls were made.
    15: Call Mka_Logon_MacSecOperational to process the error
    16: Call Mka_Logon_ReportEvent to log MKA_REPORT_EVENT_KEY_NOT_PRESENT error.
    17: Sanity check - Sanity
    18: Call Mka_Logon_TimerCallback_PermissiveMode to set MKA_TIMEOUT Dem error.
    19: VP(Mka.CP_SWS_Mka_00200,1)
        VP(Mka.CP_SWS_Mka_00028.1,1) Verify that Logon unit called Dem_SetEventStatus with DEM_EVENT_STATUS_FAILED for event MKA_E_TIMEOUT_INSTANCE.
    20: VP(Mka.EB.MkaReportEventCallout,1) Verify that Logon called User_ReportEvent callout with correct parameters to report error event.
    21: Sanity check - Check that no API calls were made.
    22: Call Mka_Logon_MacSecOperational to process the error
    23: VP(Mka.EB.MkaReportEventCallout,1) Verify that Logon called User_ReportEvent callout with correct parameters to report error event.
    24: VP(Mka.dsn.Logon.Api.MacSecOperational,1) Verify that MKA_REPORT_EVENT_KEY_NOT_PRESENT error was caught and processed.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.Api.ReportEvent</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1056</internalId></provcov>
        <provcov>
          <linksto>Mka.EB.MkaReportEventCallout</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1475</internalId></provcov>
        <provcov>
          <linksto>Mka.EB.MkaReportEventCallout_EventType</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1477</internalId></provcov>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00036</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>355</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Logon.Api.MacSecOperational</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1055</internalId></provcov>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00200</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>357</internalId></provcov>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00028.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>346</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2225</internalId></specobject>
    <specobject>
      <id>Mka_Logon_UnitTest01036_PaePermissiveMode_ReInit_Mode_Check</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Logon/TestSpec_Generated.h</sourcefile>
      <sourceline>1121</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: This test verifies that Permissive mode persists and is used on next initializtion from NvM.
Test Object: Mka_SetPaePermissiveMode.
Test Precondition: 
    -   Logon unit configuration initialized.
  
Test Execution: 
    01: Manually start Pae 2, which is configured to have EBTEST_MKA_TIMEOUT by default.
    02: VP(Mka.CP_SWS_Mka_01003,1) Verify that timer started for Pae 2.
    03: Change the permissive mode using Mka_Logon_SetPaePermissiveMode().
    04: Sanity check - Check that NvM was marked to change.
    05: Re-init Logon.
    06: Manually start Pae 2 again, which is now configured to have EBTEST_MKA_NEVER.
    07: Sanity check - Sanity Check.
    08: VP(Mka.CP_SWS_Mka_01003,1) Verify that no timer was started for Pae 2.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_01003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>385</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2226</internalId></specobject>
    <specobject>
      <id>Mka_Logon_UnitTest01037_Pae_DisabledPort</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Logon/TestSpec_Generated.h</sourcefile>
      <sourceline>1146</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that when the port is set to disabled, the participants are not started on next initialization.
Test Object: Mka_Cp_DisableMacSec().
Test Precondition: 
    -   initialize Logon.
  
Test Execution: 
    01: Call Mka_Logon_SetEnable to disable PAE 0.
    02: Sanity check - Sanity.
    03: Re-init Logon
    04: Sanity check - Sanity.
    05: VP(Mka.dsn.Logon.BypassMacSec.DisabledPort,2) Verify that Mka_Cp_DisableMacSec was called since port was disabled.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.BypassMacSec.DisabledPort</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1617</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2227</internalId></specobject>
    <specobject>
      <id>Mka_Logon_UnitTest01038_Pae_DisabledParticipants</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Logon/TestSpec_Generated.h</sourcefile>
      <sourceline>1168</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that when there is no CKN for all participants on the port and the Mka module is initialized, no participants on the PortIdx is started and Mka_Cp_DisableMacSec is called.
Test Object: Mka_Cp_DisableMacSec()
Test Precondition: 
    -   Initialize Logon.
  
Test Execution: 
    01: Call Mka_Logon_SetCknStatus to disable all participants on PAE 0.
    02: Call Mka_Logon_NvConfig_MacSecEnabled to disable MacSec.
    03: Sanity check - Sanity.
    04: Re-init Logon
    05: Sanity check - Sanity.
    06: VP(Mka.dsn.Logon.BypassMacSec.NoEnabledCakCkn,1) Verify that Mka_Cp_DisableMacSec was called since port was disabled.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.BypassMacSec.NoEnabledCakCkn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1618</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2228</internalId></specobject>
    <specobject>
      <id>Mka_Logon_UnitTest01039_ParticipantActor</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Logon/TestSpec_Generated.h</sourcefile>
      <sourceline>1191</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that when principal participant becomes only participant, Logon shall set another successful actor as principal. If called for non principal actor, logon will do nothing.
Test Object: Mka_Logon_Participant_Actor().
Test Precondition: 
    -   Logon unit configuration initialized.
  
Test Execution: 
    01: Call EbTest_Logon_ParticipantSuccesfulActor() to make participant EBTEST_PARTICIPANT_IDX_1 principal actor, and EBTEST_PARTICIPANT_IDX_2 a successful actor.
    02: Call Mka_Logon_Participant_Actor() to put participant actor into ACTIVE state.
    03: Call Mka_Logon_MainFunction() to process changes and make next successful participant as principal actor.
    04: VP(Mka.dsn.Logon.Api.ParticipantActor,1)
        VP(Mka.InterAct.Logon.Participant.Active,1) Verify that when principal actor became ACTIVE participant, next successful participant is set as principal actor.
    05: Call Mka_Logon_Participant_Actor() with participant that is not principal actor.
    06: VP(Mka.dsn.Logon.Api.ParticipantActor,1) Verify that when Mka_Logon_Participant_Actor() is called with non principal actor, nothing happens.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.Api.ParticipantActor</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1044</internalId></provcov>
        <provcov>
          <linksto>Mka.InterAct.Logon.Participant.Active</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1114</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2229</internalId></specobject>
    <specobject>
      <id>Mka_Logon_UnitTest01040_Created_2_Active</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Logon/TestSpec_Generated.h</sourcefile>
      <sourceline>1219</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that the ParticipantSM will transition to LOGON_PARTICIPANT_SM_CREATED after successful ICK gen if LinkState is Down. After LinkState goes to Active, ParticipantSM will transition to LOGON_PARTICIPANT_SM_ACTIVE and notify the KaY unit.
Test Object: ParticipantSM LOGON_PARTICIPANT_SM_CREATED to LOGON_PARTICIPANT_SM_ACTIVE.
Test Precondition: 
    -   Logon unit configuration initialized.
  
Test Execution: 
    01: Call Mka_Logon_IckGenerateFinished() for each configured controlled port.
    02: VP(Mka.dsn.Logon.ParticipantSM.GenerateIck_2_Created,1) Verify that the transition to LOGON_PARTICIPANT_SM_CREATED occurred after Logon received Mka_Logon_IckGenerateFinished. Verify that Logon called Mka_KaY_CreateParticipant.
    03: Call Mka_Logon_LinkStateChange(ACTIVE) to change the link state to Active. ParticipantSM should proceed with state transitions.
    04: VP(Mka.dsn.Logon.ParticipantSM.Created_2_Active,1)
        VP(Mka.InterAct.LinkStateChange,1) Verify that ParticipantSM transitioned to LOGON_PARTICIPANT_SM_ACTIVE by calling Mka_KaY_LinkStateActive.
    05: Call Mka_Logon_Participant_SuccessfulActor() for each configured controlled port to notify that participant has became successful actor.
    06: Sanity check - Check that Mka_Logon_Participant_SuccessfulActor() calls Mka_KaY_SetPrincipalActor() when there is no principal actor on configured controlled port.
    07: Sanity check - Check that when there is any change in Mka Nv memory, Mka shall mark memory block as changed with NvM_SetRamBlockStatus.
    08: Sanity check - Check that, if PAE has multiple participants when one became principal participant, other participants were stopped and disabled if configured so by MKA_DISABLE_NON_PRINCIPAL_PARTICIPANTS
    09: Call Mka_Logon_MainFunction() to check if disabled participants are not restarted.
    10: VP(Mka.dsn.Logon.ParticipantsRestartDisabled, 1) Verify that if PAE has multiple participants, when one becomes principal participant, other participants remain stopped if configured so MKA_DISABLE_NON_PRINCIPAL_PARTICIPANTS
    11: Sanity check - Sanity check
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.ParticipantSM.GenerateIck_2_Created</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1374</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Logon.ParticipantSM.Created_2_Active</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1372</internalId></provcov>
        <provcov>
          <linksto>Mka.InterAct.LinkStateChange</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1080</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Logon.ParticipantsRestartDisabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1601</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2230</internalId></specobject>
    <specobject>
      <id>Mka_Logon_UnitTest01041_SetPrincipalActor_ENotOk</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Logon/TestSpec_Generated.h</sourcefile>
      <sourceline>1260</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test that, after the Logon unit receives a call Mka_Logon_Participant_SuccessfulActor and tries to set the PrincipalActor by calling Mka_KaY_SetPrincipalActor, if it gets E_NOT_OK, it shall restart that participant.
Test Object: Mka_KaY_SetPrincipalActor returns E_NOT_OK for Active participant.
Test Precondition: 
    -   Logon unit configuration initialized.
  
Test Execution: 
    01: Call Mka_Logon_IckGenerateFinished() for each configured controlled port.
    02: Sanity check - Check that Logon called Mka_KaY_CreateParticipant and Mka_KaY_LinkStateActive.
    03: Set the Mka_KaY_SetPrincipalActor to return E_NOT_OK.
    04: Call Mka_Logon_Participant_SuccessfulActor() to notify that participant has become successful actor.
    05: VP(Mka.dsn.Logon.ParticipantSM.SuccessfulActor_2_Init,1) Verify that Mka_KaY_SetPrincipalActor() returned E_NOT_OK. Logon shall restart the Participant.
    06: VP(Mka.dsn.Logon.ParticipantSM.SuccessfulActor_2_Init,1) Verify that Logon had reset the Participant after Mka_KaY_SetPrincipalActor returned E_NOT_OK.
    07: Clean up.
    08: Sanity check - Sanity check
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.ParticipantSM.SuccessfulActor_2_Init</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1368</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2231</internalId></specobject>
    <specobject>
      <id>Mka_Logon_UnitTest01042_GetCknStatus_ENotOk</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Logon/TestSpec_Generated.h</sourcefile>
      <sourceline>1285</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test if invalid PAE instance participant index is returned, Mka_Logon_GetCknStatus will fail.
Test Object: Mka_Logon_GetCknStatus.
Test Precondition: 
    -   Logon Unit configuration initialized.
  
Test Execution: 
    01: VP(Mka.dsn.Logon.Api.GetCknStatus,1) Verify that Mka_Logon_GetCknStatus() shall return E_NOT_OK since Mka_Crypto_FindParticipant failed to find participant.
    02: Sanity check - Sanity.
    03: Sanity check - Sanity check
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.Api.GetCknStatus</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1048</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2232</internalId></specobject>
    <specobject>
      <id>Mka_Logon_UnitTest01043_TimerCallBack_PermissiveMode_Operational</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Logon/TestSpec_Generated.h</sourcefile>
      <sourceline>1305</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test if Pae with MacSecOperational set to True, the TimerCallback_PermissiveMode will not trigger anything.
Test Object: Mka_Logon_TimerCallback_PermissiveMode.
Test Precondition: 
    -   Logon unit configuration initialized.
  
Test Execution: 
    01: Call Mka_Logon_StartPae() for PAE that has Autostart disabled and has activation status in Nv memory set as enabled.
    02: Call EbTest_Logon_IckGenerateFinished() for participant.
    03: Call Mka_Logon_MacSecOperational for PAE Instance to set it True.
    04: VP(Mka.dsn.Logon.PermissiveMode.StopTimer,1) Verify that permissive timer was stopped after MacSec becomes operational.
    05: Call Mka_Logon_TimerCallback_PermissiveMode() for participant.
    06: VP(Mka.dsn.Logon.Api.TimerCallback_PermissiveMode,1) Verify that no other calls were made.
    07: Sanity check - Sanity check
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.PermissiveMode.StopTimer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1615</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Logon.Api.TimerCallback_PermissiveMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1054</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2233</internalId></specobject>
    <specobject>
      <id>Mka_Logon_UnitTest01044_SuccessfulActor_Failure</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Logon/TestSpec_Generated.h</sourcefile>
      <sourceline>1333</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test if calling Mka_Logon_Participant_SuccessfulActor with incorrect state will cause no further progress to be made.
Test Object: Mka_Logon_TimerCallback_PermissiveMode.
Test Precondition: 
    -   Logon unit configuration initialized.
  
Test Execution: 
    01: Call Mka_Logon_Participant_SuccessfulActor() for each configured controlled port to attempt to notify that participant has became successful actor.
    02: VP(Mka.dsn.Logon.Api.ParticipantSuccessfulActor,2) Verify that Logon_Participant_Stop was called and Dirty Bit set.
    03: Call Mka_Logon_MainFunction() to check if disabled participants are not restarted.
    04: Sanity check - Sanity.
    05: Sanity check - Sanity check
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.Api.ParticipantSuccessfulActor</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1042</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2234</internalId></specobject>
    <specobject>
      <id>Mka_Logon_UnitTest01045_ParticipantActor_NotPrincipal</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Logon/TestSpec_Generated.h</sourcefile>
      <sourceline>1355</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test if calling Mka_Logon_Participant_Actor with incorrect participant ID will cause no further progress to be made.
Test Object: Mka_Logon_Participant_Actor.
Test Precondition: 
    -   Logon unit configuration initialized.
  
Test Execution: 
    01: Call EbTest_Logon_ParticipantSuccesfulActor() to make participant EBTEST_PARTICIPANT_IDX_1 principal actor, and EBTEST_PARTICIPANT_IDX_2 a successful actor.
    02: Call Mka_Logon_Participant_Actor() to put successful actor into ACTIVE state, rather than principal actor.
    03: Call Mka_Logon_MainFunction() to process changes and make next successful participant as principal actor.
    04: VP(Mka.dsn.Logon.Api.ParticipantActor,1) Verify that when Mka_Logon_Participant_Actor() is called with non principal actor, nothing happens.
    05: Sanity check - Sanity check
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.Api.ParticipantActor</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1044</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2235</internalId></specobject>
    <specobject>
      <id>Mka_Logon_UnitTest01046_MacSecOperational_FalseInputs</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Logon/TestSpec_Generated.h</sourcefile>
      <sourceline>1377</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This tests if calling Mka_Logon_MacSecOperational with either a matching status parameter or triggering DEM event status goes false cases for each.
Test Object: Mka_Logon_MacSecOperational.
Test Precondition: 
    -   Initialize Logon.
  
Test Execution: 
    01: Call Mka_Logon_MacSecOperational for PAE Idx 0 and with status as False to pass through the if statement.
    02: VP(Mka.dsn.Logon.Api.MacSecOperational,1) Verify that no further calls were made.
    03: Call Mka_Logon_MacSecOperational with a different status state to set it.
    04: Call Mka_Logon_MMacSecOperational with another different state, FALSE, that will fail to trigger DEM response.
    05: VP(Mka.dsn.Logon.Api.MacSecOperational,1) Verify that no other call were made.
    06: Sanity check - Sanity check
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.Api.MacSecOperational</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1055</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2236</internalId></specobject>
    <specobject>
      <id>Mka_Logon_UnitTest01047_GetPaeStatus_DisabledParticipant</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Logon/TestSpec_Generated.h</sourcefile>
      <sourceline>1400</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This tests if calling Mka_Logon_GetPaeStatus with a disabled participant, either in SM or disabled, to exercise the if statement for it.
Test Object: Mka_Logon_GetPaeStatus.
Test Precondition: 
    -   Logon unit configuration initialized.
  
Test Execution: 
    01: Call Mka_Logon_TimerCallback_PermissiveMode to move PAE 1 to LOGON_PARTICIPANT_SM_DISABLED.
    02: Call Mka_Logon_GetPaeStatus() to get a status for PAE 1.
    03: VP(Mka.dsn.Logon.Api.GetPaeStatus,1) Verify that the status was undefined.
    04: Sanity check - Sanity
    05: Sanity check - Sanity check
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.Api.GetPaeStatus</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1053</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2237</internalId></specobject>
    <specobject>
      <id>Mka_Logon_UnitTest01048_LinkStateChange_NoActionChange</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Logon/TestSpec_Generated.h</sourcefile>
      <sourceline>1422</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This tests if calling Mka_Logon_LinkStateChange with a ETHTRCV_LINK_STATE while Logon Unit is initialized to exercise API.
Test Object: Mka_Logon_LinkStateChange.
Test Precondition: 
    -   Logon unit configuration initialized.
  
Test Execution: 
    01: Call Helper Function for LinkStateChange.
    02: VP(Mka.CP_SWS_Mka_91023,1) Verify that no further calls were made after calling Mka_Logon_LinkStateChange.
    03: Sanity check - Sanity check
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_91023</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>389</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2238</internalId></specobject>
    <specobject>
      <id>Mka_Logon_UnitTest01049_LinkStateChange_LogonInitFalse</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Logon/TestSpec_Generated.h</sourcefile>
      <sourceline>1442</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This tests if calling Mka_Logon_LinkStateChange with a ETHTRCV_LINK_STATE while Logon Unit is not initialized to exercise API.
Test Object: Mka_Logon_LinkStateChange.
Test Precondition: 
    -   Init Logon Unit.
  
Test Execution: 
    01: Call Mka_Logon_LinkStateChange.
    02: VP(Mka.CP_SWS_Mka_91023,1) Verify that correct functions are called if Mka_LinkStateChange is called when Logon is not initialized.
    03: Sanity check - Sanity check
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_91023</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>389</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2239</internalId></specobject>
    <specobject>
      <id>Mka_Logon_UnitTest01050_IckGenerateFinished_ENotOkay</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Logon/TestSpec_Generated.h</sourcefile>
      <sourceline>1462</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This tests if calling Mka_Logon_IckGenerateFinished when Mka_KaY_CreateParticipant returns E_NOT_OK which exercises the API.
Test Object: Mka_Logon_IckGenerateFinished.
Test Precondition: 
    -   Initialize Logon Module.
  
Test Execution: 
    01: Set Mka_KaY_CreateParticipant to return false.
    02: Call Mka_Logon_IckGenerateFinished.
    03: VP(Mka.dsn.Logon.Api.IckGenerateFinished,1) Verify that no further function calls occurred after Mka_KaY_CreateParticipant.
    04: Clean Up.
    05: Sanity check - Sanity check
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.Api.IckGenerateFinished</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1046</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2240</internalId></specobject>
    <specobject>
      <id>Mka_Logon_UnitTest01051_PaeReportError_PaeDisabled</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Logon/TestSpec_Generated.h</sourcefile>
      <sourceline>1484</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: This tests if calling Mka_Logon_ReportEvent when Pae is disabled and exercises the API.
Test Object: Mka_Logon_ReportEvent.
Test Precondition: 
    -   Initialize Logon.
  
Test Execution: 
    01: Disable PaeInstance 0.
    02: Sanity check - Sanity.
    03: Call Mka_Logon_MainFunction to apply the changes.
    04: call Mka_Logon_ReportEvent for the disabled Pae and an error code.
    05: VP(Mka.dsn.Logon.Api.ReportEvent,1) Verify that no further calls were made.
    06: Sanity check - Sanity check
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.Api.ReportEvent</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1056</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2241</internalId></specobject>
    <specobject>
      <id>Mka_Logon_UnitTest01052_MainFunction_InternalInitFail</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Logon/TestSpec_Generated.h</sourcefile>
      <sourceline>1507</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This tests if calling Mka_Logon_MainFunction and Logon_Init_Internal returns E_NOT_OK, which exercises the API.
Test Object: Mka_Logon_MainFunction.
Test Precondition: 
    -   Initialize Logon.
    -   Set Mka_Crypto_IckGenerateAsync to return E_NOT_OK.
  
Test Execution: 
    01: Call Mka_Logon_MainFunction to process changes and call Logon_Init_Internal.
    02: VP(Mka.dsn.Logon.Api.MainFunction,1) Verify that internal initialization is called and all participants are started.
    03: Revert Mka_Crypto_IckGenerateAsync_Stub to return expected values.
    04: Call Mka_Logon_MainFunction to call Logon_Init_Internal since last time it should have failed.
    05: VP(Mka.dsn.Logon.Api.MainFunction,1) Verify that internal initialization is called again meaning that it failed to initialized previously by checking that all participants are started again.
    06: Clean Up.
    07: Sanity check - Sanity check
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.Api.MainFunction</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1040</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2242</internalId></specobject>
    <specobject>
      <id>Mka_Logon_UnitTest01053_MainFunction_StartLastPrincipalInitFail</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Logon/TestSpec_Generated.h</sourcefile>
      <sourceline>1532</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This tests if calling Mka_Logon_MainFunction and Logon_Init_Internal doesn't start the last Principal Idx, which exercises the API.
Test Object: Mka_Logon_MainFunction.
Test Precondition: 
    -   Logon unit configuration initialized.
  
Test Execution: 
    01: Call EbTest_Logon_ParticipantPrincipalActor() to make participant EBTEST_PARTICIPANT_IDX_2 principal actor, and to store this principal in Nv memory for next start.
    02: Mka configuration re-initialized.
    03: Logon unit re-initialized and MainFunction ticked.
    04: Sanity check - Sanity.
    05: Sanity check - Sanity.
    06: Retry participant start in next main tick.
    07: VP(Mka.dsn.Logon.Api.MainFunction,1) Verify that if Mka_Crypto_IckGenerateAsync has returned E_NOT_OK, Logon_Init_Internal resets participant and retries in next main tick.
    08: Clean Up.
    09: Sanity check - Sanity check
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.Api.MainFunction</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1040</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2243</internalId></specobject>
    <specobject>
      <id>Mka_Logon_UnitTest01054_PaeRestart_Successful</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Logon/TestSpec_Generated.h</sourcefile>
      <sourceline>1558</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that when Mka_Logon_Pae_Restart() is called, participants for the Pae are stopped then restarted on next tick.
Test Object: Mka_Logon_Pae_Restart
Test Precondition: 
    -   Initialize Logon Unit.
  
Test Execution: 
    01: Call EbTest_Logon_ParticipantPrincipalActor() to make participant EBTEST_PARTICIPANT_IDX_1 principal actor, and to store this principal in Nv memory for next start.
    02: Call Mka_Logon_Participant_Actor() to put participant actor into ACTIVE state.
    03: Call Mka_Logon_Pae_Restart to restart all participants on Pae 1.
    04: Sanity check - Sanity.
    05: VP(Mka.dsn.Logon.Api.PaeRestart,1) Verify that each participant was restarted
    06: Call Logon Main Function to update participants.
    07: VP(Mka.dsn.Logon.Api.PaeRestart,1) Verify that the participants on Pae 1 are restarted.
    08: Sanity check - Sanity check
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.Api.PaeRestart</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1057</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2244</internalId></specobject>
    <specobject>
      <id>Mka_Logon_UnitTest01055_PaeRestart_Failure</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Logon/TestSpec_Generated.h</sourcefile>
      <sourceline>1583</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that when Mka_Logon_Pae_Restart() is called, participants for the Pae are stopped then restarted on next tick. This test checks that when participants are disabled, Mka_Logon_Pae_Restart does not stop it.
Test Object: Mka_Logon_Pae_Restart
Test Precondition: 
    -   Initialize Logon Unit.
  
Test Execution: 
    01: Set LinkState of Pae 0 to False.
    02: Disable participants on Pae 1.
    03: Sanity check - Sanity.
    04: Re-initialize the logon unit to apply changes.
    05: Call Mka_Logon_Pae_Restart.
    06: VP(Mka.dsn.Logon.Api.PaeRestart,1) Verify that no calls were made since Pae and Participants were disabled.
    07: Sanity check - Sanity check
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.Api.PaeRestart</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1057</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2245</internalId></specobject>
    <specobject>
      <id>Mka_Logon_UnitTest01056_SetEnable_DisablePae_NoChange</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Logon/TestSpec_Generated.h</sourcefile>
      <sourceline>1607</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that call to Mka_Logon_SetEnable shall set configuration value (Enabled - True/False) for given MkaPaeIdx in Nv memory and mark Nv memory block for write
Test Object: Mka_Logon_SetEnable().
Test Precondition: 
    -   Logon unit configuration initialized.
  
Test Execution: 
    01: Call Mka_Logon_GetEnable() to get status of PAE in Nv memory before it's disabled.
    02: Check that Mka_Logon_GetEnable() returned right value for PAE, TRUE.
    03: Call Mka_SetEnable() to disable PAE 1.
    04: Check that correct PAE status for given PAE is now disabled in Nv memory buffer and that memory is marked for write.
    05: Call Mka_Logon_GetEnable() to get status of PAE in Nv memory after it's disabled.
    06: Check that Mka_Logon_GetEnable() returned right value for PAE, FALSE.
    07: Call Mka_SetEnable to attempt to disable PAE 1 again.
    08: VP(Mka.dsn.Logon.Api.SetEnable,1) Verify that no calls were made during Mka_Set_Enable.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.Api.SetEnable</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1049</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2246</internalId></specobject>
    <specobject>
      <id>Mka_Logon_UnitTest01057_NvConfig_LastPrincipalGetIdx_InvalidCipherSuiteId</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Logon/TestSpec_Generated.h</sourcefile>
      <sourceline>1632</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that call to Mka_Logon_LinkStateChange with a Pae that has a valid past participant and an invalid past cipher suite id will not produce any call based on that.
Test Object: Mka_Logon_LinkStateChange.
Test Precondition: 
    -   Intialize Logon Unit
  
Test Execution: 
    01: Call Mka_Logon_LinkStateChange to set the linkstate of Pae 0 to DOWN.
    02: Sanity check - Sanity.
    03: Set the last principal Idx to a valid participant, but the ciphersuiteId to the invalid value.
    04: Call Mka_Logon_LinkStateChange with EHTRCV_LINK_STATE_ACTIVE for Pae 0 to get Logon_NvConfig_LastPrincipalGetIndex to be called with valid past participant and invalid cipher suite id.
    05: VP(Mka.CP_SWS_Mka_91023,1) Verify that with the participant ID and invalid cipher suite no further calls were made.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_91023</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>389</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2247</internalId></specobject>
    <specobject>
      <id>Mka_Logon_UnitTest01058_Logon_NvConfig_MacSecEnabled</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Logon/TestSpec_Generated.h</sourcefile>
      <sourceline>1654</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies functionality of Mka_Logon_NvConfig_MacSecEnabled API. API shall return state of MacSec enabled as it was at the startup and reading of Nv Memory. API Shall set new state in Nv memory to be read during next startup.
Test Object: Mka_Logon_NvConfig_MacSecEnabled.
Test Precondition: 
    -   Logon unit configuration initialized.
  
Test Execution: 
    01: Call Mka_Logon_NvConfig_MacSecEnabled with NULL_PTR only to retrieve current value.
    02: VP(Mka.dsn.KaY.MacSecEnabledStatus,1)
        VP(Mka.dsn.Logon.Api.MacSecEnabledStatus,1) Verify that Mka_Logon_NvConfig_MacSecEnabled returns MacSec enabled status value read from Nv Memory at startup. Initially this value is TRUE.
    03: Call Mka_Logon_NvConfig_MacSecEnabled with NewValue to set new value in Nv Memory.
    04: VP(Mka.dsn.KaY.MacSecEnabledStatus,1)
        VP(Mka.dsn.Logon.Api.MacSecEnabledStatus,1) Verify that NvM_SetRamBlockStatus is called and Nv Memory is queued for write, meaning that new value is stored in Nv Memory.
    05: Call Mka_Logon_NvConfig_MacSecEnabled with NULL_PTR to retrieve current value of MacSec enabled status.
    06: VP(Mka.dsn.KaY.MacSecEnabledStatus,1)
        VP(Mka.dsn.Logon.Api.MacSecEnabledStatus,1) Verify that Mka_Logon_NvConfig_MacSecEnabled returned same value as when called first time, since new value is only effective after system restart and new read from Nv Memory.
    07: Restart Logon unit like it was system restart. Set NvM_GetErrorStatus_Stub so that Nv Memory is not reinitialized and values preserved in NvMemory are read and used.
    08: Call Mka_Logon_NvConfig_MacSecEnabled with NULL_PTR to retrieve current value of MacSec enabled status.
    09: VP(Mka.dsn.KaY.MacSecEnabledStatus,1)
        VP(Mka.dsn.Logon.Api.MacSecEnabledStatus,1) Verify that Mka_Logon_NvConfig_MacSecEnabled returned new value that was set during previous set call, since there was system restart and new value is read from Nv Memory.
    10: Sanity check - Sanity check
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.KaY.MacSecEnabledStatus</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1590</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Logon.Api.MacSecEnabledStatus</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1058</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2248</internalId></specobject>
    <specobject>
      <id>Mka_Logon_UnitTest01059_NvSet_NoChange</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Logon/TestSpec_Generated.h</sourcefile>
      <sourceline>1689</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies the internal function use Logon_NvConfig_LastPrincipalSetIndex using Mka_Logon_Participant_SuccessfulActor. This case is when there is no need to change NvM.
Test Object: Mka_KaY_SetPrincipalActor.
Test Precondition: 
    -   Logon unit configuration initialized.
  
Test Execution: 
    01: Set principal participant and last cipher suite id in NvMemory.
    02: Set the current principal participant and cipher suite id in Pae 0 to Participant 0 and CipherSuiteId.
    03: VP(Mka.dsn.Logon.Api.ParticipantSuccessfulActor,2) Verify that values set to Pae 0 match those in NvM memory but does not trigger NvM write.
    04: Sanity check - Sanity check
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.Api.ParticipantSuccessfulActor</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1042</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2249</internalId></specobject>
    <specobject>
      <id>Mka_Logon_UnitTest01060_NvConfig_PermissiveNoChange</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Logon/TestSpec_Generated.h</sourcefile>
      <sourceline>1710</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This tests that if the permissive mode is already set, the NvM is not flagged for change again.
Test Object: Mka_Logon_SetPaePermissiveMode.
Test Precondition: 
    -   Logon unit configuration initialized.
  
Test Execution: 
    01: check that default configuration has MkaOnFailPermissiveMode = FALSE for both PAE.
    02: Call Mka_Logon_SetPaePermissiveMode() to set MkaOnFailPermissiveMode = TRUE for PAE 0 in Nv memory.
    03: Check that when function Mka_Logon_SetPaePermissiveMode() is called with MKA_TIMEOUT for PermissiveMode, Mka will set in Nv memory that PAE is in permissive mode and mark Nv memory block for write.
    04: Call Mka_Logon_SetPaePermissiveMode() with the same permissive mode as before.
    05: VP(Mka.dsn.Logon.Api.SetPaePermissiveMode,1) Verify that no changes for NvM occurred.
    06: Sanity check - Sanity check
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.Api.SetPaePermissiveMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1051</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2250</internalId></specobject>
    <specobject>
      <id>Mka_Logon_UnitTest01061_LinkState_GetDefaultParticipant_CipherId</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Logon/TestSpec_Generated.h</sourcefile>
      <sourceline>1733</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This tests that if there is no principal participant, no other participants are to be disabled.
Test Object: Mka_logon_Participant_SuccessfulActor.
Test Precondition: 
    -   Initialize Logon Unit.
  
Test Execution: 
    01: Call Mka_Logon_LinkStateChange to set Pae 0 link state to Down.
    02: Call Mka_Logon_SetCknStatus to disable participant 0 on Pae 0.
    03: Sanity check - Sanity.
    04: Re-init Logon unit
    05: Call Mka_Logon_LinkStateChange to set the link state to active with disabled participants.
    06: VP(Mka.CP_SWS_Mka_91023,1) Verify that when Mka_Logon_LinkStateChange is called with disabled participants, no further calls are made.
    07: Sanity check - Sanity check
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_91023</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>389</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2251</internalId></specobject>
    <specobject>
      <id>Mka_Logon_UnitTest01062_SetAsPrincipal_SetCipherSuiteFail</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Logon/TestSpec_Generated.h</sourcefile>
      <sourceline>1757</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This tests that if the Mka_Logon_Participant_SuccessfulActor fails to set the cipher suite correctly, the participant is stopped.
Test Object: Mka_Logon_Participant_SuccessfulActor.
Test Precondition: 
    -   Initialize Logon Unit.
  
Test Execution: 
    01: Call Mka_Logon_IckGenerateFinished for the Participant.
    02: Sanity check - Sanity check.
    03: set Mka_Cp_SetCipherSuite_Stub to fail to exercise Api.
    04: Call Mka_Logon_Participant_SuccessfulActor to trigger Logon_Participant_SetAsPrincipal to delete instance.
    05: VP(Mka.dsn.Logon.Api.ParticipantSuccessfulActor,2) Verify that Mka_Cp_CipherSuite was called, failed and then will stop the instance.
    06: Sanity check - Clean Up.
    07: Sanity check - Sanity check
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.Api.ParticipantSuccessfulActor</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1042</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2252</internalId></specobject>
    <specobject>
      <id>Mka_Logon_UnitTest01063_SetNextAsPrincipal_Failure</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Logon/TestSpec_Generated.h</sourcefile>
      <sourceline>1781</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This tests if the next potential participant on a Pae fails to be set as principal, the pae participant is disabled.
Test Object: Mka_Logon_MainFunction.
Test Precondition: 
    -   Initialize Logon Unit.
  
Test Execution: 
    01: Call EbTest_Logon_ParticipantPrincipalActor() to make first participant on PAE 1 principal actor.
    02: Call EbTest_Logon_ParticipantSuccessfulActor() to make second participant on PAE 1 successful actor.
    03: Stop first (principal) participant on PAE 1. This removes the participant as principal.
    04: Set Mka_Cp_SetCipherSuite_Stub to return E_NOT_OK.
    05: Call Mka_Logon_MainFunction to attempt next principal participant assignment. This call starts the process of assigning a new principal participant. Since Mka_Cp_SetCipherSuite will return E_NOT_OK, this process should result in a failure.
    06: VP(Mka.dsn.Logon.Api.MainFunction,1) Verify that when Mka_Cp_SetCipherSuite fails, it is stopped and the pae restarted.
    07: Check that the disabled participants are started again.
    08: Sanity check - Clean up.
    09: Sanity check - Sanity check
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.Api.MainFunction</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1040</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2253</internalId></specobject>
    <specobject>
      <id>Mka_Logon_UnitTest01065_MainFunction_ParticipantTwoGetCknFail</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Logon/TestSpec_Generated.h</sourcefile>
      <sourceline>1807</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This tests if the participant 2 of Pae 1 fails to get the Ckn, it is disabled.
Test Object: Mka_Logon_MainFunction.
Test Precondition: 
    -   Initialize Logon Unit.
  
Test Execution: 
    01: Sanity check - Sanity Check.
    02: Set Mka_Crypto_GetCknPtr to return E_NOT_OK for Particpant 2.
    03: Call Mka_Logon_MainFunction to process changes.
    04: VP(Mka.dsn.Logon.Api.MainFunction,1) Verify that Mka_Crypto_GetCknPtr is called twice for Pae 1 and Pae 2, since it will fail on Participant 2, disabling it.
    05: Clean up.
    06: Sanity check - Sanity check
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.Api.MainFunction</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1040</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2254</internalId></specobject>
    <specobject>
      <id>Mka_Logon_UnitTest01067_ParticipantSuccessfulActor_NonPrincipalFailure</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Logon/TestSpec_Generated.h</sourcefile>
      <sourceline>1830</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test checks that if in Logon_Pae_DisableNonPrincipalParticipants, called from Mka_Logon_Participant_SuccessfulActor, has a principal participant that is invalid, it does not check other participants.
Test Object: Mka_Logon_Participant_SuccessfulActor.
Test Precondition: 
    -   Logon unit configuration initialized.
  
Test Execution: 
    01: Set Mka_KaY_SetPrincipalActor_Stub to callout function that will disabled the passed in participant idx.
    02: Call Mka_Logon_IckGenerateFinished() for each configured controlled port.
    03: Check that the transition to LOGON_PARTICIPANT_SM_ACTIVE occured after Logon received Mka_Logon_IckGenerateFinished.
    04: Call Mka_Logon_Participant_SuccessfulActor() for Participant 1 on Pae 1 to attempt to promote to principal actor.
    05: Check that Mka_Logon_Participant_SuccessfulActor() shall call Mka_KaY_SetPrincipalActor() when there is no principal actor on configured controlled port.
    06: Check that when there are any change in Mka Nv memory, Mka shall mark memory block as changed with NvM_SetRamBlockStatus.
    07: Check that since the callout function for Mka_KaY_SetPrincipalActor disables participant 1 of Pae 1, it is stopped.
    08: Call Mka_Logon_MainFunction() to process changes.
    09: VP(Mka.dsn.Logon.Api.ParticipantSuccessfulActor,2) Verify that since Mka_KaY_SetPrincipalActor disables Participant 1 on Pae 1, it is started on next main function tick.
    10: Sanity check - Sanity check
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.Api.ParticipantSuccessfulActor</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1042</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2255</internalId></specobject>
    <specobject>
      <id>Mka_Logon_UnitTest01068_UpdateSecYDuringInit</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Logon/TestSpec_Generated.h</sourcefile>
      <sourceline>1857</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that Mka_Logon_Init() shall call Mka_Cp_SetCipherSuite() for each configured controlled port if configuration parameter is set to TRUE.
Test Object: MkaUpdateSecYDuringInit.
Test Precondition: 
    -   Logon unit configuration initialized.
  
Test Execution: 
    01: Call Mka_Logon_Init() to initialize MKA Logon.
    02: Call Mka_Logon_MainFunction() to continue initialization MKA Logon.
    03: VP(Mka.dsn.Logon.UpdateSecYDuringInit,1) Verify that function Mka_Cp_SetCipherSuite() is called for every PAE, when parameter MkaUpdateSecYDuringInit is set to TRUE, otherwise isn't called.
    04: Sanity check - Sanity check
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.UpdateSecYDuringInit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1619</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2256</internalId></specobject>
    <specobject>
      <id>Mka_Logon_UnitTest01069_Init_2_Created</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Logon/TestSpec_Generated.h</sourcefile>
      <sourceline>1878</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that the ParticipantSM will transition to LOGON_PARTICIPANT_SM_CREATED after participant is started when Pre-shared key is enabled and LinkState is DOWN.
Test Object: ParticipantSM LOGON_PARTICIPANT_SM_INIT to LOGON_PARTICIPANT_SM_CREATED.
Test Precondition: 
    -   Logon unit configuration initialized.
  
Test Execution: 
    01: Call Mka_MainFunction() to finish initialization.
    02: VP(Mka.dsn.Logon.ParticipantSM.Init_2_Created,1) Verify that the transition to LOGON_PARTICIPANT_SM_CREATED from LOGON_PARTICIPANT_SM_INIT occurred after Logon continued with init. Verify that Logon called Mka_KaY_CreateParticipant.
    03: Sanity check - Sanity check
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.ParticipantSM.Init_2_Created</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1359</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2257</internalId></specobject>
    <specobject>
      <id>Mka_Logon_UnitTest01070_Init_2_Active</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Logon/TestSpec_Generated.h</sourcefile>
      <sourceline>1898</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that the ParticipantSM will transition to LOGON_PARTICIPANT_SM_ACTIVE after participant is started when Pre-shared key is enabled and LinkState is ACTIVE.
Test Object: ParticipantSM LOGON_PARTICIPANT_SM_INIT to LOGON_PARTICIPANT_SM_ACTIVE.
Test Precondition: 
    -   Logon unit configuration initialized.
  
Test Execution: 
    01: Call Mka_MainFunction() to finish initialization.
    02: VP(Mka.dsn.Logon.ParticipantSM.Init_2_Active,1) Verify that the transition to LOGON_PARTICIPANT_SM_CREATED from LOGON_PARTICIPANT_SM_ACTIVE occurred when LinkState become active before Logon continued with init. Verify that Logon called Mka_KaY_CreateParticipant and Mka_KaY_LinkStateActive.
    03: Sanity check - Sanity check
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Logon.ParticipantSM.Init_2_Active</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1362</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2258</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>Mka_UnitTest01000_SetCknStatus_Uninit_Check</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Mka/TestSpec_Generated.h</sourcefile>
      <sourceline>9</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that the service Mka_SetCknStatus returns an error if module is not initialized.
Test Object: Mka_SetCknStatus().
Test Precondition: 
    -   Set RetVal to E_NOT_OK to start.
    -   define placeholder variables.
  
Test Execution: 
    01: Call MkaSetCknStatus() without init function called.
    02: VP(Mka.Det.SetCknStatus_Uninit,1)
        VP(Mka.CP_SWS_Mka_91035,1) Check that MKA_DET_REPORT_ERROR was called successfully.
    03: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Det.SetCknStatus_Uninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1137</internalId></provcov>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_91035</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>356</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2259</internalId></specobject>
    <specobject>
      <id>Mka_UnitTest01001_GetCknStatus_Uninit_Check</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Mka/TestSpec_Generated.h</sourcefile>
      <sourceline>35</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that the service Mka_GetCknStatus returns an error if module is not initialized.
Test Object: Mka_GetCknStatus().
Test Precondition: 
    -   Set RetVal to E_NOT_OK to start.
    -   define placeholder variables.
  
Test Execution: 
    01: Call Mka_GetCknStatus() without init function call.
    02: VP(Mka.Det.GetCknStatus_Uninit,1) Check that MKA_DET_REPORT_ERROR was called successfully.
    03: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Det.GetCknStatus_Uninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1141</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2260</internalId></specobject>
    <specobject>
      <id>Mka_UnitTest01002_SetEnable_Uninit_Check</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Mka/TestSpec_Generated.h</sourcefile>
      <sourceline>56</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: This test case verifies that the service Mka_SetEnable returns an error if module is not initialized.
Test Object: Mka_SetEnable().
Test Precondition: 
    -   Set RetVal to E_NOT_OK to start.
    -   define placeholder variables.
  
Test Execution: 
    01: Call Mka_SetEnable() without init function call.
    02: VP(Mka.Det.SetEnable_Uninit,1) Check the MKA_DET_REPORT_ERROR was called successfully.
    03: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Det.SetEnable_Uninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1146</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2261</internalId></specobject>
    <specobject>
      <id>Mka_UnitTest01003_GetEnable_Uninit_Check</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Mka/TestSpec_Generated.h</sourcefile>
      <sourceline>77</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: This test case verifies that the service Mka_GetEnable returns an error if module is not initialized.
Test Object: Mka_GetEnable().
Test Precondition: 
    -   Set RetVal to E_NOT_OK to start.
    -   define placeholder variables.
  
Test Execution: 
    01: call the function without calling init function
    02: VP(Mka.Det.GetEnable_Uninit,1) Check that MKA_DET_REPORT_ERROR was called successfully.
    03: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Det.GetEnable_Uninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1148</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2262</internalId></specobject>
    <specobject>
      <id>Mka_UnitTest01004_GetPaeStatus_Uninit_Check</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Mka/TestSpec_Generated.h</sourcefile>
      <sourceline>98</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that the service Mka_GetPaeStatus returns an error if module is not initialized.
Test Object: Mka_GetPaeStatus().
Test Precondition: 
    -   Set RetVal to E_NOT_OK to start
    -   define placeholder variables
  
Test Execution: 
    01: call the function without calling init function
    02: VP(Mka.Det.GetPaeStatus_Uninit,1) Check that MKA_DET_REPORT_ERROR was called successfully.
    03: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Det.GetPaeStatus_Uninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1151</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2263</internalId></specobject>
    <specobject>
      <id>Mka_UnitTest01005_SetPaePermissiveMode_Uninit_Check</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Mka/TestSpec_Generated.h</sourcefile>
      <sourceline>119</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that the service Mka_SetPaePermissiveMode returns an error if module is not initialized.
Test Object: Mka_SetPaePermissiveMode().
Test Precondition: 
    -   Set RetVal to E_NOT_OK to start.
    -   define placeholder variables.
  
Test Execution: 
    01: call the function without calling init function
    02: VP(Mka.Det.SetPaePermissiveMode_Uninit,1) Check that MKA_DET_REPORT_ERROR was called successfully.
    03: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Det.SetPaePermissiveMode_Uninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1154</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2264</internalId></specobject>
    <specobject>
      <id>Mka_UnitTest01006_StartPae_Uninit_Check</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Mka/TestSpec_Generated.h</sourcefile>
      <sourceline>140</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: This test case verifies that the service Mka_StartPae returns an error if module is not initialized.
Test Object: Mka_StartPae().
Test Precondition: 
    -   Set RetVal to E_NOT_OK to start.
    -   define placeholder variables.
  
Test Execution: 
    01: Call Mka_StartPae() without calling init function.
    02: VP(Mka.Det.StartPae_Uninit,1) Check that MKA_DET_REPORT_ERROR ws called successfully.
    03: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Det.StartPae_Uninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1156</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2265</internalId></specobject>
    <specobject>
      <id>Mka_UnitTest01007_GetMacSecStatistics_Uninit_Check</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Mka/TestSpec_Generated.h</sourcefile>
      <sourceline>161</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that the service Mka_GetMacSecStatistics returns an error if module is not initialized.
Test Object: Mka_GetMacSecStatistics().
Test Precondition: 
    -   Set RetVal to E_NOT_OK to start
    -   define placeholder variables
  
Test Execution: 
    01: call the function without calling init function
    02: VP(Mka.Det.GetMacSecStatistics_Uninit,1) Check if MKA_DET_REPORT_ERROR was called successfully.
    03: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Det.GetMacSecStatistics_Uninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1158</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2266</internalId></specobject>
    <specobject>
      <id>Mka_UnitTest01008_LinkStateChange_Uninit_Check</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Mka/TestSpec_Generated.h</sourcefile>
      <sourceline>182</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that the service Mka_LinkStateChange returns an error if module is not initialized.
Test Object: Mka_LinkStateChange().
Test Precondition: 
    -   Set RetVal to E_NOT_OK to start.
    -   define placeholder variables.
  
Test Execution: 
    01: call the function without calling init function
    02: VP(Mka.Det.LinkStateChange_Uninit,1) Check that MKA_DET_REPORT_ERROR was called successfully.
    03: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Det.LinkStateChange_Uninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1162</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2267</internalId></specobject>
    <specobject>
      <id>Mka_UnitTest01009_GetMacSecStatisticsNotification_Uninit_Check</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Mka/TestSpec_Generated.h</sourcefile>
      <sourceline>203</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that the service Mka_GetMacSecStatisticsNotification returns an error if module is not initialized.
Test Object: Mka_GetMacSecStatisticsNotification().
Test Precondition: 
    -   define placeholder variables
  
Test Execution: 
    01: call the function without calling init function Function does not return any parameters.
    02: VP(Mka.Det.GetMacSecStatisticsNotification_Uninit,1) Check that MKA_DET_REPORT_ERROR was called successfully.
    03: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Det.GetMacSecStatisticsNotification_Uninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1165</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2268</internalId></specobject>
    <specobject>
      <id>Mka_UnitTest01010_TxConfirmation_Uninit_Check</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Mka/TestSpec_Generated.h</sourcefile>
      <sourceline>223</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that the service Mka_TxConfirmation returns an error if module is not initialized.
Test Object: Mka_TxConfirmation().
Test Precondition: 
    -   define placeholder variables.
  
Test Execution: 
    01: call the function without calling init function. Function does not return any parameters.
    02: VP(Mka.Det.TxConfirmation_Uninit,1)
        VP(Mka.CP_SWS_Mka_91030,1) Check that MKA_DET_REPORT_ERROR was called successfully and it verifies existence of function Mka_TxConfirmation().
    03: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Det.TxConfirmation_Uninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1168</internalId></provcov>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_91030</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>392</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2269</internalId></specobject>
    <specobject>
      <id>Mka_UnitTest01011_MacSecUpdateSecYNotification_Uninit_Check</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Mka/TestSpec_Generated.h</sourcefile>
      <sourceline>248</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that the service Mka_MacSecUpdateSecYNotification returns an error if module is not initialized.
Test Object: Mka_MacSecUpdateSecYNotification().
Test Precondition: 
    -   define placeholder variables.
  
Test Execution: 
    01: call the function without calling init function. Function does not return any parameters.
    02: VP(Mka.Det.MacSecUpdateSecYNotification_Uninit,1) Check that MKA_DET_REPORT_ERROR was called successfully.
    03: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Det.MacSecUpdateSecYNotification_Uninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1170</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2270</internalId></specobject>
    <specobject>
      <id>Mka_UnitTest01012_MacSecAddTxSaNotification_Uninit_Check</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Mka/TestSpec_Generated.h</sourcefile>
      <sourceline>268</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that the service Mka_MacSecAddTxSaNotification returns an error if module is not initialized.
Test Object: Mka_MacSecAddTxSaNotification().
Test Precondition: 
    -   define placeholder variables.
  
Test Execution: 
    01: Call Mka_MacSecAddTxSaNotification() without calling init function. Function does not return any parameters.
    02: VP(Mka.Det.MacSecAddTxSaNotification_Uninit,1) Check that MKA_DET_REPORT_ERROR was called successfully.
    03: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Det.MacSecAddTxSaNotification_Uninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1172</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2271</internalId></specobject>
    <specobject>
      <id>Mka_UnitTest01013_MacSecAddRxSaNotification_Uninit_Check</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Mka/TestSpec_Generated.h</sourcefile>
      <sourceline>288</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that the service MacSecAddRxSaNotification returns an error if module is not initialized.
Test Object: MacSecAddRxSaNotification().
Test Precondition: 
    -   define placeholder variables.
  
Test Execution: 
    01: Call Mka_MacSecAddRxSaNotification() without calling init function. Function does not return any parameter.
    02: VP(Mka.Det.MacSecAddRxSaNotification_Uninit,1) Check that MKA_DET_REPORT_ERROR was called successfully.
    03: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Det.MacSecAddRxSaNotification_Uninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1174</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2272</internalId></specobject>
    <specobject>
      <id>Mka_UnitTest01014_RxIndication_Uninit_Check</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Mka/TestSpec_Generated.h</sourcefile>
      <sourceline>308</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that external API-s of the module shall report DET error MKA_E_UNINIT, if Mka_Init() was not previously called and flag Mka_Initialized was not set to TRUE. This test case has to be checked before calling Mka_Init().
Test Object: Software
Test Precondition: 
    -   Configure variables for Mka_RxIndication input parameters.
  
Test Execution: 
    01: Call Mka_RxIndication with acceptable input parameters.
    02: VP(Mka.Det.RxIndication_Uninit,1) Check that MKA_DET_REPORT_ERROR was called successfully.
    03: Call Mka_MainFunction.
    04: Sanity check - Check that none MainFunction of other units was called because MKA isn't initialized.
    05: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Det.RxIndication_Uninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1133</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2273</internalId></specobject>
    <specobject>
      <id>Mka_UnitTest01015_EnableMacSec_Uninit_Check</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Mka/TestSpec_Generated.h</sourcefile>
      <sourceline>330</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that the service Mka_EnableMacSec returns an error if module is not initialized.
Test Object: Mka_EnableMacSec().
Test Precondition: 
  
Test Execution: 
    01: Call Mka_EnableMacSec() without calling init function. Function does not return any parameter.
    02: VP(Mka.Det.EnableMacSec_Uninit,1) Check that MKA_DET_REPORT_ERROR was called successfully.
    03: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Det.EnableMacSec_Uninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1184</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2274</internalId></specobject>
    <specobject>
      <id>Mka_UnitTest01016_DisableMacSec_Uninit_Check</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Mka/TestSpec_Generated.h</sourcefile>
      <sourceline>349</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that the service Mka_DisableMacSec returns an error if module is not initialized.
Test Object: Mka_DisableMacSec().
Test Precondition: 
  
Test Execution: 
    01: Call Mka_DisableMacSec() without calling init function. Function does not return any parameter.
    02: VP(Mka.Det.DisableMacSec_Uninit,1) Check that MKA_DET_REPORT_ERROR was called successfully.
    03: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Det.DisableMacSec_Uninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1185</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2275</internalId></specobject>
    <specobject>
      <id>Mka_UnitTest01017_Init</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Mka/TestSpec_Generated.h</sourcefile>
      <sourceline>368</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that Mka_Init is initializing MKA units and calling their init services in correct order.
Test Object: Mka_Init().
Test Precondition: 
  
Test Execution: 
    01: Module configuration initialized with Mka_Init().
    02: VP(Mka.dsn.Lib.SciBuffer_Init,1) Verify that the buffer containing SCIs for each Pae was filled during Init phase.
    03: VP(Mka.CP_SWS_Mka_91001,1) Check if the MKA units are initialized in the correct order.
    04: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Lib.SciBuffer_Init</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1595</internalId></provcov>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_91001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>375</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2276</internalId></specobject>
    <specobject>
      <id>Mka_UnitTest01018_Main</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Mka/TestSpec_Generated.h</sourcefile>
      <sourceline>392</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that if Mka_DirtyFlag is set to TRUE, Mka_MainFunction is calling main functions of other units in correct order. Mka_MainFunction should reset Mka_DirtyFlag to False and when called again, it shall not call any other function.
Test Object: Mka_MainFunction().
Test Precondition: 
  
Test Execution: 
    01: Module configuration initialized with Mka_Init().
    02: Sanity check - Verify that Mka_DirtyFlag is True since Mka_MainFunction hasn't been called.
    03: Call Mka_MainFunction().
    04: VP(Mka.CP_SWS_Mka_91034,1)
        VP(Mka.InterAct.MainFunction,1)
        VP(Mka.InterAct.MkpduQueuing,1) Verify that MainFunction has successfully called MainFunctions of other units and had reset Mka_DirtyFlag to False. Verify that Mka_KaY_SendQueuedMkpdus has been called to check for MKPDUs queued for transmission.
    05: Call Mka_MainFunction() again.
    06: VP(Mka.CP_SWS_Mka_91034,1)
        VP(Mka.InterAct.MkpduQueuing,1) Verify that none MainFunctions of other MKA units had been called.
    07: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_91034</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>396</internalId></provcov>
        <provcov>
          <linksto>Mka.InterAct.MainFunction</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1101</internalId></provcov>
        <provcov>
          <linksto>Mka.InterAct.MkpduQueuing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1079</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2277</internalId></specobject>
    <specobject>
      <id>Mka_UnitTest01019_RxIndication</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Mka/TestSpec_Generated.h</sourcefile>
      <sourceline>426</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that the service Mka_RxIndication, when called with correct input parameters, correctly calls service Mka_RxTx_RxIndication from RxTx unit.
Test Object: Mka_RxIndication().
Test Precondition: 
    -   Configure variables for Mka_RxIndication input parameters
  
Test Execution: 
    01: Module configuration initialized with Mka_Init().
    02: Call function Mka_RxIndication() with EthIfCtrlIdx that doesn't support MacSec.
    03: VP(Mka.dsn.RxTx.Api.Mka_RxTx_RxIndication,1)
        VP(Mka.InterAct.RxMkpdu,1) Verify that Mka_RxTx_RxIndication isn't called, because given EthIfCtrlIdx doesn't have configured MacSec, then it doesn't have dedicated PAE.
    04: Call function Mka_RxIndication() with correct input.
    05: VP(Mka.dsn.RxTx.Api.Mka_RxTx_RxIndication,1)
        VP(Mka.InterAct.RxMkpdu,1) Verify that Mka_RxTx_RxIndication is called correctly with correct input parameters.
    06: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.RxTx.Api.Mka_RxTx_RxIndication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1064</internalId></provcov>
        <provcov>
          <linksto>Mka.InterAct.RxMkpdu</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1102</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2278</internalId></specobject>
    <specobject>
      <id>Mka_UnitTest01020_Init_Invalid_CfgPtr</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Mka/TestSpec_Generated.h</sourcefile>
      <sourceline>455</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that the service Mka_Init checks if the Mka_ConfigPtr is not a NULL_PTR. The check should fail and the service shall raise the development error MKA_E_PARAM_POINTER.
Test Object: Mka_Init().
Test Precondition: 
  
Test Execution: 
    01: Call Mka_Init with null pointer input parameter.
    02: VP(Mka.Det.Init_CfgPtr_Invalid,1) Check if MKA_DET_REPORT_ERROR was called successfully with correct Api and Error ID.
    03: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Det.Init_CfgPtr_Invalid</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1130</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2279</internalId></specobject>
    <specobject>
      <id>Mka_UnitTest01021_Init_Invalid_Cfg</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Mka/TestSpec_Generated.h</sourcefile>
      <sourceline>474</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that the service Mka_Init checks if the configuration pointed by Mka_ConfigPtr is valid. The check should fail and the service shall raise the development error MKA_E_INVALID_PARAMETER.
Test Object: Mka_Init().
Test Precondition: 
  
Test Execution: 
    01: Set variable for uncorrect input parameter to Mka_Init.
    02: Call Mka_Init with incorrectly set input parameter MkaConfigSet.
    03: VP(Mka.Det.Init_Cfg_Invalid,1) Check if MKA_DET_REPORT_ERROR was called successfully with correct Api and Error ID.
    04: Set valid PlatformSignature and call Mka_Init with incorrectly set input parameter MkaConfigSet.
    05: VP(Mka.Det.Init_Cfg_Invalid,1) Check if MKA_DET_REPORT_ERROR was called successfully with correct Api and Error ID.
    06: Set valid CfgSignature and call Mka_Init with incorrectly set input parameter MkaConfigSet.
    07: VP(Mka.Det.Init_Cfg_Invalid,1) Check if MKA_DET_REPORT_ERROR was called successfully with correct Api and Error ID.
    08: Set valid LcfgSignature and call Mka_Init with incorrectly set input parameter MkaConfigSet.
    09: VP(Mka.Det.Init_Cfg_Invalid,1) Check if MKA_DET_REPORT_ERROR was called successfully with correct Api and Error ID.
    10: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Det.Init_Cfg_Invalid</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1131</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2280</internalId></specobject>
    <specobject>
      <id>Mka_UnitTest01022_RxIndication_Invalid_EthIfCtrlIdx</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Mka/TestSpec_Generated.h</sourcefile>
      <sourceline>500</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that the service Mka_RxIndication checks if EthIfCtrlIdx matches configured number of EthIf controllers. The check should fail and the service shall raise the development error MKA_E_INVALID_PARAMETER.
Test Object: Mka_RxIndication().
Test Precondition: 
    -   Set variables to correct values for input parameters to Mka_RxIndication.
  
Test Execution: 
    01: Set variable WrongEthIfCtrlIdx to uncorrect value for input parameter EthIfCtrlIdx.
    02: Module configuration initialized with Mka_Init().
    03: Call Mka_RxIndication with uncorrect first input parameter.
    04: VP(Mka.Det.RxIndication_EthIfCtrlIdx_Invalid,1) Check if MKA_DET_REPORT_ERROR was called successfully.
    05: Sanity check - Sanity check
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Det.RxIndication_EthIfCtrlIdx_Invalid</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1134</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2281</internalId></specobject>
    <specobject>
      <id>Mka_UnitTest01023_RxIndication_Invalid_MacSrcAddr</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Mka/TestSpec_Generated.h</sourcefile>
      <sourceline>522</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that the service Mka_RxIndication checks if MacSrcAddr is not a NULL_PTR. The check should fail and the service shall raise the development error MKA_E_PARAM_POINTER.
Test Object: Mka_RxIndication().
Test Precondition: 
    -   Set variables to correct values for input parameters to Mka_RxIndication.
  
Test Execution: 
    01: Module configuration initialized with Mka_Init().
    02: Call Mka_RxIndication with input parameter MacSrcAddr being null pointer.
    03: VP(Mka.Det.RxIndication_MacSrcAddr_Invalid,1) Check if MKA_DET_REPORT_ERROR was called successfully.
    04: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Det.RxIndication_MacSrcAddr_Invalid</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1135</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2282</internalId></specobject>
    <specobject>
      <id>Mka_UnitTest01024_RxIndication_Invalid_DataPtr</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Mka/TestSpec_Generated.h</sourcefile>
      <sourceline>543</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that the service Mka_RxIndication checks if DataPtr is not a NULL_PTR.The check should fail and the function shall raise the development error MKA_E_PARAM_POINTER.
Test Object: Mka_RxIndication().
Test Precondition: 
    -   Set variables to correct values for other input parameters to Mka_RxIndication.
  
Test Execution: 
    01: Module configuration initialized with Mka_Init().
    02: Call Mka_RxIndication with input parameter DataPtr as null pointer.
    03: VP(Mka.Det.RxIndication_DataPtr_Invalid,1) Check if MKA_DET_REPORT_ERROR was called successfully.
    04: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Det.RxIndication_DataPtr_Invalid</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1136</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2283</internalId></specobject>
    <specobject>
      <id>Mka_UnitTest01025_SetCknStatus_Invalid_Params</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Mka/TestSpec_Generated.h</sourcefile>
      <sourceline>564</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that the service Mka_SetCknStatus checks if all input parameters being invalid.
Test Object: Mka_SetCknStatus()
Test Precondition: 
    -   Set RetVal to E_NOT_OK to start.
    -   Set invalid and valid variables.
    -   Module configuration initialized with Mka_Init().
  
Test Execution: 
    01: Call Mka_SetCknStatus() with incorrect input parameter MkaPaeIdx.
    02: VP(Mka.Det.SetCknStatus_MkaPaeIdx_Invalid,1) Check if MKA_DET_REPORT_ERROR was called successfully.
    03: Call Mka_SetCknStatus() with incorrect parameter CknPtr.
    04: VP(Mka.Det.SetCknStatus_CknPtr_Invalid,1) Check if MKA_DET_REPORT_ERROR was called successfully.
    05: Call Mka_SetCknStatus() with incorrect parameter CknLength.
    06: VP(Mka.Det.SetCknStatus_CknLength_Invalid,1)
        VP(Mka.8021X.MkaKeyHierarchy.4.1,1) Check if MKA_DET_REPORT_ERROR was called successfully.
    07: Call Mka_SetCknStatus() with incorrect parameter CknLength.
    08: VP(Mka.Det.SetCknStatus_CknLength_Invalid,1)
        VP(Mka.8021X.MkaKeyHierarchy.4.1,1) Check if MKA_DET_REPORT_ERROR was called successfully.
    09: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Det.SetCknStatus_MkaPaeIdx_Invalid</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1138</internalId></provcov>
        <provcov>
          <linksto>Mka.Det.SetCknStatus_CknPtr_Invalid</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1139</internalId></provcov>
        <provcov>
          <linksto>Mka.Det.SetCknStatus_CknLength_Invalid</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1140</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.MkaKeyHierarchy.4.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>113</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2284</internalId></specobject>
    <specobject>
      <id>Mka_UnitTest01026_GetCknStatus_Invalid_Params</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Mka/TestSpec_Generated.h</sourcefile>
      <sourceline>606</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: This test case verifies that the service Mks_GetCknStatus checks if all input parameters.
Test Object: Mks_GetCknStatus()
Test Precondition: 
    -   Set return to E_NOT_OK to start.
    -   define parameters for testing.
    -   Module configuration initialized with Mka_Init().
  
Test Execution: 
    01: Call Mka_GetCknStatus with invalid parameter for MkaPaeIdx.
    02: VP(Mka.Det.GetCknStatus_MkaPaeIdx_Invalid,1) Check if MKA_DET_REPORT_ERROR was called successfully.
    03: Call Mka_GetCknStatus() with invalid parameter for CknPtr.
    04: VP(Mka.Det.GetCknStatus_CknPtr_Invalid,1) Check if MKA_DET_REPORT_ERROR was called successfully.
    05: Call GetCknStatus() with invalid parameter CknLength.
    06: VP(Mka.Det.GetCknStatus_CknLength_Invalid,1)
        VP(Mka.8021X.MkaKeyHierarchy.4.1,1) Check if MKA_DET_REPORT_ERROR was called successfully.
    07: Call GetCknStatus() with invalid parameter CknLength.
    08: VP(Mka.Det.GetCknStatus_CknLength_Invalid,1)
        VP(Mka.8021X.MkaKeyHierarchy.4.1,1) Check if MKA_DET_REPORT_ERROR was called successfully.
    09: Call Mka_GetCknStatus() with invalid parameter EnablePtr.
    10: VP(Mka.Det.GetCknStatus_EnablePtr_Invalid,1) Check if MKA_DET_REPORT_ERROR was called successfully.
    11: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Det.GetCknStatus_MkaPaeIdx_Invalid</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1142</internalId></provcov>
        <provcov>
          <linksto>Mka.Det.GetCknStatus_CknPtr_Invalid</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1143</internalId></provcov>
        <provcov>
          <linksto>Mka.Det.GetCknStatus_CknLength_Invalid</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1144</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.MkaKeyHierarchy.4.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>113</internalId></provcov>
        <provcov>
          <linksto>Mka.Det.GetCknStatus_EnablePtr_Invalid</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1145</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2285</internalId></specobject>
    <specobject>
      <id>Mka_UnitTest01027_SetEnable_Invalid_Params</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Mka/TestSpec_Generated.h</sourcefile>
      <sourceline>654</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: This test case verifies that the service Mka_SetEnable checks if all input parameters.
Test Object: Mka_SetEnable().
Test Precondition: 
    -   Set return to E_NOT_OK to start
    -   define invalid parameters for testing.
    -   Module configuration initialized with Mka_Init().
  
Test Execution: 
    01: Call Mka_SetEnable() with invalid parameter MkaPaeIdx
    02: VP(Mka.Det.SetEnable_MkaPaeIdx_Invalid,1) Check that MKA_DET_REPORT_ERROR was called successfully.
    03: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Det.SetEnable_MkaPaeIdx_Invalid</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1147</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2286</internalId></specobject>
    <specobject>
      <id>Mka_UnitTest01028_GetEnable_Invalid_Params</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Mka/TestSpec_Generated.h</sourcefile>
      <sourceline>676</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: This test case verifies that the service Mka_GetEnable checks if all input parameters.
Test Object: Mka_GetEnable().
Test Precondition: 
    -   Set return to E_NOT_OK to start.
    -   define parameters for testing.
    -   Module configuration initialized with Mka_Init().
  
Test Execution: 
    01: Call Mka_GetEnable() with invalid parameter MkaPaeIdx.
    02: VP(Mka.Det.GetEnable_MkaPaeIdx_Invalid,1) Check that MKA_DET_REPORT_ERROR was called successfully
    03: Call Mka_GetEnable() with invalid parameter Enable_Ptr.
    04: VP(Mka.Det.GetEnable_EnablePtr_Invalid,1) Check that MKA_DET_REPORT_ERROR was called successfully.
    05: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Det.GetEnable_MkaPaeIdx_Invalid</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1149</internalId></provcov>
        <provcov>
          <linksto>Mka.Det.GetEnable_EnablePtr_Invalid</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1150</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2287</internalId></specobject>
    <specobject>
      <id>Mka_UnitTest01029_GetPaeStatus_Invalid_Params</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Mka/TestSpec_Generated.h</sourcefile>
      <sourceline>704</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: This test case verifies that the service Mka_GetPaeStatus checks if all input parameters.
Test Object: Mka_GetPaeStatus().
Test Precondition: 
    -   Set RetVal to E_NOT_OK to start.
    -   define parameters for testing.
  
Test Execution: 
    01: Module configuration initialized with Mka_Init().
    02: Call Mka_GetPaeStatus() with invalid parameter MkaPaeIdx.
    03: VP(Mka.Det.GetPaeStatus_MkaPaeIdx_Invalid,1) Check that MKA_DET_REPORT_ERROR was called successfully.
    04: Call Mka_GetPaeStatus() with invalid parameter StatusPtr.
    05: VP(Mka.Det.GetPaeStatus_PaeStatusPtr_Invalid,1) Check that MKA_DET_REPORT_ERROR was called successfully.
    06: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Det.GetPaeStatus_MkaPaeIdx_Invalid</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1152</internalId></provcov>
        <provcov>
          <linksto>Mka.Det.GetPaeStatus_PaeStatusPtr_Invalid</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1153</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2288</internalId></specobject>
    <specobject>
      <id>Mka_UnitTest01030_SetPaePermissiveMode_Invalid_Params</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Mka/TestSpec_Generated.h</sourcefile>
      <sourceline>732</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: This test case verifies that the service Mka_SetPaePermissiveMode checks if all input parameters.
Test Object: Mka_SetPaePermissiveMode().
Test Precondition: 
    -   Set RetVal to E_NOT_OK to start
    -   define parameters for testing.
    -   Module configuration initialized with Mka_Init().
  
Test Execution: 
    01: Call Mka_SetPaePermissiveMode() with invalid parameter MkaPaeIdx.
    02: VP(Mka.Det.SetPaePermissiveMode_MkaPaeIdx_Invalid,1) Check that MKA_DET_REPORT_ERROR was called successfully.
    03: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Det.SetPaePermissiveMode_MkaPaeIdx_Invalid</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1155</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2289</internalId></specobject>
    <specobject>
      <id>Mka_UnitTest01031_StartPae_Invalid_Params</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Mka/TestSpec_Generated.h</sourcefile>
      <sourceline>754</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: This test case verifies that the service Mka_StartPae checks if all input parameters.
Test Object: Mka_StartPae().
Test Precondition: 
    -   Set RetVal to E_NOT_OK to start.
    -   define invalid parameters for testing.
    -   Module configuration initialized with Mka_Init().
  
Test Execution: 
    01: Call Mka_StartPae() with invalid parameter MkaPaeIdx.
    02: VP(Mka.Det.StartPae_MkaPaeIdx_Invalid,1) Check that MKA_DET_REPORT_ERROR was called successfully.
    03: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Det.StartPae_MkaPaeIdx_Invalid</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1157</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2290</internalId></specobject>
    <specobject>
      <id>Mka_UnitTest01032_GetMacSecStatistics_Invalid_Params</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Mka/TestSpec_Generated.h</sourcefile>
      <sourceline>776</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: This test case verifies that the service Mka_GetMacSecStatistics checks if all input parameters.
Test Object: Mka_GetMacSecStatistics().
Test Precondition: 
    -   Set RetVal to E_NOT_OK to start.
    -   define parameters for testing.
    -   Module configuration initialized with Mka_Init().
  
Test Execution: 
    01: Call Mka_GetMacSecStatistics() with invalid parameter MkaPaeIdx.
    02: VP(Mka.Det.GetMacSecStatistics_MkaPaeIdx_Invalid,1) Check that MKA_DET_REPORT_ERROR was called successfully
    03: Call Mka_GetMacSecStatistics() with invalid parameter CknPtr.
    04: VP(Mka.Det.GetMacSecStatistics_CknPtr_Invalid,1) Check that MKA_DET_REPORT_ERROR was called successfully.
    05: Call Mka_GetMacSecStatistics() with invalid parameter CknLength.
    06: VP(Mka.Det.GetMacSecStatistics_CknLength_Invalid,1) Check that MKA_DET_REPORT_ERROR was called successfully.
    07: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Det.GetMacSecStatistics_MkaPaeIdx_Invalid</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1159</internalId></provcov>
        <provcov>
          <linksto>Mka.Det.GetMacSecStatistics_CknPtr_Invalid</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1160</internalId></provcov>
        <provcov>
          <linksto>Mka.Det.GetMacSecStatistics_CknLength_Invalid</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1161</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2291</internalId></specobject>
    <specobject>
      <id>Mka_UnitTest01033_LinkStateChange_Invalid_PaeIdx</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Mka/TestSpec_Generated.h</sourcefile>
      <sourceline>810</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that the service Mka_LinkStateChange checks if PaeIdx input parameter is valid.
Test Object: Mka_LinkStateChange().
Test Precondition: 
    -   Set RetVal to E_NOT_OK to start.
    -   Define parameters for testing.
    -   Module configuration initialized with Mka_Init().
  
Test Execution: 
    01: Call Mka_LinkStateChange() with invalid parameter MkaPaeIdx.
    02: VP(Mka.Det.LinkStateChange_MkaPaeIdx_Invalid,1) Check if MKA_DET_REPORT_ERROR was called correctly.
    03: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Det.LinkStateChange_MkaPaeIdx_Invalid</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1163</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2292</internalId></specobject>
    <specobject>
      <id>Mka_UnitTest01034_GetMacSecStatisticsNotification_Invalid_Params</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Mka/TestSpec_Generated.h</sourcefile>
      <sourceline>832</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that the service Mka_GetMacSecStatisticsNotification checks if all input parameters.
Test Object: Mka_GetMacSecStatisticsNotification().
Test Precondition: 
    -   define parameters for testing.
    -   Module configuration initialized with Mka_Init().
  
Test Execution: 
    01: Call Mka_GetMacSecStatistics() with invalid parameter MkaPaeIdx. Function does not return any parameters.
    02: VP(Mka.Det.GetMacSecStatisticsNotification_MkaPaeIdx_Invalid,1) Check that MKA_DET_REPORT_ERROR was called successfully.
    03: Call Mka_GetMacSecStatistics() with invalid parameter MacSecStatsPtr. Function does not return any parameters.
    04: VP(Mka.Det.GetMacSecStatisticsNotifications_MacSecStatsPtr_Invalid,1) Check that MKA_DET_REPORT_ERROR was called successfully.
    05: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Det.GetMacSecStatisticsNotification_MkaPaeIdx_Invalid</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1166</internalId></provcov>
        <provcov>
          <linksto>Mka.Det.GetMacSecStatisticsNotifications_MacSecStatsPtr_Invalid</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1167</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2293</internalId></specobject>
    <specobject>
      <id>Mka_UnitTest01035_TxConfirmation_Invalid_Params</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Mka/TestSpec_Generated.h</sourcefile>
      <sourceline>859</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that the service Mka_TxConfirmation checks if all input parameters.
Test Object: Mka_TxConfirmation().
Test Precondition: 
    -   Define parameters for testing.
    -   Module configuration initialized with Mka_Init().
  
Test Execution: 
    01: Call TxConfirmation() with invalid parameter EthIfCtrlIdx. Function does not return any parameters.
    02: VP(Mka.Det.TxConfirmation_EthIfCtrlIdx_Invalid,1) Check if MKA_DET_REPORT_ERROR was called successfully.
    03: Call TxConfirmation() with valid parameters.
    04: VP(Mka.CP_SWS_Mka_91030,1) Verify that, when Mka_TxConfirmation() is called with valid parameters, Det wasn't called to report error.
    05: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Det.TxConfirmation_EthIfCtrlIdx_Invalid</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1169</internalId></provcov>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_91030</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>392</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2294</internalId></specobject>
    <specobject>
      <id>Mka_UnitTest01036_LinkStateChange_TransceiverLinkState_Invalid</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Mka/TestSpec_Generated.h</sourcefile>
      <sourceline>886</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that the service Mka_LinkStateChange returns an error if invalid parameter is used.
Test Object: Mka_LinkStateChange().
Test Precondition: 
    -   Set RetVal to E_NOT_OK to start
    -   define parameters for testing.
    -   Module configuration initialized with Mka_Init().
  
Test Execution: 
    01: Call Mka_LinkStateChange() with invalid parameter MkaPaeIdx.
    02: VP(Mka.Det.LinkStateChange_TransceiverLinkState_Invalid,1) Check that MKA_DET_REPORT_ERROR was called successfully.
    03: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Det.LinkStateChange_TransceiverLinkState_Invalid</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1164</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2295</internalId></specobject>
    <specobject>
      <id>Mka_UnitTest01037_MacSecUpdateSecYNotification_MkaPaeIdx_Invalid_Params</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Mka/TestSpec_Generated.h</sourcefile>
      <sourceline>908</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that the service Mka_MacSecUpdateSecYNotification checks if all input parameters.
Test Object: Mka_MacSecUpdateSecYNotification().
Test Precondition: 
    -   define invalid parameters for testing.
    -   Module configuration initialized with Mka_Init().
  
Test Execution: 
    01: Call Mka_MacSecUpSecYNotification() with invalid parameter MkaPaeIdx. Function does not return any paramters
    02: VP(Mka.Det.MacSecUpdateSecYNotification_MkaPaeIdx_Invalid,1) Check that MKA_DET_REPORT_ERROR was called successfully.
    03: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Det.MacSecUpdateSecYNotification_MkaPaeIdx_Invalid</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1171</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2296</internalId></specobject>
    <specobject>
      <id>Mka_UnitTest01038_MacSecAddTxSaNotification_MkaPaeIdx_Invalid_Params</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Mka/TestSpec_Generated.h</sourcefile>
      <sourceline>929</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that the service Mka_MacSecAddTxSaNotification checks if all input parameters.
Test Object: Mka_MacSecAddTxSaNotification().
Test Precondition: 
    -   define invalid parameters for testing.
    -   Module configuration initialized with Mka_Init().
  
Test Execution: 
    01: Call Mka_MacSecAddTxSaNotification() with invalid parameter MkaPaeIdx. Function does not return any parameters.
    02: VP(Mka.Det.MacSecAddTxSaNotification_MkaPaeIdx_Invalid,1) Check that MKA_DET_REPORT_ERROR was called successfully.
    03: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Det.MacSecAddTxSaNotification_MkaPaeIdx_Invalid</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1173</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2297</internalId></specobject>
    <specobject>
      <id>Mka_UnitTest01039_MacSecAddRxSaNotification_MkaPaeIdx_Invalid_Params</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Mka/TestSpec_Generated.h</sourcefile>
      <sourceline>950</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that the service Mka_MacSecAddRxSaNotification checks if all input parameters.
Test Object: Mka_MacSecAddRxSaNotification().
Test Precondition: 
    -   define invalid parameters for testing.
    -   Module configuration initialized with Mka_Init().
  
Test Execution: 
    01: Call Mka_MacSecAddRxSaNotification() with invalid parameter MkaPaeIdx. Function does not return any parameters.
    02: VP(Mka.Det.MacSecAddRxSaNotification_MkaPaeIdx_Invalid,1) Check that MKA_DET_REPORT_ERROR was called successfully.
    03: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Det.MacSecAddRxSaNotification_MkaPaeIdx_Invalid</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1175</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2298</internalId></specobject>
    <specobject>
      <id>Mka_UnitTest01040_GetVersionInfo</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Mka/TestSpec_Generated.h</sourcefile>
      <sourceline>971</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that the service Mka_GetVersionInfo returns correct and expected output.
Test Object: Mka_GetVersionInfo().
Test Precondition: 
    -   define invalid parameters for testing.
  
Test Execution: 
    01: Call Mka_GetVersionInfo() with input parameter Test_VersionInfo.
    02: VP(Mka.CP_SWS_Mka_91014,1) Check that Mka_GetVersionInfo returned correct values and Mka_GetVersionInfo returned E_OK.
    03: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_91014</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>376</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2299</internalId></specobject>
    <specobject>
      <id>Mka_UnitTest01041_GetVersionInfo_VersionInfoPtr_Invalid_Params</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Mka/TestSpec_Generated.h</sourcefile>
      <sourceline>991</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that the service Mka_GetVersionInfo checks if input parameter is not a Null pointer.
Test Object: Mka_GetVersionInfo().
Test Precondition: 
    -   define invalid parameters for testing.
  
Test Execution: 
    01: Call Mka_GetVersionInfo() with invalid parameter Test_VersionInfoPtr. Function does not return any parameters.
    02: VP(Mka.Det.GetVersionInfo_VersioninfoPtr_Invalid,1) Check that MKA_DET_REPORT_ERROR was called successfully and Mka_GetVersionInfo returned E_NOT_OK.
    03: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Det.GetVersionInfo_VersioninfoPtr_Invalid</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1132</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2300</internalId></specobject>
    <specobject>
      <id>Mka_UnitTest01042_StartPae</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Mka/TestSpec_Generated.h</sourcefile>
      <sourceline>1011</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that the service Mka_StartPae will call Mka_Logon_StartPae with correct parameters.
Test Object: Mka_StartPae().
Test Precondition: 
    -   Module configuration initialized with Mka_Init().
  
Test Execution: 
    01: Call Mka_StartPae().
    02: VP(Mka.CP_SWS_Mka_91022,1) Check that Mka_StartPae called Mka_Logon_StartPae with correct parameters.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_91022</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>386</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2301</internalId></specobject>
    <specobject>
      <id>Mka_UnitTest01043_SetCknStatus</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Mka/TestSpec_Generated.h</sourcefile>
      <sourceline>1030</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that Mka_SetCknStatus() calls Mka_Logon_SetCknStatus with correct parameters.
Test Object: Mka_SetCknStatus().
Test Precondition: 
    -   Set RetVal to E_NOT_OK to start.
    -   define placeholder variables.
  
Test Execution: 
    01: Call Mka_SetCknStatus() with correct parameters.
    02: VP(Mka.CP_SWS_Mka_91015,1) Verify that Mka_SetCknStatus shall call Mka_Logon_SetCknStatus with correct parameters.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_91015</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>377</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2302</internalId></specobject>
    <specobject>
      <id>Mka_UnitTest01044_GetCknStatus</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Mka/TestSpec_Generated.h</sourcefile>
      <sourceline>1050</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that Mka_GetCknStatus() calls Mka_Logon_GetCknStatus with correct parameters.
Test Object: Mka_GetCknStatus().
Test Precondition: 
    -   Set RetVal to E_NOT_OK to start.
    -   define placeholder variables.
  
Test Execution: 
    01: Call Mka_GetCknStatus() with correct parameters.
    02: VP(Mka.CP_SWS_Mka_91016,1) Verify that Mka_GetCknStatus shall call Mka_Logon_GetCknStatus with correct parameters.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_91016</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>379</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2303</internalId></specobject>
    <specobject>
      <id>Mka_UnitTest01045_GetEnable</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Mka/TestSpec_Generated.h</sourcefile>
      <sourceline>1070</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that Mka_GetEnable() calls Mka_Logon_GetEnable with correct parameters.
Test Object: Mka_GetEnable().
Test Precondition: 
    -   Set RetVal to E_NOT_OK to start.
    -   define placeholder variables.
  
Test Execution: 
    01: Call Mka_GetEnable() with correct parameters.
    02: VP(Mka.CP_SWS_Mka_91017,1) Verify that Mka_GetEnable shall set call Mka_Logon_GetEnable with correct parameters.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_91017</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>382</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2304</internalId></specobject>
    <specobject>
      <id>Mka_UnitTest01046_SetEnable</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Mka/TestSpec_Generated.h</sourcefile>
      <sourceline>1090</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that Mka_SetEnable() calls Mka_Logon_SetEnable with correct parameters.
Test Object: Mka_SetEnable().
Test Precondition: 
    -   Set RetVal to E_NOT_OK to start.
    -   define placeholder variables.
  
Test Execution: 
    01: Call Mka_SetEnable() with correct parameters.
    02: VP(Mka.CP_SWS_Mka_91020,1) Verify that Mka_SetEnable shall set call Mka_Logon_SetEnable with correct parameters.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_91020</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>380</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2305</internalId></specobject>
    <specobject>
      <id>Mka_UnitTest01047_SetPaePermissiveMode</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Mka/TestSpec_Generated.h</sourcefile>
      <sourceline>1110</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that Mka_SetPaePermissiveMode() calls Mka_Logon_SetPaePermissiveMode with correct parameters.
Test Object: Mka_SetPaePermissiveMode().
Test Precondition: 
    -   Set RetVal to E_NOT_OK to start.
    -   define placeholder variables.
  
Test Execution: 
    01: Call Mka_SetPaePermissiveMode() with correct parameters.
    02: VP(Mka.CP_SWS_Mka_91021,1) Verify that Mka_SetPaePermissiveMode shall set call Mka_Logon_SetPaePermissiveMode with correct parameters.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_91021</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>384</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2306</internalId></specobject>
    <specobject>
      <id>Mka_UnitTest01048_LinkStateChange</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Mka/TestSpec_Generated.h</sourcefile>
      <sourceline>1130</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that the service Mka_LinkStateChange will call Mka_Logon_LinkStateChange with correct parameters.
Test Object: Mka_LinkStateChange().
Test Precondition: 
    -   Module configuration initialized with Mka_Init().
  
Test Execution: 
    01: Call Mka_StartPae().
    02: VP(Mka.CP_SWS_Mka_91023,1) Check that Mka_StartPae called Mka_Logon_LinkStateChange with correct parameters.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_91023</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>389</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2307</internalId></specobject>
    <specobject>
      <id>Mka_UnitTest01049_GetMacSecStatistics</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Mka/TestSpec_Generated.h</sourcefile>
      <sourceline>1149</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that the service Mka_GetMacSecStatistics behaves as expected when called with correct or incorrect parameters.
Test Object: Mka_GetMacSecStatistics().
Test Precondition: 
    -   Module configuration initialized with Mka_Init().
  
Test Execution: 
    01: Call Mka_GetMacSecStatistics() with nonexistent CKN on given Pae.
    02: VP(Mka.dsn.Mka.GetMacSecStatistics,1) Verify that Mka_GetMacSecStatistics returned E_NOT_OK and made no further api calls.
    03: Set Ckn to correct value.
    04: Call Mka_GetMacSecStatistics() with correct CKN for given Pae.
    05: VP(Mka.dsn.Mka.GetMacSecStatistics,1) Verify that Mka_GetMacSecStatistics returned E_OK and called EthIf_MacSecGetMacSecStats.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Mka.GetMacSecStatistics</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1455</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2308</internalId></specobject>
    <specobject>
      <id>Mka_UnitTest01050_GetMacSecStatisticsNotification</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Mka/TestSpec_Generated.h</sourcefile>
      <sourceline>1171</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that the service Mka_GetMacSecStatisticsNotification behaves as expected. In P0, there is no callback API defined. In P1, defined callback API exists.
Test Object: Mka_GetMacSecStatisticsNotification().
Test Precondition: 
    -   Prepare variable MacSecStats.
    -   Module configuration initialized with Mka_Init().
  
Test Execution: 
    01: Call GetMacSecStatisticsNotification().
    02: VP(Mka.dsn.Mka.GetMacSecStatisticsNotification,1) Verify that Mka_GetMacSecStatisticsNotification made no further api calls since no API callback has been defined.
    03: VP(Mka.dsn.Mka.GetMacSecStatisticsNotification,1) Verify that Mka_GetMacSecStatisticsNotification made called a defined callback API with correct parameters.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Mka.GetMacSecStatisticsNotification</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1456</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2309</internalId></specobject>
    <specobject>
      <id>Mka_UnitTest01051_Init_Failed</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Mka/TestSpec_Generated.h</sourcefile>
      <sourceline>1192</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that Mka_Init is failed initializing MKA units when Mka_Logon_Init returns E_NOT_OK.
Test Object: Mka_Init().
Test Precondition: 
    -   Configure that Mka_Logon_Init returns E_NOT_OK and reset Mka_DirtyFlag to initial value.
  
Test Execution: 
    01: Module configuration initialized with Mka_Init().
    02: VP(Mka.dsn.Mka.Init_NotInitialized,1) Verify that EthIf_UpdatePhysAddrFilter returned E_NOT_OK and that other Init functions aren't called. Verify that Mka_Init() returned E_NOT_OK.
    03: Call Mka_MainFunction().
    04: VP(Mka.dsn.Mka.Init_NotInitialized,1)
        VP(Mka.InterAct.Initialization,1) Verify that MainFunction didn't call any MainFunctions of other units, because Mka isn't initialized and Mka_DirtyFlag is still TRUE.
    05: Configure that EthIf_UpdatePhysAddrFilter returns E_OK.
    06: Module configuration initialized with Mka_Init().
    07: VP(Mka.dsn.Mka.Init_NotInitialized,1)
        VP(Mka.InterAct.Initialization,1) Verify that Mka_Logon_Init returned E_OK and Mka is initialized. Verify that Mka_Init() returned E_OK.
    08: Call Mka_MainFunction().
    09: VP(Mka.dsn.Mka.Init_NotInitialized,1)
        VP(Mka.InterAct.Initialization,1) Verify that MainFunction called MainFunctions of other units, and Mka_DirtyFlag is set to FALSE.
    10: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Mka.Init_NotInitialized</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1470</internalId></provcov>
        <provcov>
          <linksto>Mka.InterAct.Initialization</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1100</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2310</internalId></specobject>
    <specobject>
      <id>Mka_UnitTest01052_IsValidConfig_NullPtr</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Mka/TestSpec_Generated.h</sourcefile>
      <sourceline>1226</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that the function Mka_IsValidConfig checks if the configuration is NULL_PTR. If received configuration is NULL_PTR, it returns E_NOT_OK.
Test Object: Mka_IsValidConfig().
Test Precondition: 
  
Test Execution: 
    01: Call Mka_Init with incorrectly set input parameter MkaConfigSet.
    02: VP(Mka.dsn.Mka.IsValidConfig_NullPtr,1) Verify that Mka_IsValidConfig returned E_NOT_OK, since received configuration is NULL_PTR.
    03: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.Mka.IsValidConfig_NullPtr</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1472</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2311</internalId></specobject>
    <specobject>
      <id>Mka_UnitTest01053_HandleEvents_MkaNotInitialized</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Mka/TestSpec_Generated.h</sourcefile>
      <sourceline>1245</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: Test case verifies that when Mka_HandleEvents() is called before MKA module is successfully initialized, the call is ignored.
Test Object: Mka_HandleEvents().
Test Precondition: 
  
Test Execution: 
    01: Configure that Mka_Logon_Init returns E_NOT_OK which will disable successful initialization of Mka module.
    02: Call Mka_Init() to initialize Mka module.
    03: Set Mka dirty flag to simulate reception of an external event that requires processing.
    04: Call Mka_HandleEvents() to trigger processing of external events.
    05: VP(Mka.dsn.MkaExt.HandleEventsApi.MkaNotInitialized,1)
        VP(Mka.dsn.Api.HandleEvents,1) Verify that Mka_HandleEvents() did not call any main functions of other units, because Mka was not successfully initialized.
    06: Configure that EthIf_UpdatePhysAddrFilter returns E_OK.
    07: Call Mka_Init() to initialize Mka module.
    08: Call Mka_HandleEvents() to trigger processing of external events.
    09: VP(Mka.dsn.MkaExt.HandleEventsApi.MkaNotInitialized,1)
        VP(Mka.dsn.Api.HandleEvents,1) Verify that Mka_HandleEvents() called main functions of other units, which proves that when Mka is successfully initialized Mka_HandleEvents() triggers event processing.
    10: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.MkaExt.HandleEventsApi.MkaNotInitialized</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1471</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.Api.HandleEvents</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>988</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2312</internalId></specobject>
    <specobject>
      <id>Mka_UnitTest01054_GetMacSecEnabled_Uninit_Check</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Mka/TestSpec_Generated.h</sourcefile>
      <sourceline>1277</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that the service Mka_GetMacSecEnabled returns an error if module is not initialized.
Test Object: Mka_GetMacSecEnabled().
Test Precondition: 
  
Test Execution: 
    01: Call Mka_GetMacSecEnabled() without calling init function.
    02: VP(Mka.Det.GetMacSecEnabled_Uninit,1) Check that MKA_DET_REPORT_ERROR was called successfully.
    03: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Det.GetMacSecEnabled_Uninit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1186</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2313</internalId></specobject>
    <specobject>
      <id>Mka_UnitTest01055_GetMacSecEnabled_StatusPtr_Invalid</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_Mka/TestSpec_Generated.h</sourcefile>
      <sourceline>1296</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test case verifies that the service Mka_GetMacSecEnabled returns an error if provided parameter StatusPtr is a NULL_PTR.
Test Object: Mka_GetMacSecEnabled().
Test Precondition: 
  
Test Execution: 
    01: Call Mka_Init() to initialize Mka module.
    02: Call Mka_GetMacSecEnabled() without calling init function.
    03: VP(Mka.Det.GetMacSecEnabled_StatusPtr_Invalid,1) Check that MKA_DET_REPORT_ERROR was called successfully.
    04: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.Det.GetMacSecEnabled_StatusPtr_Invalid</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1187</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2314</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>Mka_RxTx_UnitTest01001_Initial_2_BufUnalloc_2_BufAlloc</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_RxTx/TestSpec_Generated.h</sourcefile>
      <sourceline>9</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that, after the MKA is initialized and Mka_RxTx_GetTxBuffer is called for first time, the TX Buffer is allocated successfully.
Test Object: Mka_RxTx_GetTxBuffer unit external API existence.
Test Precondition: 
    -   Prepare EthIf_ProvideTxBuffer stub to return expected parameters.
    -   Module configuration initialized with Mka_Init().
  
Test Execution: 
    01: Call Mka_RxTx_Init() to initialize MKA RxTx unit.
    02: Call Mka_RxTx_GetTxBuffer to allocate Tx Buffer.
    03: VP(Mka.dsn.RxTx.TxSM.TxBufUnalloc_2_TxBufAllocLocked,2)
        VP(Mka.dsn.RxTx.Api.Mka_RxTx_GetTxBuffer,1)
        VP(Mka.dsn.RxTx.TxSM.Initial_2_TxBufUnalloc,2)
        VP(Mka.dsn.RxTx.Api.Mka_RxTx_Init,1)
        VP(Mka.InterAct.TxMkpdu,1) Check that RxTx initialization process was successful and that the state transitioned to Buffer_Unallocated. Verify that new buffer was allocated successfully, indicating transition from Buffer_Unallocated to Buffer_Allocated_Locked.
    04: Sanity check - Sanity check
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.RxTx.TxSM.TxBufUnalloc_2_TxBufAllocLocked</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1407</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.RxTx.Api.Mka_RxTx_GetTxBuffer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1061</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.RxTx.TxSM.Initial_2_TxBufUnalloc</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1410</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.RxTx.Api.Mka_RxTx_Init</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1060</internalId></provcov>
        <provcov>
          <linksto>Mka.InterAct.TxMkpdu</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1103</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2315</internalId></specobject>
    <specobject>
      <id>Mka_RxTx_UnitTest01002_BufAlloc_2_WaitIcvGenFin_2_BufUnalloc</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_RxTx/TestSpec_Generated.h</sourcefile>
      <sourceline>51</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that when the state is set to Buffer_Allocated_Locked and API Mka_RxTx_TxBufferReady is called, the state transitions to Wait_Icv_Generate_Finished until the ICV is generated. If ICV is generated successfully, Mka_RxTx_IcvGenerateFinished is called with E_OK with EthIf_Transmit() consequently and state is switched to Buffer_Unallocated. It also verifies correct setting of M field parameter during call of Mka_Crypto_IcvGenerateAsync_Stub().
Test Object: Mka_RxTx_TxBufferReady transitions in both Asynchronous and Synchronous mode.
Test Precondition: 
    -   RxTx unit initialized.
    -   Call Mka_RxTx_GetTxBuffer to allocate Tx Buffer.
  
Test Execution: 
    01: Call Mka_RxTx_ReleaseTxBuffer to try to release the buffer that is not allocated. Call shall be ignored.
    02: VP(Mka.dsn.RxTx.TxSM.ReleaseTxBuffer.UnexpectedState,1) Verify that the call was ignored.
    03: Call Mka_RxTx_TxBufferReady to transition from Buffer_Allocated_Locked to Wait_Icv_Generate_Finished.
    04: VP(Mka.dsn.RxTx.TxSM.TxBufAllocLocked_2_WaitIcvGenFin,2)
        VP(Mka.dsn.RxTx.Api.Mka_RxTx_TxBufferReady,1)
        VP(Mka.InterAct.TxMkpdu,1) Verify that transition to Wait_Icv_Generate_Finished was successfully made and thus the Crypto API Mka_Crypto_IcvGenerateAsync has been called.
    05: Call Mka_RxTx_ReleaseTxBuffer to try to release the buffer that is not allocated. Call shall be ignored.
    06: VP(Mka.dsn.RxTx.TxSM.ReleaseTxBuffer.UnexpectedState,1) Verify that the call was ignored.
    07: VP(Mka.dsn.RxTx.Api.Mka_RxTx_TxBufferReady.MField,2)
        VP(Mka.8021X.MkaTransport.6,1) Verify that concatenation of configured MAC destination address, source MAC address of a physical controller (first 6 bytes of SCI) and MKA protocol Ethernet type (0x888E) are stored at the beginning of a buffer provided to Mka_Crypto_IcvGenerateAsync().
    08: Simulate successful ICV generation by calling back RxTx unit (callback from Crypto unit).
    09: VP(Mka.dsn.RxTx.TxSM.WaitIcvGenFin_2_TxBufUnalloc,2)
        VP(Mka.dsn.RxTx.Api.Mka_RxTx_IcvGenerateFinished,1)
        VP(Mka.InterAct.TxMkpdu,1) Verify that EthIf_Transmit was called with correct input parameters.
    10: Call Mka_RxTx_GetTxBuffer to check if the state has transitioned to Buffer_Unallocated. If that is the case, Mka_RxTx_GetTxBuffer shall call EthIf_ProvideTxBuffer.
    11: VP(Mka.dsn.RxTx.TxSM.WaitIcvGenFin_2_TxBufUnalloc,2) Verify that new buffer was allocated successfully, which means that the state has transitioned to Buffer_Unallocated beforehand.
    12: Sanity check - Reset RxTx instance state.
    13: Sanity check - Sanity check
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.RxTx.TxSM.ReleaseTxBuffer.UnexpectedState</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1629</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.RxTx.TxSM.TxBufAllocLocked_2_WaitIcvGenFin</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1406</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.RxTx.Api.Mka_RxTx_TxBufferReady</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1063</internalId></provcov>
        <provcov>
          <linksto>Mka.InterAct.TxMkpdu</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1103</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.RxTx.Api.Mka_RxTx_TxBufferReady.MField</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1630</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.MkaTransport.6</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>156</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.RxTx.TxSM.WaitIcvGenFin_2_TxBufUnalloc</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1409</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.RxTx.Api.Mka_RxTx_IcvGenerateFinished</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1066</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2316</internalId></specobject>
    <specobject>
      <id>Mka_RxTx_UnitTest01003_BufAlloc_2_WaitIcvGenFin_2_BufAlloc</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_RxTx/TestSpec_Generated.h</sourcefile>
      <sourceline>115</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that when the state is set to Buffer_Allocated_Locked and API Mka_RxTx_TxBufferReady is called, the state transitions to Wait_Icv_Generate_Finished until the ICV is generated. If ICV generating fails, Mka_RxTx_IcvGenerateFinished is called with parameter E_NOT_OK, the state is moved to Buffer_Allocated_Unlocked.
Test Object: Mka_RxTx_TxBufferReady transitions in both Asynchronous and Synchronous mode.
Test Precondition: 
    -   RxTx unit initialized.
    -   Call Mka_RxTx_GetTxBuffer to allocate Tx Buffer.
  
Test Execution: 
    01: Call Mka_RxTx_TxBufferReady to transition from Buffer_Allocated_Locked to Wait_Icv_Generate_Finished.
    02: Sanity check - Check that transition to Wait_Icv_Generate_Finished was successfully made and thus the Crypto API Mka_Crypto_IcvGenerateAsync has been called.
    03: Simulate failed ICV gen. by calling back RxTx unit (callback from Crypto unit) with E_NOT_OK.
    04: VP(Mka.dsn.RxTx.TxSM.WaitIcvGenFin_2_TxBufAllocUnlocked,2) RxTx instance should change it's state to Buffer_Allocated_Unlocked, thus it shall not call EthIf_Transmit.
    05: Call Mka_RxTx_GetTxBuffer from Buffer_Allocated_Unlocked. If that is the case, the request should return E_OK without calling EthIf_ProvideTxBuffer
    06: VP(Mka.dsn.RxTx.TxSM.TxBufAllocUnlocked_2_TxBufAllocLocked,2) Verify that the state was in Buffer_Allocated_Unlocked state. Calling Mka_RxTx_GetTxBuffer shall return E_OK and switch state to Buffer_Allocated_Locked.
    07: Sanity check - Reset RxTx instance state.
    08: Sanity check - Sanity check
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.RxTx.TxSM.WaitIcvGenFin_2_TxBufAllocUnlocked</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1411</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.RxTx.TxSM.TxBufAllocUnlocked_2_TxBufAllocLocked</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1408</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2317</internalId></specobject>
    <specobject>
      <id>Mka_RxTx_UnitTest01004_Initial_2_RxBufFree_2_WaitIcvVerFin_2_RxBufFree</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_RxTx/TestSpec_Generated.h</sourcefile>
      <sourceline>145</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that, after the MKA is initialized the Rx state machine shall transition to Buffer_Free state. This means that, if Mka_RxTx_RxIndication is called with correct input parameters and the called APIs Mka_Crypto_FindParticipant and Mka_Crypto_IcvVerifyAsync return positive results, calling Mka_RxTx_IcvVerifyFinished shall make further call to Mka_KaY_RxMkpdu implying that the received message was checked and the state made successful transitions from Wait_Icv_Verify_Finished back to Buffer_Free.
Test Object: Software
Test Precondition: 
    -   Prepare EthIf_ProvideTxBuffer stub to return expected parameters.
    -   Module configuration initialized with Mka_Init().
  
Test Execution: 
    01: Call Mka_RxTx_Init() to initialize MKA RxTx unit.
    02: Create Mkpdu with 16 Octets.
    03: Call Mka_RxTx_RxIndication with correct input parameters to transition from Buffer_Free state to Wait_Icv_Verify_Finished. This can be done only if the active state is Buffer_Free.
    04: VP(Mka.dsn.RxTx.Api.Mka_RxTx_RxIndication,1)
        VP(Mka.dsn.RxTx.RxSM.RxBufFree_2_WaitIcvVer,2)
        VP(Mka.dsn.RxTx.RxSM.Initial_2_RxBufFree,2)
        VP(Mka.8021X.MkaTransport.2,1)
        VP(Mka.InterAct.RxMkpdu,1) Check that RxTx initialization process was successful and that the Rx state machine transitioned to RXTX_RX_BUFFER_FREE. Verify that the transition to state Wait_Icv_Verify_Finished was made as RxTx unit shall call Mka_Crypto_FindParticipant and Mka_Crypto_IcvVerifyAsync and wait for the response.
    05: Call Mka_RxTx_IcvVerifyFinished to make transition from Wait_Icv_Verify_Finished to Buffer_Free state.
    06: VP(Mka.dsn.RxTx.Api.Mka_RxTx_IcvVerifyFinished,1)
        VP(Mka.dsn.RxTx.RxSM.WaitIcvVer_2_RxBufFree_OK,2)
        VP(Mka.InterAct.RxMkpdu,1) Verify that transition to Buffer_Free state was successful as RxTx unit shall call Mka_KaY_RxMkpdu with an expected set of input parameters.
    07: Call Mka_RxTx_RxIndication with correct input parameters to transition from Buffer_Free state to Wait_Icv_Verify_Finished. This can be done only if the active state is Buffer_Free.
    08: Sanity check - Check if Mka_Crypto_FindParticipant and Mka_Crypto_IcvVerifyAsync have been called which indicates a state change.
    09: Call Mka_RxTx_IcvVerifyFinished with input parameter E_NOT_OK. No API calls shall be made.
    10: VP(Mka.dsn.RxTx.Api.Mka_RxTx_IcvVerifyFinished,1)
        VP(Mka.dsn.RxTx.RxSM.WaitIcvVer_2_RxBufFree_NOT_OK,2)
        VP(Mka.CP_SWS_Mka_00034,1) Verify that Mka_Logon_ReportEvent was called with MKA_E_KEY_MISMATCH_INSTANCE.
    11: Sanity check - Sanity check
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.RxTx.Api.Mka_RxTx_RxIndication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1064</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.RxTx.RxSM.RxBufFree_2_WaitIcvVer</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1403</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.RxTx.RxSM.Initial_2_RxBufFree</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1404</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.MkaTransport.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>152</internalId></provcov>
        <provcov>
          <linksto>Mka.InterAct.RxMkpdu</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1102</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.RxTx.Api.Mka_RxTx_IcvVerifyFinished</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1065</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.RxTx.RxSM.WaitIcvVer_2_RxBufFree_OK</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1401</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.RxTx.RxSM.WaitIcvVer_2_RxBufFree_NOT_OK</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1402</internalId></provcov>
        <provcov>
          <linksto>Mka.CP_SWS_Mka_00034</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>353</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2318</internalId></specobject>
    <specobject>
      <id>Mka_RxTx_UnitTest01005_RxBufFree_2_WaitIcvVerFin_Fail</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_RxTx/TestSpec_Generated.h</sourcefile>
      <sourceline>214</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that, after the MKA is initialized and the Rx state machine transitions to Buffer_Free state, the EAPOL MKPDU shall be dropped if the input parameters for the service Mka_RxTx_RxIndication are incorrect. If this happens, no further state transition should happen and the PDU shall be ignored.
Test Object: Software
Test Precondition: 
    -   RxTx unit initialized
  
Test Execution: 
    01: Create TestMkpdu for tests.
    02: Call Mka_RxTx_RxIndication with too small value of the LenByte input parameter. There should be no further state transitions and the call should be ignored.
    03: VP(Mka.8021X.Eapol.27.2,1) Verify that no other state transitions happened and the call was ignored.
    04: Modify TestMkpdu to have incorrect EAPOL packet type.
    05: Call Mka_RxTx_RxIndication with Frame type that is not EAPOL_MKA. There should be no further state transitions and the call should be ignored.
    06: VP(Mka.dsn.RxTx.Api.Mka_RxTx_RxIndication.EAPoLPacketType,1) Verify that no other state transitions happened and the call was ignored.
    07: Modify lower octet of EAPOL Packet Body Length of TestMkpdu to have packet body value of zero. Set Packet Type to correct value.
    08: Call Mka_RxTx_RxIndication with too small parameter for EAPOL Packet body length. There should be no further state transitions and the call should be ignored.
    09: VP(Mka.dsn.RxTx.Api.Mka_RxTx_RxIndication.LenByteEAPoLBodyPacketLength,1) Verify that no other state transitions happened and the call was ignored.
    10: Sanity check - Sanity check
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.27.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>71</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.RxTx.Api.Mka_RxTx_RxIndication.EAPoLPacketType</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1621</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.RxTx.Api.Mka_RxTx_RxIndication.LenByteEAPoLBodyPacketLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1622</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2319</internalId></specobject>
    <specobject>
      <id>Mka_RxTx_UnitTest01006_EAPOL_27_1_Through_4</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_RxTx/TestSpec_Generated.h</sourcefile>
      <sourceline>249</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that, after the MKA is initialized and the Rx state machine transitions to Buffer_Free state, the EAPOL MKPDU shall be dropped if the message parameters are breaking the conditions such as: Mka_RxTx_RxIndication is called with individual destination address of MKPDU, MKPDU body length is not divisible with 4 or basic parameter for body length is bigger than EAPOL packet body length.
Test Object: Software
Test Precondition: 
    -   RxTx unit initialized
  
Test Execution: 
    01: Create and Modify TestMkpdu.
    02: Call Mka_RxTx_RxIndication with individual destination address of MKPDU. There should be no further state transitions and the call should be ignored.
    03: VP(Mka.8021X.Eapol.27.1,1) Verify that Mka_Crypto_FindParticipant and Mka_Crypto_IcvVerifyAsync have been called which indicates a state change. MKPDU is processed, because destination address is configured to processed messages, even when destination address isn't broadcast address, it is achieved with function call EthIf_UpdatePhysAddrFilter().
    04: Modify lower octet of EAPoL Body Length to not be divisible by four in TestMkpdu.
    05: Call Mka_RxTx_RxIndication with MKPDU body length not divisible with 4. There should be no further state transitions and the call should be ignored.
    06: VP(Mka.8021X.Eapol.27.3,1) Verify that no other state transitions happened and the call was ignored.
    07: Modify TestMkpdu so that Basic Parameter body length is larger than EAPOL packet body length
    08: Call Mka_RxTx_RxIndication with basic parameter for body length being bigger than EAPOL packet body length. There should be no further state transitions and the call should be ignored.
    09: VP(Mka.8021X.Eapol.27.4,1) Verify that no other state transitions happened and the call was ignored.
    10: Sanity check - Sanity check
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.27.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>70</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.Eapol.27.3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>72</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.Eapol.27.4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>73</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2320</internalId></specobject>
    <specobject>
      <id>Mka_RxTx_UnitTest01007_EAPOL_27_5_Through_6</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_RxTx/TestSpec_Generated.h</sourcefile>
      <sourceline>284</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that, after the MKA is initialized and the Rx state machine transitions to Buffer_Free state, the EAPOL MKPDU shall be dropped if the message parameters have: unexpected CKN or incorrect algorithm agility parameter. Each Test_Data_* array has at least one wrong parameter as specified in the verify critera and step description.
Test Object: Software
Test Precondition: 
    -   RxTx unit initialized.
    -   Prepare stubs to return expected parameters.
  
Test Execution: 
    01: Create Mkpdu for Tests
    02: Call Mka_RxTx_RxIndication. When Mka_Crypto_FindParticipant is called, it shall return invalid ParticipantIdx to simulate unexpected CKN in the Test_Data.
    03: VP(Mka.8021X.Eapol.27.5,1) Verify that after Mka_Crypto_FindParticipant was called, no other state transitions happened and no further calls were made.
    04: Sanity check - Reset stub values.
    05: Modify TestMkpdu with unrecognized Algorithm Agility Parameter.
    06: Call Mka_RxTx_RxIndication with incorrect algorithm agility input parameter. There should be no further state transitions and the RxIndication procedure shall be terminated.
    07: VP(Mka.8021X.Eapol.27.6,1) Verify that after calling Mka_Crypto_FindParticipant, the process was terminated and no further calls were made.
    08: Sanity check - Sanity check
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.27.5</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>74</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.Eapol.27.6</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>75</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2321</internalId></specobject>
    <specobject>
      <id>Mka_RxTx_UnitTest01008_EAPOL_27_7</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_RxTx/TestSpec_Generated.h</sourcefile>
      <sourceline>314</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that when Mka_RxTx_RxIndication is called with correct input parameters while in Buffer_Free state, if ICV verification fails as in Mka_Crypto_IcvVerifyAsync returns E_NOT_OK, the state shall transition to Wait_Icv_Verify_Finished, but the message buffer should be reset and no further calls should be made till the state resets back to Buffer_Free.
Test Object: Software
Test Precondition: 
    -   Prepare stubs to return expected parameters.
  
Test Execution: 
    01: Create Mkpdu for tests.
    02: Call Mka_RxTx_RxIndication with correct input parameters. Mka_Crypto_IcvVerifyAsync shall return E_NOT_OK to simulate incorrect ICV parameter inside the MKPDU. Due to this, after the state transitions to Wait_Icv_Verify_Finished, the message buffer should be reset and the state should transition back to Buffer_Free.
    03: VP(Mka.8021X.Eapol.27.7,1)
        VP(Mka.EB.CP_SWS_Mka_00006,1) Verify that the calls for FindMkaId and IcvVerifyAsync were made and that Mka_Crypto_IcvVerifyAsync returned E_NOT_OK, which implies that no ICK has been generated beforehand or that ICV gen. failed for some other reason.
    04: Call Mka_RxTx_IcvVerifyFinished to check if the state transitioned correctly after incorrect ICV verification. After Mka_Crypto_IcvVerifyAsync returned E_NOT_OK, the state should transition back to Buffer_Free which means that, when Mka_RxTx_IcvVerifyFinished is called, the RxTx unit shall not make any further calls or transitions.
    05: VP(Mka.8021X.Eapol.27.7,1)
        VP(Mka.EB.CP_SWS_Mka_00006,1) Verify that no further calls were made which implies that the message was discarded and the state transitioned to Buffer_Free.
    06: Sanity check - Sanity check
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.27.7</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>76</internalId></provcov>
        <provcov>
          <linksto>Mka.EB.CP_SWS_Mka_00006</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>304</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2322</internalId></specobject>
    <specobject>
      <id>Mka_RxTx_UnitTest01009_ValidateMkpdu_InvalidEtherHeaderType</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_RxTx/TestSpec_Generated.h</sourcefile>
      <sourceline>343</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that when MKPDU was received with Ethernet header type invalid , MKPDU is discarded.
Test Object: Mka_RxTx_RxIndication() discard MKPDU if has invalid Ethernet header type.
Test Precondition: 
    -   RxTx unit initialized.
  
Test Execution: 
    01: Create Mkpdu for Test.
    02: Call Mka_RxTx_RxIndication() to indicate frame reception with correct parameters.
    03: Call Mka_RxTx_RxIndication() to indicate frame reception with individual destination address.
    04: VP(Mka.8021X.Eapol.5,1)
        VP(Mka.8021X.Eapol.8.5,1)
        VP(Mka.8021X.Eapol.8.7,1) Verify that MKPDU is discarded, because Ethernet header type isn't MacSec ethernet type. MKPDU should be discarded at beginning of check and Crypto isn't called for Mka_Crypto_FindParticipant() and Mka_Crypto_IcvVerifyAsync().
    05: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.5</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>35</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.Eapol.8.5</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>47</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.Eapol.8.7</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>49</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2323</internalId></specobject>
    <specobject>
      <id>Mka_RxTx_UnitTest01010_ValidateMkpdu_MkpduWithInvalidLengths</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_RxTx/TestSpec_Generated.h</sourcefile>
      <sourceline>375</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that received MKPDU is shorter than 32 octets or Length of received data is shorter then 32 + EAPOL header length octets, but bigger then 32 octets and if incomplete EAPOL-MKA is received or some part of EAPOL body is missing MKPDU shall be discarded.
Test Object: Mka_RxTx_RxIndication() discard MKPDU if lengths are invalid.
Test Precondition: 
    -   RxTx unit initialized.
  
Test Execution: 
    01: Create and Modify Mkpdu for Test. EapolPacketBodyLength is set to less than 32 octets
    02: Call Mka_RxTx_RxIndication() to indicate frame reception with EAPoL body length shorter than 32 octets.
    03: VP(Mka.8021X.Eapol.27.2,1) Verify that MKPDU is discarded, because in MKPDU EAPoL body length is shorter than 32 octets. MKPDU should be discarded at begining of check and Crypto isn't called for Mka_Crypto_FindParticipant() and Mka_Crypto_IcvVerifyAsync().
    04: Return EAPoL body length to correct value by setting lower octet.
    05: Call Mka_RxTx_RxIndication() to indicate frame reception with Length of received data between 32 and 32 + EAPOL header length.
    06: VP(Mka.8021X.Eapol.27.2,1) Verify that MKPDU is discarded, because Length of received data is shorter than 32 + EAPOL header length. MKPDU should be discarded at begining of check and Crypto isn't called for Mka_Crypto_FindParticipant() and Mka_Crypto_IcvVerifyAsync().
    07: Call Mka_RxTx_RxIndication() to indicate frame reception with Length of received data between 32 + EAPOL header length and actual size of MKPDU.
    08: VP(Mka.8021X.Eapol.27.2,1) Verify that MKPDU is discarded, because incomplete EAPOK-MKA is received, some part of EAPOL body is missing. MKPDU should be discarded at begining of check and Crypto isn't called for Mka_Crypto_FindParticipant() and Mka_Crypto_IcvVerifyAsync().
    09: Call Mka_RxTx_RxIndication() with correct Length of received data to verify MKPDU will not be discarded.
    10: Sanity check - Crypto is called for Mka_Crypto_FindParticipant() and Mka_Crypto_IcvVerifyAsync() because MKPDU is valid.
    11: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.27.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>71</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2324</internalId></specobject>
    <specobject>
      <id>Mka_RxTx_UnitTest01011_ValidateMkpdu_MkpduNotMultipleOf4</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_RxTx/TestSpec_Generated.h</sourcefile>
      <sourceline>403</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that when MKPDU was received with length that is not a multiple of 4 octets, MKPDU is discarded.
Test Object: Mka_RxTx_RxIndication() discard MKPDU if length isn't a multiple of 4 octets.
Test Precondition: 
    -   RxTx unit initialized.
  
Test Execution: 
    01: Create and Modify Mkpdu for test.
    02: Call Mka_RxTx_RxIndication() to indicate frame reception with EAPOL-MKA that isn't multiple of 4.
    03: VP(Mka.8021X.Eapol.27.3,1) Verify that MKPDU is discarded, because received MKPDU length is not multiple of 4. MKPDU should be discarded at begining of check and Crypto isn't called for Mka_Crypto_FindParticipant() and Mka_Crypto_IcvVerifyAsync().
    04: Modify TestMkpdu for a valid multiple of 4 using null padding octet.
    05: Call Mka_RxTx_RxIndication() to indicate frame reception with EAPOL-MKA which contain Null padding octets to be multiple of 4.
    06: Sanity check - Verify that MKPDU isn't discarded, because received MKPDU has length that is multiple of 4 because of the padding. It is called Crypto for Mka_Crypto_FindParticipant() and Mka_Crypto_IcvVerifyAsync().
    07: Sanity check - Sanity check
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.27.3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>72</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2325</internalId></specobject>
    <specobject>
      <id>Mka_RxTx_UnitTest01012_ValidateMkpdu_IndividualPacketBodyLength</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_RxTx/TestSpec_Generated.h</sourcefile>
      <sourceline>427</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that when MKPDU was received with EAPOL-MKA packet body length shorter than sum of Basic parameter set and 16 octets of ICV, parameter set is discarded..
Test Object: Mka_RxTx_RxIndication() discard MKPDU with sum of Basic parameter set and 16 octets of ICV is bigger than EAPOL-MKA packet body length.
Test Precondition: 
    -   RxTx unit initalize.
  
Test Execution: 
    01: Create Mkpdu. Modify Mkpdu to have EAPoL body length to be shorter than sum of basic parameter set and 16 octets of ICV
    02: Call Mka_RxTx_RxIndication() to indicate frame reception with incorrect packet body length.
    03: VP(Mka.8021X.Eapol.27.4,1) Verify that MKPDU is discarded, because received MKPDU has packet with EAPOL-MKA packet body length shorter than sum of Basic parameter set and 16 octets of ICV. MKPDU should be discarded at begining of check and Crypto isn't called for Mka_Crypto_FindParticipant() and Mka_Crypto_IcvVerifyAsync().
    04: Set EAPoL body length to correct length.
    05: Call Mka_RxTx_RxIndication() to indicate frame reception with correct packet body length.
    06: Sanity check - EAPOL-MKA isn't discarded with valid value of EAPOL-MKA packet body length.
    07: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.27.4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>73</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2326</internalId></specobject>
    <specobject>
      <id>Mka_RxTx_UnitTest01013_ValidateMkpdu_InvalidCkn</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_RxTx/TestSpec_Generated.h</sourcefile>
      <sourceline>451</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that when MKPDU was received with invalid CKN, that isn't configured.
Test Object: Mka_RxTx_RxIndication() discard MKPDU because of invalid CKN.
Test Precondition: 
    -   RxTx unit initialized.
  
Test Execution: 
    01: Create Mkpdu for Testing.
    02: Call Mka_RxTx_RxIndication().
    03: VP(Mka.8021X.Eapol.27.5,1)
        VP(Mka.8021X.MkaTransport.2,1) Verify that MKPDU is discarded, RxTx called crypto to find ParticipantIdx with function Mka_Crypto_FindParticipant(). Because of invalid CKN, MKPDU is discarded and crypto isn't called for Mka_Crypto_IcvVerifyAsync().
    04: VP(Mka.EB.RunTimeEvent.BitFieldDefinition,1)
        VP(Mka.EB.RunTimeEvent.TriggeredEventPae,1) Verify that, after Ckn verification failed, a bit for that event has been set for the selected Pae.
    05: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.27.5</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>74</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.MkaTransport.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>152</internalId></provcov>
        <provcov>
          <linksto>Mka.EB.RunTimeEvent.BitFieldDefinition</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1478</internalId></provcov>
        <provcov>
          <linksto>Mka.EB.RunTimeEvent.TriggeredEventPae</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1480</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2327</internalId></specobject>
    <specobject>
      <id>Mka_RxTx_UnitTest01014_ValidateMkpdu_NotSupportedAlgorithAgillty</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_RxTx/TestSpec_Generated.h</sourcefile>
      <sourceline>487</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that when MKPDU was received with Algorithm Agility that is not supported by standard IEEE 802.1X-2020, MKPDU is discarded.
Test Object: Mka_RxTx_RxIndication() discard MKPDU because of not supported Algorith Agillty.
Test Precondition: 
    -   RxTx unit initialized.
  
Test Execution: 
    01: Create Mkpdu for Testing.
    02: Call Mka_RxTx_RxIndication() with valid MKPDU.
    03: Sanity check - EAPOL-MKA isn't discarded.
    04: Set new Algorithm Agility in MKPDU.
    05: Call Mka_RxTx_RxIndication() with Algorithm Agility that isn't supported.
    06: VP(Mka.8021X.Eapol.27.6,1)
        VP(Mka.8021X.MkaKeyHierarchy.29,1) Verify that MKPDU is discarded when received Algorithm Agility isn't supported. Crypto is called for Mka_Crypto_FindParticipant() to find ParticipantIdx from CKN, but after check of Algorithm Agility MKPDU is discarded and Mka_Crypto_IcvVerifyAsync() isn't called.
    07: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.27.6</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>75</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.MkaKeyHierarchy.29</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2328</internalId></specobject>
    <specobject>
      <id>Mka_RxTx_UnitTest01015_ValidateMkpdu_IcvVerification</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_RxTx/TestSpec_Generated.h</sourcefile>
      <sourceline>516</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that when MKPDU is received with valid ICV, MKPDU is passed to KaY unit via function Mka_KaY_RxMkpdu(), and when ICV is invalid, MKPDU is discarded.
Test Object: Mka_RxTx_RxIndication() passes MKPDU to KaY unit if is ICV valid or discard MKPDU if is ICV invalid.
Test Precondition: 
    -   RxTx unit initialized
  
Test Execution: 
    01: Create Mkpdu for Testing.
    02: Call Mka_RxTx_RxIndication() with valid MKPDU.
    03: Sanity check - EAPOL-MKA isn't discarded.
    04: Call Mka_RxTx_IcvVerifyFinished() with Result = E_OK to simulate that ICV verification succeeded.
    05: VP(Mka.8021X.Eapol.27.7,1) Verify that is MKPDU passed to KaY unit with function call of Mka_KaY_RxMkpdu().
    06: Call Mka_RxTx_IsIcvErrorPresent() to get status of ICV verification.
    07: VP(Mka.dsn.RxTx.Api.Mka_RxTx_IsIcvErrorPresent,1) Verify that Mka_RxTx_IsIcvErrorPresent() returned FALSE, which represent that there is no error.
    08: Call Mka_RxTx_RxIndication() with valid MKPDU.
    09: Sanity check - EAPOL-MKA isn't discarded.
    10: Call Mka_RxTx_IcvVerifyFinished() with Result = E_NOT_OK to simulate that was ICV verification failed.
    11: VP(Mka.8021X.Eapol.27.7,1) Verify that MKPDU isn't passed to KaY unit with function call of Mka_KaY_RxMkpdu(), because ICV was incorrect.
    12: VP(Mka.EB.RunTimeEvent.BitFieldDefinition,1)
        VP(Mka.EB.RunTimeEvent.TriggeredEventParticipant,1) Verify that, after Icv verification failed, a bit for that event has been set for the selected Participant.
    13: Call Mka_RxTx_IsIcvErrorPresent() to get status of ICV verification.
    14: VP(Mka.dsn.RxTx.Api.Mka_RxTx_IsIcvErrorPresent,1) Verify that Mka_RxTx_IsIcvErrorPresent() returned TRUE, which represent that there was an error in verification of ICV.
    15: Sanity check - Sanity check.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.27.7</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>76</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.RxTx.Api.Mka_RxTx_IsIcvErrorPresent</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1067</internalId></provcov>
        <provcov>
          <linksto>Mka.EB.RunTimeEvent.BitFieldDefinition</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1478</internalId></provcov>
        <provcov>
          <linksto>Mka.EB.RunTimeEvent.TriggeredEventParticipant</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1479</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2329</internalId></specobject>
    <specobject>
      <id>Mka_RxTx_UnitTest01016_RxIndication_GetRxBufferFail</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_RxTx/TestSpec_Generated.h</sourcefile>
      <sourceline>561</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that when Mka_RxTx_RxIndication() is called and allocation of Rx buffer fails because it is already in use EAPOL PDU shall be dropped
Test Object: Mka_RxTx_RxIndication() discards MKPDU if Mka_RxTx_RxIndication() is called in WAIT_ICV_VERIFY_FINISHED state
Test Precondition: 
    -   RxTx unit initialized
  
Test Execution: 
    01: Create and Modify Mkpdu for test with frame size bigger than buffer size.
    02: Call Mka_RxTx_RxIndication with valid parameters to transition to WAIT_ICV_VERIFY_FINISHED.
    03: Sanity check - Check that the transition to state WAIT_ICV_VERIFY_FINISHED was made as RxTx unit shall call Mka_Crypto_FindParticipant and Mka_Crypto_IcvVerifyAsync and wait for the response
    04: Call Mka_RxTx_RxIndication with valid parameters from WAIT_ICV_VERIFY_FINISHED state. There should be no further state transitions and the call should be ignored.
    05: VP(Mka.dsn.RxTx.Api.Mka_RxTx_RxIndication.GetRxBuffer.Fail,2) Verify that no other state transitions happened and the call was ignored. RxTx unit shall call Mka_Crypto_FindParticipant but Mka_Crypto_IcvVerifyAsync is not reached since the buffer is not free
    06: VP(Mka.EB.RunTimeEvent.BitFieldDefinition,1)
        VP(Mka.EB.RunTimeEvent.TriggeredEventParticipant,1) Verify that, after Rx buffer allocation failed, a bit for that event has been set for the selected Participant.
    07: Sanity check - Sanity check
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.RxTx.Api.Mka_RxTx_RxIndication.GetRxBuffer.Fail</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1623</internalId></provcov>
        <provcov>
          <linksto>Mka.EB.RunTimeEvent.BitFieldDefinition</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1478</internalId></provcov>
        <provcov>
          <linksto>Mka.EB.RunTimeEvent.TriggeredEventParticipant</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1479</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2330</internalId></specobject>
    <specobject>
      <id>Mka_RxTx_UnitTest01017_RxIndication_DataSizeOversized</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_RxTx/TestSpec_Generated.h</sourcefile>
      <sourceline>594</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that when Mka_RxTx_RxIndication() is called and buffer size is smaller than required (2 * Mac address size (6) + Ethernet type size + EAPOL header size (4) + received MKPDU size), the frame shall be silently dropped
Test Object: Mka_RxTx_RxIndication() discards MKPDU if the frame size is bigger than buffer size
Test Precondition: 
    -   RxTx unit initialized
  
Test Execution: 
    01: Create and Modify Mkpdu for test with frame size bigger than buffer size.
    02: Call Mka_RxTx_RxIndication with frame size bigger than buffer size There should be no further state transitions and the call should be ignored.
    03: VP(Mka.dsn.RxTx.Api.Mka_RxTx_RxIndication.DataSize.Oversized,1) Verify that no other state transitions happened and the call was ignored. RxTx unit shall call Mka_Crypto_FindParticipant but Mka_Crypto_IcvVerifyAsync is not reached since the frame size is bigger than the buffer size
    04: Sanity check - Sanity check
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.RxTx.Api.Mka_RxTx_RxIndication.DataSize.Oversized</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1624</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2331</internalId></specobject>
    <specobject>
      <id>Mka_RxTx_UnitTest01018_GetTxBuffer_ProvideTxBufferFail</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_RxTx/TestSpec_Generated.h</sourcefile>
      <sourceline>615</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that when Mka_RxTx_GetTxBuffer() is called and allocation of buffer in EthIf fails (EthIf_ProvideTxBuffer() returns other than BUFREQ_OK) MKA returns E_NOT_OK
Test Object: Mka_RxTx_GetTxBuffer() returns E_NOT_OK when EthIf_ProvideTxBuffer returns BUFREQ_E_NOT_OK, BUFREQ_E_BUSY, or BUFREQ_E_OVFL
Test Precondition: 
    -   RxTx unit initialized.
  
Test Execution: 
    01: EthIf_ProvideTxBuffer should return other than BUFREQ_OK for Mka_RxTx_GetTxBuffer to fail while in RXTX_TX_BUFFER_UNALLOCATED state
    02: Call Mka_RxTx_GetTxBuffer to allocate Tx Buffer.
    03: VP(Mka.dsn.RxTx.Api.Mka_RxTx_GetTxBuffer.ProvideTxBuffer.Fail,1) Verify that new buffer was not allocated
    04: EthIf_ProvideTxBuffer should return other than BUFREQ_OK for Mka_RxTx_GetTxBuffer to fail while in RXTX_TX_BUFFER_UNALLOCATED state
    05: Call Mka_RxTx_GetTxBuffer to allocate Tx Buffer.
    06: VP(Mka.dsn.RxTx.Api.Mka_RxTx_GetTxBuffer.ProvideTxBuffer.Fail,1) Verify that new buffer was not allocated
    07: EthIf_ProvideTxBuffer should return other than BUFREQ_OK for Mka_RxTx_GetTxBuffer to fail while in RXTX_TX_BUFFER_UNALLOCATED state
    08: Call Mka_RxTx_GetTxBuffer to allocate Tx Buffer.
    09: VP(Mka.dsn.RxTx.Api.Mka_RxTx_GetTxBuffer.ProvideTxBuffer.Fail,1) Verify that new buffer was not allocated
    10: Sanity check - Sanity check
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.RxTx.Api.Mka_RxTx_GetTxBuffer.ProvideTxBuffer.Fail</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1625</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2332</internalId></specobject>
    <specobject>
      <id>Mka_RxTx_UnitTest01019_GetTxBuffer_UnexpectedState</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_RxTx/TestSpec_Generated.h</sourcefile>
      <sourceline>642</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that when Mka_RxTx_GetTxBuffer() is called from an unexpected TxSM state (other than RXTX_TX_BUFFER_UNALLOCATED or RXTX_TX_BUFFER_ALLOCATED_UNLOCKED) MKA will ignore the call and return E_NOT_OK
Test Object: Mka_RxTx_GetTxBuffer() will not call EthIf_ProvideTxBuffer and will return E_NOT_OK
Test Precondition: 
    -   Prepare stubs to return expected parameters.
    -   Module configuration initialized with Mka_Init().
    -   Call Mka_RxTx_GetTxBuffer to transition to BUFFER_ALLOCATED_LOCKED.
  
Test Execution: 
    01: Sanity check - Check that transition to BUFFER_ALLOCATED_LOCKED was made and thus EthIf_ProvideTxBuffer has been called.
    02: Call Mka_RxTx_GetTxBuffer from BUFFER_ALLOCATED_LOCKED state.
    03: VP(Mka.dsn.RxTx.TxSM.GetTxBuffer.UnexpectedState,1) Verify that call to Mka_RxTx_GetTxBuffer from BUFFER_ALLOCATED_LOCKED state is ignored and returns E_NOT_OK
    04: Call Mka_RxTx_TxBufferReady to transition to WAIT_ICV_GENERATE_FINISHED.
    05: Sanity check - Check that transition to WAIT_ICV_GENERATE_FINISHED was successfully made and thus the Crypto API Mka_Crypto_IcvGenerateAsync has been called.
    06: Call Mka_RxTx_GetTxBuffer from WAIT_ICV_GENERATE_FINISHED state.
    07: VP(Mka.dsn.RxTx.TxSM.GetTxBuffer.UnexpectedState,1) Verify that call to Mka_RxTx_GetTxBuffer from WAIT_ICV_GENERATE_FINISHED state is ignored and returns E_NOT_OK
    08: Simulate failed ICV gen. by calling back RxTx unit (callback from Crypto unit) with E_NOT_OK to transition to BUFFER_ALLOCATED_UNLOCKED.
    09: VP(Mka.EB.RunTimeEvent.BitFieldDefinition,1)
        VP(Mka.EB.RunTimeEvent.TriggeredEventParticipant,1) Verify that, after Icv generate failed, a bit for that event has been set for the selected Participant.
    10: Sanity check - Check that previous state was BUFFER_ALLOCATED_UNLOCKED. Calling Mka_RxTx_GetTxBuffer from BUFFER_ALLOCATED_UNLOCKED shall return E_OK and switch state to BUFFER_ALLOCATED_LOCKED without calling EthIf_ProvideTxBuffer
    11: Sanity check - Sanity check
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.RxTx.TxSM.GetTxBuffer.UnexpectedState</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1628</internalId></provcov>
        <provcov>
          <linksto>Mka.EB.RunTimeEvent.BitFieldDefinition</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1478</internalId></provcov>
        <provcov>
          <linksto>Mka.EB.RunTimeEvent.TriggeredEventParticipant</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1479</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2333</internalId></specobject>
    <specobject>
      <id>Mka_RxTx_UnitTest01021_IcvGenerateFinished_UnexpectedState</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_RxTx/TestSpec_Generated.h</sourcefile>
      <sourceline>681</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that when Mka_RxTx_IcvGenerateFinished() is called from an unexpected TxSM state (other than RXTX_WAIT_ICV_GENERATE_FINISHED) MKA will ignore the call
Test Object: Mka_RxTx_IcvGenerateFinished() will not call EthIf_Transmit
Test Precondition: 
    -   RxTx unit initialized.
  
Test Execution: 
    01: Simulate incorrect call of IcvGenerateFinished from BUFFER_UNALLOCATED state
    02: VP(Mka.dsn.RxTx.TxSM.IcvGenerateFinished.UnexpectedState,2) Verify that EthIf_Transmit was not called
    03: Call Mka_RxTx_GetTxBuffer to transition to BUFFER_ALLOCATED_LOCKED.
    04: Sanity check - Check that transition to BUFFER_ALLOCATED_LOCKED was made and thus EthIf_ProvideTxBuffer has been called.
    05: Simulate incorrect call of IcvGenerateFinished from BUFFER_ALLOCATED_LOCKED state
    06: VP(Mka.dsn.RxTx.TxSM.IcvGenerateFinished.UnexpectedState,2) Verify that EthIf_Transmit was not called
    07: Call Mka_RxTx_TxBufferReady to transition to WAIT_ICV_GENERATE_FINISHED.
    08: Sanity check - Check that transition to WAIT_ICV_GENERATE_FINISHED was successfully made and thus the Crypto API Mka_Crypto_IcvGenerateAsync has been called.
    09: Simulate failed ICV gen. by calling back RxTx unit (callback from Crypto unit) with E_NOT_OK to transition to BUFFER_ALLOCATED_UNLOCKED.
    10: Sanity check - Check that transition BUFFER_ALLOCATED_UNLOCKED was made and thus EthIf_Transmit was not called.
    11: Simulate incorrect call of IcvGenerateFinished from BUFFER_ALLOCATED_UNLOCKED state
    12: VP(Mka.dsn.RxTx.TxSM.IcvGenerateFinished.UnexpectedState,2) Verify that EthIf_Transmit was not called
    13: Sanity check - Check that previous state was BUFFER_ALLOCATED_UNLOCKED. Calling Mka_RxTx_GetTxBuffer from BUFFER_ALLOCATED_UNLOCKED shall return E_OK and switch state to BUFFER_ALLOCATED_LOCKED without calling EthIf_ProvideTxBuffer
    14: Sanity check - Sanity check
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.RxTx.TxSM.IcvGenerateFinished.UnexpectedState</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1626</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2334</internalId></specobject>
    <specobject>
      <id>Mka_RxTx_UnitTest01022_TxBufferReady_UnexpectedState</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_RxTx/TestSpec_Generated.h</sourcefile>
      <sourceline>712</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that when Mka_RxTx_TxBufferReady() is called from an unexpected TxSM state (other than RXTX_TX_BUFFER_ALLOCATED_LOCKED) MKA will ignore the call and return E_NOT_OK
Test Object: Mka_RxTx_TxBufferReady() will not call Mka_Crypto_IcvGenerateAsync and will return E_NOT_OK
Test Precondition: 
    -   RxTx unit initialized.
  
Test Execution: 
    01: Call Mka_RxTx_TxBufferReady from BUFFER_UNALLOCATED state.
    02: VP(Mka.dsn.RxTx.TxSM.TxBufferReady.UnexpectedState,2) Verify that call to Mka_RxTx_TxBufferReady from BUFFER_UNALLOCATED state is ignored and returns E_NOT_OK
    03: Call Mka_RxTx_GetTxBuffer to transition to BUFFER_ALLOCATED_LOCKED.
    04: Sanity check - Check that transition to BUFFER_ALLOCATED_LOCKED was made and thus EthIf_ProvideTxBuffer has been called.
    05: Call Mka_RxTx_TxBufferReady to transition to WAIT_ICV_GENERATE_FINISHED.
    06: Sanity check - Check that transition to WAIT_ICV_GENERATE_FINISHED was successfully made and thus the Crypto API Mka_Crypto_IcvGenerateAsync has been called.
    07: Call Mka_RxTx_TxBufferReady from WAIT_ICV_GENERATE_FINISHED state
    08: VP(Mka.dsn.RxTx.TxSM.TxBufferReady.UnexpectedState,2) Verify that call to Mka_RxTx_TxBufferReady from WAIT_ICV_GENERATE_FINISHED state is ignored and returns E_NOT_OK
    09: Simulate failed ICV gen. by calling back RxTx unit (callback from Crypto unit) with E_NOT_OK to transition to BUFFER_ALLOCATED_UNLOCKED.
    10: Call Mka_RxTx_TxBufferReady from BUFFER_ALLOCATED_UNLOCKED state
    11: VP(Mka.dsn.RxTx.TxSM.TxBufferReady.UnexpectedState,2) Verify that call to Mka_RxTx_TxBufferReady from BUFFER_ALLOCATED_UNLOCKED state is ignored and returns E_NOT_OK
    12: Sanity check - Check that previous state was BUFFER_ALLOCATED_UNLOCKED. Calling Mka_RxTx_GetTxBuffer from BUFFER_ALLOCATED_UNLOCKED shall return E_OK and switch state to BUFFER_ALLOCATED_LOCKED without calling EthIf_ProvideTxBuffer
    13: Sanity check - Sanity check
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.RxTx.TxSM.TxBufferReady.UnexpectedState</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1627</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2335</internalId></specobject>
    <specobject>
      <id>Mka_RxTx_UnitTest01023_EthIf_Transmit_ParamCheck</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_RxTx/TestSpec_Generated.h</sourcefile>
      <sourceline>742</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that EthIf_Transmit() is called with correct parameters with sent MKPDU.
Test Object: EthIf_Transmit() will return correct parameters for DstMacAddress and FrameType.
Test Precondition: 
    -   RxTx unit initialized.
    -   Create Mkpdu for transmition.
  
Test Execution: 
    01: Call Mka_RxTx_GetTxBuffer to allocate Tx Buffer.
    02: Copy MKPDU into the buffer.
    03: Call Mka_RxTx_TxBufferReady to transition from Buffer_Allocated to Wait_Icv_Generate_Finished.
    04: Simulate successful ICV generation by calling back RxTx unit (callback from Crypto unit).
    05: VP(Mka.EB.Eapol.3,1)
        VP(Mka.8021X.Eapol.5,1) Verify that EthIf_Transmit was called with correct input parameters.
    06: VP(Mka.dsn.RxTx.Api.Mka_RxTx_TxBufferReady.MField,2) Verify that the buffer provided to EthIf_Transmit() starts with MKPDU, i.e. that DA, SA and EtherType are removed.
    07: Sanity check - Sanity check
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.EB.Eapol.3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>33</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.Eapol.5</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>35</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.RxTx.Api.Mka_RxTx_TxBufferReady.MField</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1630</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2336</internalId></specobject>
    <specobject>
      <id>Mka_RxTx_UnitTest01024_Correct_Packet_Type</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_RxTx/TestSpec_Generated.h</sourcefile>
      <sourceline>776</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that when Mka_RxTx_RxIndication() is called with invalid packet type in sent MKPDU, it is rejected.
Test Object: Mka_RxTx_RxIndication() called with incorrect Packet Type in the MKPDU.
Test Precondition: 
    -   RxTx unit initialized.
    -   Create Mkpdu for transmition.
    -   Call Mka_RxTx_GetTxBuffer to allocate Tx Buffer.
  
Test Execution: 
    01: Modify MKPDU to have the incorrect Packet Type.
    02: Call Mka_RxTx_RxIndication() when Mkpdu has incorrect packet type.
    03: VP(Mka.8021X.Eapol.8.4,1)
        VP(Mka.8021X.Eapol.8.7,1) Verify that the trace is empty since incorrect parameter was passed.
    04: Set Packet Type to correct version .
    05: Call Mka_RxTx_RxIndication with correct packet type.
    06: Sanity check - Verify that further functions were called since correct parameter was passed.
    07: Sanity check - Sanity check
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.8.4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>46</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.Eapol.8.7</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>49</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2337</internalId></specobject>
    <specobject>
      <id>Mka_RxTx_UnitTest01025_PacketBodySize_Verification</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_RxTx/TestSpec_Generated.h</sourcefile>
      <sourceline>807</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that when Mka_RxTx_RxIndication() is called with a very large Packet Body Length. is rejected.
Test Object: Mka_RxTx_RxIndication is called with large packet body length is rejected.
Test Precondition: 
    -   RxTx unit initialized.
    -   Create Mkpdu for transmition.
    -   Call Mka_RxTx_GetTxBuffer to allocate Tx Buffer.
  
Test Execution: 
    01: Set EAPOL packet Body Length to large number still divisible by 4.
    02: call Mka_RxTx_RxIndication() with Packet Body Length greater than expected.
    03: VP(Mka.8021X.Eapol.8.6,1)
        VP(Mka.8021X.Eapol.8.7,1) Verify that the trace is empty since incorrect parameter was passed.
    04: Set Eapol Packet Body Length to correct value.
    05: Call Mka_RxTx_RxIndication with IsBroadcast == True.
    06: Sanity check - Verify that further functions were called since correct parameter was passed.
    07: Sanity check - Sanity check
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.Eapol.8.6</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>48</internalId></provcov>
        <provcov>
          <linksto>Mka.8021X.Eapol.8.7</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>49</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2338</internalId></specobject>
    <specobject>
      <id>Mka_RxTx_UnitTest01026_BufAllocLocked_2_BufAllocUnlocked</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_RxTx/TestSpec_Generated.h</sourcefile>
      <sourceline>838</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that, after the MKA is initialized and the TX Buffer is allocated successfully, a call to Mka_RxTx_ReleaseTxBuffer will release the buffer successfully and change the RxTx Tx SM to state Buffer_Allocated_Unlocked.
Test Object: Mka_RxTx_GetTxBuffer unit external API existence.
Test Precondition: 
    -   Prepare EthIf_ProvideTxBuffer stub to return expected parameters.
  
Test Execution: 
    01: Call Mka_RxTx_GetTxBuffer to allocate Tx Buffer.
    02: Sanity check - Check that RxTx initialization process was successful and that the state transitioned to Buffer_Unallocated. Verify that new buffer was allocated successfully, indicating transition from Buffer_Unallocated to Buffer_Allocated_Locked.
    03: Call Mka_RxTx_ReleaseTxBuffer to release the buffer.
    04: VP(Mka.dsn.RxTx.TxSM.TxBufAllocLocked_2_TxBufAllocUnlocked,1)
        VP(Mka.dsn.RxTx.Api.Mka_RxTx_ReleaseTxBuffer,1) Verify that Mka_RxTx_ReleaseTxBuffer returned E_OK, indicating that buffer has been released and the Tx Sm transitioned to state Buffer_Allocated_Unlocked.
    05: Call Mka_RxTx_ReleaseTxBuffer to try to release the buffer that is not allocated. Call shall be ignored.
    06: VP(Mka.dsn.RxTx.TxSM.ReleaseTxBuffer.UnexpectedState,1) Verify that the call was ignored.
    07: Call Mka_RxTx_GetTxBuffer to allocate Tx Buffer.
    08: Sanity check - Check that RxTx initialization process was successful and that the state transitioned to Buffer_Allocated_Locked. This confirms that the previous state was Buffer_Allocated_Unlocked.
    09: Sanity check - Sanity check
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.RxTx.TxSM.TxBufAllocLocked_2_TxBufAllocUnlocked</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1405</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.RxTx.Api.Mka_RxTx_ReleaseTxBuffer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1062</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.RxTx.TxSM.ReleaseTxBuffer.UnexpectedState</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1629</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2339</internalId></specobject>
    <specobject>
      <id>Mka_RxTx_UnitTest01027_TxBufferReady_IcvGenerateAsync_ENotOk</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_RxTx/TestSpec_Generated.h</sourcefile>
      <sourceline>873</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that when function Mka_RxTx_TxBufferReady() is called and Mka_Crypto_IcvGenerateAsync() returns E_NOT_OK, buffer is released and SM transits into state RXTX_TX_BUFFER_ALLOCATED_UNLOCKED.
Test Object: Software
Test Precondition: 
    -   Initialize RxTx unit and configure that Mka_Crypto_IcvGenerateAsync returns E_NOT_OK.
    -   Call Mka_RxTx_GetTxBuffer to allocate Tx Buffer.
  
Test Execution: 
    01: Call Mka_RxTx_TxBufferReady to transition from Buffer_Allocated_Locked to Wait_Icv_Generate_Finished.
    02: VP(Mka.dsn.RxTx.Api.TxBufferReady.IcvGenerateAsync_ENotOk,1) Verify that Mka_RxTx_TxBufferReady() and Mka_Crypto_IcvGenerateAsync() returned E_NOT_OK.
    03: Call Mka_RxTx_ReleaseTxBuffer to try to release the buffer.
    04: VP(Mka.dsn.RxTx.TxSM.ReleaseTxBuffer.UnexpectedState,1) Verify that the call was ignored, because buffer is already released.
    05: Sanity check - Sanity check
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.dsn.RxTx.Api.TxBufferReady.IcvGenerateAsync_ENotOk</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1631</internalId></provcov>
        <provcov>
          <linksto>Mka.dsn.RxTx.TxSM.ReleaseTxBuffer.UnexpectedState</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1629</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2340</internalId></specobject>
    <specobject>
      <id>Mka_RxTx_UnitTest01028_Invalid_CKN_size_In_Received_BasicParameterSet</id>
      <status>approved</status>
      <source>EB test case specification (asc_Mka)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Mka/test/ts5/Implementation/IN/Mka_UnitTest_RxTx/TestSpec_Generated.h</sourcefile>
      <sourceline>900</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: This test verifies that MKPDU parser will handle correctly received EAPOL message with MKPDU that contains no CKN or CKN is too large.
Test Object: Software
Test Precondition: 
    -   Prepare EthIf_ProvideTxBuffer stub to return expected parameters.
    -   Module configuration initialized with Mka_Init().
  
Test Execution: 
    01: Call Mka_RxTx_Init() to initialize MKA RxTx unit.
    02: Create MKPDU.
    03: Modify Basic parameter set body length to contain no CKN.
    04: Call Mka_RxTx_RxIndication with seemingly correct input parameters.
    05: VP(Mka.8021X.MkaKeyHierarchy.4.1,1) Check that if Basic parameter set has no CKN whole MKPDU is discarded, no calls has been made and MKA_EVENT_MKPDU_DROPPED_UNKNOWN_CKN bit was set for that PAE.
    06: Create MKPDU.
    07: Modify Basic parameter set body length to contain CKN of length 33 octets.
    08: Clear Mka_RunTimeEventsPae[EBTEST_PAE_IDX_0] error bits.
    09: Call Mka_RxTx_RxIndication with seemingly correct input parameters.
    10: VP(Mka.8021X.MkaKeyHierarchy.4.1,1) Check that if Basic parameter set has CKN length larger than maximum allowed whole MKPDU is discarded, no calls has been made and MKA_EVENT_MKPDU_DROPPED_UNKNOWN_CKN bit was set for that PAE.
    11: Sanity check - Sanity check
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>Mka.8021X.MkaKeyHierarchy.4.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>113</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2341</internalId></specobject>
  </specobjects>
  </specdocument>
  <violations/>
  <oreqmViolations/>
</tracingresults>
