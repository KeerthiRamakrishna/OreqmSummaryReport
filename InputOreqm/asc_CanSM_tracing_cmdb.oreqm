<?xml version="1.0" encoding="UTF-8"?>
<tracingresults>
  <environment>
    <toolname>ReqM2</toolname>
    <toolversion>1.30.0 (stable)</toolversion>
    <toolcopyright>Copyright 2010 - 2018 Elektrobit Automotive GmbH</toolcopyright>
    <libxmlversion>2.0207</libxmlversion>
    <libxml2compileversion>2.9.10</libxml2compileversion>
    <libxml2runtimeversion>20912</libxml2runtimeversion>
    <perlversion>v5.32.1</perlversion>
    <perlptrsize>64</perlptrsize>
    <commandline>-t -q -o asc_CanSM_tracing_cmdb.oreqm -O /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/TestProtocols/LogBase/requirements -c /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_PluginBuildEnv/common/config/AutoCoreReqM2Rules_RMP4_0.xml -s approved,rejected --wfatal WDUPLICATEID,WDUPLICATEIDANDVER /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/build/reqm/ReqM2_Native/asc_CanSM_public_modulereference_integration_req.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/build/reqm/ReqM2_Native/asc_CanSM_requirements_CanSM_4_0_3.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/build/reqm/ReqM2_Native/asc_CanSM_requirements_CanSM_4_1_1.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/build/reqm/ReqM2_Native/asc_CanSM_requirements_CanSM_4_2_2.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/build/reqm/ReqM2_Native/asc_CanSM_requirements_CanSM_EBExtensions.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/build/reqm/ReqM2_Native/asc_CanSM_requirements_CanSM_R20-11.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/build/reqm/ReqM2_Native/asc_CanSM_testspec_Manual_TestSpec.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/build/reqm/common_req/CanSM_DbgInst_EB_Extension.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/build/reqm/common_req/CanSM_VerifyStub_EB_Extension.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/build/reqm/ReqM2_GenericImporter/reqm_DEV.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/build/reqm/ReqM2_GenericImporter/reqm_IMPL.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/build/reqm/ReqM2_GenericImporter/reqm_IMPLXML.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/build/reqm/ReqM2_DocBookImporter/reqm_SWDD.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/build/reqm/ReqM2_OldCImporter/reqm_SWUTS_LEGACY.reqm</commandline>
    <timestamp>Mon Jun 17 21:37:55 2024</timestamp>
  </environment>
  <cmdline>
    <cmdparam>
      <name>I</name>
      <values>
        <value>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/TestProtocols/LogBase/requirements</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>O</name>
      <values>
        <value>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/TestProtocols/LogBase/requirements</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>c</name>
      <values>
        <value>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_PluginBuildEnv/common/config/AutoCoreReqM2Rules_RMP4_0.xml</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>o</name>
      <values>
        <value>asc_CanSM_tracing_cmdb.oreqm</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>q</name>
    </cmdparam>
    <cmdparam>
      <name>s</name>
      <values>
        <value>approved</value>
        <value>rejected</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>t</name>
    </cmdparam>
    <cmdparam>
      <name>wfatal</name>
      <values>
        <value>WDUPLICATEID</value>
        <value>WDUPLICATEIDANDVER</value>
      </values>
    </cmdparam>
  </cmdline>
  <inputfiles>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/build/reqm/ReqM2_Native/asc_CanSM_public_modulereference_integration_req.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/build/reqm/ReqM2_Native/asc_CanSM_requirements_CanSM_4_0_3.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/build/reqm/ReqM2_Native/asc_CanSM_requirements_CanSM_4_1_1.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/build/reqm/ReqM2_Native/asc_CanSM_requirements_CanSM_4_2_2.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/build/reqm/ReqM2_Native/asc_CanSM_requirements_CanSM_EBExtensions.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/build/reqm/ReqM2_Native/asc_CanSM_requirements_CanSM_R20-11.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/build/reqm/ReqM2_Native/asc_CanSM_testspec_Manual_TestSpec.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/build/reqm/common_req/CanSM_DbgInst_EB_Extension.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/build/reqm/common_req/CanSM_VerifyStub_EB_Extension.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/build/reqm/ReqM2_GenericImporter/reqm_DEV.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/build/reqm/ReqM2_GenericImporter/reqm_IMPL.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/build/reqm/ReqM2_GenericImporter/reqm_IMPLXML.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/build/reqm/ReqM2_DocBookImporter/reqm_SWDD.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/build/reqm/ReqM2_OldCImporter/reqm_SWUTS_LEGACY.reqm</inputfile>
  </inputfiles>
  <configuration>
    <doctypes>
    <regexs>
      <!-- external level -->
      <regex>creq</regex>       <!-- since 10/1018: introduced for updated tracing model-->

      <!-- product line level -->
      <regex>fea</regex>
      <regex>swpad</regex>      <!-- since 10/1018: introduced for updated tracing model-->
      <regex>swts</regex>

      <!-- bundle level -->
      <regex>swrs</regex>
      <regex>swad</regex>
      <regex>swintts</regex>

      <!-- module level -->
      <regex>swdd</regex>
      <regex>swurs</regex>      <!-- since 10/1018: introduced for updated tracing model-->
      <regex>swmts</regex>      <!-- since 01/1010: introduced for updated tracing model RMP4.0-->
      <regex>swuts</regex>
      <regex>impl</regex>

      <!-- legacy items -->
      <regex>dev</regex>
      <regex>man</regex>
      <regex>lim</regex>
    </regexs>
  </doctypes>
    <rules>
    <!-- The Ruleset for RMP4.0 is currently identical to the previous rule set. This rule is
        intoduce to show that the right file is uses. It will be removed when the RMP4.0 rule set is
    reworked -->
    <rule>
      <name>INFO.Rule set RMP4.0</name>
      <description>This rules indicates that RMP4.0 rule set is used.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(./status!='approved') and (./status!='rejected')]</applyto>
          <condition>false()</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>WRN.general.doctypes</name>
      <description>The used doctype is not part of the tracing model</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobjects/@doctype</applyto>
          <condition>((. != 'creq') or (. != 'fea') or (. != 'swpad') or (. != 'swts') or (. != 'swrs') or (. !='swad') or (. != 'swintts') or (.!= 'swdd') or (. != 'swurs') or (. != 'swmts') or (. != 'swuts') or (. != 'impl') or (. != 'dev') or (. != 'man') or (. != 'lim'))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.general.status</name>
      <description>All specification objects must be either in status=approved or in status=rejected. Other
        statuses are not allowed. How to fix: Set status to rejected or approved.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(./status!='approved') and (./status!='rejected')]</applyto>
          <condition>false()</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.general.rejected</name>
      <description>Status status=rejected is only allowed for requirements. How to fix: set to approved for specification object that are not requirements.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype!='swrs')  and (../@doctype!='swmrs') and (../@doctype!='swurs') and (./status='rejected')]</applyto>
          <condition>false()</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.general.comment</name>
      <description>Specification objects with status=rejected shall have a comment or rationale that
        starts with on of the following texts: "This requirement is informational only", "This requirement is not applicable".
        How to fix: Add some text starting with "This requirement is informational only"
        or "This requirement is not applicable" to either the comment or to the rationale.
        Comment: Implementation of check checks for contains instead of starts-with since there is
        no trim function in the used XPATH engine.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(./status='rejected')]</applyto>
          <condition>contains(./comment,"This requirement is informational only") or contains(./rationale,"This requirement is informational only") or contains(./comment,"This requirement is not applicable") or contains(./rationale,"This requirement is not applicable")</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.general.rejected.coverage</name>
      <description>Specification objects with status=rejected shall not need coverage. How to fix: remove need for coverage.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(./status='rejected')]</applyto>
          <condition>count(./needscoverage)=0</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swurs.needscoverage.count</name>
      <description>Unit requirements with status=approved need to be covered, exceptions from
      this rule: configuration requirements (postfix "_CONF" or "_Conf" or prefix "ECUC_") and requirements with
      a comment starting with "The adherence to this requirement is ensured by the following
      release check (URL to the checklist template plus ID of the check):".
      How to fix: Provide a needsobj element for those specobjects or comment according to the rule.
      </description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swurs') and (./status='approved') and count(./needscoverage/needsobj)=0 and count(./fulfilledby/ffbObj)=0]</applyto>
          <!--This condition is false if the id of a specification object does not end with '_Conf' or '_CONF' or does not start with ECUC_ -->
          <condition>substring-after(./id,"ECUC_")!="" or substring-before(./id,"_Conf")!="" or substring-before(./id,"_CONF")!="" or contains(./comment,"The adherence to this requirement is ensured by the following release check (URL to the checklist template plus ID of the check):")</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swurs.needscoverage.rationale</name>
      <description>Requirements with status=approved and without coverage needs that are
        configuration requirements (postfix "_CONF" or "_Conf" or prefix "ECUC_") shall have a comment or rationale
        with the following text: "This is a configuration parameter requirement without functional
        specification.". How to fix: Add some text starting with "This is a configuration parameter
        requirements without functional specification" to either the comment or to the rationale.</description>
      <regexchecks>
        <regexcheck>
          <applyto>//specobject[(../@doctype='swurs') and (./status='approved') and count(./needscoverage/needsobj)=0 and (substring-after(./id,"ECUC_")!="" or substring-before(./id,"_CONF")!="" or substring-before(./id,"_Conf")!="")]</applyto>
          <regex>This is a configuration parameter requirement without functional specification.</regex>
        </regexcheck>
      </regexchecks>
    </rule>

    <rule>
      <name>ERR.swrs.needscoverage.rationale</name>
      <description>Requirements with status=approved and without coverage needs that are
        configuration requirements (postfix "_CONF" or "_Conf" or prefix "ECUC_") shall have a comment or rationale
        with the following text: "This is a configuration parameter requirement without functional
        specification.". How to fix: Add some text starting with "This is a configuration parameter
        requirements without functional specification" to either the comment or to the rationale.</description>
      <regexchecks>
        <regexcheck>
          <applyto>//specobject[(../@doctype='swrs') and (./status='approved') and count(./needscoverage/needsobj)=0 and (substring-after(./id,"ECUC_")!="" or substring-before(./id,"_CONF")!="" or substring-before(./id,"_Conf")!="")]</applyto>
          <regex>This is a configuration parameter requirement without functional specification.</regex>
        </regexcheck>
      </regexchecks>
    </rule>

    <rule>
      <name>ERR.swurs.releases</name>
      <description>Requirements which originates from AUTOSAR (source tag contains term 'AUTOSAR_SWS', 'AUTOSAR_TPS',
        'AUTOSAR_ASWS' or 'AUTOSAR_TR') shall have their release tag set to 'AUTOSAR {major}.{minor}.{patch}' (e.g. 'AUTOSAR 4.3.0').
        Other requirements (including refinements of AUTOSAR requirements) must not contain any of the listed prefixes as
        part of the source tag.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swurs') and (contains(./source,'AUTOSAR_SWS') or contains(./source,'AUTOSAR_TPS') or contains(./source,'AUTOSAR_ASWS') or contains(./source,'AUTOSAR_TR'))]</applyto>
          <condition>contains(./releases/release,'AUTOSAR')</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swrs.releases</name>
      <description>Requirements which originates from AUTOSAR (source tag contains term 'AUTOSAR_SWS', 'AUTOSAR_TPS',
        'AUTOSAR_ASWS' or 'AUTOSAR_TR') shall have their release tag set to 'AUTOSAR {major}.{minor}.{patch}' (e.g. 'AUTOSAR 4.3.0').
        Other requirements (including refinements of AUTOSAR requirements) must not contain any of the listed prefixes as
        part of the source tag.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swrs') and (contains(./source,'AUTOSAR_SWS') or contains(./source,'AUTOSAR_TPS') or contains(./source,'AUTOSAR_ASWS') or contains(./source,'AUTOSAR_TR'))]</applyto>
          <condition>contains(./releases/release,'AUTOSAR')</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swdd.needscoverage.count</name>
      <description>Design elements with status=approved need to be covered.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swdd') and (./status='approved') and count(./needscoverage/needsobj)=0]</applyto>
          <condition>false()</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swurs.needscoverage.doctypes</name>
      <description>Requirements can be covered only by swurs, swad, dev, lim, swdd, impl, swuts, swmts, or man</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swurs')]</applyto>
          <condition>(./needscoverage/needsobj="swurs" or ./needscoverage/needsobj="swad" or ./needscoverage/needsobj="dev" or ./needscoverage/needsobj="lim" or ./needscoverage/needsobj="swdd" or ./needscoverage/needsobj="impl" or ./needscoverage/needsobj="swuts" or ./needscoverage/needsobj="swmts" or ./needscoverage/needsobj="man" or (count(./needscoverage/needsobj)=0))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swrs.needscoverage.doctypes</name>
      <description>Requirements of type swrs can be covered only by swrs, swurs, swad, swintts or man</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swrs')]</applyto>
          <condition>(./needscoverage/needsobj="swrs" or ./needscoverage/needsobj="swurs" or ./needscoverage/needsobj="swad" or ./needscoverage/needsobj="swuts" or ./needscoverage/needsobj="swintts" or ./needscoverage/needsobj="man" or (count(./needscoverage/needsobj)=0))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swdd.needscoverage.doctypes</name>
      <description>Design elements of type swdd can only be covered by swdd, swurs, impl, swuts, lim or man</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swdd')]</applyto>
          <condition>(./needscoverage/needsobj="swdd" or ./needscoverage/needsobj="swurs" or ./needscoverage/needsobj="impl" or ./needscoverage/needsobj="swuts" or ./needscoverage/needsobj="swmts" or ./needscoverage/needsobj="lim" or ./needscoverage/needsobj="man" or (count(./needscoverage/needsobj)=0))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.dev.needscoverage.count</name>
      <description>Deviations shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='dev')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swuts.needscoverage.count</name>
      <description>Test case sepecifications shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swuts')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swmts.needscoverage.count</name>
      <description>Test case sepecifications shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swmts')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swintts.needscoverage.count</name>
      <description>Test case sepecifications shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swintts')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swts.needscoverage.count</name>
      <description>Test case sepecifications shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swts')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.man.needscoverage.count</name>
      <description>Manual test cases shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='man')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.impl.needscoverage.count</name>
      <description>Source code shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='impl')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.lim.needscoverage.count</name>
      <description>Limitations shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='lim')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.fea.needscoverage.test</name>
      <description>Features shall be tested by software test ('swts') or manuel test ('man'). If no test is planned a justification shall be given.
                   A justification can be given in the futherinfo tag. The justification shall start with this rule name.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='fea')]</applyto>
          <condition>(
               ./needscoverage/needsobj="swts" or ./needscoverage/needsobj="man" or ./fulfilledby/ffbObj/ffbType="swts" or ./fulfilledby/ffbObj/ffbType="man" or contains(./furtherinfo,"fea.needscoverage.test") or contains(./furtherinfo,"fea.needscoverage.doctypes"))</condition>
        </conditioncheck>
      </conditionchecks>
          </rule>

    <rule>
      <name>WRN.fea.needscoverage.impl</name>
      <description>Features shall be covered by implementation fea, swrs, swad, swpad, swurs, man and swts. For lagacy features a justification is acceppted. A justification can be given in the futherinfo tag. The justification shall start with this rule name.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='fea')]</applyto>
          <condition>( ./needscoverage/needsobj="swrs" or ./fulfilledby/ffbObj/ffbType="swrs" or ./fulfilledby/ffbObj/ffbType="swad" or ./needscoverage/needsobj="swpad" or ./fulfilledby/ffbObj/ffbType="swpad" or ./needscoverage/needsobj="swurs" or ./fulfilledby/ffbObj/ffbType="swurs" or ./needscoverage/needsobj="fea" or ./fulfilledby/ffbObj/ffbType="fea" or contains(./furtherinfo,"fea.needscoverage.impl"))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>


    <rule>
      <name>ERR.swad.fulfilledby.doctypes</name>
      <description>Architectural design objects of type swad can only be covered by swurs, swad, swdd, swintts, man, otherwise they should be refined with swrs</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swad')]</applyto>
          <condition>(./fulfilledby/ffbObj/ffbType="swurs" or ./needscoverage/needsobj="swurs" or ./fulfilledby/ffbObj/ffbType="req" or ./needscoverage/needsobj="req" or ./fulfilledby/ffbObj/ffbType="swad" or ./needscoverage/needsobj="swad" or ./fulfilledby/ffbObj/ffbType="swdd" or ./fulfilledby/ffbObj/ffbType="swintts" or ./needscoverage/needsobj="swintts" or ./fulfilledby/ffbObj/ffbType="man" or ./needscoverage/needsobj="man") </condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swmts.providescoverage.doctypes</name>
      <description>Test case specifications (tcs) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='tcs')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.man.providescoverage.doctypes</name>
      <description>Manual test case specification (man) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='man')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

   <rule>
      <name>ERR.swuts.providescoverage.doctypes</name>
      <description>Software unit test case specification (swuts) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swuts')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

   <rule>
      <name>ERR.swintts.providescoverage.doctypes</name>
      <description>Software integration test case specification (swintts) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swintts')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

   <rule>
      <name>ERR.swts.providescoverage.doctypes</name>
      <description>Software test case specification (swts) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swts')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

  </rules>
    <oreqmRules>

        <rule>
            <name>WRN.swts.needscoverage.count</name>
            <description>Violated if there are more than 10 swts specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swts']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swts']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swts.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>
        <rule>
            <name>WRN.man.needscoverage.count</name>
            <description>Violated if there are more than 10 man specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='man']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='man']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>man.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>
        <rule>
            <name>WRN.swintts.needscoverage.count</name>
            <description>Violated if there are more than 10 swintts specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swintts']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swintts']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swintts.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>
        <rule>
            <name>WRN.swmts.needscoverage.count</name>
            <description>Violated if there are more than 10 swmts specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swmts']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swmts']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swmts.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swuts.needscoverage.count</name>
            <description>Violated if there are more than 10 swuts specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swuts']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swuts']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swuts.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swpad.needscoverage.count</name>
            <description>Violated if there are more than 10 swpad specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swpad']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swpad']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swpad.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swrs.needscoverage.count</name>
            <description>Violated if there are more than 10 swrs specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swrs']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swrs']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swrs.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swad.needscoverage.count</name>
            <description>Violated if there are more than 10 swad specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swad']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swad']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swad.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swurs.needscoverage.count</name>
            <description>Violated if there are more than 10 swurs specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swurs']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swurs']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swurs.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swdd.needscoverage.count</name>
            <description>Violated if there are more than 10 swdd specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swdd']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swdd']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swdd.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.impl.needscoverage.count</name>
            <description>Violated if there are more than 10 impl specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='impl']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='impl']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>impl.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swrs.fulfilledby.count</name>
            <description>Violated if there are more than 10 swrs specobjects as fulfilledby link to one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swrs'])) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swrs'])) &gt; 10]/furtherinfo</applyto>
                                        <regex>swrs.fulfilledby.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swad.fulfilledby.count</name>
            <description>Violated if there are more than 10 swad specobjects as fulfilledby link to one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swad'])) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swad'])) &gt; 10]/furtherinfo</applyto>
                                        <regex>swad.fulfilledby.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swurs.fulfilledby.count</name>
            <description>Violated if there are more than 10 swurs specobjects as fulfilledby link to one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swurs'])) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swurs'])) &gt; 10]/furtherinfo</applyto>
                                        <regex>swurs.fulfilledby.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swdd.fulfilledby.count</name>
            <description>Violated if there are more than 10 swdd specobjects as fulfilledby link to one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swdd'])) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swdd'])) &gt; 10]/furtherinfo</applyto>
                                        <regex>swdd.fulfilledby.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>
  </oreqmRules>
  </configuration>
  <specdocument>
    <specobjects doctype="lim">
    <specobject>
      <id>lim.CanSM.EB_INTREQ_CanSM_0001</id>
      <status>approved</status>
      <source>EB integration requirement</source>
      <version>1</version>
      <description>
      <!-- Incompatibility with AUTOSAR conform CanTrcv module -->
      <!-- class: minor, long term -->
      <!-- class-reason:
         * will NOT be updated in future releases -->
      The CanSM state machine is incompatible to a CanTrcv strictly implemented according to the
      requirements of the CanTrcv SWS for the purpose of making a transition to state
      <code>COMM_NO_COMMUNICATION</code> if partial network is enabled.
     </description>
      <rationale>During a transition towards state <code>COMM_NO_COMMUNICATION</code>
      (refer to Figure 7-3) the CanSM calls <code>CanIf_CheckTrcvWakeFlag</code>
      [CANSM458] and waits for the callback function <code>CanSM_CheckTransceiverWakeFlagIndication</code>
      [CANSM460].
      Contrary to the requirements in the CanSM SWS the CanTrcv SWS [CanTrcv224] demands the callback only
      for the case that a wakeup was detected.
      To ensure correct functionality the CanTrcv must invoke <code>CanIf_CheckTrcvWakeFlagIndication</code> in any case.
      </rationale>
      <providescoverage>
        <provcov>
          <linksto>dsn.CanSM.CanTrcvDependency</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>598</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>0</internalId></specobject>
    <specobject>
      <id>lim.CanSM.EB_INTREQ_CanSM_0002</id>
      <status>approved</status>
      <source>EB integration requirement</source>
      <version>1</version>
      <description>
      <!-- Bus-Off Recovery threshold that switches from L1 to L2 -->
      <!-- class: minor, long term -->
      <!-- class-reason:
         * was behaving differently before implementation of ASCCANSM-564 -->
        The threshold that switches from Bus-Off Recovery L1 to L2 was implemented in such a way that
        the actual time was a 1 less than the configured parameter in CanSM configuration. After the
        implementation, the time spent waiting to swith to L2 is now equal to the configured parameter.
      </description>
      <rationale>The behaviour was that L2 was reached a MainFunction call earlier than expected.
        The fix was meant to bring the expectation of the user, configured in the CanSM configuration
        into actual sequence of events.
      </rationale>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1</internalId></specobject>
    <specobject>
      <id>lim.CanSM.EB_INTREQ_CanSM_0003</id>
      <status>approved</status>
      <source>EB integration requirement</source>
      <version>1</version>
      <description>
      <!-- CanSM_Init distribution -->
      <!-- class: minor, long term -->
      <!-- class-reason:
         * New Init functions for every partitions -->
        In order to re-initialize the module, All init functions for all partitions shall be called.
      </description>
      <rationale>If <code>CanSMDistributedChannelInitEnable</code> is enabled, a <code>CanSM_Init_"SN"()</code> shall be generated
        for every ECUC partitions referenced by CanSM channel, where "SN" is the short name the EcucPartition.
        The first called init function will reset all internal state for every channels. No init function after the first call
        function will be able reset the internal state.
      </rationale>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs">
    <specobject>
      <id>CanSM.ASR40.ECUC_CanSM_00127</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        Name: CanSMDemEventParameterRefs
        Container Type: Sub-Container
        Parent Containers: CanSMManagerNetwork,
        Description: Container for the references to DemEventParameter elements which shall be invoked 
        using the API Dem_ReportErrorStatus API in case the corresponding error occurs. The EventId is 
        taken from the referenced DemEventParameter's DemEventId value. The standardized errors are 
        provided in the container and can be extended by vendor specific error references.
        Lower Multiplicity: 0
        Upper Multiplicity: 1
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>3</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.ECUC_CanSM_00312</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        Name: CanSMMainFunctionTimePeriod
        Parameter Type: FloatValue
        Parent Containers: CanSMGeneral,
        Description: This parameter defines the cycle time of the function CanSM_MainFunction in 
        seconds
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Origin: AUTOSAR_ECUC
        Symbolic-Name-Value: false
        Max-Value: 65.535 (Type:
        Min-Value: 0.001 (Type:
      </description>
      <comment>
        Refined by configuration parameter derived from Mainfunction period.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ECUC_CanSM_00128</srcid><srcstatus/><internalId>277</internalId></linkedfrom><linkedfrom><srcid>CanSM.ECUC_CanSM_00129</srcid><srcstatus/><internalId>278</internalId></linkedfrom><linkedfrom><srcid>CanSM.ECUC_CanSM_00130</srcid><srcstatus/><internalId>279</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>4</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.ECUC_CanSM_00342</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        Name: CanSmChangeBaudrateApi
        Parameter Type: Boolean
        Parent Containers: CanSMGeneral,
        Description: The support of the Can_ChangeBaudrate API is optional.
        Introduction: If this parameter is set to true the Can_ChangeBaudrate API shall be supported. 
        Otherwise the API is not supported.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Origin: AUTOSAR_ECUC
        Symbolic-Name-Value: false
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CANSM.ChangeBaudrateMissing</srcid><srcstatus/><internalId>545</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>5</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00009</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        The header file CanSM_ComM.h shall export the CanSM module's API dedicated to the ComM module.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_COMM_DEDICATED_EXPORTS</srcid><srcstatus/><internalId>609</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>6</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00010</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>2</version>
      <description>
        The header file CanSM_Cfg.h shall contain references to the parameters of the c-source files 
        CanSM_Lcfg.c and CanSM_PBcfg.c  and shall contain pre-compile parameters, which are not 
        declared as "const" parameter, but as defines.
      </description>
      <comment>
        Link time configuration is not supported.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ECUC_CanSM_00351</srcid><srcstatus/><internalId>533</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>7</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00011</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        The header file CanSM_Cbk.h shall declare the callback notification functions of the CanSM 
        module.
      </description>
      <comment>
        Requirement does not clearly define which callback notification functions shall
        be declared in CanSM_Cbk.h.
        CanSM_TxTimeoutException for example shall be declared in a separate header file
        (see CANSM549) although it is also a callback notification function.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.CANSM011.1</srcid><srcstatus/><internalId>161</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>8</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00013</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>2</version>
      <description>
        The CanSM module (CanSM.c) shall reference its header file CanSM.h.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CANSM.MainHeader</srcid><srcstatus/><internalId>552</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>9</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00014</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        The CanSM module (CanSM.c) shall include the header file Dem.h.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.SWS_CanSM_00014.1</srcid><srcstatus/><internalId>162</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.CANSM014.2</srcid><srcstatus/><internalId>163</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>10</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00015</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        The CanSM module (CanSM.c) shall include the header file Det.h.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_HEADER_INCLUSION</srcid><srcstatus/><internalId>610</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>11</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00016</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        The CanSM module (CanSM.c) shall include the header file MemMap.h.
      </description>
      <comment>
        The usage of header file MemMap.h needs a more detailed specification.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.SWS_CanSM_00016.1</srcid><srcstatus/><internalId>164</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.CANSM016.2</srcid><srcstatus/><internalId>165</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>12</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00017</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        The CanSM module (CanSM.c) shall include the header file CanIf.h.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_HEADER_INCLUSION</srcid><srcstatus/><internalId>610</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>13</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00025</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        The CanSM module shall perform Inter Module Checks to avoid integration of incompatible files. 
        The imported included files shall be checked by preprocessing directives.
      </description>
      <comment>
        According to Autosar SRS BSW General BSW004 intramodule checks are not explicitly
        required and intermodule checks shall be performed by the configuration tool.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CANSM.ConsChck</srcid><srcstatus/><internalId>546</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>14</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00028</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        Detected development errors shall be reported to the Det_ReportError service of the Development 
        Error Tracer (DET) if the pre-processor switch CanSMDevErrorDetect is set "on"
      </description>
      <comment>
        CanSMDevErrorDetect is a configuration parameter.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.DevelopmentErrors</srcid><srcstatus/><internalId>262</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>15</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00069</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        Development error values shall be of type uint8.
      </description>
      <furtherinfo> 
        Justifying rule: WRN.swurs.needscoverage.count violation.
        Requirement not atomic, and is defined by more than 10 requirements
      </furtherinfo>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.SWS_CanSM_00069.Type</srcid><srcstatus/><internalId>250</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.ErrorTable.CANSM_E_UNINIT</srcid><srcstatus/><internalId>251</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.ErrorTable.CANSM_E_PARAM_POINTER</srcid><srcstatus/><internalId>252</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.ErrorTable.CANSM_E_INVALID_NETWORK_HANDLE</srcid><srcstatus/><internalId>253</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.ErrorTable.CANSM_E_PARAM_CONTROLLER</srcid><srcstatus/><internalId>254</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.ErrorTable.CANSM_E_PARAM_TRANSCEIVER</srcid><srcstatus/><internalId>255</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.ErrorTable.CANSM_E_BUSOFF_RECOVERY_ACTIVE</srcid><srcstatus/><internalId>256</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.ErrorTable.CANSM_E_WAIT_MODE_INDICATION</srcid><srcstatus/><internalId>257</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.ErrorTable.CANSM_E_INVALID_COMM_REQUEST</srcid><srcstatus/><internalId>258</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.ErrorTable.CANSM_E_PARAM_INVALID_BAUDRATE</srcid><srcstatus/><internalId>259</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.ErrorTable.CANSM_E_MODE_REQUEST_TIMEOUT</srcid><srcstatus/><internalId>260</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.ErrorTable.CANSM_E_BUS_OFF</srcid><srcstatus/><internalId>261</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>16</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00071</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        If the CanSMDevErrorDetect switch is enabled, the API parameter checking shall be enabled. The 
        detailed description of the detected errors can be found in chapter 7.3 and chapter 8.
      </description>
      <comment>
        Requirement redundant and replaced by a requirement CanSM.ASR40.DevelopmentErrors.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.DevelopmentErrors</srcid><srcstatus/><internalId>262</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>17</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00072</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        The detection of production code errors cannot be switched off.
      </description>
      <comment>
        This requirement is informational only.
        This requirement is not applicable: Replaced by coding guideline [BSWM_EB_002].
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>18</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00074</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        Production errors shall be reported to the Diagnostic Event Manager.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_DEM2DET_BUS_OFF</srcid><srcstatus/><internalId>745</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>19</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00174</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        The header file CanSM.h shall include the header file ComM.h.
      </description>
      <comment>
        This requirement is inconsistent. ComM includes CanSM header file
        CanSM_ComM.h (refer to figure 1 in ComM Autosar SWS).
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.CANSM174.1</srcid><srcstatus/><internalId>160</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>20</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00179</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>2</version>
      <description>
        Only for configuration variant 3: The function CanSM_Init shall report the development error 
        CANSM_E_PARAM_POINTER to the DET, if the user of this function hands over a NULL-pointer as 
        ConfigPtr.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_NOIN_NOCO_SYNC_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>652</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>21</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00191</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        The CanSM module (CanSM.c) shall include the header file ComM_BusSM.h.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_HEADER_INCLUSION</srcid><srcstatus/><internalId>610</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>22</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00238</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        The header file CanSM.h shall include the header file ComStack_Types.h.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_COMMON_PUBLISHED_PARAMETERS_HEADER_FILE</srcid><srcstatus/><internalId>603</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>23</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00243</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        Module            Imported Type
        CanIf             CanIf_ControllerModeType
        CanIf_NotifStatusType
        CanIf_PduSetModeType
        Can_GeneralTypes  CanTrcv_TrcvModeType
        ComM              ComM_ModeType
        ComStack_Types    NetworkHandleType
        Dem               Dem_EventIdType
        Dem_EventStatusType
        Std_Types         Std_ReturnType
        Std_VersionInfoType
      </description>
      <comment>
        This requirement is informational only.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>24</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00244</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        The function CanSM_GetVersionInfo shall return the version information of this module. The 
        version information includes: Module Id Vendor Id Vendor specific version numbers (BSW00407)
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_30000</srcid><srcstatus/><internalId>724</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>25</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00252</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>2</version>
      <description>
        Mix of pre compile-, link time and post buildtime parameters(
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_40037_6_1N1C0T</srcid><srcstatus/><internalId>606</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_PBSELECTABLE</srcid><srcstatus/><internalId>620</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_40027</srcid><srcstatus/><internalId>716</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_40029</srcid><srcstatus/><internalId>717</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_40031</srcid><srcstatus/><internalId>718</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_40033</srcid><srcstatus/><internalId>719</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_40035</srcid><srcstatus/><internalId>720</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_40039</srcid><srcstatus/><internalId>721</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_CONFIG_ACCESS</srcid><srcstatus/><internalId>839</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_GLOBALINIT_VARIABLE</srcid><srcstatus/><internalId>840</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>26</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00253</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        The header file CanSM_EcuM.h shall export the init function of the CanSM.
      </description>
      <comment>
        This requirement is informational only.
        This requirement is not applicable: The requirement is inconsistent to EcuM.
        The EcuM SWS does not contain a requirement to include CanSM_EcuM.h.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>27</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00254</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        The CanSM module (CanSM.c) shall reference its header file CanSM_Cfg.h.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_HEADER_INCLUSION</srcid><srcstatus/><internalId>610</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>28</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00266</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        The CanSM module shall store the latest notified current network mode with 
        ComM_BusSM_ModeIndication (chapter 8.6.1) for each configured CAN network internally (ref. to 
        CANSM126_Conf)
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_MULT_TRANSITIONS_2NW</srcid><srcstatus/><internalId>708</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_PN_NOPN_MIXED</srcid><srcstatus/><internalId>712</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_INDEP_MODE_IND</srcid><srcstatus/><internalId>713</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_30012</srcid><srcstatus/><internalId>723</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_MULT_NETWORKS_1</srcid><srcstatus/><internalId>743</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_MULT_NETWORKS_2</srcid><srcstatus/><internalId>744</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00266</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>310</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>29</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00282</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        The CanSM module shall return E_NOT_OK for the API request CanSM_GetCurrentComMode, if the 
        initial transition for the requested CAN network with E_NOCOM (ref. to CANSM430) is not 
        finished yet.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_30002</srcid><srcstatus/><internalId>725</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00282</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>312</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>30</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00309</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        The type definitions of the debug-able variables of the CanSM module shall be exported by the 
        standard module header file CanSM.h.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CANSM.DebugAndTrace</srcid><srcstatus/><internalId>548</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>31</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00310</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        The CanSM module shall define every variable as global, which is designated to be accessed by 
        AUTOSAR debugging.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CANSM.DebugAndTrace</srcid><srcstatus/><internalId>548</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>32</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00347</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        The header file CanSM_BswM.h shall export the interfaces, which are dedicated to the BswM 
        module.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_40074</srcid><srcstatus/><internalId>602</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>33</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00348</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        The CanSM module (CanSM.c) shall include the header file CanSM_BswM.h.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_HEADER_INCLUSION</srcid><srcstatus/><internalId>610</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>34</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00361</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        The CanSM module shall provide a file CanSM_Lcfg.c that contains all link time configurable 
        parameters of the module.
      </description>
      <comment>
        Link time configuration is not supported.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ECUC_CanSM_00351</srcid><srcstatus/><internalId>533</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>35</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00362</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>2</version>
      <description>
        The CanSM module shall provide a file CanSM_PBcfg.c that contains all post build time 
        configurable parameters of the module.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_PBSELECTABLE</srcid><srcstatus/><internalId>620</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>36</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00363</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        The detection of development errors shall be configurable as ON / OFF.
      </description>
      <comment>
        Requirement redundant and replaced by a requirement CanSM.ASR40.DevelopmentErrors.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.DevelopmentErrors</srcid><srcstatus/><internalId>262</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>37</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00364</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        The detection of development errors shall be configurable at pre-compile time.
      </description>
      <comment>
        Requirement redundant and replaced by a requirement CanSM.ASR40.DevelopmentErrors.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.DevelopmentErrors</srcid><srcstatus/><internalId>262</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>38</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00365</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        The switch CanSMDevErrorDetect (ref. to CANSM133_Conf) shall activate or deactivate the 
        detection of all development errors.
      </description>
      <comment>
        Requirement redundant and replaced by a requirement CanSM.ASR40.DevelopmentErrors.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.DevelopmentErrors</srcid><srcstatus/><internalId>262</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>39</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00366</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        If the source code for caller and callee of CanSM_GetVersionInfo is available this function 
        should be realized as a macro. The macro should be defined in the header file CanSM.h.
      </description>
      <comment>
        This requirement is informational only.
        This requirement is not applicable: EB coding guideline [BSWM_C_500] proposes
        the implementation as function (compare example section).
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>40</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00367</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        The function CanSM_GetVersionInfo shall be configurable On/Off by the configuration parameter: 
        CANSM_VERSION_INFO_API (ref. to CANSM311_Conf)
      </description>
      <comment>
        This requirement is a identical subset of CanSM.ASR40.CANSM368.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.SWS_CanSM_00368</srcid><srcstatus/><internalId>42</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>41</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00368</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        The function CanSM_GetVersionInfo shall be pre compile time configurable by the configuration 
        parameter: CANSM_VERSION_INFO_API (ref. to CANSM311_Conf)
      </description>
      <comment>
        Refines usage of configuration parameter CanSMVersionInfoApi.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_40064</srcid><srcstatus/><internalId>607</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.SWS_CanSM_00367</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>41</internalId></provcov>
        <provcov>
          <linksto>CanSM.ECUC_CanSM_00311</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>285</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>42</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00375</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        The CanSM module shall deny any network mode request, if the time since the last detected bus-
        off is lower than CanSMBorTimeL1 (ref. to CANSM128_Conf) and the bus-off counter is lower than 
        CanSMBorCounterL1ToL2 (ref. to CANSM131_Conf)
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CANSM.DenyModeRequest</srcid><srcstatus/><internalId>550</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>43</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00376</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        The CanSM module shall deny any network mode request, if the time since the last detected bus-
        off is lower than CanSMBorTimeL2 and the bus-off counter is greater or equal than 
        CanSMBorCounterL1ToL2 (ref. to CANSM131_Conf)
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CANSM.DenyModeRequest</srcid><srcstatus/><internalId>550</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>44</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00377</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        If the CanSM module has to deny the request CanSM_RequestComMode, because of a not finished bus-
        off recovery (ref. to CANSM375 and CANSM376), then this function shall call the function 
        Det_ReportError with the ErrorId parameter CANSM_E_BUSOFF_RECOVERY_ACTIVE (ref. to chapter 7.3)
      </description>
      <comment>
        Defines one exact usage of the DET error code CANSM_E_BUSOFF_RECOVERY_ACTIVE.
        Precondition: development error detection enabled.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CANSM.DenyModeRequest</srcid><srcstatus/><internalId>550</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.ErrorTable.CANSM_E_BUSOFF_RECOVERY_ACTIVE</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>256</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.DevelopmentErrors</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>262</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>45</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00385</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        If the CanSM module state machine was triggered with T_REPEAT_MAX (ref. to CANSM463, CANSM480, 
        CANSM495, CANSM523, CANSM536), the CanSM module shall call the function Det_ReportError with 
        the ErrorId parameter CANSM_E_MODE_REQUEST_TIMEOUT (ref. to chapter 7.3)
      </description>
      <furtherinfo> 
        Justifying rule: WRN.swurs.needscoverage.count violation.
        The requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine, It is not complete nor consistent All requirement of this kind
        are coverd by more than 10 requirements describing the complete state transition.
      </furtherinfo>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR41.TX_TIMEOUT_EXCEPTION.T_S_CC_STOPPED_PRE_NOCOM.Pn</srcid><srcstatus/><internalId>101</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR41.TX_TIMEOUT_EXCEPTION.T_S_CC_STARTED_PRE_NOCOM.Pn</srcid><srcstatus/><internalId>102</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_FULLCOM_PRE_NOCOM.NoPn</srcid><srcstatus/><internalId>168</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_FULLCOM_PRE_NOCOM.Pn</srcid><srcstatus/><internalId>169</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.NoPn.1</srcid><srcstatus/><internalId>176</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.Pn.1</srcid><srcstatus/><internalId>177</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.NoPn.2</srcid><srcstatus/><internalId>178</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.Pn.2</srcid><srcstatus/><internalId>179</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.NoPn.3</srcid><srcstatus/><internalId>180</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.Pn.3</srcid><srcstatus/><internalId>181</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.NoPn.1</srcid><srcstatus/><internalId>182</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.Pn.1</srcid><srcstatus/><internalId>183</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.NoPn.2</srcid><srcstatus/><internalId>184</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.Pn.2</srcid><srcstatus/><internalId>185</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>46</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00395</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        If the CanSM module has to deny the request CanSM_RequestComMode, because of a pending mode 
        indication (ref. to CANSM388), then this function shall call the function Det_ReportError with 
        the ErrorId parameter CANSM_E_WAIT_MODE_INDICATION (ref. to chapter 7.3)
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CANSM.DenyModeRequest</srcid><srcstatus/><internalId>550</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.ErrorTable.CANSM_E_WAIT_MODE_INDICATION</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>257</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.DevelopmentErrors</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>262</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>47</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00396</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        Service name: CanSM_ControllerModeIndication Syntax: void CanSM_ControllerModeIndication(
        uint8 ControllerId, CanIf_ControllerModeType ControllerMode) Service ID[hex]: 0x07 Sync/
        Async: Synchronous Reentrancy: Reentrant (only for different CAN controllers) Parameters (in): 
        ControllerId CAN controller, whose mode has changed ControllerMode Notified CAN controller mode 
        Parameters (inout): None Parameters (out): None Return value: None Description: This callback 
        shall notify the CanSM module about a CAN controller mode change.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_CBK_EXPORTS</srcid><srcstatus/><internalId>608</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>48</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00402</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        The function CanSM_RequestComMode shall deny its request, if the current network mode is 
        COMM_NO_COMMUNICATION and the user of this function requests COMM_SILENT_COMMUNICATION.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CANSM.DenyModeRequest</srcid><srcstatus/><internalId>550</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>49</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00403</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        If the function CanSM_RequestComMode denies its request, because of an invalid requested 
        transistion, it shall invocate the function Det_ReportError with ErrorId parameter 
        CANSM_E_INVALID_COMM_REQUEST.
      </description>
      <comment>
        Defines one exact usage of the DET error code CANSM_E_INVALID_COMM_REQUEST.
        Precondition: development error detection enabled.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_30004</srcid><srcstatus/><internalId>727</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.ErrorTable.CANSM_E_INVALID_COMM_REQUEST</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>258</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.DevelopmentErrors</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>262</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>50</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00430</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        The effect E_NOCOM of the CanSM_BSM state machine (ref. to Figure 71) shall change the 
        internally stored network mode (ref. to CANSM266) of the addressed CAN network to 
        COMM_NO_COMMUNICATION and shall call the API ComM_BusSM_ModeIndication with the parameters 
        Channel := CanSMComMNetworkHandleRef (ref. to CANSM161_Conf) and ComMode := 
        COMM_NO_COMMUNICATION.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.EB.Transitions.NoTransceiver.2</srcid><srcstatus/><internalId>106</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_PRE_NOCOM_NOCOM.NoPn.1</srcid><srcstatus/><internalId>191</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_PRE_NOCOM_NOCOM.NoPn.2</srcid><srcstatus/><internalId>192</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_PRE_NOCOM_NOCOM.Pn.1</srcid><srcstatus/><internalId>193</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_PRE_NOCOM_NOCOM.Pn.2</srcid><srcstatus/><internalId>194</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00430</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>347</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>51</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00435</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        The effect E_FULL_COM of the CanSM_BSM state machine (ref. to Figure 71) shall call at 1st 
        place for the corresponding CAN network the API BswM_CanSM_CurrentState with the parameters 
        Network := CanSMComMNetworkHandleRef and CurrentState := CANSM_BSWM_FULL_COMMUNICATION.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSM.T_PRE_FULLCOM_FULLCOM</srcid><srcstatus/><internalId>167</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_FULLCOM</srcid><srcstatus/><internalId>171</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_SILENTCOM_FULLCOM</srcid><srcstatus/><internalId>174</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>52</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00436</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        The guarding condition CANSM_BSM_G_PN_NOT_SUPPORTED of the sub state machine 
        CANSM_BSM_S_PRE_NO_COM (ref. to Figure 72) shall evaluate, if the configuration parameter 
        CanTrcvHwPnSupport (ref. to [9], CanTrcv160_Conf) is FALSE, which is available via the 
        reference CanSMTransceiverId (ref. to CANSM137_Conf) or if no CanSMTransceiverId is configured 
        at all.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSM.T_FULLCOM_PRE_NOCOM.NoPn</srcid><srcstatus/><internalId>168</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.NoPn.1</srcid><srcstatus/><internalId>176</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.NoPn.2</srcid><srcstatus/><internalId>178</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.NoPn.3</srcid><srcstatus/><internalId>180</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.NoPn.1</srcid><srcstatus/><internalId>182</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.NoPn.2</srcid><srcstatus/><internalId>184</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.NoPn.3</srcid><srcstatus/><internalId>186</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_SILENTCOM_PRE_NOCOM.NoPn</srcid><srcstatus/><internalId>189</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_NOT_INITIALIZED_PRE_NOCOM.NoPn</srcid><srcstatus/><internalId>195</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>53</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00437</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        The guarding condition CANSM_BSM_G_PN_SUPPORTED of the sub state machine CANSM_BSM_S_PRE_NO_COM 
        ref. to Figure 72) shall evaluate, if a CanSMTransceiverId (ref. to CANSM137_Conf) is 
        configured and if the configuration parameter CanTrcvHwPnSupport (ref. to [9], CanTrcv160_Conf)
        is TRUE, which is available via the reference CanSMTransceiverId (ref. to CANSM137_Conf)
      </description>
      <furtherinfo> 
        Justifying rule: WRN.swurs.needscoverage.count violation.
        The requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine, It is not complete nor consistent All requirement of this kind
        are coverd by more than 10 requirements describing the complete state transition.
      </furtherinfo>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR41.TX_TIMEOUT_EXCEPTION.T_S_CC_STOPPED_PRE_NOCOM.Pn</srcid><srcstatus/><internalId>101</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR41.TX_TIMEOUT_EXCEPTION.T_S_CC_STARTED_PRE_NOCOM.Pn</srcid><srcstatus/><internalId>102</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_FULLCOM_PRE_NOCOM.Pn</srcid><srcstatus/><internalId>169</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.Pn.1</srcid><srcstatus/><internalId>177</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.Pn.2</srcid><srcstatus/><internalId>179</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.Pn.3</srcid><srcstatus/><internalId>181</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.Pn.1</srcid><srcstatus/><internalId>183</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.Pn.2</srcid><srcstatus/><internalId>185</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.Pn.3</srcid><srcstatus/><internalId>187</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_SILENTCOM_PRE_NOCOM.Pn</srcid><srcstatus/><internalId>190</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_NOT_INITIALIZED_PRE_NOCOM.Pn</srcid><srcstatus/><internalId>196</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>54</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00463</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        If the sub state machine CANSM_BSM_DeinitPnSupported (ref. to Figure 73) has repeated any of 
        the CanIf API calls (ref. to CANSM438, CANSM441, CANSM446, CANSM450, CANSM453, CANSM458, 
        CANSM462) more often than configured (ref. to CANSM335_Conf) without getting the return value 
        E_OK and without getting the supposed mode indication callbacks (ref. to CANSM444, CANSM448, 
        CANSM452, CANSM456, CANSM460), this shall trigger the sub state machine 
        CANSM_BSM_DeinitPnSupported with T_REPEAT_MAX.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMDeInitPn.T_S_PN_CLEAR_WUF_S_PN_CLEAR_WUF.2</srcid><srcstatus/><internalId>199</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSMDeInitPn.T_S_PN_CC_STOPPED_S_PN_CLEAR_WUF</srcid><srcstatus/><internalId>202</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSMDeInitPn.T_S_TRCV_NORMAL_S_PN_CLEAR_WUF</srcid><srcstatus/><internalId>205</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSMDeInitPn.T_S_TRCV_STANDBY_S_PN_CLEAR_WUF</srcid><srcstatus/><internalId>208</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSMDeInitPn.T_S_CHECK_WFLAG_IN_CC_SLEEP_S_PN_CLEAR_WUF</srcid><srcstatus/><internalId>212</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSMDeInitPn.T_S_CHECK_WFLAG_IN_NOT_CC_SLEEP_S_PN_CLEAR_WUF.2</srcid><srcstatus/><internalId>215</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ECUC_CanSM_00335</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>288</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>55</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00480</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        If the sub state machine CANSM_BSM_DeinitPnNotSupported (ref. to Figure 74) has repeated any of 
        the CanIf API calls (ref. to CANSM464, CANSM468, CANSM472, CANSM476) more often than configured 
        ref. to CANSM335_Conf) without getting the return value E_OK and without getting the supposed 
        mode indication callbacks (ref. to CANSM466, CANSM470, CANSM474, CANSM478), this shall trigger 
        the sub state machine CANSM_BSM_DeinitPnNotSupported with T_REPEAT_MAX.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMDeInitNoPn.T_S_CC_STOPPED_S_CC_STOPPED.2</srcid><srcstatus/><internalId>218</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSMDeInitNoPn.T_S_CC_SLEEP_S_CC_STOPPED</srcid><srcstatus/><internalId>221</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_NORMAL_S_CC_STOPPED</srcid><srcstatus/><internalId>224</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_STANDBY_S_CC_STOPPED</srcid><srcstatus/><internalId>226</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ECUC_CanSM_00335</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>288</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>56</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00495</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        If the sub state machine CANSM_BSM_S_PRE_FULLCOM (ref. to Figure 75) has repeated any of the 
        CanIf API calls (ref. to CANSM483, CANSM487, CANSM491) more often than configured (ref. to 
        CANSM335_Conf) without getting the return value E_OK and without getting the supposed mode 
        indication callbacks (ref. to CANSM485, CANSM489, CANSM493), this shall trigger the sub state 
        machine CANSM_BSM_S_PRE_FULLCOM with T_REPEAT_MAX.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.NoPn.1</srcid><srcstatus/><internalId>176</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.Pn.1</srcid><srcstatus/><internalId>177</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.NoPn.2</srcid><srcstatus/><internalId>178</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.Pn.2</srcid><srcstatus/><internalId>179</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.NoPn.3</srcid><srcstatus/><internalId>180</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.Pn.3</srcid><srcstatus/><internalId>181</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ECUC_CanSM_00335</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>288</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>57</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00498</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        The effect E_BUS_OFF_PASSIVE of the sub state machine CANSM_BSM_S_FULLCOM (ref. to Figure 76) 
        shall invocate Dem_ReportErrorStatus (ref. to chapter 8.6.1) with the parameters EventId := 
        CANSM_E_BUS_OFF (ref. to CANSM070_Conf) and EventStatus := DEM_EVENT_STATUS_PASSED.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_NO_BUS_OFF</srcid><srcstatus/><internalId>232</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ECUC_CanSM_00070</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>273</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00666</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>532</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>58</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00501</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        Service name: CanSM_CheckBaudrate Syntax: Std_ReturnType CanSM_CheckBaudrate(
        NetworkHandleType network, const uint16 Baudrate) Service ID[hex]: 0x0c Sync/Async: 
        Synchronous Reentrancy: Reentrant Parameters (in): network Handle of the addressed CAN network 
        to check if a baudrate is supported Baudrate Baudrate to check in kbps Parameters (inout): None 
        Parameters (out): None Return value: Std_ReturnType E_OK: Baudrate supported by all configured 
        CAN controllers of the networkE_NOT_OK: Baudrate not supported / invalid network Description: 
        This service shall check, if a certain baudrate is supported by the configured CAN controllers 
        of a certain CAN network.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CANSM.ChangeBaudrateMissing</srcid><srcstatus/><internalId>545</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>59</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00503</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        If no condition is present to deny the CanSM_ChangeBaudrate request according to CANSM502, 
        CANSM505, CANSM530 and CANSM573, then the CanSM module shall return E_OK and start the 
        asynchronous process to change the baud rate of the CAN network's CAN Controllers to the 
        checked and requested baud rate (ref. to CANSM507)
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CANSM.ChangeBaudrateMissing</srcid><srcstatus/><internalId>545</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>60</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00507</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        The API function CanSM_ChangeBaudrate (ref. to CANSM501) shall trigger the sub state machine 
        CANSM_BSM_S_FULLCOM (ref. to Figure 76) for the requested CAN network with T_CHANGE_BR_REQUEST,
        if the CanSM module has accepted the CanSM_ChangeBaudrate request with return of E_OK.
      </description>
      <comment>
        This requirement has been replaced by CanSM.ASR41.SWS_CanSM_00507.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CANSM.ChangeBaudrateMissing</srcid><srcstatus/><internalId>545</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR41.SWS_CanSM_00507</srcid><srcstatus/><internalId>90</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>61</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00513</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        The effect E_TX_OFF of the sub state machine CANSM_BSM_S_FULLCOM (ref. to Figure 76) shall call 
        for the configured CAN controllers of the CAN network (ref. to CANSM141_Conf) the API function 
        CanIf_SetPduMode (ref. to chapter 8.6.1) with the parameters ControllerId := CanSMControllerId 
        ref. to CANSM141_Conf) and PduModeRequest := CANIF_SET_TX_OFFLINE.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CANSM.PNFilter</srcid><srcstatus/><internalId>551</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>62</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00514</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        The guarding condition G_TX_ON of the sub state machine CANSM_BSM_S_FULLCOM (ref. to Figure 76)
        shall be passed after a time duration of CanSMBorTimeL1 (ref. to CANSM128_Conf), if the count 
        of bus-off recovery retries with E_BUS_OFF without passing the guarding condition 
        G_BUS_OFF_PASSIVE is lower than CanSMBorCounterL1ToL2 (ref. to CANSM131_Conf)
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMFull.T_S_TX_OFF_S_BUS_OFF_CHECK</srcid><srcstatus/><internalId>243</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ECUC_CanSM_00131</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>280</internalId></provcov>
        <provcov>
          <linksto>CanSM.ECUC_CanSM_00128</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>277</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>63</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00515</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        The guarding condition G_TX_ON of the sub state machine CANSM_BSM_S_FULLCOM (ref. to Figure 76)
        shall be passed after a time duration of CanSMBorTimeL2 (ref. to CANSM129_Conf), if the count 
        of bus-off recovery retries with E_BUS_OFF without passing the guarding condition 
        G_BUS_OFF_PASSIVE is greater than or equal to CanSMBorCounterL1ToL2 (ref. to CANSM131_Conf)
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMFull.T_S_TX_OFF_S_BUS_OFF_CHECK</srcid><srcstatus/><internalId>243</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ECUC_CanSM_00131</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>280</internalId></provcov>
        <provcov>
          <linksto>CanSM.ECUC_CanSM_00129</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>278</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>64</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00522</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        The effect E_BUS_OFF of the sub state machine CANSM_BSM_S_FULLCOM (ref. to Figure 76) shall 
        invocate Dem_ReportErrorStatus (ref. to chapter 8.6.1) with the parameters EventId := 
        CANSM_E_BUS_OFF (ref. to CANSM070_Conf) and EventStatus := DEM_EVENT_STATUS_PRE_FAILED.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_RESTART_CC</srcid><srcstatus/><internalId>233</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSMFull.T_S_NO_BUS_OFF_S_RESTART_CC</srcid><srcstatus/><internalId>237</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ECUC_CanSM_00070</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>273</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00666</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>532</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>65</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00523</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        If the sub state machine CANSM_BSM_S_FULLCOM (ref. to Figure 76) has repeated the CanIf API to 
        restart the CAN controller(s) of the CAN network (ref. to CANSM509) more often than configured 
        ref. to CANSM335_Conf) without getting the return value E_OK and without getting the supposed 
        mode indication (ref. to CANSM511), this shall trigger the sub state machine 
        CANSM_BSM_S_FULLCOM with T_REPEAT_MAX.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSM.T_FULLCOM_PRE_NOCOM.NoPn</srcid><srcstatus/><internalId>168</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_FULLCOM_PRE_NOCOM.Pn</srcid><srcstatus/><internalId>169</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ECUC_CanSM_00335</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>288</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>66</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00531</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        The effect E_CHANGE_BAUDRATE of the sub state machine CANSM_BSM_S_CHANGE_BAUDRATE (ref. to 
        Figure 77) shall call at 2nd place for all configured CAN controllers of the CAN network (ref. 
        to CANSM141_Conf) the API request CanIf_ChangeBaudrate (ref. to chapter 8.6.2) with the 
        respective ControllerId parameter and shall use as baudrate parameter the checked and 
        remembered baud rate (ref. to CANSM572 and CANSM503)
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CANSM.ChangeBaudrateMissing</srcid><srcstatus/><internalId>545</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.SWS_CanSM_00531</srcid><srcstatus/><internalId>439</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>67</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00536</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        If the sub state machine CANSM_BSM_S_CHANGE_BAUDRATE (ref. to Figure 77) has repeated the 
        referenced CanIf APIs (ref. to CANSM524, CANSM532) for the CAN controllers of the corresponding 
        CAN network more often than configured (ref. to CANSM335_Conf) without getting the return value 
        E_OK and without getting the supposed mode indications (ref. to CANSM526, CANSM534), this shall 
        trigger the sub state machine CANSM_BSM_S_CHANGE_BAUDRATE with T_REPEAT_MAX.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.NoPn.1</srcid><srcstatus/><internalId>182</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.Pn.1</srcid><srcstatus/><internalId>183</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.NoPn.2</srcid><srcstatus/><internalId>184</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.Pn.2</srcid><srcstatus/><internalId>185</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ECUC_CanSM_00335</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>288</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>68</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00537</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        The effect E_FULL_TO_SILENT_COM of the CanSM_BSM state machine (ref. to Figure 71) shall call 
        at 3rd place for each configured CAN controller of the CAN network the API CanIf_SetPduMode 
        with the parameters ControllerId := CanSMControllerId (ref. to CANSM141_Conf) and 
        PduModeRequest := CANIF_SET_TX_OFFLINE.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CANSM.PNFilter</srcid><srcstatus/><internalId>551</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>69</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00538</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        The effect E_FULL_TO_SILENT_COM of the CanSM_BSM state machine (ref. to Figure 71) shall call 
        at 4th place for the corresponding CAN network the API ComM_BusSM_ModeIndication with the 
        parameters Channel := CanSMComMNetworkHandleRef (ref. to CANSM161_Conf) and ComMode := 
        COMM_SILENT_COMMUNICATION.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSM.T_FULLCOM_SILENTCOM.BusOffCheck.1</srcid><srcstatus/><internalId>108</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_FULLCOM_SILENTCOM.BusOffCheck.2</srcid><srcstatus/><internalId>109</internalId></linkedfrom><linkedfrom><srcid>CanSM.EB.BSM.T_FULLCOM_SILENTCOM.S_TX_OFF.1</srcid><srcstatus/><internalId>110</internalId></linkedfrom><linkedfrom><srcid>CanSM.EB.BSM.T_FULLCOM_SILENTCOM.S_TX_OFF.2</srcid><srcstatus/><internalId>111</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_FULLCOM_SILENTCOM.1</srcid><srcstatus/><internalId>172</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_FULLCOM_SILENTCOM.2</srcid><srcstatus/><internalId>173</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_SILENTCOM</srcid><srcstatus/><internalId>188</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>70</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00540</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        The effect E_FULL_COM of the CanSM_BSM state machine (ref. to Figure 71) shall call at 3rd 
        place for the corresponding CAN network the API ComM_BusSM_ModeIndication with the parameters 
        Channel := CanSMComMNetworkHandleRef (ref. to CANSM161_Conf) and ComMode := 
        COMM_FULL_COMMUNICATION.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSM.T_PRE_FULLCOM_FULLCOM</srcid><srcstatus/><internalId>167</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_FULLCOM</srcid><srcstatus/><internalId>171</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_SILENTCOM_FULLCOM</srcid><srcstatus/><internalId>174</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>71</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00547</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        The header file CanSM_Dcm.h shall export the interfaces, which are dedicated to the Dcm module.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_CHECK_CANSM_DCM_H</srcid><srcstatus/><internalId>604</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>72</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00548</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        The CanSM module (CanSM.c) shall include the interface CanNm_ConfirmPnAvailability (
        CanNm_ConfirmPnAvailability.h) of the CanNm module.
      </description>
      <comment>
        CanNm_ConfirmPnAvailability interface is provided in header file CanNm.h.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.SWS_CanSM_00548.1</srcid><srcstatus/><internalId>166</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>73</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00549</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        The header file CanSM_TxTimeoutException.h shall provide the callback function 
        CanSM_TxTimeoutException as optional interface to the CanNm module.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_PNSUPPORT_ON</srcid><srcstatus/><internalId>618</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>74</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00554</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        The API request CanSM_RequestComMode (ref. to CANSM062) with the parameter ComM_Mode equal to 
        COMM_NO_COMMUNICATION shall trigger the sub state machine CANSM_BSM_S_FULLCOM (ref. to Figure 
        76) with T_SILENT_COM_MODE_REQUEST, which corresponds to the function parameter network and the 
        configuration parameter CANSM_NETWORK_HANDLE (ref. to CANSM161_Conf)
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSM.T_FULLCOM_SILENTCOM.BusOffCheck.2</srcid><srcstatus/><internalId>109</internalId></linkedfrom><linkedfrom><srcid>CanSM.EB.BSM.T_FULLCOM_SILENTCOM.S_TX_OFF.2</srcid><srcstatus/><internalId>111</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_FULLCOM_SILENTCOM.2</srcid><srcstatus/><internalId>173</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>75</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00562</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        The CanSM module shall deny the CanSM_CheckBaudrate API request, if the NetworkHandle parameter 
        does not match to the configured Network handles of the CanSM module (ref. to CANSM161_Conf)
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CANSM.ChangeBaudrateMissing</srcid><srcstatus/><internalId>545</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>76</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00563</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        If the NetworkHandle parameter in the CanSM_CheckBaudrate request matches to one of the 
        configured Network handles (ref. to CANSM161_Conf) and the requested baud rate is supported (
        ref. to CANSM567), then the function shall return E_OK.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CANSM.ChangeBaudrateMissing</srcid><srcstatus/><internalId>545</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>77</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00564</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        The CanSM module shall provide the API function CanSM_CheckBaudrate, if the
        CanSmChangeBaudrateApi parameter (ref. to CanSM.ASR40.CANSM342_Conf) is configured
        with the value TRUE.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CANSM.ChangeBaudrateMissing</srcid><srcstatus/><internalId>545</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>78</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00565</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        The CanSM module shall not provide the API function CanSM_CheckBaudrate, if the
        CanSmChangeBaudrateApi parameter (ref. to CanSM.ASR40.CANSM342_Conf) is configured
        with the value FALSE.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CANSM.ChangeBaudrateMissing</srcid><srcstatus/><internalId>545</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>79</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00566</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        If the NetworkHandle parameter in the CanSM_CheckBaudrate request matches to one of the 
        configured Network handles (ref. to CANSM161_Conf) and the requested baud rate is not supported 
        ref. to CANSM568), then the function shall return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CANSM.ChangeBaudrateMissing</srcid><srcstatus/><internalId>545</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>80</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00567</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        If the CanSM module is requested to provide the information, if a certain baudrate is supported 
        by a configured CAN network (ref. to CANSM126_Conf) with CanSM_CheckBaudrate (ref. to CANSM501)
        then the CanSM module shall reference the CanIf API function CanIf_CheckBaudrate (ref. to 
        chapter 8.6.2) for all configured CAN controllers of the CAN network and notify, that the baud 
        rate is supported by the CAN network, if all CanIf_CheckBaudrate calls have returned E_OK.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CANSM.ChangeBaudrateMissing</srcid><srcstatus/><internalId>545</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>81</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00568</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        If the CanSM module is requested to provide the information, if a certain baud rate is 
        supported by a configured CAN network (ref. to CANSM126_Conf) with CanSM_CheckBaudrate (ref. to 
        CANSM501), then the CanSM module shall reference the CanIf API function CanIf_CheckBaudrate (
        ref. to chapter 8.6.2) for all configured CAN controllers of the CAN network and notify, that 
        the baud rate is not supported, if not all CanIf_CheckBaudrate calls have returned E_OK.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CANSM.ChangeBaudrateMissing</srcid><srcstatus/><internalId>545</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>82</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00571</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        The function CanSM_CheckBaudrate shall call the function Det_ReportError with ErrorId parameter 
        CANSM_E_INVALID_NETWORK_HANDLE (ref. to chapter 7.3), if it does not accept the network handle 
        of the request.
      </description>
      <comment>
        Defines one exact usage of the DET error code CANSM_E_INVALID_NETWORK_HANDLE.
        Precondition: development error detection enabled.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CANSM.ChangeBaudrateMissing</srcid><srcstatus/><internalId>545</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.ErrorTable.CANSM_E_INVALID_NETWORK_HANDLE</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>253</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.DevelopmentErrors</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>262</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>83</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00572</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        The CanSM module shall remember for each configured CAN network the checked baud rate and the 
        notified result of the last CanSM_CheckBaudrate call (ref. to CANSM567 and CANSM568)
      </description>
      <comment>
        Rationale: This is necessary to decide, if the following CanSM_ChangeBaudrate
        (ref. to CANSM561) call is valid.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CANSM.ChangeBaudrateMissing</srcid><srcstatus/><internalId>545</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>84</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00573</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        If the requested baud rate is not equal to the remembered baud rate of the last 
        CanSM_CheckBaudrate call (ref. to CANSM572) for the corresponding CAN network or if the 
        remembered result of the last CanSM_CheckBaudrate call for the corresponding CAN network has 
        been E_NOT_OK, then the CanSM_ChangeBaudrate call shall return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CANSM.ChangeBaudrateMissing</srcid><srcstatus/><internalId>545</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>85</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00574</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        If the requested baud rate is not equal to the remembered baud rate of the last 
        CanSM_CheckBaudrate call (ref. to CANSM572) for the corresponding CAN network or if the 
        remembered result of the last CanSM_CheckBaudrate call for the corresponding CAN network has 
        been E_NOT_OK, then the CanSM_ChangeBaudrate call the function Det_ReportError with ErrorId 
        parameter CANSM_E_PARAM_INVALID_BAUDRATE (ref. to chapter 7.3)
      </description>
      <comment>
        Defines one exact usage of the DET error code CANSM_E_PARAM_INVALID_BAUDRATE.
        Precondition: development error detection enabled.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CANSM.ChangeBaudrateMissing</srcid><srcstatus/><internalId>545</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.ErrorTable.CANSM_E_PARAM_INVALID_BAUDRATE</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>259</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.DevelopmentErrors</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>262</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>86</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00250</id>
      <status>approved</status>
      <version>2</version>
      <description>
        description=VARIANT-PRE-COMPILE: Only pre-compile parameters}
      </description>
      <comment>
        Only post-build configuration supported.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ECUC_CanSM_00351</srcid><srcstatus/><internalId>533</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>87</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00251</id>
      <status>approved</status>
      <version>1</version>
      <description>
        description=VARIANT-LINK-TIME: Mix of pre-compile and link time parameters}
      </description>
      <comment>
        Only pre-compile configuration supported.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ECUC_CanSM_00351</srcid><srcstatus/><internalId>533</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>88</internalId></specobject>
    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00599</id>
      <status>approved</status>
      <version>1</version>
      <description>
        description=The standardized common published parameters as required by BSW00402 in the
        General Requirements on Basic Software Modules [3] shall be published within the
        header file of this module and need to be provided in the BSW Module Description.
        The according module abbreviation can be found in the List of Basic Software Modules [1]
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.SWS_CanSM_00599.1</srcid><srcstatus/><internalId>265</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.SWS_CanSM_00599.2</srcid><srcstatus/><internalId>266</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>89</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs">


      <specobject>
         <id>CanSM.ASR41.SWS_CanSM_00507</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        The API function CanSM_SetBaudrate shall trigger the sub
        state machine CANSM_BSM_S_FULLCOM (ref. to Figure 7-6) for the requested
        CAN network with T_CHANGE_BR_REQUEST, if the CanSM module has accepted
        the CanSM_SetBaudrate (ref. to SWS_CanSM_00561) request with return of E_OK.
      </description>
         <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
         <releases>
            <release>AUTOSAR 4.1.1</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSM.T_FULLCOM_CHANGE_BAUDRATE</srcid><srcstatus/><internalId>170</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00507</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>61</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>90</internalId></specobject>

      <specobject>
         <id>CanSM.ASR41.SWS_CanSM_00503</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        If no condition is present to deny the CanSM_SetBaudrate
        request  according  to  SWS_CanSM_00502  and  SWS_CanSM_00505,
        SWS_CanSM_00530,  then  the  CanSM  module  shall  return  E_OK  and  start  the
        asynchronous  process  to  change  the  baud  rate  of  the  CAN  network's  CAN Controllers.
      </description>
         <releases>
            <release>AUTOSAR 4.1.1</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_CHANGE_BR_REQUEST_SYNC_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>671</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_CHANGE_BR_REQUEST_SYNC</srcid><srcstatus/><internalId>802</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>91</internalId></specobject>


      <!--
    new transitions for CanSM_TxTimeoutException
    ============================================
    -->

      <specobject>
         <id>CanSM.ASR41.SWS_CanSM_00578</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V3.2.0</source>
         <version>1</version>
         <description>
        As  long  the  sub  state  machine
        CANSM_BSM_S_TX_TIMEOUT_EXCEPTION  (ref.  to  Figure  7-9)  is  in  the  state
        S_CC_STOPPED,  the  CanSM  module  shall  operate  the  do  action
        DO_SET_CC_MODE_STOPPED and therefore repeat for all configured CAN controllers
        of  the  CAN  network  (ref.  to  ECUC_CanSM_00141)  the  API  request
        CanIf_SetControllerMode (ref. to chapter 8.6.1) with ControllerMode equal
        to CANIF_CS_STOPPED.
      </description>
         <releases>
            <release>AUTOSAR 4.1.1</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR41.BSM.T_FULLCOM_TX_TIMEOUT_EXCEPTION</srcid><srcstatus/><internalId>96</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR41.TX_TIMEOUT_EXCEPTION.T_S_CC_STOPPED_S_CC_STOPPED</srcid><srcstatus/><internalId>98</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>92</internalId></specobject>

      <specobject>
         <id>CanSM.ASR41.SWS_CanSM_00582</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V3.2.0</source>
         <version>1</version>
         <description>
        As  long  the  sub  state  machine
        CANSM_BSM_S_TX_TIMEOUT_EXCEPTION  (ref.  to  Figure  7-9)  is  in  the  state
        S_CC_STARTED,  the  CanSM  module  shall  operate  the  do  action
        DO_SET_CC_MODE_STARTED and therefore repeat for all configured CAN controllers
        of  the  CAN  network  (ref.  to  ECUC_CanSM_00141)  the  API  request
        CanIf_SetControllerMode (ref. to chapter 8.6.1) with ControllerMode equal
        to CANIF_CS_STARTED.
      </description>
         <releases>
            <release>AUTOSAR 4.1.1</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR41.TX_TIMEOUT_EXCEPTION.T_S_CC_STOPPED_S_CC_STARTED</srcid><srcstatus/><internalId>99</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR41.TX_TIMEOUT_EXCEPTION.T_S_CC_STARTED_S_CC_STARTED</srcid><srcstatus/><internalId>100</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>93</internalId></specobject>

      <specobject>
         <id>CanSM.ASR41.SWS_CanSM_00583</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V3.2.0</source>
         <version>1</version>
         <description>
        If  the  CanSM  module  has  got  all  mode  indications  (ref.  to
        SWS_CanSM_00396) for the configured CAN controllers of the CAN network (ref. to
        ECUC_CanSM_00141) after the respective requests to start the CAN controllers of
        the  CAN  network  (ref.  to  SWS_CanSM_00582),  this  shall  trigger  the  sub  state
        machine CANSM_BSM_S_TX_TIMEOUT_EXCEPTION (ref. to Figure 7-9) of the CAN
        network with T_CC_STARTED_INDICATED.
      </description>
         <releases>
            <release>AUTOSAR 4.1.1</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR41.BSM.T_TX_TIMEOUT_EXCEPTION_FULLCOM</srcid><srcstatus/><internalId>97</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>94</internalId></specobject>

      <specobject>
         <id>CanSM.ASR41.SWS_CanSM_00575</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V3.2.0</source>
         <version>1</version>
         <description>
        If  the  sub  state  machine
        CANSM_BSM_S_TX_TIMEOUT_EXCEPTION (ref.  to  Figure  7-9)    has  repeated  the
        CanIf  API  to  restart  the  CAN  controllers(s)  of  the  CAN  network  more  often  than
        configured  (ref.  to  ECUC_CanSM_00335)  without  getting  the  supposed  mode
        indication,  this  shall  trigger  the  sub  state  machine
        CANSM_BSM_S_TX_TIMEOUT_EXCEPTION with T_REPEAT_MAX.
      </description>
         <releases>
            <release>AUTOSAR 4.1.1</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR41.TX_TIMEOUT_EXCEPTION.T_S_CC_STOPPED_PRE_NOCOM.Pn</srcid><srcstatus/><internalId>101</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR41.TX_TIMEOUT_EXCEPTION.T_S_CC_STARTED_PRE_NOCOM.Pn</srcid><srcstatus/><internalId>102</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>95</internalId></specobject>

      <!-- refined requirements -->

    <!-- enter CANSM_BSM_S_TX_TIMEOUT_EXCEPTION state machine -->
    <specobject>
         <id>CanSM.ASR41.BSM.T_FULLCOM_TX_TIMEOUT_EXCEPTION</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V3.2.0</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_NO_BUS_OFF of state machine CANSM_BSM_S_FULLCOM
        and trigger T_TX_TIMEOUT_EXCEPTION applies, CanSM shall operate action DO_SET_CC_MODE_STOPPED
        and enter state S_CC_STOPPED of state machine CANSM_BSM_S_TX_TIMEOUT_EXCEPTION.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <releases>
            <release>AUTOSAR R20-11</release>
            <release>AUTOSAR 4.1.1</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_TXTIMEOUTEXCEPTION_ASYNC_NoPN_DET_ON</srcid><srcstatus/><internalId>638</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_TXTIMEOUTEXCEPTION_SYNC_NoPN_DET_ON</srcid><srcstatus/><internalId>639</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_TXTIMEOUTEXCEPTION_ASYNC</srcid><srcstatus/><internalId>769</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_TXTIMEOUTEXCEPTION_SYNC</srcid><srcstatus/><internalId>770</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00584</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>472</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR41.SWS_CanSM_00578</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>92</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00578</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>467</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>96</internalId></specobject>

      <!-- leave CANSM_BSM_S_TX_TIMEOUT_EXCEPTION state machine -->
    <specobject>
         <id>CanSM.ASR41.BSM.T_TX_TIMEOUT_EXCEPTION_FULLCOM</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V3.2.0</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_CC_STARTED of state machine
        CANSM_BSM_S_TX_TIMEOUT_EXCEPTION and trigger T_CC_STARTED_INDICATED
        (synchronous or asynchronous) and guardian condition G_CC_STARTED_E_OK applies,
        CanSM shall enter state S_NO_BUS_OFF of state machine CANSM_BSM_S_FULLCOM.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <releases>
            <release>AUTOSAR R20-11</release>
            <release>AUTOSAR 4.1.1</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_TXTIMEOUTEXCEPTION_ASYNC_NoPN_DET_ON</srcid><srcstatus/><internalId>638</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_TXTIMEOUTEXCEPTION_SYNC_NoPN_DET_ON</srcid><srcstatus/><internalId>639</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_TXTIMEOUTEXCEPTION_ASYNC_SYNC_2_NoPN_DET_ON</srcid><srcstatus/><internalId>641</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_TXTIMEOUTEXCEPTION_ASYNC</srcid><srcstatus/><internalId>769</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_TXTIMEOUTEXCEPTION_SYNC</srcid><srcstatus/><internalId>770</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_TXTIMEOUTEXCEPTION_ASYNC_SYNC_2</srcid><srcstatus/><internalId>772</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00580</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>469</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00581</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>470</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR41.SWS_CanSM_00583</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>94</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>97</internalId></specobject>

      <!-- self transition -->
    <specobject>
         <id>CanSM.ASR41.TX_TIMEOUT_EXCEPTION.T_S_CC_STOPPED_S_CC_STOPPED</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V3.2.0</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_CC_STOPPED of state machine
        CANSM_BSM_S_TX_TIMEOUT_EXCEPTION and trigger T_CC_STOPPED_TIMEOUT applies,
        CanSM shall operate action DO_SET_CC_MODE_STOPPED and enter state S_CC_STOPPED
        of state machine CANSM_BSM_S_TX_TIMEOUT_EXCEPTION.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <releases>
            <release>AUTOSAR R20-11</release>
            <release>AUTOSAR 4.1.1</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_TXTIMEOUTEXCEPTION_TIMEOUT_1_NoPN_DET_ON</srcid><srcstatus/><internalId>642</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_TXTIMEOUTEXCEPTION_TIMEOUT_1</srcid><srcstatus/><internalId>773</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00576</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>465</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR41.SWS_CanSM_00578</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>92</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00578</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>467</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>98</internalId></specobject>

      <specobject>
         <id>CanSM.ASR41.TX_TIMEOUT_EXCEPTION.T_S_CC_STOPPED_S_CC_STARTED</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V3.2.0</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_CC_STOPPED of state machine
        CANSM_BSM_S_TX_TIMEOUT_EXCEPTION and trigger T_CC_STOPPED_INDICATED
        (synchronous or asynchronous) and guardian condition G_CC_STOPPED_E_OK applies applies,
        CanSM shall operate action DO_SET_CC_MODE_STARTED and enter state S_CC_STARTED
        of state machine CANSM_BSM_S_TX_TIMEOUT_EXCEPTION.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <releases>
            <release>AUTOSAR R20-11</release>
            <release>AUTOSAR 4.1.1</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_TXTIMEOUTEXCEPTION_ASYNC_NoPN_DET_ON</srcid><srcstatus/><internalId>638</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_TXTIMEOUTEXCEPTION_SYNC_NoPN_DET_ON</srcid><srcstatus/><internalId>639</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_TXTIMEOUTEXCEPTION_ASYNC_SYNC_1_NoPN_DET_ON</srcid><srcstatus/><internalId>640</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_TXTIMEOUTEXCEPTION_ASYNC</srcid><srcstatus/><internalId>769</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_TXTIMEOUTEXCEPTION_SYNC</srcid><srcstatus/><internalId>770</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_TXTIMEOUTEXCEPTION_ASYNC_SYNC_1</srcid><srcstatus/><internalId>771</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00577</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>466</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00579</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>468</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR41.SWS_CanSM_00582</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>93</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00582</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>471</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>99</internalId></specobject>

      <!-- self transition -->
    <specobject>
         <id>CanSM.ASR41.TX_TIMEOUT_EXCEPTION.T_S_CC_STARTED_S_CC_STARTED</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V3.2.0</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_CC_STARTED of state machine
        CANSM_BSM_S_TX_TIMEOUT_EXCEPTION and trigger T_CC_STARTED_TIMEOUT applies,
        CanSM shall operate action DO_SET_CC_MODE_STARTED and enter state S_CC_STARTED
        of state machine CANSM_BSM_S_TX_TIMEOUT_EXCEPTION.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <releases>
            <release>AUTOSAR R20-11</release>
            <release>AUTOSAR 4.1.1</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_TXTIMEOUTEXCEPTION_TIMEOUT_2_NoPN_DET_ON</srcid><srcstatus/><internalId>643</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_TXTIMEOUTEXCEPTION_TIMEOUT_2</srcid><srcstatus/><internalId>774</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.ASR41.SWS_CanSM_00582</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>93</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00582</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>471</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>100</internalId></specobject>

      <specobject>
         <id>CanSM.ASR41.TX_TIMEOUT_EXCEPTION.T_S_CC_STOPPED_PRE_NOCOM.Pn</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_CC_STOPPED of state machine
        CANSM_BSM_S_TX_TIMEOUT_EXCEPTION and trigger T_REPEAT_MAX applies,
        CanSM shall execute effect E_PRE_NOCOM, operate action DO_CLEAR_TRCV_WUF, call
        Det_ReportError with error ID CANSM_E_MODE_REQUEST_TIMEOUT and enter state S_PN_CLEAR_WUF
        of state machine CANSM_BSM_DeinitPnSupportedProceed.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <releases>
            <release>AUTOSAR R20-11</release>
            <release>AUTOSAR 4.1.1</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_TXTIMEOUTEXCEPTION_TIMEOUT_3_NoPN_DET_ON</srcid><srcstatus/><internalId>644</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_TXTIMEOUTEXCEPTION_TIMEOUT_3_NoPN_DET_ON_Distribution</srcid><srcstatus/><internalId>650</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_TXTIMEOUTEXCEPTION_TIMEOUT_3</srcid><srcstatus/><internalId>775</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.ASR41.SWS_CanSM_00575</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>95</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00431</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>348</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00437</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>54</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00385</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>46</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00438</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>355</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.ErrorTable.CANSM_E_MODE_REQUEST_TIMEOUT</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>260</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>101</internalId></specobject>

      <specobject>
         <id>CanSM.ASR41.TX_TIMEOUT_EXCEPTION.T_S_CC_STARTED_PRE_NOCOM.Pn</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_CC_STARTED of state machine
        CANSM_BSM_S_TX_TIMEOUT_EXCEPTION and trigger T_REPEAT_MAX applies,
        CanSM shall execute effect E_PRE_NOCOM, operate action DO_CLEAR_TRCV_WUF, call
        Det_ReportError with error ID CANSM_E_MODE_REQUEST_TIMEOUT and enter state S_PN_CLEAR_WUF
        of state machine CANSM_BSM_DeinitPnSupportedProceed.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <releases>
            <release>AUTOSAR R20-11</release>
            <release>AUTOSAR 4.1.1</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_TXTIMEOUTEXCEPTION_TIMEOUT_4_NoPN_DET_ON</srcid><srcstatus/><internalId>645</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_TXTIMEOUTEXCEPTION_TIMEOUT_4_NoPN_DET_ON_Distribution</srcid><srcstatus/><internalId>651</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_TXTIMEOUTEXCEPTION_TIMEOUT_4</srcid><srcstatus/><internalId>776</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_TXTIMEOUTEXCEPTION_TIMEOUT_5</srcid><srcstatus/><internalId>777</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.ASR41.SWS_CanSM_00575</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>95</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00431</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>348</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00437</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>54</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00385</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>46</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00438</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>355</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.ErrorTable.CANSM_E_MODE_REQUEST_TIMEOUT</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>260</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>102</internalId></specobject>


  </specobjects>
    <specobjects doctype="swurs">
    
      <specobject>
         <id>CanSM.ASR42.SWS_CANSM_00539</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V4.2.2</source>
         <version>1</version>
         <description>
        The effect E_FULL_COM of the CanSM_BSM state machine (ref. to Figure 7-1) shall
        call at 1st place for each configured CAN controller of the CAN network
        the API CanIf_SetPduMode with the parameters ControllerId :=
        CanSMControllerId (ref. to CanSM.ASR40.CANSM141_Conf) and PduModeRequest :=
        CANIF_ONLINE.
      </description>
         <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
         <releases>
            <release>AUTOSAR 4.2.2</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSM.T_PRE_FULLCOM_FULLCOM</srcid><srcstatus/><internalId>167</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_FULLCOM</srcid><srcstatus/><internalId>171</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_SILENTCOM_FULLCOM</srcid><srcstatus/><internalId>174</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00539</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>445</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>103</internalId></specobject>
    
      <specobject>
         <id>CanSM.ASR42.SWS_CANSM_00516</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V4.2.2</source>
         <version>1</version>
         <description>
        The effect E_TX_ON of the sub state machine CANSM_BSM_S_FULLCOM (ref. to
        Figure 7-6) shall call at 1st place for the configured CAN controllers of
        the CAN network (ref. to CanSM.ASR40.CANSM141_Conf) the API function CanIf_SetPduMode
        (ref. to chapter 8.6.1) with the parameters ControllerId :=
        CanSMControllerId (ref. to CanSM.ASR40.CANSM141_Conf) and PduModeRequest :=
        CANIF_ONLINE.
      </description>
         <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
         <releases>
            <release>AUTOSAR 4.2.2</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMFull.T_S_TX_OFF_S_BUS_OFF_CHECK</srcid><srcstatus/><internalId>243</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00516</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>426</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>104</internalId></specobject>

  </specobjects>
    <specobjects doctype="swurs">
      <specobject>
         <id>CanSM.EB.CanSMActivatePN</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        There shall be a configuration parameter for each network (CanSMManagerNetwork) which
        activates/deactivates partial networking for the affected network.

        Name                CanSMActivatePN
        Description         Enables and disables partial network support for particular network
        Multiplicity        1
        Type                EcucBooleanParamDef
        Default value       FALSE
        ConfigurationClass  Pre-compile time   X   All Variants
        Link time           -
        Post-build time     -
        Scope /Dependency   scope: Local
      </description>
      <furtherinfo> 
        Justifying rule: WRN.swuts.needscoverage.count violation.
        A requirement can end up being satisified by numerous tests because
        the module can be subject to various scenarios 
      </furtherinfo>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_S_RNOCOM_SYNC_NOPN</srcid><srcstatus/><internalId>632</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_NOCO_TXTIMEOUTEXCEPTION_NOPN</srcid><srcstatus/><internalId>636</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_NOCO_TXTIMEOUTEXCEPTION_NOPN_Distribution</srcid><srcstatus/><internalId>648</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_PN_NOPN_MIXED</srcid><srcstatus/><internalId>712</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOIN_NOCO_SYNC_PN</srcid><srcstatus/><internalId>746</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_SICO_NOCO_ASYNC_PN</srcid><srcstatus/><internalId>747</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_API_NEGATIVERETURN_PN</srcid><srcstatus/><internalId>748</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_NOCO_ASYNC_PN</srcid><srcstatus/><internalId>749</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_TIMEOUT_SYNC_PN_1</srcid><srcstatus/><internalId>750</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_TIMEOUT_SYNC_PN_2</srcid><srcstatus/><internalId>751</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_CHECK_TRCV_WFLAG_SYNC_PN</srcid><srcstatus/><internalId>752</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_REPEAT_MAX_DEINIT_PN_1</srcid><srcstatus/><internalId>754</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_REPEAT_MAX_DEINIT_PN_2</srcid><srcstatus/><internalId>755</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_REPEAT_MAX_DEINIT_PN_3</srcid><srcstatus/><internalId>756</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_REPEAT_MAX_DEINIT_PN_4</srcid><srcstatus/><internalId>757</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_REPEAT_MAX_DEINIT_PN_5</srcid><srcstatus/><internalId>758</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_REPEAT_MAX_PRE_FULLCOM_PN_1</srcid><srcstatus/><internalId>759</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_REPEAT_MAX_PRE_FULLCOM_PN_2</srcid><srcstatus/><internalId>760</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_REPEAT_MAX_PRE_FULLCOM_PN_3</srcid><srcstatus/><internalId>761</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_REPEAT_MAX_FULLCOM_PN_1</srcid><srcstatus/><internalId>762</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_S_RNOCOM_SYNC_PN</srcid><srcstatus/><internalId>763</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_NOCO_TXTIMEOUTEXCEPTION_PN</srcid><srcstatus/><internalId>767</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>105</internalId></specobject>

      <!--
    =======================================================================================
    State machine requirements for  N O   T R A N S C E I V E R:
    -->

    <!-- CANSM_BSM_DeinitPnNotSupported: S_CC_SLEEP to CANSM_BSM_S_NOCOM -->
    <specobject>
         <id>CanSM.EB.Transitions.NoTransceiver.2</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        If no transceiver is configured for a CAN network,
        and the CanSM module is in state S_CC_SLEEP of state machine
        CANSM_BSM_DeinitPnNotSupportedProceed and trigger T_CC_SLEEP_INDICATED applies,
        CanSM shall execute effect E_NO_COM and enter state CANSM_BSM_S_NOCOM
        of state machine CANSM_BSM.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_NOIN_NOCO_SYNC_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>652</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_SICO_NOCO_SYNC_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>662</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_NOCO_SYNC_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>700</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_S_RNOCO_SYNC_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>701</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOIN_NOCO_SYNC</srcid><srcstatus/><internalId>783</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_SICO_NOCO_SYNC</srcid><srcstatus/><internalId>793</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_NOCO_SYNC</srcid><srcstatus/><internalId>831</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_S_RNOCO_SYNC</srcid><srcstatus/><internalId>832</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00560</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>456</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00557</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>454</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00470</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>386</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00430</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>51</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00556</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>453</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>106</internalId></specobject>

      <!-- CANSM_BSM_S_PRE_FULLCOM: CANSM_BSM_S_NOCOM to S_CC_STOPPED -->
    <specobject>
         <id>CanSM.EB.Transitions.NoTransceiver.3</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        If no transceiver is configured for a CAN network,
        and the CanSM module is in state CANSM_BSM_S_NOCOM of state machine
        CANSM_BSM and trigger T_FULL_COM_MODE_REQUEST applies,
        CanSM shall operate action DO_SET_CC_MODE_STOPPED and enter state S_CC_STOPPED
        of state machine CANSM_BSM_S_PRE_FULLCOM.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_NOCO_FUCO_ASYNC_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>654</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_TIMEOUT_SYNC_1_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>655</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_TIMEOUT_SYNC_2_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>656</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_FUCO_ASYNC</srcid><srcstatus/><internalId>785</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_TIMEOUT_SYNC_1</srcid><srcstatus/><internalId>786</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_TIMEOUT_SYNC_2</srcid><srcstatus/><internalId>787</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00560</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>456</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00425</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>342</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00487</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>400</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00635</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>508</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>107</internalId></specobject>

      <!-- new transitions from S_BUS_OFF_CHECK via RequestComMode -->

    <specobject>
         <id>CanSM.ASR40.BSM.T_FULLCOM_SILENTCOM.BusOffCheck.1</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_BUS_OFF_CHECK of state machine
        CANSM_BSM_S_FULLCOM and trigger T_SILENT_COM_MODE_REQUEST (as defined in CANSM499)
        applies, CanSM shall execute effect E_FULL_TO_SILENT_COM and enter state
        CANSM_BSM_S_SILENTCOM of state machine CANSM_BSM.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_FUCO_SICO_3_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>683</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_SICO_3</srcid><srcstatus/><internalId>814</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00499</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>411</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00434</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>351</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00541</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>447</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00538</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>70</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00635</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>508</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>108</internalId></specobject>

      <specobject>
         <id>CanSM.ASR40.BSM.T_FULLCOM_SILENTCOM.BusOffCheck.2</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_BUS_OFF_CHECK of state machine
        CANSM_BSM_S_FULLCOM and trigger T_SILENT_COM_MODE_REQUEST  (as defined in CANSM554)
        applies, CanSM shall execute effect E_FULL_TO_SILENT_COM and enter state
        CANSM_BSM_S_SILENTCOM of state machine CANSM_BSM.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_FUCO_NOCO_TXTIMEOUTEXCEPTION_NOPN</srcid><srcstatus/><internalId>636</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_NOCO_TXTIMEOUTEXCEPTION_NOPN_Distribution</srcid><srcstatus/><internalId>648</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_NOCO_ASYNC_PN</srcid><srcstatus/><internalId>749</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_TIMEOUT_SYNC_PN_1</srcid><srcstatus/><internalId>750</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_TIMEOUT_SYNC_PN_2</srcid><srcstatus/><internalId>751</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_CHECK_TRCV_WFLAG_SYNC_PN</srcid><srcstatus/><internalId>752</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_NOCO_TXTIMEOUTEXCEPTION_PN</srcid><srcstatus/><internalId>767</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00554</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>75</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00434</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>351</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00541</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>447</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00538</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>70</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00635</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>508</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>109</internalId></specobject>

      <!-- new EB specific transitions from S_TX_OFF via RequestComMode -->

    <specobject>
         <id>CanSM.EB.BSM.T_FULLCOM_SILENTCOM.S_TX_OFF.1</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_TX_OFF of state machine
        CANSM_BSM_S_FULLCOM and trigger T_SILENT_COM_MODE_REQUEST (as defined in CANSM499)
        applies, CanSM shall execute effect E_FULL_TO_SILENT_COM and enter state
        CANSM_BSM_S_SILENTCOM of state machine CANSM_BSM.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_FUCO_SICO_4_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>684</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_SICO_4</srcid><srcstatus/><internalId>815</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00499</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>411</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00434</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>351</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00541</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>447</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00538</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>70</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00635</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>508</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>110</internalId></specobject>

      <specobject>
         <id>CanSM.EB.BSM.T_FULLCOM_SILENTCOM.S_TX_OFF.2</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_TX_OFF of state machine
        CANSM_BSM_S_FULLCOM and trigger T_SILENT_COM_MODE_REQUEST  (as defined in CANSM554)
        applies, CanSM shall execute effect E_FULL_TO_SILENT_COM and enter state
        CANSM_BSM_S_SILENTCOM of state machine CANSM_BSM.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_FUCO_SICO_5_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>685</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_SICO_5</srcid><srcstatus/><internalId>816</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00554</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>75</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00434</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>351</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00541</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>447</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00538</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>70</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00635</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>508</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>111</internalId></specobject>

      <!--
    end State machine requirements
    =======================================================================================
    -->

    <specobject>
         <id>CanSM.EB.Api.CanSM_MainFunction.Uninitialized</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        If a main function of an un-initialized module is called from the BSW
        Scheduler, then it shall return immediately without performing any
        functionality and without raising any errors.
      </description>
         <comment>
      </comment>
         <needscoverage>
            <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanSM_MainFunction.c_59</srcid><srcstatus/><internalId>586</internalId></linkedfrom></coveredby></needscov>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_30057</srcid><srcstatus/><internalId>738</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>112</internalId></specobject>

      <specobject>
         <id>CanSM.EB.CanIf_GetTxConfirmationState.Optional</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        If the parameter CanSMBorTxConfirmationPolling (CanSM.ASR40.CANSM339_Conf) is set
        to false for all networks, the CanSM module shall not depend on the API
        CanIf_GetTxConfirmationState.
      </description>
         <comment>
        This requirement ensures compatibility with ASR40 CanIf.
        By setting parameter CanIfPublicTxConfirmPollingSupport (CanIf.ASR40.CANIF733_Conf),
        the CanIf module may disable the API CanIf_GetTxConfirmationState.
      </comment>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_40041</srcid><srcstatus/><internalId>722</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>113</internalId></specobject>

      <specobject>
         <id>CanSM.EB.BusOffEventsCount.NOCO_FUCO</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        After the CanSM module changes the communication mode for a CAN network from
        COMM_NO_COMMUNICATION to COMM_FULL_COMMUNICATION, it shall set the count
        of bus-off events to 0 for the respective CAN network.
      </description>
         <verifycrit>
        CanSMBorCounterL1ToL2 defines a number of bus-off events till the bus-off
        handling in the state machine changes. After initialization exactly
        CanSMBorCounterL1ToL2 events must happen to see this changed behaviour. If
        the state machine changes its behaviour, the error counter was reset to 0,
        otherwise it was either another value or there is a more complicated defect
        in the CanSM concerning the counting of events which should be covered by
        other requirements.
      </verifycrit>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_BUSOFF_COUNT_RESET_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>699</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_BUSOFF_COUNT_RESET</srcid><srcstatus/><internalId>830</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>114</internalId></specobject>

      <specobject>
         <id>CanSM.EB.Api.NegativeReturn</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        When a call of a function of the CAN Interface API returns a failure
        (e.g. E_NOT_OK), the CanSM shall ignore this return value and continue with the
        transition.
        Rationale:
        Most of the relevant CAN Interface API functions call the regarding CanSM
        indication function. If the indication is missing CanSM recovers via
        a timeout handling.
        In case of CanIf_SetPduMode, which has no indication, a negative return value
        can only happen in case of a DET error.
      </description>
         <comment>
        This requirement ensures consistency with other &lt;Bus&gt;SM modules which
        have a similar requirement (e.g. FrSm149).
      </comment>
         <needscoverage>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.EB.Api.NegativeReturn.CanIf_SetPduMode</srcid><srcstatus/><internalId>116</internalId></linkedfrom><linkedfrom><srcid>CanSM.EB.Api.NegativeReturn.CanIf_CheckTrcvWakeFlag</srcid><srcstatus/><internalId>117</internalId></linkedfrom><linkedfrom><srcid>CanSM.EB.Api.NegativeReturn.CanIf_ClearTrcvWufFlag</srcid><srcstatus/><internalId>118</internalId></linkedfrom><linkedfrom><srcid>CanSM.EB.Api.NegativeReturn.CanIf_SetTrcvMode</srcid><srcstatus/><internalId>119</internalId></linkedfrom><linkedfrom><srcid>CanSM.EB.Api.NegativeReturn.CanIf_SetControllerMode</srcid><srcstatus/><internalId>120</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>115</internalId></specobject>

      <specobject>
         <id>CanSM.EB.Api.NegativeReturn.CanIf_SetPduMode</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        When a call to CanIf_SetPduMode returns a failure, the CanSM shall ignore
        this return value and continue with the transition.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_SETPDUMODE_FAILURE_1_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>702</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_SETPDUMODE_FAILURE_1</srcid><srcstatus/><internalId>833</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.EB.Api.NegativeReturn</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>115</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>116</internalId></specobject>

      <specobject>
         <id>CanSM.EB.Api.NegativeReturn.CanIf_CheckTrcvWakeFlag</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        When a call to CanIf_CheckTrcvWakeFlag returns a failure, the CanSM shall ignore
        this return value and continue with the transition.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_API_NEGATIVERETURN_PN</srcid><srcstatus/><internalId>748</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.EB.Api.NegativeReturn</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>115</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>117</internalId></specobject>

      <specobject>
         <id>CanSM.EB.Api.NegativeReturn.CanIf_ClearTrcvWufFlag</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        When a call to CanIf_ClearTrcvWufFlag returns a failure, the CanSM shall ignore
        this return value and continue with the transition.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_API_NEGATIVERETURN_PN</srcid><srcstatus/><internalId>748</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.EB.Api.NegativeReturn</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>115</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>118</internalId></specobject>

      <specobject>
         <id>CanSM.EB.Api.NegativeReturn.CanIf_SetTrcvMode</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        When a call to CanIf_SetTrcvMode returns a failure, the CanSM shall ignore
        this return value and continue with the transition.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_API_NEGATIVERETURN_PN</srcid><srcstatus/><internalId>748</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.EB.Api.NegativeReturn</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>115</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>119</internalId></specobject>

      <specobject>
         <id>CanSM.EB.Api.NegativeReturn.CanIf_SetControllerMode</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        When a call to CanIf_SetControllerMode returns a failure, the CanSM shall ignore
        this return value and continue with the transition.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_API_NEGATIVERETURN_PN</srcid><srcstatus/><internalId>748</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.EB.Api.NegativeReturn</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>115</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>120</internalId></specobject>

      <specobject>
         <id>CanSM.EB.BSWMDGeneration_1</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        The CanSM module's generator shall generate a basic software
        module description (BSWMD) based on the CanSM module's
        configuration containing information on the exclusive areas
        required by the CanSM module's implementation.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_SCHM</srcid><srcstatus/><internalId>621</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>121</internalId></specobject>

      <specobject>
         <id>CanSM.EB.BSWMDGeneration_2</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        The CanSM module's generator shall generate a basic software
        module description (BSWMD) based on the CanSM module's
        configuration containing information on the scheduled
        MainFunctions together with the scheduling period.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_SCHM</srcid><srcstatus/><internalId>621</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>122</internalId></specobject>

      <specobject>
         <id>CanSM.EB.BSWMDGeneration_3</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        The CanSM module's BSWMD shall be generated using a generator
        mode named "generate_swcd".
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_SCHM</srcid><srcstatus/><internalId>621</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>123</internalId></specobject>

      <specobject>
         <id>CanSM.EB.BusOffRecovery.SetNetworkModeSilentCommunication</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        If the CanSM module has got the mode indications for the currently handled CAN
        network according to CANSM511,
        the CanSM module shall change the internally stored network
        mode of respective CAN network to COMM_SILENT_COMMUNICATION.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_DEBOUNCE_SYNC_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>689</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_TX_OFF_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>690</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_DEBOUNCE_SYNC</srcid><srcstatus/><internalId>820</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_TX_OFF</srcid><srcstatus/><internalId>821</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>124</internalId></specobject>

      <specobject>
         <id>CanSM.EB.BusOffRecovery.SetTxOnline</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        If effect E_TX_ON takes place (ref. to CANSM516 and CANSM517)
        the CanSM module shall change the internally stored network
        mode of respective CAN network to COMM_FULL_COMMUNICATION.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_TX_ON_L2_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>695</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_TX_ON_L2</srcid><srcstatus/><internalId>826</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>125</internalId></specobject>

      <specobject>
         <id>CanSM.EB.BusOffRecovery.RestartCtrl</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        If CanSM performs bus-off recovery for a network with multiple underlying
        CanSMController, then CanSM shall restart only those CanSM controller who
        signalized bus-off before.
        Rationale:
        A Can controller in bus-off is set to state STOPPED by the Can driver.
        Restarting the controller by CanSM is a valid transition and the normal
        procedure during bus-off recovery.
        A Can controller who is not in bus-off stays operational (state STARTED).
        Restarting such a controller is an invalid transition (Can driver requirement
        CAN409). Such a request is rejected by the Can driver and no mode indication
        is done. Without complete mode indications from all controllers, CanSM runs
        into a timeout and transits to no communication.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_MULT_TRANSITIONS_2NW</srcid><srcstatus/><internalId>708</internalId></linkedfrom></coveredby></needscov>
            <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanSM_Cbk.c_79</srcid><srcstatus/><internalId>582</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/CanSM_StateMachine.c_2325</srcid><srcstatus/><internalId>588</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>126</internalId></specobject>

      <specobject>
         <id>CanSM.EB.ControllerModeIndication.WrongIndication</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        Whenever CanSM receives a controller mode indication (as reaction of a
        previous call to CanIf_SetControllerMode), CanSM shall ignore this indication
        if the indicated controller mode is not the same as the requested controller mode.
        If a subsequent indication with the correct controller mode occurs, CanSM
        shall continue with its transition.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_WRONG_INDICATION_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>706</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_WRONG_INDICATION</srcid><srcstatus/><internalId>837</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>127</internalId></specobject>

      <specobject>
         <id>CanSM.EB.TransceiverModeIndication.WrongIndication</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        Whenever CanSM receives a transceiver mode indication (as reaction of a
        previous call to CanIf_SetTrcvMode), CanSM shall ignore this indication
        if the indicated transceiver mode is not the same as the requested transceiver mode.
        If a subsequent indication with the correct transceiver mode occurs, CanSM
        shall continue with its transition.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_WRONG_INDICATION_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>706</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_WRONG_INDICATION</srcid><srcstatus/><internalId>837</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>128</internalId></specobject>

      <specobject>
         <id>CanSM.EB.RequestComMode.NoTransition</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        If CanSM receives a mode request for the same mode that CanSM actually
        has and no transition is ongoing, CanSM shall silently ignore this request.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_STAY_IN_MODE_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>707</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_STAY_IN_MODE</srcid><srcstatus/><internalId>838</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>129</internalId></specobject>

      <specobject>
         <id>CanSM.EB.RequestComMode.InvalidMode</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        The CanSM module shall deny the API request CanSM_RequestComMode, if the
        ComM_Mode parameter of the request does not have the value COMM_NO_COMMUNICATION
        or COMM_SILENT_COMMUNICATION or COMM_FULL_COMMUNICATION.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_30004</srcid><srcstatus/><internalId>727</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>130</internalId></specobject>

      <!-- CanSM_TxTimeoutException -->

    <specobject>
         <id>CanSM.EB.TxTimeoutException.TurnOff</id>
         <status>approved</status>
         <source>EB</source>
         <version>2</version>
         <description>
        The API service function CanSM_TxTimeoutException shall be available in source,
        only if EB specific configuration parameter CanSMTxTimeoutExceptionApi set to 'true'.
      </description>
         <comment>
        This can be tested with a compile test.
      </comment>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_PNSUPPORT_OFF</srcid><srcstatus/><internalId>616</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_PNSUPPORT_OFF_TXTIMEOUTSUPPORT_ON</srcid><srcstatus/><internalId>617</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_PNSUPPORT_ON</srcid><srcstatus/><internalId>618</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>131</internalId></specobject>

      <specobject>
         <id>CanSM.EB.TxTimeoutException.OngoingRecovery</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        As long as there is an ongoing recovery from a transmission timeout,
        subsequent calls to CanSM_TxTimeoutException shall be silently ignored
        for this channel.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_TXTIMEOUTEXCEPTION_2ND_CALL_NoPN_DET_ON</srcid><srcstatus/><internalId>647</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_TXTIMEOUTEXCEPTION_2ND_CALL</srcid><srcstatus/><internalId>779</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>132</internalId></specobject>

      <specobject>
         <id>CanSM.EB.TxTimeoutException.Ignore</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        In any CanSM state other than CANSM_S_FUCO_NO_BUS_OFF,
        CanSM_TxTimeoutException shall be silently ignored.
      </description>
      <furtherinfo> 
        Justifying rule: WRN.swuts.needscoverage.count violation.
        A requirement can end up being satisified by numerous tests because
        the module can be subject to various scenarios 
      </furtherinfo>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_NOCO_TXTIMEOUTEXCEPTION_SYNC_NoPN_DET_ON</srcid><srcstatus/><internalId>633</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_SICO_TXTIMEOUTEXCEPTION_SYNC_NoPN_DET_ON</srcid><srcstatus/><internalId>634</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_FUCO_TXTIMEOUTEXCEPTION_SYNC_NoPN_DET_ON</srcid><srcstatus/><internalId>635</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_NOCO_TXTIMEOUTEXCEPTION_NOPN</srcid><srcstatus/><internalId>636</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_FUCO_TXTIMEOUTEXCEPTION_NOPN</srcid><srcstatus/><internalId>637</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_NOCO_TXTIMEOUTEXCEPTION_NOPN_Distribution</srcid><srcstatus/><internalId>648</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_FUCO_TXTIMEOUTEXCEPTION_NOPN_Distribution</srcid><srcstatus/><internalId>649</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_NOCO_TXTIMEOUTEXCEPTION_SYNC</srcid><srcstatus/><internalId>764</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_SICO_TXTIMEOUTEXCEPTION_SYNC</srcid><srcstatus/><internalId>765</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_FUCO_TXTIMEOUTEXCEPTION_SYNC</srcid><srcstatus/><internalId>766</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_NOCO_TXTIMEOUTEXCEPTION_PN</srcid><srcstatus/><internalId>767</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_FUCO_TXTIMEOUTEXCEPTION_PN</srcid><srcstatus/><internalId>768</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>133</internalId></specobject>

      <specobject>
         <id>CanSM.EB.CanSMEnhancedBusOffReporting</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        There shall be a pre-compile-time parameter which
        enables/disables enhanced bus-off reporting to BswM.
        The CanSM distinguish between the states CANSM_BSWM_BUS_OFF_L1
        and CANSM_BSWM_BUS_OFF_L2 instead of having only one state
        CANSM_BSWM_BUS_OFF.

        Name                CanSMEnhancedBusOffReporting {CANSM_ENHANCED_BUSOFF_REPORTING}
        Description         Enables or disables advances bus-off reporting to BswM
        Multiplicity        1
        Type                EcucBooleanParamDef
        Default value       FALSE
        ConfigurationClass  Pre-compile time   X   All Variants
        Link time           -
        Post-build time     -
        Scope /Dependency   scope: Local
      </description>
         <comment>
      </comment>
         <needscoverage>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.CANSM508.BusOff</srcid><srcstatus/><internalId>244</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.CANSM508.BusOffL1</srcid><srcstatus/><internalId>245</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.CANSM508.BusOffL2</srcid><srcstatus/><internalId>246</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>134</internalId></specobject>

      <specobject>
         <id>CanSM.EB.ComMMode</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        CanSM shall always store a ComM request with valid function arguments.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_MAIN_INTERRUPTION</srcid><srcstatus/><internalId>714</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_ONGOING_TRANSITION</srcid><srcstatus/><internalId>715</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>135</internalId></specobject>

      <specobject>
         <id>CanSM.EB.NoComToSilentCom</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        If the CanSM module is in state CANSM_BSM_S_NOCOM and ComM requests
        the mode COMM_SILENT_COMMUNICATION, CanSM shall enter state
        CANSM_BSM_S_SILENTCOM via the states CANSM_BSM_S_PRE_FULLCOM and
        CANSM_BSM_S_FULLCOM.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_NOCO_SICO_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>686</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_SICO</srcid><srcstatus/><internalId>817</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>136</internalId></specobject>

      <specobject>
         <id>CanSM.EB.CanSMTransceiverId</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        CanSM shall configure at least one CanSMTransceiverId if CanIf
        has the transceiver support enabled.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_GEN_001_ERR_ALL_CANSMTRANSCEIVERID_DISABLED</srcid><srcstatus/><internalId>622</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>137</internalId></specobject>
    
    
    
      <!-- Specific Bus-Off handling -->

    <specobject>
         <id>CanSM.EB.CanSMBusDeactivateBusOff</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        There shall be a pre-compile-time parameter which enables/disables specific
        Bus-Off handling.
        Name                CanSMBusDeactivatedBusOff
        Description         Enables or disables specific Bus-Off handling
        Multiplicity        1
        Type                EcucBooleanParamDef
        Default value       FALSE
        ConfigurationClass  Pre-compile time   X   All Variants
        Link time           -
        Post-build time     -
        Scope /Dependency   scope: Local
      </description>
         <needscoverage>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.EB.BusOffRecovery.E_BUS_OFF.NoCom</srcid><srcstatus/><internalId>139</internalId></linkedfrom><linkedfrom><srcid>CanSM.EB.BusOffRecovery.E_OFF.SetPduToOffline</srcid><srcstatus/><internalId>140</internalId></linkedfrom><linkedfrom><srcid>CanSM.EB.BusOffRecovery.G_WAIT_TIME_RECOVERY</srcid><srcstatus/><internalId>141</internalId></linkedfrom><linkedfrom><srcid>CanSM.EB.BusOffRecovery.S_RESTART_CC</srcid><srcstatus/><internalId>142</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>138</internalId></specobject>


      <specobject>
         <id>CanSM.EB.BusOffRecovery.E_BUS_OFF.NoCom</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        If <parameter>CanSMBusDeactivatedBusOff</parameter> is activated, the effect E_BUS_OFF
        of the sub state machine CANSM_BSM_S_FULLCOM shall call in 2nd place for the corresponding
        CAN network the API ComM_BusSM_ModeIndication with the parameters Channel := CanSMComMNetworkHandleRef
        (ref. to CANSM161_Conf) and ComMode := COMM_NO_COMMUNICATION (after BswM_CanSM_CurrentState was indicated,
        see CanSM.ASR40.CANSM508.BusOff).
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_BUSDEACTIVATED_SUCCESSFUL_RECOVERY</srcid><srcstatus/><internalId>709</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_BUSDEACTIVATED_FAILED_RECOVERY</srcid><srcstatus/><internalId>710</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.EB.CanSMBusDeactivateBusOff</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>138</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>139</internalId></specobject>


      <specobject>
         <id>CanSM.EB.BusOffRecovery.E_OFF.SetPduToOffline</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        If <parameter>CanSMBusDeactivatedBusOff</parameter> is activated the effect E_OFF of the
        sub state machine CANSM_BSM_S_FULLCOM shall call for the configured CAN controllers of the
        CAN network (ref. to CANSM141_Conf) the API function CanIf_SetPduMode with the parameters
        ControllerId := CanSMControllerId (ref. to CANSM141_Conf) and PduModeRequest := CANIF_OFFLINE.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_BUSDEACTIVATED_SUCCESSFUL_RECOVERY</srcid><srcstatus/><internalId>709</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_BUSDEACTIVATED_FAILED_RECOVERY</srcid><srcstatus/><internalId>710</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.EB.CanSMBusDeactivateBusOff</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>138</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>140</internalId></specobject>


      <specobject>
         <id>CanSM.EB.BusOffRecovery.G_WAIT_TIME_RECOVERY</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        If <parameter>CanSMBusDeactivatedBusOff</parameter> is activated and the CanSM module is
        in state S_FUCO_OFF of state machine CANSM_BSM_S_FULLCOM and the guarding condition G_TX_ON
        applies, CanSM shall enter state S_FUCO_RESTART_CC of state machine CANSM_BSM_S_FULLCOM.
        (see S_FUCO_BUSDEACTIVATED_BUS_OFF.png)
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_BUSDEACTIVATED_SUCCESSFUL_RECOVERY</srcid><srcstatus/><internalId>709</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_BUSDEACTIVATED_FAILED_RECOVERY</srcid><srcstatus/><internalId>710</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.EB.CanSMBusDeactivateBusOff</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>138</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>141</internalId></specobject>


      <specobject>
         <id>CanSM.EB.BusOffRecovery.S_RESTART_CC</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        If <parameter>CanSMBusDeactivatedBusOff</parameter> is activated and the sub-state machine
        CANSM_BSM_S_FULLCOM is in the state S_FUCO_RESTART_CC, the CanSM module shall operate the do
        action DO_SET_CC_MODE_STARTED and therefore repeat for all configured CAN controllers of the
        CAN network the API request CanIf_SetControllerMode with ControllerMode equal to CANIF_CS_STARTED. 
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_BUSDEACTIVATED_SUCCESSFUL_RECOVERY</srcid><srcstatus/><internalId>709</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_BUSDEACTIVATED_FAILED_RECOVERY</srcid><srcstatus/><internalId>710</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.EB.CanSMBusDeactivateBusOff</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>138</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>142</internalId></specobject>
    
    
      <!-- Invert logic for AUTOSAR 4.0.2 and remove AUTOSAR 3.x legacy support for symbolic names -->
    
    <specobject>
         <id>CanSM.EB.LegacySymbolicNameValue</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        If macro CANSM_PROVIDE_LEGACY_SYMBOLIC_NAMES is defined:
        1 Macro for symbolic name values shall be generated for all parameters having
        SymbolicNameValue set to true:
        as:ref(CanSMComMNetworkHandleRef)/ComMChannelId
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_SymbolicNameValues</srcid><srcstatus/><internalId>611</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>143</internalId></specobject>
    
      <specobject>
         <id>CanSM.EB.NonLegacySymbolicNameValue</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        If macro CANSM_PROVIDE_LEGACY_SYMBOLIC_NAMES is not defined:
        symbolic name values for all parameters having
        SymbolicNameValue set to true, shall not be generated.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_NonLegacySymbolicNameValues</srcid><srcstatus/><internalId>614</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>144</internalId></specobject>

      <!-- MultiCore Support requirements -->
    
      <specobject>
        <id>CanSM.Config.SchM_Call_CanSM_ModeIndication</id>
        <status>approved</status>
        <source>EB</source>
        <version>1</version>
        <description>
          If CanSMMultiCoreSupport is TRUE, CanSM shall call
          SchM_Call_CanSM_RequiredCSEntry_ComM_BusSM_ModeIndication_[network_short_name]
          instead of ComM_BusSM_ModeIndication.
        </description>
        <needscoverage>
          <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_MULTICORE_ENABLED_ON</srcid><srcstatus/><internalId>612</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_TX_ON_DELAYED</srcid><srcstatus/><internalId>629</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_NOCO_TXTIMEOUTEXCEPTION_NOPN</srcid><srcstatus/><internalId>636</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_FUCO_TXTIMEOUTEXCEPTION_NOPN</srcid><srcstatus/><internalId>637</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_NOCO_TXTIMEOUTEXCEPTION_NOPN_Distribution</srcid><srcstatus/><internalId>648</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_FUCO_TXTIMEOUTEXCEPTION_NOPN_Distribution</srcid><srcstatus/><internalId>649</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_MULT_TRANSITIONS_2NW</srcid><srcstatus/><internalId>708</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_BUSDEACTIVATED_SUCCESSFUL_RECOVERY</srcid><srcstatus/><internalId>709</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_BUSDEACTIVATED_FAILED_RECOVERY</srcid><srcstatus/><internalId>710</internalId></linkedfrom></coveredby></needscov>
        <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>145</internalId></specobject>

      <!-- Post-build Support requirements -->
    
      <specobject>
        <id>CanSM.EB.PBSelectable.FileName</id>
        <status>approved</status>
        <source>EB</source>
        <version>1</version>
        <description>
          If postBuildVariant returns a non-empty string, the module's post-build-time
          configuration file names shall be changed in the following way:
          &lt;Mod&gt;[_*]_PBcfg.* to &lt;Mod&gt;_&lt;postBuildVariant&gt;[_*]_PBcfg.*
        </description>
        <needscoverage>
          <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_PBSELECTABLE</srcid><srcstatus/><internalId>620</internalId></linkedfrom></coveredby></needscov>
        <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>146</internalId></specobject>
    
      <specobject>
        <id>CanSM.EB.PBSelectable.TypeName</id>
        <status>approved</status>
        <source>EB</source>
        <version>1</version>
        <description>
          If postBuildVariant returns a non-empty string, the module's post-build-time
          configuration type/variable names shall be changed in the following way:
          - &lt;Mod&gt;_[Const]ConfigLayoutType to &lt;Mod&gt;_&lt;postBuildVariant&gt;_[Const]ConfigLayoutType
        </description>
        <needscoverage>
          <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_PBSELECTABLE</srcid><srcstatus/><internalId>620</internalId></linkedfrom></coveredby></needscov>
        <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>147</internalId></specobject>
    
      <specobject>
        <id>CanSM.EB.PBSelectable.Master</id>
        <status>approved</status>
        <source>EB</source>
        <version>1</version>
        <description>
          If postBuildVariant returns a non-empty string, the module shall generate a post-build-time
          configuration file &lt;Mod&gt;_PBcfg.h/c which includes all the variants specific post-build-time
          configurations (&lt;Mod&gt;_&lt;postBuildVariant&gt;[_*]_PBcfg.h/c).
        </description>
        <needscoverage>
          <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_PBSELECTABLE</srcid><srcstatus/><internalId>620</internalId></linkedfrom></coveredby></needscov>
        <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>148</internalId></specobject>

      <specobject>
        <id>CanSM.EB.CanSMMaxNumberOfTransceivers</id>
        <status>approved</status>
        <source>EB</source>
        <version>1</version>
        <description>
          There shall be a pre-compile-time parameter which specifies the maximum
          number of transceivers across all variants.
          Name                CanSMMaxNumberOfTransceivers
          Description         Maximum number of transceivers
          Multiplicity        1
          Type                EcucIntegerParamDef
          Default value       1
          ConfigurationClass  Pre-compile time   X   All Variants
          Link time           -
          Post-build time     -
          Scope /Dependency   scope: Local
        </description>
        <needscoverage>
          <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_PBSELECTABLE</srcid><srcstatus/><internalId>620</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_GEN_002_ERR_MAXTRCV_CONFIG</srcid><srcstatus/><internalId>623</internalId></linkedfrom></coveredby></needscov>
        <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>149</internalId></specobject>
     
     <specobject>
        <id>CanSM.EB.CanSMDistributedChannelProcessing</id>
        <status>approved</status>
        <source>EB</source>
        <version>2</version>
        <description>
           There shall be a pre-compile-time parameter which specifies if CanSM channels Distribution is enabled.
           Name                CanSMDistributedChannelProcessingSupport
           Description         This parameter enables CanSM channels Distribution.
           Type                Boolean
           Default value       false
           ConfigurationClass  Pre-compile time   X   All Variants
           Link time           -
           Post-build time     -
           Scope /Dependency   scope: Local
        </description>
        <needscoverage>
           <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanSM_EBParameters.xdm.m4_157</srcid><srcstatus/><internalId>589</internalId></linkedfrom></coveredby></needscov>
        <containerCovstatus>covered</containerCovstatus></needscoverage>
     <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>150</internalId></specobject>
     
     <specobject>
        <id>CanSM.EB.CanSMDistributedChannels_MainFunctions</id>
        <status>approved</status>
        <source>EB</source>
        <version>1</version>
        <description>
           If CanSMDistributedChannelProcessing is enabled,
           and the optional parameter ComMChannelPartitionRef is configured for the referenced ComMChannel via CanSMComMNetworkHandleRef,
           a CanSM_MainFunction_"SN"() shall be created (where "SN" is the shortName of the EcucPartition).
        </description>
        <needscoverage>
           <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate/include/CanSM_Partitions_MainFunction.h_25</srcid><srcstatus/><internalId>575</internalId></linkedfrom></coveredby></needscov>
        <containerCovstatus>covered</containerCovstatus></needscoverage>
     <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>151</internalId></specobject>

     <specobject>
        <id>CanSM.EB.CanSMDistributedChannels_MainFunctions_Processing</id>
        <status>approved</status>
        <source>EB</source>
        <version>1</version>
        <description>
           The main function related processing of each CAN network shall be assigned to the corresponding CanSM_MainFunction_"SN" based on its ComMChannelPartitionRef.
        </description>
        <needscoverage>
           <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_NOCO_FUCO_2CC_2NW_Distribution</srcid><srcstatus/><internalId>630</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_FUCO_2CC_2NW_Distribution_2EcucPartition</srcid><srcstatus/><internalId>631</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_NOCO_TXTIMEOUTEXCEPTION_NOPN_Distribution</srcid><srcstatus/><internalId>648</internalId></linkedfrom></coveredby></needscov>
           <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate/src/CanSM_Partitions_MainFunction.c_43</srcid><srcstatus/><internalId>580</internalId></linkedfrom></coveredby></needscov>
        <containerCovstatus>covered</containerCovstatus></needscoverage>
     <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>152</internalId></specobject>
     <specobject>
        <id>CanSM.EB.CanSMDistributedChannels_MainFunctions_Processing_Generic</id>
        <status>approved</status>
        <source>EB</source>
        <version>1</version>
        <description>
           CAN networks that do not have ComMChannelPartitionRef configured will be processed in the generic CanSM_MainFunction().
        </description>
        <needscoverage>
           <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_NOCO_FUCO_2CC_2NW_Distribution</srcid><srcstatus/><internalId>630</internalId></linkedfrom></coveredby></needscov>
           <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanSM_MainFunction.c_66</srcid><srcstatus/><internalId>587</internalId></linkedfrom></coveredby></needscov>
        <containerCovstatus>covered</containerCovstatus></needscoverage>
     <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>153</internalId></specobject>

     <specobject>
        <id>CanSM.EB.CanSMDistributedChannels_CanTrcvChannel_Mapping</id>
        <status>approved</status>
        <source>EB</source>
        <version>1</version>
        <description>
           If the Can Transceiver Channel (CanSMTransceiverId) is not mapped to the same EcucPartition as the ComMChannelPartition,
       a warning shall be thrown.
        </description>
        <needscoverage>
           <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanSM_Extension.xdm.m4_146</srcid><srcstatus/><internalId>594</internalId></linkedfrom></coveredby></needscov>
           <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_003_Warning_CAN_Trcv_Mapping</srcid><srcstatus/><internalId>625</internalId></linkedfrom></coveredby></needscov>
        <containerCovstatus>covered</containerCovstatus></needscoverage>
     <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>154</internalId></specobject>
     
     <specobject>
        <id>CanSM.EB.CanSMDistributedChannels_NoPartitionRef</id>
        <status>approved</status>
        <source>EB</source>
        <version>1</version>
        <description>
           If CanSMDistributedChannelProcessingSupport is ON and no ComMChannelPartitionRef is configured or parameter doesn't exist,
           a warning shall be thrown.
        </description>
        <needscoverage>
           <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanSM_EBParameters.xdm.m4_182</srcid><srcstatus/><internalId>590</internalId></linkedfrom></coveredby></needscov>
           <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_NoEcucPartition</srcid><srcstatus/><internalId>613</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_003_Warning_No_ComMChannelPartitionRef</srcid><srcstatus/><internalId>626</internalId></linkedfrom></coveredby></needscov>
        <containerCovstatus>covered</containerCovstatus></needscoverage>
     <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>155</internalId></specobject>

     <specobject>
        <id>CanSM.EB.CanSMDistributedChannels_Same_Partition_Referencing</id>
        <status>approved</status>
        <source>EB</source>
        <version>1</version>
        <description>
           if CanSMDistributedChannelProcessingSupport is ON and all ComMChannelPartitionRef are referencing the same partition,
           a warning shall be thrown.
        </description>
        <needscoverage>
           <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanSM_EBParameters.xdm.m4_185</srcid><srcstatus/><internalId>591</internalId></linkedfrom></coveredby></needscov>
           <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_003_Warning_Same_ComMChannelPartitionRef</srcid><srcstatus/><internalId>627</internalId></linkedfrom></coveredby></needscov>
        <containerCovstatus>covered</containerCovstatus></needscoverage>
     <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>156</internalId></specobject>

     <specobject>
        <id>CanSM.EB.CanSMDistributedChannels_No_CanControllerEcucPartitionRef</id>
        <status>approved</status>
        <source>EB</source>
        <version>1</version>
        <description>
           if CanControllerEcucPartitionRef doesn't exist, and more than one partition is referenced via ComMChannelPartitionRef,
           an error shall be thrown.
        </description>
        <needscoverage>
           <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanSM_Extension.xdm.m4_138</srcid><srcstatus/><internalId>593</internalId></linkedfrom></coveredby></needscov>
        <containerCovstatus>covered</containerCovstatus></needscoverage>
     <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>157</internalId></specobject>

     <specobject>
        <id>CanSM.EB.CanSMDistributedChannels_ComM_And_Controller_Mapping</id>
        <status>approved</status>
        <source>EB</source>
        <version>1</version>
        <description>
            All controllers from a CAN Network must be mapped to the same partition as the ComM channel,
            otherwise an error shall be thrown.
        </description>
        <needscoverage>
           <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanSM_Extension.xdm.m4_507</srcid><srcstatus/><internalId>595</internalId></linkedfrom></coveredby></needscov>
           <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_002_Err_CAN_Controller_Mapping</srcid><srcstatus/><internalId>624</internalId></linkedfrom></coveredby></needscov>
        <containerCovstatus>covered</containerCovstatus></needscoverage>
     <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>158</internalId></specobject>

    <specobject>
      <id>CanSM.ASR40.CANSM008.1</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The header file CanSM.h shall export all type definitions, function declarations
        and defines as specified in chapter 8 shall be exported with the exception of
        CanSM_RequestComMode and CanSM_GetCurrentComMode (refer to CanSM.ASR40.SWS_CanSM_00174.1).
      </description>
      <comment>
        This requirement clarifies which types and APIs shall be reported
        referring to the Autosar SWS.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_MERGE_COMPILE_OFF</srcid><srcstatus/><internalId>605</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_NOT_DEDICATED_EXPORTS</srcid><srcstatus/><internalId>615</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00008</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>292</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>159</internalId></specobject>

    <specobject>
      <id>CanSM.ASR40.CANSM174.1</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The header file file CanSM_ComM.h shall be provided which shall export
        the API used by module ComM (CanSM_RequestComMode and CanSM_GetCurrentComMode).
      </description>
      <comment>
        The rationale given for this requirement is that some APIs use type
        definitions of the ComM module. But these APIs are exported through
        CanSM_ComM.h.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_COMM_DEDICATED_EXPORTS</srcid><srcstatus/><internalId>609</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.SWS_CanSM_00174</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>20</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>160</internalId></specobject>

    <specobject>
      <id>CanSM.ASR40.CANSM011.1</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The header file CanSM_Cbk.h shall declare the following callback notification
        functions of the CanSM module:
        - CanSM_ControllerBusOff (refer to chapter 8.4.1 of the CanSM SWS)
        - CanSM_ControllerModeIndication (refer to chapter 8.4.2 of the CanSM SWS)
        - CanSM_TransceiverModeIndication (refer to chapter 8.4.3 of the CanSM SWS)
        - CanSM_ClearTrcvWufFlagIndication (refer to chapter 8.4.5 of the CanSM SWS)
        - CanSM_CheckTransceiverWakeFlagIndication (refer to chapter 8.4.6 of the CanSM SWS)
        - CanSM_ConfirmPnAvailability (refer to chapter 8.4.7 of the CanSM SWS)
      </description>
      <comment>
        The new formulation of the requirement exactly lists all callback notification
        functions which shall be declared in CanSM_Cbk.h.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_CBK_EXPORTS</srcid><srcstatus/><internalId>608</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_PNSUPPORT_ON</srcid><srcstatus/><internalId>618</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.SWS_CanSM_00011</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>8</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00064</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>297</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00396</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>321</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00399</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>324</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00413</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>330</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00416</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>333</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00419</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>336</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>161</internalId></specobject>

    <specobject>
      <id>CanSM.ASR40.SWS_CanSM_00014.1</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The CanSM module (CanSM.c) shall include the header file Dem.h
        only if diagnosic events are used (paramter CanSMBusOffReportToDem
        set to value "DEM").
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_HEADER_INCLUSION</srcid><srcstatus/><internalId>610</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.SWS_CanSM_00014</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>10</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>162</internalId></specobject>

    <specobject>
      <id>CanSM.ASR40.CANSM014.2</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The CanSM module (CanSM.c) must not include the header file Dem.h
        of no diagnosic events are used (paramter CanSMBusOffReportToDem
        set to value "DET" or "DISABLE").
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_40064</srcid><srcstatus/><internalId>607</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.SWS_CanSM_00014</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>10</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>163</internalId></specobject>

      <specobject>
         <id>CanSM.ASR40.SWS_CanSM_00016.1</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        MemMap.h inclusion at the beginning of a section shall be preceded by a
        &lt;MODULE&gt;_START_SEC_&lt;TYPE_PROPERTIES&gt; macro.
        MemMap.h inclusion at the end of a section shall be preceded by a
        &lt;MODULE&gt;_STOP_SEC_&lt;TYPE_PROPERTIES&gt; macro.
        &lt;MODULE&gt;_START_SEC_&lt;TYPE_PROPERTIES&gt; and
        &lt;MODULE&gt;_STOP_SEC_&lt;TYPE_PROPERTIES&gt; must be balanced.
      </description>
         <comment>
        This requirement defines the placement (inside the module source) of header
        file MamMap.h.
      </comment>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_CBK_EXPORTS</srcid><srcstatus/><internalId>608</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00016</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>12</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>164</internalId></specobject>

      <specobject>
         <id>CanSM.ASR40.CANSM016.2</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        Particular symbols (functions, global variables) shall be mapped to memory
        sections according to the respective symbol property, including:
        - constness
        - variable size
        - initializationcharacteristics
      </description>
         <comment>
        This requirement needs a manual code review.
      </comment>
         <needscoverage>
            <needscov><needsobj>man</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.man.MemMap</srcid><srcstatus/><internalId>535</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00016</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>12</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>165</internalId></specobject>

      <specobject>
         <id>CanSM.ASR40.SWS_CanSM_00548.1</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        The CanSM module (CanSM.c) shall include the interface
        CanNm_ConfirmPnAvailability (CanNm.h) of the CanNm
        module.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_HEADER_INCLUSION</srcid><srcstatus/><internalId>610</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00548</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>73</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>166</internalId></specobject>

    <specobject>
         <id>CanSM.ASR40.BSM.T_PRE_FULLCOM_FULLCOM</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_CC_STARTED of state machine CANSM_BSM_S_PRE_FULLCOM
        and trigger T_CC_STARTED_INDICATED applies (synchronous or asynchronous),
        CanSM shall execute effect E_FULL_COM
        and enter state S_BUS_OFF_CHECK of state machine CANSM_BSM_S_FULLCOM.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_NOCO_FUCO_SYNC_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>653</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_FUCO_ASYNC_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>654</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_TIMEOUT_SYNC_1_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>655</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_TIMEOUT_SYNC_2_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>656</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_FUCO_SYNC</srcid><srcstatus/><internalId>784</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_FUCO_ASYNC</srcid><srcstatus/><internalId>785</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_TIMEOUT_SYNC_1</srcid><srcstatus/><internalId>786</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_TIMEOUT_SYNC_2</srcid><srcstatus/><internalId>787</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00435</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>52</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR42.SWS_CANSM_00539</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>103</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00540</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>71</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00493</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>406</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>167</internalId></specobject>

      <specobject>
         <id>CanSM.ASR40.BSM.T_FULLCOM_PRE_NOCOM.NoPn</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_RESTART_CC of state machine CANSM_BSM_S_FULLCOM
        and trigger T_REPEAT_MAX and guardian condition CANSM_BSM_G_PN_NOT_SUPPORTED applies,
        CanSM shall execute effect E_PRE_NOCOM, call Det_ReportError with
        error ID CANSM_E_MODE_REQUEST_TIMEOUT, operate action DO_SET_CC_MODE_STOPPED
        and enter state S_CC_STOPPED
        of state machine CANSM_BSM_DeinitPnNotSupportedProceed.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_FUCO_SRNOCO_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>691</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_SRNOCO</srcid><srcstatus/><internalId>822</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00431</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>348</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00523</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>66</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00436</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>53</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00385</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>46</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00464</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>380</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.ErrorTable.CANSM_E_MODE_REQUEST_TIMEOUT</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>260</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>168</internalId></specobject>

      <specobject>
         <id>CanSM.ASR40.BSM.T_FULLCOM_PRE_NOCOM.Pn</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_RESTART_CC of state machine CANSM_BSM_S_FULLCOM
        and trigger T_REPEAT_MAX and guardian condition applies CANSM_BSM_G_PN_SUPPORTED,
        CanSM shall execute effect E_PRE_NOCOM, operate action DO_CLEAR_TRCV_WUF, call
        Det_ReportError with error ID CANSM_E_MODE_REQUEST_TIMEOUT and enter state S_PN_CLEAR_WUF
        of state machine CANSM_BSM_DeinitPnSupportedProceed.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_REPEAT_MAX_FULLCOM_PN_1</srcid><srcstatus/><internalId>762</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00431</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>348</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00523</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>66</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00437</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>54</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00385</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>46</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00438</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>355</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.ErrorTable.CANSM_E_MODE_REQUEST_TIMEOUT</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>260</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>169</internalId></specobject>

      <specobject>
         <id>CanSM.ASR40.BSM.T_FULLCOM_CHANGE_BAUDRATE</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_NO_BUS_OFF of state machine CANSM_BSM_S_FULLCOM
        and trigger T_CHANGE_BR_REQUEST applies, CanSM shall execute effect
        E_CHANGE_BR_BSWM_MODE, operate action DO_SET_CC_MODE_STOPPED
        and enter state S_CC_STOPPED of state machine CANSM_BSM_S_CHANGE_BAUDRATE_PROCEED.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_CHANGE_BR_REQUEST_SYNC_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>671</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_CHANGE_BR_REQUEST_SYNC</srcid><srcstatus/><internalId>802</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.ASR41.SWS_CanSM_00507</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>90</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00528</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>436</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00524</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>432</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>170</internalId></specobject>

      <specobject>
         <id>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_FULLCOM</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_CC_STARTED of state machine
        CANSM_BSM_S_CHANGE_BAUDRATE and trigger T_CC_STARTED_INDICATED
        (synchronous or asynchronous) and guardian
        condition G_NO_COM_MODE_NOT_REQUESTED and G_FULL_COM_MODE_REQUESTED applies,
        CanSM shall execute effect E_BR_END_FULL_COM and enter state S_BUS_OFF_CHECK
        of state machine CANSM_BSM_S_FULLCOM.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_CC_STARTED_INDICATED_CHANGE_BR_FUCO_SYNC_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>676</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_CC_STARTED_INDICATED_CHANGE_BR_FUCO_SYNC</srcid><srcstatus/><internalId>807</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00534</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>442</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00543</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>449</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00427</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>344</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00432</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>349</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00435</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>52</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR42.SWS_CANSM_00539</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>103</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00540</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>71</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00635</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>508</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>171</internalId></specobject>

      <specobject>
         <id>CanSM.ASR40.BSM.T_FULLCOM_SILENTCOM.1</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_NO_BUS_OFF of state machine
        CANSM_BSM_S_FULLCOM and trigger T_SILENT_COM_MODE_REQUEST (as defined in CANSM499)
        applies, CanSM shall execute effect E_FULL_TO_SILENT_COM and enter state
        CANSM_BSM_S_SILENTCOM of state machine CANSM_BSM.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_FUCO_SICO_1_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>681</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_SICO_1</srcid><srcstatus/><internalId>812</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00499</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>411</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00434</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>351</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00541</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>447</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00538</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>70</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00635</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>508</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>172</internalId></specobject>

      <specobject>
         <id>CanSM.ASR40.BSM.T_FULLCOM_SILENTCOM.2</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_NO_BUS_OFF of state machine
        CANSM_BSM_S_FULLCOM and trigger T_SILENT_COM_MODE_REQUEST  (as defined in CANSM554)
        applies, CanSM shall execute effect E_FULL_TO_SILENT_COM and enter state
        CANSM_BSM_S_SILENTCOM of state machine CANSM_BSM.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_FUCO_SICO_2_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>682</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_SICO_2</srcid><srcstatus/><internalId>813</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00554</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>75</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00434</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>351</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00541</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>447</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00538</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>70</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00635</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>508</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>173</internalId></specobject>

      <specobject>
         <id>CanSM.ASR40.BSM.T_SILENTCOM_FULLCOM</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        If the CanSM module is in state CANSM_BSM_S_SILENTCOM of state machine CANSM_BSM
        and trigger T_FULL_COM_MODE_REQUEST applies, CanSM shall execute effect
        E_SILENT_TO_FULL_COM and enter state S_BUS_OFF_CHECK of state machine
        CANSM_BSM_S_FULLCOM.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_SICO_FUCO_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>670</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_SICO_FUCO</srcid><srcstatus/><internalId>801</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00425</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>342</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00550</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>451</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00435</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>52</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR42.SWS_CANSM_00539</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>103</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00540</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>71</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00635</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>508</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>174</internalId></specobject>

      <specobject>
         <id>CanSM.ASR40.BSM.T_NOCOM_PRE_FULLCOM</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        If the CanSM module is in state CANSM_BSM_S_NOCOM of state machine CANSM_BSM
        and a transceiver is configured for a CAN network
        and trigger T_FULL_COM_MODE_REQUEST applies, CanSM shall operate action
        DO_SET_TRCV_MODE_NORMAL and enter state S_TRCV_NORMAL
        of state machine CANSM_BSM_S_PRE_FULLCOM.
      </description>
      <furtherinfo> 
        Justifying rule: WRN.swuts.needscoverage.count violation.
        A requirement can end up being satisified by numerous tests because
        the module can be subject to various scenarios 
      </furtherinfo>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_MODE_REQ_REP_PARTIAL</srcid><srcstatus/><internalId>628</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_FUCO_2CC_2NW_Distribution</srcid><srcstatus/><internalId>630</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_FUCO_2CC_2NW_Distribution_2EcucPartition</srcid><srcstatus/><internalId>631</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_FUCO_SYNC_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>653</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_FUCO_ASYNC_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>654</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_TIMEOUT_SYNC_1_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>655</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_TIMEOUT_SYNC_2_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>656</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_FUCO_2CC</srcid><srcstatus/><internalId>741</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_FUCO_SYNC</srcid><srcstatus/><internalId>784</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_FUCO_ASYNC</srcid><srcstatus/><internalId>785</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_TIMEOUT_SYNC_1</srcid><srcstatus/><internalId>786</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_TIMEOUT_SYNC_2</srcid><srcstatus/><internalId>787</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00425</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>342</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00483</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>396</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00635</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>508</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>175</internalId></specobject>

      <specobject>
         <id>CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.NoPn.1</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_TRCV_NORMAL of state machine CANSM_BSM_S_PRE_FULLCOM
        and trigger T_REPEAT_MAX and guardian condition CANSM_BSM_G_PN_NOT_SUPPORTED applies,
        CanSM shall call Det_ReportError with error ID CANSM_E_MODE_REQUEST_TIMEOUT,
        operate action DO_SET_CC_MODE_STOPPED and enter state S_CC_STOPPED of state machine
        CANSM_BSM_DeinitPnNotSupportedProceed.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_NOCO_FUCO_FAILED_1_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>657</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_FUCO_FAILED_1</srcid><srcstatus/><internalId>788</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00495</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>57</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00436</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>53</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00385</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>46</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00464</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>380</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.ErrorTable.CANSM_E_MODE_REQUEST_TIMEOUT</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>260</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>176</internalId></specobject>

      <specobject>
         <id>CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.Pn.1</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_TRCV_NORMAL of state machine CANSM_BSM_S_PRE_FULLCOM
        and trigger T_REPEAT_MAX and guardian condition CANSM_BSM_G_PN_SUPPORTED applies,
        CanSM shall operate action DO_CLEAR_TRCV_WUF, call Det_ReportError with error ID
        CANSM_E_MODE_REQUEST_TIMEOUT and enter state S_PN_CLEAR_WUF of state machine
        CANSM_BSM_DeinitPnSupportedProceed.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_REPEAT_MAX_PRE_FULLCOM_PN_1</srcid><srcstatus/><internalId>759</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00495</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>57</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00437</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>54</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00385</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>46</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00438</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>355</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.ErrorTable.CANSM_E_MODE_REQUEST_TIMEOUT</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>260</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>177</internalId></specobject>

      <specobject>
         <id>CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.NoPn.2</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_CC_STOPPED of state machine CANSM_BSM_S_PRE_FULLCOM
        and trigger T_REPEAT_MAX and guardian condition CANSM_BSM_G_PN_NOT_SUPPORTED applies,
        CanSM shall call Det_ReportError with error ID CANSM_E_MODE_REQUEST_TIMEOUT,
        operate action DO_SET_CC_MODE_STOPPED and enter state S_CC_STOPPED of state machine
        CANSM_BSM_DeinitPnNotSupportedProceed.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_NOCO_FUCO_2CC_2NW_Distribution</srcid><srcstatus/><internalId>630</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_FUCO_2CC_2NW_Distribution_2EcucPartition</srcid><srcstatus/><internalId>631</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_FUCO_FAILED_1_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>657</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_FUCO_FAILED_2_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>658</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_FUCO_2CC</srcid><srcstatus/><internalId>741</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_FUCO_FAILED_1</srcid><srcstatus/><internalId>788</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_FUCO_FAILED_2</srcid><srcstatus/><internalId>789</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00495</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>57</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00436</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>53</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00385</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>46</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00464</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>380</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.ErrorTable.CANSM_E_MODE_REQUEST_TIMEOUT</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>260</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>178</internalId></specobject>

      <specobject>
         <id>CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.Pn.2</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_CC_STOPPED of state machine CANSM_BSM_S_PRE_FULLCOM
        and trigger T_REPEAT_MAX and guardian condition CANSM_BSM_G_PN_SUPPORTED applies,
        CanSM shall operate action DO_CLEAR_TRCV_WUF, call Det_ReportError with error ID
        CANSM_E_MODE_REQUEST_TIMEOUT and enter state S_PN_CLEAR_WUF of state machine
        CANSM_BSM_DeinitPnSupportedProceed.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_REPEAT_MAX_PRE_FULLCOM_PN_2</srcid><srcstatus/><internalId>760</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00495</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>57</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00437</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>54</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00385</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>46</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00438</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>355</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.ErrorTable.CANSM_E_MODE_REQUEST_TIMEOUT</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>260</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>179</internalId></specobject>

      <specobject>
         <id>CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.NoPn.3</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_CC_STARTED of state machine CANSM_BSM_S_PRE_FULLCOM
        and trigger T_REPEAT_MAX and guardian condition CANSM_BSM_G_PN_NOT_SUPPORTED applies,
        CanSM shall call Det_ReportError with error ID CANSM_E_MODE_REQUEST_TIMEOUT,
        operate action DO_SET_CC_MODE_STOPPED and enter state S_CC_STOPPED of state machine
        CANSM_BSM_DeinitPnNotSupportedProceed.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_NOCO_FUCO_FAILED_3_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>659</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_FUCO_FAILED_3</srcid><srcstatus/><internalId>790</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00495</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>57</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00436</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>53</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00385</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>46</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00464</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>380</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.ErrorTable.CANSM_E_MODE_REQUEST_TIMEOUT</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>260</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>180</internalId></specobject>

      <specobject>
         <id>CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.Pn.3</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_CC_STARTED of state machine CANSM_BSM_S_PRE_FULLCOM
        and trigger T_REPEAT_MAX and guardian condition CANSM_BSM_G_PN_SUPPORTED applies,
        CanSM shall operate action DO_CLEAR_TRCV_WUF, call Det_ReportError with error
        ID CANSM_E_MODE_REQUEST_TIMEOUT and
        enter state S_PN_CLEAR_WUF of state machine CANSM_BSM_DeinitPnSupportedProceed.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_REPEAT_MAX_PRE_FULLCOM_PN_3</srcid><srcstatus/><internalId>761</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00495</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>57</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00437</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>54</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00385</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>46</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00438</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>355</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.ErrorTable.CANSM_E_MODE_REQUEST_TIMEOUT</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>260</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>181</internalId></specobject>

      <specobject>
         <id>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.NoPn.1</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_CC_STOPPED of state machine
        CANSM_BSM_S_CHANGE_BAUDRATE and trigger T_REPEAT_MAX and guardian condition
        CANSM_BSM_G_PN_NOT_SUPPORTED applies, CanSM shall execute effect E_PRE_NOCOM,
        call Det_ReportError with error ID CANSM_E_MODE_REQUEST_TIMEOUT,
        operate action DO_SET_CC_MODE_STOPPED and enter
        state S_CC_STOPPED of state machine CANSM_BSM_DeinitPnNotSupportedProceed.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_REPEAT_MAX_CHANGE_BR_S_CC_STOPPED_NOPN_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>679</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_REPEAT_MAX_CHANGE_BR_S_CC_STOPPED_NOPN</srcid><srcstatus/><internalId>810</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00536</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>68</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00436</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>53</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00385</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>46</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00431</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>348</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00464</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>380</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.ErrorTable.CANSM_E_MODE_REQUEST_TIMEOUT</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>260</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>182</internalId></specobject>

      <specobject>
         <id>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.Pn.1</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_CC_STOPPED of state machine
        CANSM_BSM_S_CHANGE_BAUDRATE and trigger T_REPEAT_MAX and guardian condition
        CANSM_BSM_G_PN_SUPPORTED applies, CanSM shall execute effect E_PRE_NOCOM,
        operate action DO_CLEAR_TRCV_WUF, call Det_ReportError with error
        ID CANSM_E_MODE_REQUEST_TIMEOUT and enter
        state S_PN_CLEAR_WUF of state machine CANSM_BSM_DeinitPnSupportedProceed.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_REPEAT_MAX_CHANGE_BR_S_CC_STOPPED_PN</srcid><srcstatus/><internalId>781</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00536</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>68</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00437</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>54</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00385</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>46</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00431</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>348</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00438</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>355</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.ErrorTable.CANSM_E_MODE_REQUEST_TIMEOUT</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>260</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>183</internalId></specobject>

      <specobject>
         <id>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.NoPn.2</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_CC_STARTED of state machine
        CANSM_BSM_S_CHANGE_BAUDRATE and trigger T_REPEAT_MAX and guardian condition
        CANSM_BSM_G_PN_NOT_SUPPORTED applies, CanSM shall execute effect E_PRE_NOCOM,
        call Det_ReportError with error ID CANSM_E_MODE_REQUEST_TIMEOUT, operate action
        DO_SET_CC_MODE_STOPPED and enter
        state S_CC_STOPPED of state machine CANSM_BSM_DeinitPnNotSupportedProceed.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_REPEAT_MAX_CHANGE_BR_S_CC_STARTED_NOPN_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>680</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_REPEAT_MAX_CHANGE_BR_S_CC_STARTED_NOPN</srcid><srcstatus/><internalId>811</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00536</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>68</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00436</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>53</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00385</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>46</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00431</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>348</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00464</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>380</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.ErrorTable.CANSM_E_MODE_REQUEST_TIMEOUT</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>260</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>184</internalId></specobject>

      <specobject>
         <id>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.Pn.2</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_CC_STARTED of state machine
        CANSM_BSM_S_CHANGE_BAUDRATE and trigger T_REPEAT_MAX and guardian condition
        CANSM_BSM_G_PN_SUPPORTED applies, CanSM shall execute effect E_PRE_NOCOM,
        operate action DO_CLEAR_TRCV_WUF, call Det_ReportError with error
        ID CANSM_E_MODE_REQUEST_TIMEOUT and enter state
        S_PN_CLEAR_WUF of state machine CANSM_BSM_DeinitPnSupportedProceed.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_REPEAT_MAX_CHANGE_BR_S_CC_STARTED_PN</srcid><srcstatus/><internalId>782</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00536</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>68</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00437</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>54</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00385</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>46</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00431</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>348</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00438</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>355</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.ErrorTable.CANSM_E_MODE_REQUEST_TIMEOUT</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>260</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>185</internalId></specobject>

      <specobject>
         <id>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.NoPn.3</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_CC_STARTED of state machine CANSM_BSM_S_CHANGE_BAUDRATE
        and trigger T_CC_STARTED_INDICATED (synchronous or asynchronous)
        and guardian condition G_NO_COM_MODE_REQUESTED
        and CANSM_BSM_G_PN_NOT_SUPPORTED applies, CanSM shall execute effect E_PRE_NOCOM,
        operate action DO_SET_CC_MODE_STOPPED and enter state
        S_CC_STOPPED of state machine CANSM_BSM_DeinitPnNotSupportedProceed.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_CC_STARTED_INDICATED_CHANGE_BR_NOCO_NOPN_ASYNC_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>678</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_CC_STARTED_INDICATED_CHANGE_BR_NOCO_NOPN_ASYNC</srcid><srcstatus/><internalId>809</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00436</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>53</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00534</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>442</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00431</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>348</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00542</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>448</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00464</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>380</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00635</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>508</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>186</internalId></specobject>

      <specobject>
         <id>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.Pn.3</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_CC_STARTED of state machine
        CANSM_BSM_S_CHANGE_BAUDRATE
        and trigger T_CC_STARTED_INDICATED (synchronous or asynchronous) and
        guardian conditions G_NO_COM_MODE_REQUESTED
        and CANSM_BSM_G_PN_SUPPORTED applies, CanSM shall execute effect E_PRE_NOCOM,
        operate action DO_CLEAR_TRCV_WUF and enter state
        S_PN_CLEAR_WUF of state machine CANSM_BSM_DeinitPnSupportedProceed.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_CC_STARTED_INDICATED_CHANGE_BR_NOCO_PN_ASYNC</srcid><srcstatus/><internalId>780</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00437</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>54</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00534</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>442</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00431</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>348</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00542</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>448</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00438</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>355</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00635</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>508</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>187</internalId></specobject>

      <specobject>
         <id>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_SILENTCOM</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_CC_STARTED of state machine
        CANSM_BSM_S_CHANGE_BAUDRATE and trigger T_CC_STARTED_INDICATED (synchronous or asynchronous)
        and guardian condition G_NO_COM_MODE_NOT_REQUESTED and G_SILENT_COM_MODE_REQUESTED applies,
        CanSM shall execute effect E_BR_END_SILENT_COM and enter state CANSM_BSM_S_SILENTCOM
        of state machine CANSM_BSM.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_CC_STARTED_INDICATED_CHANGE_BR_SICO_ASYNC_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>677</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_CC_STARTED_INDICATED_CHANGE_BR_SICO_ASYNC</srcid><srcstatus/><internalId>808</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00429</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>346</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00433</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>350</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00534</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>442</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00543</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>449</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00434</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>351</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00541</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>447</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00538</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>70</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00635</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>508</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>188</internalId></specobject>

      <specobject>
         <id>CanSM.ASR40.BSM.T_SILENTCOM_PRE_NOCOM.NoPn</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        If the CanSM module is in state CANSM_BSM_S_SILENTCOM of state machine
        CANSM_BSM and trigger T_NO_COM_MODE_REQUEST and guardian condition
        CANSM_BSM_G_PN_NOT_SUPPORTED applies, CanSM shall execute effect E_PRE_NOCOM,
        operate action DO_SET_CC_MODE_STOPPED
        and enter state CC_STOPPED of state machine CANSM_BSM_DeinitPnNotSupportedProceed.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_FUCO_NOCO_TXTIMEOUTEXCEPTION_NOPN</srcid><srcstatus/><internalId>636</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_NOCO_TXTIMEOUTEXCEPTION_NOPN_Distribution</srcid><srcstatus/><internalId>648</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_SICO_NOCO_SYNC_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>662</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_NOCO_SYNC_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>700</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_SICO_NOCO_SYNC</srcid><srcstatus/><internalId>793</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_NOCO_SYNC</srcid><srcstatus/><internalId>831</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00426</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>343</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00431</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>348</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00436</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>53</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00464</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>380</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00635</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>508</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>189</internalId></specobject>

      <specobject>
         <id>CanSM.ASR40.BSM.T_SILENTCOM_PRE_NOCOM.Pn</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        If the CanSM module is in state CANSM_BSM_S_SILENTCOM of state machine
        CANSM_BSM and trigger T_NO_COM_MODE_REQUEST and guardian condition
        CANSM_BSM_G_PN_SUPPORTED applies, CanSM shall execute effect E_PRE_NOCOM,
        operate action DO_CLEAR_TRCV_WUF and enter state S_PN_CLEAR_WUF of
        state machine CANSM_BSM_DeinitPnSupportedProceed.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_SICO_NOCO_ASYNC_PN</srcid><srcstatus/><internalId>747</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_NOCO_ASYNC_PN</srcid><srcstatus/><internalId>749</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_TIMEOUT_SYNC_PN_1</srcid><srcstatus/><internalId>750</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_TIMEOUT_SYNC_PN_2</srcid><srcstatus/><internalId>751</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_CHECK_TRCV_WFLAG_SYNC_PN</srcid><srcstatus/><internalId>752</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_ASYNC_DEINITPN_TIMEOUTS</srcid><srcstatus/><internalId>753</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_NOCO_TXTIMEOUTEXCEPTION_PN</srcid><srcstatus/><internalId>767</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00426</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>343</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00431</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>348</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00437</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>54</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00438</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>355</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00635</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>508</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>190</internalId></specobject>

      <specobject>
         <id>CanSM.ASR40.BSM.T_PRE_NOCOM_NOCOM.NoPn.1</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_TRCV_STANDBY of state machine
        CANSM_BSM_DeinitPnNotSupportedProceed and its NOT the initial transition
        (transition did NOT start in CANSM_BSM_S_NOT_INITIALIZED)
        and trigger T_TRCV_STANDBY_INDICATED
        (synchronous or asynchronous) applies, CanSM shall execute effect E_NO_COM
        and enter state CANSM_BSM_S_NOCOM of state machine CANSM_BSM.
      </description>
      <furtherinfo> 
        Justifying rule: WRN.swuts.needscoverage.count violation.
        A requirement can end up being satisified by numerous tests because
        the module can be subject to various scenarios 
      </furtherinfo>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_FUCO_NOCO_TXTIMEOUTEXCEPTION_NOPN</srcid><srcstatus/><internalId>636</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_NOCO_TXTIMEOUTEXCEPTION_NOPN_Distribution</srcid><srcstatus/><internalId>648</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_SICO_NOCO_SYNC_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>662</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_SICO_NOCO_ASYNC_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>663</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_TIMEOUT_SYNC_1_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>664</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_TIMEOUT_SYNC_2_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>665</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_NOCO_SYNC_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>700</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_S_RNOCO_SYNC_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>701</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_SICO_NOCO_SYNC</srcid><srcstatus/><internalId>793</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_SICO_NOCO_ASYNC</srcid><srcstatus/><internalId>794</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_TIMEOUT_SYNC_1</srcid><srcstatus/><internalId>795</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_TIMEOUT_SYNC_2</srcid><srcstatus/><internalId>796</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_NOCO_SYNC</srcid><srcstatus/><internalId>831</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_S_RNOCO_SYNC</srcid><srcstatus/><internalId>832</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00430</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>51</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00478</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>394</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>191</internalId></specobject>

      <specobject>
         <id>CanSM.ASR40.BSM.T_PRE_NOCOM_NOCOM.NoPn.2</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_TRCV_STANDBY of state machine
        CANSM_BSM_DeinitPnNotSupportedProceed and its the initial transition
        (transition started in CANSM_BSM_S_NOT_INITIALIZED)
        and trigger T_TRCV_STANDBY_INDICATED
        (synchronous or asynchronous) applies, CanSM must not execute effect E_NO_COM
        and shall enter state CANSM_BSM_S_NOCOM of state machine CANSM_BSM.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <needscoverage>
            <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CANSM.InitialTransition</srcid><srcstatus/><internalId>549</internalId></linkedfrom></coveredby></needscov>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_NOIN_NOCO_SYNC_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>652</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOIN_NOCO_ASYNC</srcid><srcstatus/><internalId>740</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOIN_NOCO_SYNC</srcid><srcstatus/><internalId>783</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00430</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>51</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00478</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>394</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>192</internalId></specobject>

      <specobject>
         <id>CanSM.ASR40.BSM.T_PRE_NOCOM_NOCOM.Pn.1</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_CHECK_WFLAG_IN_CC_SLEEP of state machine
        CANSM_BSM_DeinitPnSupportedProceed and its NOT the initial transition
        (transition did NOT start in CANSM_BSM_S_NOT_INITIALIZED)
        and trigger T_CHECK_WFLAG_INDICATED
        (synchronous or asynchronous) applies, CanSM shall execute effect E_NO_COM
        and enter state CANSM_BSM_S_NOCOM of state machine CANSM_BSM.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_SICO_NOCO_ASYNC_PN</srcid><srcstatus/><internalId>747</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_NOCO_ASYNC_PN</srcid><srcstatus/><internalId>749</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_TIMEOUT_SYNC_PN_2</srcid><srcstatus/><internalId>751</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_NOCO_TXTIMEOUTEXCEPTION_PN</srcid><srcstatus/><internalId>767</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00430</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>51</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00460</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>377</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>193</internalId></specobject>

      <specobject>
         <id>CanSM.ASR40.BSM.T_PRE_NOCOM_NOCOM.Pn.2</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_CHECK_WFLAG_IN_CC_SLEEP of state machine
        CANSM_BSM_DeinitPnSupportedProceed and its the initial transition
        (transition started in CANSM_BSM_S_NOT_INITIALIZED)
        and trigger T_CHECK_WFLAG_INDICATED (synchronous or asynchronous) applies,
        CanSM must not execute effect E_NO_COM
        and shall enter state CANSM_BSM_S_NOCOM of state machine CANSM_BSM.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_NOIN_NOCO_SYNC_PN</srcid><srcstatus/><internalId>746</internalId></linkedfrom></coveredby></needscov>
            <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CANSM.InitialTransition</srcid><srcstatus/><internalId>549</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00430</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>51</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00460</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>377</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>194</internalId></specobject>

      <specobject>
         <id>CanSM.ASR40.BSM.T_NOT_INITIALIZED_PRE_NOCOM.NoPn</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        If the CanSM module is in state CANSM_BSM_S_NOT_INITIALIZED of state machine
        CANSM_BSM and trigger CanSM_Init and guardian condition CANSM_BSM_G_PN_NOT_SUPPORTED
        applies, CanSM shall execute effect E_PRE_NO_COM, operate action DO_SET_CC_MODE_STOPPED
        and enter state S_CC_STOPPED of state machine CANSM_BSM_DeinitPnNotSupportedProceed.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_S_RNOCOM_SYNC_NOPN</srcid><srcstatus/><internalId>632</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOIN_NOCO_SYNC_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>652</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_SICO_NOCO_ASYNC_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>663</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_TIMEOUT_SYNC_1_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>664</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_TIMEOUT_SYNC_2_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>665</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOIN_NOCO_ASYNC</srcid><srcstatus/><internalId>740</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOIN_NOCO_SYNC</srcid><srcstatus/><internalId>783</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_SICO_NOCO_ASYNC</srcid><srcstatus/><internalId>794</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_TIMEOUT_SYNC_1</srcid><srcstatus/><internalId>795</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_TIMEOUT_SYNC_2</srcid><srcstatus/><internalId>796</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00423</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>340</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00431</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>348</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00436</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>53</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00464</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>380</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>195</internalId></specobject>

      <specobject>
         <id>CanSM.ASR40.BSM.T_NOT_INITIALIZED_PRE_NOCOM.Pn</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        If the CanSM module is in state CANSM_BSM_S_NOT_INITIALIZED of state machine
        CANSM_BSM and trigger CanSM_Init and guardian condition CANSM_BSM_G_PN_SUPPORTED
        applies, CanSM shall execute effect E_PRE_NO_COM, operate action DO_CLEAR_TRCV_WUF
        and enter state S_PN_CLEAR_WUF of state machine CANSM_BSM_DeinitPnSupportedProceed.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_NOIN_NOCO_SYNC_PN</srcid><srcstatus/><internalId>746</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00423</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>340</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00431</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>348</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00437</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>54</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00438</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>355</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>196</internalId></specobject>

    <specobject>
         <id>CanSM.ASR40.BSMDeInitPn.T_S_PN_CLEAR_WUF_S_PN_CC_STOPPED</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_PN_CLEAR_WUF of state machine
        CANSM_BSM_DeinitPnSupportedProceed and trigger T_CLEAR_WUF_INDICATED
        (synchronous or asynchronous) applies, CanSM shall operate action
        DO_SET_CC_MODE_STOPPED and enter state S_PN_CC_STOPPED
        of state machine CANSM_BSM_DeinitPnSupportedProceed.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_S_RNOCOM_SYNC_NOPN</srcid><srcstatus/><internalId>632</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOIN_NOCO_SYNC_PN</srcid><srcstatus/><internalId>746</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_SICO_NOCO_ASYNC_PN</srcid><srcstatus/><internalId>747</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_NOCO_ASYNC_PN</srcid><srcstatus/><internalId>749</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_TIMEOUT_SYNC_PN_1</srcid><srcstatus/><internalId>750</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_TIMEOUT_SYNC_PN_2</srcid><srcstatus/><internalId>751</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_CHECK_TRCV_WFLAG_SYNC_PN</srcid><srcstatus/><internalId>752</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_ASYNC_DEINITPN_TIMEOUTS</srcid><srcstatus/><internalId>753</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_S_RNOCOM_SYNC_PN</srcid><srcstatus/><internalId>763</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_NOCO_TXTIMEOUTEXCEPTION_PN</srcid><srcstatus/><internalId>767</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00440</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>357</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00441</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>358</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>197</internalId></specobject>

    <specobject>
         <id>CanSM.ASR40.BSMDeInitPn.T_S_PN_CLEAR_WUF_S_PN_CLEAR_WUF.1</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_PN_CLEAR_WUF of state machine
        CANSM_BSM_DeinitPnSupportedProceed and trigger T_CLEAR_WUF_TIMEOUT applies,
        CanSM shall operate action DO_CLEAR_TRCV_WUF and enter state S_PN_CLEAR_WUF
        of state machine CANSM_BSM_DeinitPnSupportedProceed.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_NOCO_TIMEOUT_SYNC_PN_1</srcid><srcstatus/><internalId>750</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_ASYNC_DEINITPN_TIMEOUTS</srcid><srcstatus/><internalId>753</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00443</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>360</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00438</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>355</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00439</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>356</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>198</internalId></specobject>

      <!-- restart DeInit process -->
    <specobject>
         <id>CanSM.ASR40.BSMDeInitPn.T_S_PN_CLEAR_WUF_S_PN_CLEAR_WUF.2</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_PN_CLEAR_WUF of state machine
        CANSM_BSM_DeinitPnSupportedProceed and trigger T_REPEAT_MAX applies,
        CanSM shall operate action DO_CLEAR_TRCV_WUF, call Det_ReportError with
        error ID CANSM_E_MODE_REQUEST_TIMEOUT and enter state S_PN_CLEAR_WUF
        of state machine CANSM_BSM_DeinitPnSupportedProceed.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_ASYNC_DEINITPN_TIMEOUTS</srcid><srcstatus/><internalId>753</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00438</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>355</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00463</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>55</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.ErrorTable.CANSM_E_MODE_REQUEST_TIMEOUT</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>260</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>199</internalId></specobject>

      <!-- Stop controller -->
    <specobject>
         <id>CanSM.ASR40.BSMDeInitPn.T_S_PN_CC_STOPPED_S_TRCV_NORMAL</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_PN_CC_STOPPED of state machine
        CANSM_BSM_DeinitPnSupportedProceed and trigger T_CC_STOPPED_INDICATED
        (synchronous or asynchronous) applies, CanSM shall operate action
        DO_SET_TRCV_MODE_NORMAL and enter state S_TRCV_NORMAL
        of state machine CANSM_BSM_DeinitPnSupportedProceed.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_S_RNOCOM_SYNC_NOPN</srcid><srcstatus/><internalId>632</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOIN_NOCO_SYNC_PN</srcid><srcstatus/><internalId>746</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_SICO_NOCO_ASYNC_PN</srcid><srcstatus/><internalId>747</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_NOCO_ASYNC_PN</srcid><srcstatus/><internalId>749</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_TIMEOUT_SYNC_PN_1</srcid><srcstatus/><internalId>750</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_TIMEOUT_SYNC_PN_2</srcid><srcstatus/><internalId>751</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_CHECK_TRCV_WFLAG_SYNC_PN</srcid><srcstatus/><internalId>752</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_ASYNC_DEINITPN_TIMEOUTS</srcid><srcstatus/><internalId>753</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_S_RNOCOM_SYNC_PN</srcid><srcstatus/><internalId>763</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_NOCO_TXTIMEOUTEXCEPTION_PN</srcid><srcstatus/><internalId>767</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00444</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>361</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00446</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>363</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>200</internalId></specobject>

      <!-- self transition -->
    <specobject>
         <id>CanSM.ASR40.BSMDeInitPn.T_S_PN_CC_STOPPED_S_PN_CC_STOPPED</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_PN_CC_STOPPED of state machine
        CANSM_BSM_DeinitPnSupportedProceed and trigger T_CC_STOPPED_TIMEOUT applies,
        CanSM shall operate action DO_SET_CC_MODE_STOPPED and enter state S_PN_CC_STOPPED
        of state machine CANSM_BSM_DeinitPnSupportedProceed.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_NOCO_TIMEOUT_SYNC_PN_1</srcid><srcstatus/><internalId>750</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_ASYNC_DEINITPN_TIMEOUTS</srcid><srcstatus/><internalId>753</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_REPEAT_MAX_DEINIT_PN_1</srcid><srcstatus/><internalId>754</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00445</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>362</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00441</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>358</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00442</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>359</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>201</internalId></specobject>

      <!-- restart DeInit process -->
    <specobject>
         <id>CanSM.ASR40.BSMDeInitPn.T_S_PN_CC_STOPPED_S_PN_CLEAR_WUF</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_PN_CC_STOPPED of state machine
        CANSM_BSM_DeinitPnSupportedProceed and trigger T_REPEAT_MAX applies,
        CanSM shall operate action DO_CLEAR_TRCV_WUF, call Det_ReportError with
        error ID CANSM_E_MODE_REQUEST_TIMEOUT and enter state S_PN_CLEAR_WUF
        of state machine CANSM_BSM_DeinitPnSupportedProceed.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_REPEAT_MAX_DEINIT_PN_1</srcid><srcstatus/><internalId>754</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00438</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>355</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00463</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>55</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.ErrorTable.CANSM_E_MODE_REQUEST_TIMEOUT</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>260</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>202</internalId></specobject>

      <!-- Transceiver normal -->
    <specobject>
         <id>CanSM.ASR40.BSMDeInitPn.T_S_TRCV_NORMAL_S_TRCV_STANDBY</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_TRCV_NORMAL of state machine
        CANSM_BSM_DeinitPnSupportedProceed and trigger T_TRCV_NORMAL_INDICATED
        (synchronous or asynchronous) applies,
        CanSM shall operate action DO_SET_TRCV_STANDBY and enter state S_TRCV_STANDBY
        of state machine CANSM_BSM_DeinitPnSupportedProceed.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_S_RNOCOM_SYNC_NOPN</srcid><srcstatus/><internalId>632</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOIN_NOCO_SYNC_PN</srcid><srcstatus/><internalId>746</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_SICO_NOCO_ASYNC_PN</srcid><srcstatus/><internalId>747</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_NOCO_ASYNC_PN</srcid><srcstatus/><internalId>749</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_TIMEOUT_SYNC_PN_1</srcid><srcstatus/><internalId>750</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_TIMEOUT_SYNC_PN_2</srcid><srcstatus/><internalId>751</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_CHECK_TRCV_WFLAG_SYNC_PN</srcid><srcstatus/><internalId>752</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_ASYNC_DEINITPN_TIMEOUTS</srcid><srcstatus/><internalId>753</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_S_RNOCOM_SYNC_PN</srcid><srcstatus/><internalId>763</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_NOCO_TXTIMEOUTEXCEPTION_PN</srcid><srcstatus/><internalId>767</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00448</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>365</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00450</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>367</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>203</internalId></specobject>

      <!-- self transition -->
    <specobject>
         <id>CanSM.ASR40.BSMDeInitPn.T_S_TRCV_NORMAL_S_TRCV_NORMAL</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_TRCV_NORMAL of state machine
        CANSM_BSM_DeinitPnSupportedProceed and trigger T_TRCV_NORMAL_TIMEOUT applies,
        CanSM shall operate action DO_SET_TRCV_MODE_NORMAL and enter state S_TRCV_NORMAL
        of state machine CANSM_BSM_DeinitPnSupportedProceed.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_NOCO_TIMEOUT_SYNC_PN_1</srcid><srcstatus/><internalId>750</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_ASYNC_DEINITPN_TIMEOUTS</srcid><srcstatus/><internalId>753</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_REPEAT_MAX_DEINIT_PN_2</srcid><srcstatus/><internalId>755</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00446</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>363</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00449</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>366</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00447</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>364</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>204</internalId></specobject>

      <!-- restart DeInit process -->
    <specobject>
         <id>CanSM.ASR40.BSMDeInitPn.T_S_TRCV_NORMAL_S_PN_CLEAR_WUF</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_TRCV_NORMAL of state machine
        CANSM_BSM_DeinitPnSupportedProceed and trigger T_REPEAT_MAX applies,
        CanSM shall operate action DO_CLEAR_TRCV_WUF, call Det_ReportError with
        error ID CANSM_E_MODE_REQUEST_TIMEOUT and enter state S_PN_CLEAR_WUF
        of state machine CANSM_BSM_DeinitPnSupportedProceed.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_REPEAT_MAX_DEINIT_PN_2</srcid><srcstatus/><internalId>755</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00438</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>355</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00463</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>55</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.ErrorTable.CANSM_E_MODE_REQUEST_TIMEOUT</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>260</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>205</internalId></specobject>

      <!-- Transceiver standby -->
    <specobject>
         <id>CanSM.ASR40.BSMDeInitPn.T_S_TRCV_STANDBY_S_CC_SLEEP</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_TRCV_STANDBY of state machine
        CANSM_BSM_DeinitPnSupportedProceed and trigger T_TRCV_STANDBY_INDICATED
        (synchronous or asynchronous) applies,
        CanSM shall operate action DO_SET_CC_MODE_SLEEP and enter state S_CC_SLEEP
        of state machine CANSM_BSM_DeinitPnSupportedProceed.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_S_RNOCOM_SYNC_NOPN</srcid><srcstatus/><internalId>632</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOIN_NOCO_SYNC_PN</srcid><srcstatus/><internalId>746</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_SICO_NOCO_ASYNC_PN</srcid><srcstatus/><internalId>747</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_NOCO_ASYNC_PN</srcid><srcstatus/><internalId>749</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_TIMEOUT_SYNC_PN_1</srcid><srcstatus/><internalId>750</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_TIMEOUT_SYNC_PN_2</srcid><srcstatus/><internalId>751</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_CHECK_TRCV_WFLAG_SYNC_PN</srcid><srcstatus/><internalId>752</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_ASYNC_DEINITPN_TIMEOUTS</srcid><srcstatus/><internalId>753</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_S_RNOCOM_SYNC_PN</srcid><srcstatus/><internalId>763</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_NOCO_TXTIMEOUTEXCEPTION_PN</srcid><srcstatus/><internalId>767</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00453</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>370</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00452</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>369</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>206</internalId></specobject>

      <!-- self transition -->
    <specobject>
         <id>CanSM.ASR40.BSMDeInitPn.T_S_TRCV_STANDBY_S_TRCV_STANDBY</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_TRCV_STANDBY of state machine
        CANSM_BSM_DeinitPnSupportedProceed and trigger T_TRCV_STANDBY_TIMEOUT applies,
        CanSM shall operate action DO_SET_TRCV_STANDBY and enter state S_TRCV_STANDBY
        of state machine CANSM_BSM_DeinitPnSupportedProceed.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_NOCO_TIMEOUT_SYNC_PN_2</srcid><srcstatus/><internalId>751</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_ASYNC_DEINITPN_TIMEOUTS</srcid><srcstatus/><internalId>753</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_REPEAT_MAX_DEINIT_PN_3</srcid><srcstatus/><internalId>756</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00450</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>367</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00451</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>368</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00454</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>371</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>207</internalId></specobject>

      <!-- restart DeInit process -->
    <specobject>
         <id>CanSM.ASR40.BSMDeInitPn.T_S_TRCV_STANDBY_S_PN_CLEAR_WUF</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_TRCV_STANDBY of state machine
        CANSM_BSM_DeinitPnSupportedProceed and trigger T_REPEAT_MAX applies,
        CanSM shall operate action DO_CLEAR_TRCV_WUF, call Det_ReportError with
        error ID CANSM_E_MODE_REQUEST_TIMEOUT and enter state S_PN_CLEAR_WUF
        of state machine CANSM_BSM_DeinitPnSupportedProceed.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_REPEAT_MAX_DEINIT_PN_3</srcid><srcstatus/><internalId>756</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00438</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>355</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00463</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>55</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.ErrorTable.CANSM_E_MODE_REQUEST_TIMEOUT</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>260</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>208</internalId></specobject>

      <!-- Controller sleep -->
    <specobject>
         <id>CanSM.ASR40.BSMDeInitPn.T_S_CC_SLEEP_S_CHECK_WFLAG_IN_CC_SLEEP</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_CC_SLEEP of state machine
        CANSM_BSM_DeinitPnSupportedProceed and trigger T_CC_SLEEP_INDICATED
        (synchronous or asynchronous) applies,
        CanSM shall operate action DO_CHECK_WFLAG and enter state S_CHECK_WFLAG_IN_CC_SLEEP
        of state machine CANSM_BSM_DeinitPnSupportedProceed.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_NOIN_NOCO_SYNC_PN</srcid><srcstatus/><internalId>746</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_SICO_NOCO_ASYNC_PN</srcid><srcstatus/><internalId>747</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_NOCO_ASYNC_PN</srcid><srcstatus/><internalId>749</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_TIMEOUT_SYNC_PN_2</srcid><srcstatus/><internalId>751</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_S_RNOCOM_SYNC_PN</srcid><srcstatus/><internalId>763</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_NOCO_TXTIMEOUTEXCEPTION_PN</srcid><srcstatus/><internalId>767</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00458</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>375</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00456</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>373</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>209</internalId></specobject>

      <specobject>
         <id>CanSM.ASR40.BSMDeInitPn.T_S_CC_SLEEP_S_CHECK_WFLAG_IN_NOT_CC_SLEEP</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_CC_SLEEP of state machine
        CANSM_BSM_DeinitPnSupportedProceed and trigger CANSM_BSM_T_CC_SLEEP_TIMEOUT applies,
        CanSM shall operate action DO_CHECK_WFLAG and enter state S_CHECK_WFLAG_IN_NOT_CC_SLEEP
        of state machine CANSM_BSM_DeinitPnSupportedProceed.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_NOCO_TIMEOUT_SYNC_PN_1</srcid><srcstatus/><internalId>750</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_CHECK_TRCV_WFLAG_SYNC_PN</srcid><srcstatus/><internalId>752</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_ASYNC_DEINITPN_TIMEOUTS</srcid><srcstatus/><internalId>753</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00462</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>379</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00457</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>374</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00455</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>372</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>210</internalId></specobject>

      <!-- Check wakeup flags (in sleep) -->
      <!-- self transition -->
    <specobject>
         <id>CanSM.ASR40.BSMDeInitPn.T_S_CHECK_WFLAG_IN_CC_SLEEP_S_CHECK_WFLAG_IN_CC_SLEEP</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_CHECK_WFLAG_IN_CC_SLEEP of state machine
        CANSM_BSM_DeinitPnSupportedProceed and trigger T_CHECK_WFLAG_TIMEOUT applies,
        CanSM shall operate action DO_CHECK_WFLAG and enter state S_CHECK_WFLAG_IN_CC_SLEEP
        of state machine CANSM_BSM_DeinitPnSupportedProceed.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_SICO_NOCO_ASYNC_PN</srcid><srcstatus/><internalId>747</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_TIMEOUT_SYNC_PN_2</srcid><srcstatus/><internalId>751</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_REPEAT_MAX_DEINIT_PN_4</srcid><srcstatus/><internalId>757</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00458</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>375</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00459</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>376</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00461</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>378</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>211</internalId></specobject>

      <!-- restart DeInit process -->
    <specobject>
         <id>CanSM.ASR40.BSMDeInitPn.T_S_CHECK_WFLAG_IN_CC_SLEEP_S_PN_CLEAR_WUF</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_CHECK_WFLAG_IN_CC_SLEEP of state machine
        CANSM_BSM_DeinitPnSupportedProceed and trigger T_REPEAT_MAX applies,
        CanSM shall operate action DO_CLEAR_TRCV_WUF, call Det_ReportError with
        error ID CANSM_E_MODE_REQUEST_TIMEOUT and enter state S_PN_CLEAR_WUF
        of state machine CANSM_BSM_DeinitPnSupportedProceed.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_REPEAT_MAX_DEINIT_PN_4</srcid><srcstatus/><internalId>757</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00438</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>355</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00463</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>55</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.ErrorTable.CANSM_E_MODE_REQUEST_TIMEOUT</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>260</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>212</internalId></specobject>

      <!-- Check wakeup flags (not in sleep) -->
    <specobject>
         <id>CanSM.ASR40.BSMDeInitPn.T_S_CHECK_WFLAG_IN_NOT_CC_SLEEP_S_PN_CLEAR_WUF.1</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_CHECK_WFLAG_IN_NOT_CC_SLEEP of state machine
        CANSM_BSM_DeinitPnSupportedProceed and trigger T_CHECK_WFLAG_INDICATED
        (synchronous or asynchronous) applies,
        CanSM shall operate action DO_CLEAR_TRCV_WUF and enter state S_PN_CLEAR_WUF
        of state machine CANSM_BSM_DeinitPnSupportedProceed.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
        Rational:
        If the CAN controller does not indicate a transition in mode SLEEP it shall
        be assumed that the CAN controller detected a wakeup event and therefore
        is still in state STOPPED.
        It is mandatory to restart the DeInit process to bring the CAN controller in
        state SLEEP (by repeating the DeInit process).
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_NOCO_TIMEOUT_SYNC_PN_1</srcid><srcstatus/><internalId>750</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_CHECK_TRCV_WFLAG_SYNC_PN</srcid><srcstatus/><internalId>752</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_ASYNC_DEINITPN_TIMEOUTS</srcid><srcstatus/><internalId>753</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00460</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>377</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00438</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>355</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>213</internalId></specobject>

      <!-- self transition -->
    <specobject>
         <id>CanSM.ASR40.BSMDeInitPn.T_S_CHECK_WFLAG_IN_NOT_CC_SLEEP_S_CHECK_WFLAG_IN_NOT_CC_SLEEP</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_CHECK_WFLAG_IN_NOT_CC_SLEEP of state machine
        CANSM_BSM_DeinitPnSupportedProceed and trigger T_CHECK_WFLAG_TIMEOUT applies,
        CanSM shall operate action DO_CHECK_WFLAG and enter state S_CHECK_WFLAG_IN_NOT_CC_SLEEP
        of state machine CANSM_BSM_DeinitPnSupportedProceed.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_NOCO_TIMEOUT_SYNC_PN_1</srcid><srcstatus/><internalId>750</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_ASYNC_DEINITPN_TIMEOUTS</srcid><srcstatus/><internalId>753</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_REPEAT_MAX_DEINIT_PN_5</srcid><srcstatus/><internalId>758</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00462</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>379</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00461</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>378</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00459</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>376</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>214</internalId></specobject>

      <!-- restart DeInit process -->
    <specobject>
         <id>CanSM.ASR40.BSMDeInitPn.T_S_CHECK_WFLAG_IN_NOT_CC_SLEEP_S_PN_CLEAR_WUF.2</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_CHECK_WFLAG_IN_NOT_CC_SLEEP of state machine
        CANSM_BSM_DeinitPnSupportedProceed and trigger T_REPEAT_MAX applies,
        CanSM shall operate action DO_CLEAR_TRCV_WUF, call Det_ReportError with
        error ID CANSM_E_MODE_REQUEST_TIMEOUT and enter state S_PN_CLEAR_WUF
        of state machine CANSM_BSM_DeinitPnSupportedProceed.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_REPEAT_MAX_DEINIT_PN_5</srcid><srcstatus/><internalId>758</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00438</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>355</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00463</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>55</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.ErrorTable.CANSM_E_MODE_REQUEST_TIMEOUT</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>260</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>215</internalId></specobject>

    <!-- Controller stopped -->
    <specobject>
         <id>CanSM.ASR40.BSMDeInitNoPn.T_S_CC_STOPPED_S_CC_SLEEP</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_CC_STOPPED of state machine
        CANSM_BSM_DeinitPnNotSupportedProceed and trigger T_CC_STOPPED_INDICATED
        (synchronous or asynchronous) applies,
        CanSM shall operate action DO_SET_CC_MODE_SLEEP and enter state S_CC_SLEEP
        of state machine CANSM_BSM_DeinitPnNotSupportedProceed.
      </description>
      <furtherinfo> 
        Justifying rule: WRN.swuts.needscoverage.count violation.
        A requirement can end up being satisified by numerous tests because
        the module can be subject to various scenarios 
      </furtherinfo>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_FUCO_NOCO_TXTIMEOUTEXCEPTION_NOPN</srcid><srcstatus/><internalId>636</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_NOCO_TXTIMEOUTEXCEPTION_NOPN_Distribution</srcid><srcstatus/><internalId>648</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOIN_NOCO_SYNC_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>652</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_SICO_NOCO_SYNC_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>662</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_SICO_NOCO_ASYNC_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>663</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_TIMEOUT_SYNC_1_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>664</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_TIMEOUT_SYNC_2_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>665</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_NOCO_SYNC_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>700</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_S_RNOCO_SYNC_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>701</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOIN_NOCO_ASYNC</srcid><srcstatus/><internalId>740</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOIN_NOCO_SYNC</srcid><srcstatus/><internalId>783</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_SICO_NOCO_SYNC</srcid><srcstatus/><internalId>793</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_SICO_NOCO_ASYNC</srcid><srcstatus/><internalId>794</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_TIMEOUT_SYNC_1</srcid><srcstatus/><internalId>795</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_TIMEOUT_SYNC_2</srcid><srcstatus/><internalId>796</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_NOCO_SYNC</srcid><srcstatus/><internalId>831</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_S_RNOCO_SYNC</srcid><srcstatus/><internalId>832</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00468</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>384</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00466</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>382</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>216</internalId></specobject>

      <!-- self transition -->
    <specobject>
         <id>CanSM.ASR40.BSMDeInitNoPn.T_S_CC_STOPPED_S_CC_STOPPED.1</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_CC_STOPPED of state machine
        CANSM_BSM_DeinitPnNotSupportedProceed and trigger T_CC_STOPPED_TIMEOUT applies,
        CanSM shall operate action DO_SET_CC_MODE_STOPPED and enter state S_CC_STOPPED
        of state machine CANSM_BSM_DeinitPnNotSupportedProceed.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_SICO_NOCO_ASYNC_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>663</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_TIMEOUT_SYNC_1_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>664</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_REPEAT_MAX_DEINIT_NOPN_1_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>666</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_SICO_NOCO_ASYNC</srcid><srcstatus/><internalId>794</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_TIMEOUT_SYNC_1</srcid><srcstatus/><internalId>795</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_REPEAT_MAX_DEINIT_NOPN_1</srcid><srcstatus/><internalId>797</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00466</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>382</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00465</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>381</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00464</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>380</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00467</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>383</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>217</internalId></specobject>

      <!-- restart DeInit process -->
    <specobject>
         <id>CanSM.ASR40.BSMDeInitNoPn.T_S_CC_STOPPED_S_CC_STOPPED.2</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_CC_STOPPED of state machine
        CANSM_BSM_DeinitPnNotSupportedProceed and trigger T_REPEAT_MAX applies,
        CanSM shall operate action DO_SET_CC_MODE_STOPPED and enter state S_CC_STOPPED
        of state machine CANSM_BSM_DeinitPnNotSupportedProceed.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_REPEAT_MAX_DEINIT_NOPN_1_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>666</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_REPEAT_MAX_DEINIT_NOPN_1</srcid><srcstatus/><internalId>797</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00480</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>56</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00464</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>380</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>218</internalId></specobject>

      <!-- Controller sleep -->
    <specobject>
         <id>CanSM.ASR40.BSMDeInitNoPn.T_S_CC_SLEEP_S_TRCV_NORMAL</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_CC_SLEEP of state machine
        CANSM_BSM_DeinitPnNotSupportedProceed
        and a transceiver is configured for a CAN network
        and trigger T_CC_SLEEP_INDICATED (synchronous or asynchronous) applies,
        CanSM shall operate action DO_SET_TRCV_MODE_NORMAL and enter state S_TRCV_NORMAL
        of state machine CANSM_BSM_DeinitPnNotSupportedProceed.
      </description>
      <furtherinfo> 
        Justifying rule: WRN.swuts.needscoverage.count violation.
        A requirement can end up being satisified by numerous tests because
        the module can be subject to various scenarios 
      </furtherinfo>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_FUCO_NOCO_TXTIMEOUTEXCEPTION_NOPN</srcid><srcstatus/><internalId>636</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_NOCO_TXTIMEOUTEXCEPTION_NOPN_Distribution</srcid><srcstatus/><internalId>648</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOIN_NOCO_SYNC_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>652</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_SICO_NOCO_SYNC_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>662</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_SICO_NOCO_ASYNC_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>663</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_TIMEOUT_SYNC_1_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>664</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_TIMEOUT_SYNC_2_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>665</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_NOCO_SYNC_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>700</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_S_RNOCO_SYNC_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>701</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOIN_NOCO_ASYNC</srcid><srcstatus/><internalId>740</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOIN_NOCO_SYNC</srcid><srcstatus/><internalId>783</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_SICO_NOCO_SYNC</srcid><srcstatus/><internalId>793</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_SICO_NOCO_ASYNC</srcid><srcstatus/><internalId>794</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_TIMEOUT_SYNC_1</srcid><srcstatus/><internalId>795</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_TIMEOUT_SYNC_2</srcid><srcstatus/><internalId>796</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_NOCO_SYNC</srcid><srcstatus/><internalId>831</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_S_RNOCO_SYNC</srcid><srcstatus/><internalId>832</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00472</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>388</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00470</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>386</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>219</internalId></specobject>

      <!-- self transition -->
    <specobject>
         <id>CanSM.ASR40.BSMDeInitNoPn.T_S_CC_SLEEP_S_CC_SLEEP</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_CC_SLEEP of state machine
        CANSM_BSM_DeinitPnNotSupportedProceed and trigger T_CC_SLEEP_TIMEOUT applies,
        CanSM shall operate action DO_SET_CC_MODE_SLEEP and enter state S_CC_SLEEP
        of state machine CANSM_BSM_DeinitPnNotSupportedProceed.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_SICO_NOCO_ASYNC_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>663</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_TIMEOUT_SYNC_2_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>665</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_REPEAT_MAX_DEINIT_NOPN_2_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>667</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_SICO_NOCO_ASYNC</srcid><srcstatus/><internalId>794</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_TIMEOUT_SYNC_2</srcid><srcstatus/><internalId>796</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_REPEAT_MAX_DEINIT_NOPN_2</srcid><srcstatus/><internalId>798</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00468</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>384</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00469</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>385</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00471</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>387</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>220</internalId></specobject>

      <!-- restart DeInit process -->
    <specobject>
         <id>CanSM.ASR40.BSMDeInitNoPn.T_S_CC_SLEEP_S_CC_STOPPED</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_CC_SLEEP of state machine
        CANSM_BSM_DeinitPnNotSupportedProceed and trigger T_REPEAT_MAX applies,
        CanSM shall operate action DO_SET_CC_MODE_STOPPED and enter state S_CC_STOPPED
        of state machine CANSM_BSM_DeinitPnNotSupportedProceed.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_REPEAT_MAX_DEINIT_NOPN_2_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>667</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_REPEAT_MAX_DEINIT_NOPN_2</srcid><srcstatus/><internalId>798</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00480</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>56</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00464</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>380</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>221</internalId></specobject>

      <!-- Transceiver normal -->
    <specobject>
         <id>CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_NORMAL_S_TRCV_STANDBY</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_TRCV_NORMAL of state machine
        CANSM_BSM_DeinitPnNotSupportedProceed and trigger T_TRCV_NORMAL_INDICATED
        (synchronous or asynchronous) applies,
        CanSM shall operate action DO_SET_TRCV_MODE_STANDBY and enter state S_TRCV_STANDBY
        of state machine CANSM_BSM_DeinitPnNotSupportedProceed.
      </description>
      <furtherinfo> 
        Justifying rule: WRN.swuts.needscoverage.count violation.
        A requirement can end up being satisified by numerous tests because
        the module can be subject to various scenarios 
      </furtherinfo>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_FUCO_NOCO_TXTIMEOUTEXCEPTION_NOPN</srcid><srcstatus/><internalId>636</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_NOCO_TXTIMEOUTEXCEPTION_NOPN_Distribution</srcid><srcstatus/><internalId>648</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOIN_NOCO_SYNC_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>652</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_SICO_NOCO_SYNC_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>662</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_SICO_NOCO_ASYNC_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>663</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_TIMEOUT_SYNC_1_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>664</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_TIMEOUT_SYNC_2_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>665</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_NOCO_SYNC_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>700</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_S_RNOCO_SYNC_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>701</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOIN_NOCO_ASYNC</srcid><srcstatus/><internalId>740</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOIN_NOCO_SYNC</srcid><srcstatus/><internalId>783</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_SICO_NOCO_SYNC</srcid><srcstatus/><internalId>793</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_SICO_NOCO_ASYNC</srcid><srcstatus/><internalId>794</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_TIMEOUT_SYNC_1</srcid><srcstatus/><internalId>795</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_TIMEOUT_SYNC_2</srcid><srcstatus/><internalId>796</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_NOCO_SYNC</srcid><srcstatus/><internalId>831</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_S_RNOCO_SYNC</srcid><srcstatus/><internalId>832</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00474</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>390</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00476</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>392</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>222</internalId></specobject>

      <!-- self transition -->
    <specobject>
         <id>CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_NORMAL_S_TRCV_NORMAL</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_TRCV_NORMAL of state machine
        CANSM_BSM_DeinitPnNotSupportedProceed and trigger T_TRCV_NORMAL_TIMEOUT applies,
        CanSM shall operate action DO_SET_TRCV_MODE_NORMAL and enter state S_TRCV_NORMAL
        of state machine CANSM_BSM_DeinitPnNotSupportedProceed.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_SICO_NOCO_ASYNC_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>663</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_TIMEOUT_SYNC_1_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>664</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_REPEAT_MAX_DEINIT_NOPN_3_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>668</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_SICO_NOCO_ASYNC</srcid><srcstatus/><internalId>794</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_TIMEOUT_SYNC_1</srcid><srcstatus/><internalId>795</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_REPEAT_MAX_DEINIT_NOPN_3</srcid><srcstatus/><internalId>799</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00472</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>388</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00475</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>391</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00473</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>389</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>223</internalId></specobject>

      <!-- restart DeInit process -->
    <specobject>
         <id>CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_NORMAL_S_CC_STOPPED</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_TRCV_NORMAL of state machine
        CANSM_BSM_DeinitPnNotSupportedProceed and trigger T_REPEAT_MAX applies,
        CanSM shall operate action DO_SET_CC_MODE_STOPPED and enter state S_CC_STOPPED
        of state machine CANSM_BSM_DeinitPnNotSupportedProceed.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_REPEAT_MAX_DEINIT_NOPN_3_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>668</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_REPEAT_MAX_DEINIT_NOPN_3</srcid><srcstatus/><internalId>799</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00480</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>56</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00464</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>380</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>224</internalId></specobject>

      <!-- Transceiver standby -->

      <!-- self transition -->
    <specobject>
         <id>CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_STANDBY_S_TRCV_STANDBY</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_TRCV_STANDBY of state machine
        CANSM_BSM_DeinitPnNotSupportedProceed and trigger CANSM_BSM_T_TRCV_STANDBY_TIMEOUT applies,
        CanSM shall operate action DO_SET_TRCV_MODE_STANDBY and enter state S_TRCV_STANDBY
        of state machine CANSM_BSM_DeinitPnNotSupportedProceed.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_SICO_NOCO_ASYNC_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>663</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_TIMEOUT_SYNC_2_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>665</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_REPEAT_MAX_DEINIT_NOPN_4_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>669</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_SICO_NOCO_ASYNC</srcid><srcstatus/><internalId>794</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_TIMEOUT_SYNC_2</srcid><srcstatus/><internalId>796</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_REPEAT_MAX_DEINIT_NOPN_4</srcid><srcstatus/><internalId>800</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00479</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>395</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00477</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>393</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00476</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>392</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>225</internalId></specobject>

      <!-- restart DeInit process -->
    <specobject>
         <id>CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_STANDBY_S_CC_STOPPED</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_TRCV_STANDBY of state machine
        CANSM_BSM_DeinitPnNotSupportedProceed and trigger T_REPEAT_MAX applies,
        CanSM shall operate action DO_SET_CC_MODE_STOPPED and enter state S_CC_STOPPED
        of state machine CANSM_BSM_DeinitPnNotSupportedProceed.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_REPEAT_MAX_DEINIT_NOPN_4_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>669</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_REPEAT_MAX_DEINIT_NOPN_4</srcid><srcstatus/><internalId>800</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00480</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>56</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00464</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>380</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>226</internalId></specobject>

    <!-- Transceiver normal -->
    <specobject>
         <id>CanSM.ASR40.BSMPreFull.T_S_TRCV_NORMAL_S_CC_STOPPED</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_TRCV_NORMAL of state machine
        CANSM_BSM_S_PRE_FULLCOM and trigger T_TRCV_NORMAL_INDICATED
        (synchronous or asynchronous) applies,
        CanSM shall operate action DO_SET_CC_MODE_STOPPED and enter state S_CC_STOPPED
        of state machine CANSM_BSM_S_PRE_FULLCOM.
      </description>
      <furtherinfo> 
        Justifying rule: WRN.swuts.needscoverage.count violation.
        A requirement can end up being satisified by numerous tests because
        the module can be subject to various scenarios 
      </furtherinfo>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_MODE_REQ_REP_PARTIAL</srcid><srcstatus/><internalId>628</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_FUCO_2CC_2NW_Distribution</srcid><srcstatus/><internalId>630</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_FUCO_2CC_2NW_Distribution_2EcucPartition</srcid><srcstatus/><internalId>631</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_FUCO_SYNC_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>653</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_FUCO_ASYNC_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>654</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_TIMEOUT_SYNC_1_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>655</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_TIMEOUT_SYNC_2_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>656</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_FUCO_TRCV_IND_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>660</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_FUCO_LATE_IND_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>704</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_FUCO_2CC</srcid><srcstatus/><internalId>741</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_FUCO_SYNC</srcid><srcstatus/><internalId>784</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_FUCO_ASYNC</srcid><srcstatus/><internalId>785</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_TIMEOUT_SYNC_1</srcid><srcstatus/><internalId>786</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_TIMEOUT_SYNC_2</srcid><srcstatus/><internalId>787</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_FUCO_TRCV_IND</srcid><srcstatus/><internalId>791</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_FUCO_LATE_IND</srcid><srcstatus/><internalId>835</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00487</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>400</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00485</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>398</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00558</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>455</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>227</internalId></specobject>

      <!-- self transition -->
    <specobject>
         <id>CanSM.ASR40.BSMPreFull.T_S_TRCV_NORMAL_S_TRCV_NORMAL</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_TRCV_NORMAL of state machine
        CANSM_BSM_S_PRE_FULLCOM and trigger T_TRCV_NORMAL_TIMEOUT applies,
        CanSM shall operate action DO_SET_TRCV_MODE_NORMAL and enter state S_TRCV_NORMAL
        of state machine CANSM_BSM_S_PRE_FULLCOM.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_MODE_REQ_REP_PARTIAL</srcid><srcstatus/><internalId>628</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_FUCO_FAILED_1_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>657</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_REPEAT_MAX_PRE_FULLCOM_PN_1</srcid><srcstatus/><internalId>759</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_FUCO_FAILED_1</srcid><srcstatus/><internalId>788</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00483</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>396</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00484</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>397</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00486</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>399</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>228</internalId></specobject>

      <!-- Controller stopped -->
    <specobject>
         <id>CanSM.ASR40.BSMPreFull.T_S_CC_STOPPED_S_CC_STARTED</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_CC_STOPPED of state machine
        CANSM_BSM_S_PRE_FULLCOM and trigger T_CC_STOPPED_INDICATED
        (synchronous or asynchronous) applies,
        CanSM shall operate action DO_SET_CC_MODE_STARTED and enter state S_CC_STARTED
        of state machine CANSM_BSM_S_PRE_FULLCOM.
      </description>
      <furtherinfo> 
        Justifying rule: WRN.swuts.needscoverage.count violation.
        A requirement can end up being satisified by numerous tests because
        the module can be subject to various scenarios 
      </furtherinfo>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_NOCO_FUCO_SYNC_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>653</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_FUCO_ASYNC_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>654</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_TIMEOUT_SYNC_1_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>655</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_TIMEOUT_SYNC_2_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>656</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_FUCO_CC_IND_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>661</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_FUCO_LATE_IND_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>704</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_FUCO_SYNC</srcid><srcstatus/><internalId>784</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_FUCO_ASYNC</srcid><srcstatus/><internalId>785</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_TIMEOUT_SYNC_1</srcid><srcstatus/><internalId>786</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_TIMEOUT_SYNC_2</srcid><srcstatus/><internalId>787</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_FUCO_CC_IND</srcid><srcstatus/><internalId>792</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_FUCO_LATE_IND</srcid><srcstatus/><internalId>835</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00491</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>404</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00489</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>402</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>229</internalId></specobject>

      <!-- self transition -->
    <specobject>
         <id>CanSM.ASR40.BSMPreFull.T_S_CC_STOPPED_S_CC_STOPPED</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_CC_STOPPED of state machine
        CANSM_BSM_S_PRE_FULLCOM and trigger T_CC_STOPPED_TIMEOUT applies,
        CanSM shall operate action DO_SET_CC_MODE_STOPPED and enter state S_CC_STOPPED
        of state machine CANSM_BSM_S_PRE_FULLCOM.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_NOCO_FUCO_FAILED_1_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>657</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_FUCO_FAILED_2_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>658</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_REPEAT_MAX_PRE_FULLCOM_PN_2</srcid><srcstatus/><internalId>760</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_FUCO_FAILED_1</srcid><srcstatus/><internalId>788</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_FUCO_FAILED_2</srcid><srcstatus/><internalId>789</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00487</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>400</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00488</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>401</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00490</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>403</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>230</internalId></specobject>

      <!-- Controller started -->

      <!-- self transition -->
    <specobject>
         <id>CanSM.ASR40.BSMPreFull.T_S_CC_STARTED_S_CC_STARTED</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_CC_STARTED of state machine
        CANSM_BSM_S_PRE_FULLCOM and trigger T_CC_STARTED_TIMEOUT applies,
        CanSM shall operate action DO_SET_CC_MODE_STARTED and enter state S_CC_STARTED
        of state machine CANSM_BSM_S_PRE_FULLCOM.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_NOCO_FUCO_FAILED_3_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>659</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_REPEAT_MAX_PRE_FULLCOM_PN_3</srcid><srcstatus/><internalId>761</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_FUCO_FAILED_3</srcid><srcstatus/><internalId>790</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00491</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>404</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00492</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>405</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00494</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>407</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>231</internalId></specobject>

    <specobject>
         <id>CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_NO_BUS_OFF</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_BUS_OFF_CHECK of state machine
        CANSM_BSM_S_FULLCOM and guardian condition G_BUS_OFF_PASSIVE applies,
        CanSM shall execute effect E_BUS_OFF_PASSIVE and enter state S_NO_BUS_OFF
        of state machine CANSM_BSM_S_FULLCOM.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_BUS_OFF_PASSIVE_TIMER_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>687</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_TIME_TX_ENSURE_VIO_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>696</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_L1_TO_RECOVERY_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>697</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_L2_TO_RECOVERY_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>698</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_BUS_OFF_PASSIVE_POLL</srcid><srcstatus/><internalId>742</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_BUS_OFF_PASSIVE_TIMER</srcid><srcstatus/><internalId>818</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_TIME_TX_ENSURE_VIO</srcid><srcstatus/><internalId>827</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_L1_TO_RECOVERY</srcid><srcstatus/><internalId>828</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_L2_TO_RECOVERY</srcid><srcstatus/><internalId>829</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00496</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>408</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00497</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>409</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00498</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>58</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>232</internalId></specobject>

      <specobject>
         <id>CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_RESTART_CC</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_BUS_OFF_CHECK of state machine
        CANSM_BSM_S_FULLCOM and and trigger T_BUS_OFF applies,
        CanSM shall execute effect E_BUS_OFF, operate the do action
        DO_SET_CC_MODE_STARTED and enter state S_RESTART_CC
        of state machine CANSM_BSM_S_FULLCOM.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CANSM.BusoffCallOrder</srcid><srcstatus/><internalId>543</internalId></linkedfrom></coveredby></needscov>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_RESTART_CC.BusOff</srcid><srcstatus/><internalId>234</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_RESTART_CC.BusOffL1</srcid><srcstatus/><internalId>235</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_RESTART_CC.BusOffL2</srcid><srcstatus/><internalId>236</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00500</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>412</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.CANSM508.BusOff</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>244</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.CANSM508.BusOffL1</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>245</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.CANSM508.BusOffL2</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>246</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00521</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>430</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00522</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>65</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00509</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>420</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>233</internalId></specobject>

      <specobject>
         <id>CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_RESTART_CC.BusOff</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
         <version>2</version>
         <description>
        If the CanSM module is in state S_BUS_OFF_CHECK of state machine
        CANSM_BSM_S_FULLCOM, the trigger T_BUS_OFF applies and the conditions
        as decribed in CanSM.ASR40.CANSM508.BusOff applies then:
        CanSM shall call the following API functions in the listed order:
        1. BswM_CanSM_CurrentState as described in [CANSM508.BusOff],
        2. Dem_ReportErrorStatus as described in [CANSM522],
        3. CanIf_SetControllerMode (do action DO_SET_CC_MODE_STARTED) as described in [CANSM509]
        and enter state S_RESTART_CC of state machine CANSM_BSM_S_FULLCOM.
      </description>
      <furtherinfo> 
        Justifying rule: WRN.swuts.needscoverage.count violation.
        A requirement can end up being satisified by numerous tests because
        the module can be subject to various scenarios 
      </furtherinfo>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_DEBOUNCE_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>688</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_DEBOUNCE_SYNC_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>689</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_L1_TO_L2_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>694</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_TIME_TX_ENSURE_VIO_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>696</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_BUS_OFF_LATE_BUS_OFF_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>705</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_DEM2DET_BUS_OFF</srcid><srcstatus/><internalId>745</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_DEBOUNCE</srcid><srcstatus/><internalId>819</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_DEBOUNCE_SYNC</srcid><srcstatus/><internalId>820</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_L1_TO_L2</srcid><srcstatus/><internalId>825</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_TIME_TX_ENSURE_VIO</srcid><srcstatus/><internalId>827</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_BUS_OFF_LATE_BUS_OFF</srcid><srcstatus/><internalId>836</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_RESTART_CC</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>233</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>234</internalId></specobject>

      <specobject>
         <id>CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_RESTART_CC.BusOffL1</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
         <version>2</version>
         <description>
        If the CanSM module is in state S_BUS_OFF_CHECK of state machine
        CANSM_BSM_S_FULLCOM and, the trigger T_BUS_OFF applies and the conditions
        as decribed in CanSM.ASR40.CANSM508.BusOffL1 applies then:
        CanSM shall call the following API functions in the listed order:
        1. BswM_CanSM_CurrentState as described in [CANSM508.BusOffL1],
        2. Dem_ReportErrorStatus as described in [CANSM522],
        3. CanIf_SetControllerMode (do action DO_SET_CC_MODE_STARTED) as described in [CANSM509]
        and enter state S_RESTART_CC of state machine CANSM_BSM_S_FULLCOM.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_DEBOUNCE_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>688</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_L1_TO_L2_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>694</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_TIME_TX_ENSURE_VIO_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>696</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_BUS_OFF_LATE_BUS_OFF_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>705</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_DEBOUNCE</srcid><srcstatus/><internalId>819</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_L1_TO_L2</srcid><srcstatus/><internalId>825</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_TIME_TX_ENSURE_VIO</srcid><srcstatus/><internalId>827</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_BUS_OFF_LATE_BUS_OFF</srcid><srcstatus/><internalId>836</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_RESTART_CC</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>233</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>235</internalId></specobject>

      <specobject>
         <id>CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_RESTART_CC.BusOffL2</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
         <version>2</version>
         <description>
        If the CanSM module is in state S_BUS_OFF_CHECK of state machine
        CANSM_BSM_S_FULLCOM, the trigger T_BUS_OFF applies and the conditions
        as decribed in CanSM.ASR40.CANSM508.BusOffL2 applies then:
        CanSM shall call the following API functions in the listed order:
        1. BswM_CanSM_CurrentState as described in [CANSM508.BusOffL2],
        2. Dem_ReportErrorStatus as described in [CANSM522],
        3. CanIf_SetControllerMode (do action DO_SET_CC_MODE_STARTED) as described in [CANSM509]
        and enter state S_RESTART_CC of state machine CANSM_BSM_S_FULLCOM.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_DEBOUNCE_SYNC_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>689</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_DEBOUNCE_SYNC</srcid><srcstatus/><internalId>820</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_RESTART_CC</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>233</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>236</internalId></specobject>

      <specobject>
         <id>CanSM.ASR40.BSMFull.T_S_NO_BUS_OFF_S_RESTART_CC</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_NO_BUS_OFF of state machine
        CANSM_BSM_S_FULLCOM and trigger T_BUS_OFF applies,
        CanSM shall execute effect E_BUS_OFF, operate the do action
        DO_SET_CC_MODE_STARTED and enter state S_RESTART_CC
        of state machine CANSM_BSM_S_FULLCOM.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CANSM.BusoffCallOrder</srcid><srcstatus/><internalId>543</internalId></linkedfrom></coveredby></needscov>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMFull.T_S_NO_BUS_OFF_S_RESTART_CC.BusOff</srcid><srcstatus/><internalId>238</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSMFull.T_S_NO_BUS_OFF_S_RESTART_CC.BusOffL1</srcid><srcstatus/><internalId>239</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00500</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>412</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.CANSM508.BusOff</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>244</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.CANSM508.BusOffL1</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>245</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00521</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>430</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00522</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>65</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00509</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>420</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>237</internalId></specobject>

      <specobject>
         <id>CanSM.ASR40.BSMFull.T_S_NO_BUS_OFF_S_RESTART_CC.BusOff</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
         <version>2</version>
         <description>
        If the CanSM module is in state S_NO_BUS_OFF of state machine
        CANSM_BSM_S_FULLCOM, the trigger T_BUS_OFF applies and the conditions
        as decribed in CanSM.ASR40.CANSM508.BusOff applies then:
        CanSM shall call the following API functions in the listed order:
        1. BswM_CanSM_CurrentState as described in [CANSM508.BusOff],
        2. Dem_ReportErrorStatus as described in [CANSM522],
        3. CanIf_SetControllerMode (do action DO_SET_CC_MODE_STARTED) as described in [CANSM509]
        and enter state S_RESTART_CC of state machine CANSM_BSM_S_FULLCOM.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_TX_ON_DELAYED</srcid><srcstatus/><internalId>629</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_BUS_OFF_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>692</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_BUS_OFF</srcid><srcstatus/><internalId>823</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.ASR40.BSMFull.T_S_NO_BUS_OFF_S_RESTART_CC</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>237</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>238</internalId></specobject>

      <specobject>
         <id>CanSM.ASR40.BSMFull.T_S_NO_BUS_OFF_S_RESTART_CC.BusOffL1</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
         <version>2</version>
         <description>
        If the CanSM module is in state S_NO_BUS_OFF of state machine
        CANSM_BSM_S_FULLCOM, the trigger T_BUS_OFF applies and the conditions
        as decribed in CanSM.ASR40.CANSM508.BusOffL1 applies then:
        CanSM shall call the following API functions in the listed order:
        1. BswM_CanSM_CurrentState as described in [CANSM508.BusOffL1],
        2. Dem_ReportErrorStatus as described in [CANSM522],
        3. CanIf_SetControllerMode (do action DO_SET_CC_MODE_STARTED) as described in [CANSM509]
        and enter state S_RESTART_CC of state machine CANSM_BSM_S_FULLCOM.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_BUS_OFF_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>692</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_BUS_OFF</srcid><srcstatus/><internalId>823</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.ASR40.BSMFull.T_S_NO_BUS_OFF_S_RESTART_CC</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>237</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>239</internalId></specobject>

      <specobject>
         <id>CanSM.ASR40.BSMFull.T_S_RESTART_CC_S_TX_OFF</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_RESTART_CC of state machine
        CANSM_BSM_S_FULLCOM and trigger T_RESTART_CC_INDICATED
        (synchronous or asynchronous) applies,
        CanSM shall execute effect E_TX_OFF and enter state S_TX_OFF
        of state machine CANSM_BSM_S_FULLCOM.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CANSM.BusoffCallOrder</srcid><srcstatus/><internalId>543</internalId></linkedfrom></coveredby></needscov>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMFull.T_S_RESTART_CC_S_TX_OFF.2</srcid><srcstatus/><internalId>241</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00511</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>422</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>240</internalId></specobject>

      <specobject>
         <id>CanSM.ASR40.BSMFull.T_S_RESTART_CC_S_TX_OFF.2</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_RESTART_CC of state machine
        CANSM_BSM_S_FULLCOM and trigger T_RESTART_CC_INDICATED
        (synchronous or asynchronous) applies,
        CanSM shall call ComM_BusSM_ModeIndication as described in [CANSM521]
        and enter state S_TX_OFF of state machine CANSM_BSM_S_FULLCOM.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_TX_ON_DELAYED</srcid><srcstatus/><internalId>629</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_DEBOUNCE_SYNC_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>689</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_TX_OFF_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>690</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_L1_TO_L2_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>694</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_DEBOUNCE_SYNC</srcid><srcstatus/><internalId>820</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_TX_OFF</srcid><srcstatus/><internalId>821</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_L1_TO_L2</srcid><srcstatus/><internalId>825</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.ASR40.BSMFull.T_S_RESTART_CC_S_TX_OFF</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>240</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>241</internalId></specobject>

      <!-- self transition -->
    <specobject>
         <id>CanSM.ASR40.BSMFull.T_S_RESTART_CC_S_RESTART_CC</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_RESTART_CC of state machine
        CANSM_BSM_S_FULLCOM and trigger T_RESTART_CC_TIMEOUT applies,
        CanSM shall operate action DO_SET_CC_MODE_STARTED and enter state S_RESTART_CC
        of state machine CANSM_BSM_S_FULLCOM.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_TX_ON_DELAYED</srcid><srcstatus/><internalId>629</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_SRNOCO_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>691</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_REPEAT_MAX_FULLCOM_PN_1</srcid><srcstatus/><internalId>762</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_SRNOCO</srcid><srcstatus/><internalId>822</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00509</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>420</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00510</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>421</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00512</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>423</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>242</internalId></specobject>

      <specobject>
         <id>CanSM.ASR40.BSMFull.T_S_TX_OFF_S_BUS_OFF_CHECK</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_TX_OFF of state machine
        CANSM_BSM_S_FULLCOM and guardian condition G_TX_ON applies,
        CanSM shall execute effect E_TX_ON and enter state S_BUS_OFF_CHECK
        of state machine CANSM_BSM_S_FULLCOM.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_TX_ON_DELAYED</srcid><srcstatus/><internalId>629</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_TX_ON_L1_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>693</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_L1_TO_L2_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>694</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_TX_ON_L2_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>695</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_TX_ON_L1</srcid><srcstatus/><internalId>824</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_L1_TO_L2</srcid><srcstatus/><internalId>825</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_TX_ON_L2</srcid><srcstatus/><internalId>826</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00514</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>63</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00515</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>64</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR42.SWS_CANSM_00516</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>104</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00517</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>428</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00518</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>429</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>243</internalId></specobject>

      <specobject>
         <id>CanSM.ASR40.CANSM508.BusOff</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
         <version>1</version>
         <description>
        If configuration parameter CanSMEnhancedBusOffReporting is disabled:
        The effect E_BUS_OFF of the sub state machine CANSM_BSM_S_FULLCOM (ref. to
        Figure 7-6) shall call at 1st place for the corresponding CAN network the
        API BswM_CanSM_CurrentState with the parameters Network :=
        CanSMComMNetworkHandleRef and CurrentState := CANSM_BSWM_BUS_OFF.
      </description>
         <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_RESTART_CC</srcid><srcstatus/><internalId>233</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSMFull.T_S_NO_BUS_OFF_S_RESTART_CC</srcid><srcstatus/><internalId>237</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00508</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>419</internalId></provcov>
            <provcov>
               <linksto>CanSM.EB.CanSMEnhancedBusOffReporting</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>134</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>244</internalId></specobject>

      <specobject>
         <id>CanSM.ASR40.CANSM508.BusOffL1</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
         <version>1</version>
         <description>
        If configuration parameter CanSMEnhancedBusOffReporting is enabled
        and the bus-off recovery counter is lower than CanSMBorCounterL1ToL2:
        The effect E_BUS_OFF of the sub state machine CANSM_BSM_S_FULLCOM (ref. to
        Figure 7-6) shall call at 1st place for the corresponding CAN network the
        API BswM_CanSM_CurrentState with the parameters Network :=
        CanSMComMNetworkHandleRef and CurrentState := CANSM_BSWM_BUS_OFF_L1.
      </description>
         <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_RESTART_CC</srcid><srcstatus/><internalId>233</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSMFull.T_S_NO_BUS_OFF_S_RESTART_CC</srcid><srcstatus/><internalId>237</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00508</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>419</internalId></provcov>
            <provcov>
               <linksto>CanSM.EB.CanSMEnhancedBusOffReporting</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>134</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>245</internalId></specobject>

      <specobject>
         <id>CanSM.ASR40.CANSM508.BusOffL2</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
         <version>1</version>
         <description>
        If configuration parameter CanSMEnhancedBusOffReporting is enabled:
        and the bus-off recovery counter is greater than or equal to CanSMBorCounterL1ToL2:
        The effect E_BUS_OFF of the sub state machine CANSM_BSM_S_FULLCOM (ref. to
        Figure 7-6) shall call at 1st place for the corresponding CAN network the
        API BswM_CanSM_CurrentState with the parameters Network :=
        CanSMComMNetworkHandleRef and CurrentState := CANSM_BSWM_BUS_OFF_L2.
      </description>
         <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_RESTART_CC</srcid><srcstatus/><internalId>233</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00508</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>419</internalId></provcov>
            <provcov>
               <linksto>CanSM.EB.CanSMEnhancedBusOffReporting</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>134</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>246</internalId></specobject>

    <specobject>
         <id>CanSM.ASR40.BSMBr.T_S_CC_STOPPED_S_CC_STARTED</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_CC_STOPPED of state machine
        CANSM_BSM_S_CHANGE_BAUDRATE and trigger T_CC_STOPPED_INDICATED
        (synchronous or asynchronous) applies,
        CanSM shall execute effect E_CHANGE_BAUDRATE, operate action DO_SET_CC_MODE_STARTED
        and enter state S_CC_STARTED of state machine CANSM_BSM_S_CHANGE_BAUDRATE.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_CC_STOPPED_INDICATED_CHANGE_BR_SYNC_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>672</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_CC_STOPPED_INDICATED_CHANGE_BR_ASYNC_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>673</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_CC_STOPPED_INDICATED_CHANGE_BR_SYNC</srcid><srcstatus/><internalId>803</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_CC_STOPPED_INDICATED_CHANGE_BR_ASYNC</srcid><srcstatus/><internalId>804</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00532</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>440</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00526</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>434</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00529</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>437</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00531</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>439</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>247</internalId></specobject>

      <!-- self transition -->
    <specobject>
         <id>CanSM.ASR40.BSMBr.T_S_CC_STOPPED_S_CC_STOPPED</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_CC_STOPPED of state machine
        CANSM_BSM_S_CHANGE_BAUDRATE and trigger T_CC_STOPPED_TIMEOUT applies,
        CanSM shall operate action DO_SET_CC_MODE_STOPPED
        and enter state S_CC_STOPPED of state machine CANSM_BSM_S_CHANGE_BAUDRATE.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_CC_STOPPED_TIMEOUT_CHANGE_BR_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>674</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_CC_STOPPED_TIMEOUT_CHANGE_BR</srcid><srcstatus/><internalId>805</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00524</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>432</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00525</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>433</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00527</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>435</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>248</internalId></specobject>

      <!-- self transition -->
    <specobject>
         <id>CanSM.ASR40.BSMBr.T_S_CC_STARTED_S_CC_STARTED</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
         <version>1</version>
         <description>
        If the CanSM module is in state S_CC_STARTED of state machine
        CANSM_BSM_S_CHANGE_BAUDRATE and trigger T_CC_STARTED_TIMEOUT applies,
        CanSM shall operate action DO_SET_CC_MODE_STARTED
        and enter state S_CC_STARTED of state machine CANSM_BSM_S_CHANGE_BAUDRATE.
      </description>
         <comment>
        This requirement describes one transition of the CanSM (sub-)state machine,
        merging the involved trigger and/or guardian condition and/or effect.
        The refined requirements only describes a single trigger or guardian condition
        or effect and therefore does not show the dependencies.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_CC_STARTED_TIMEOUT_CHANGE_BR_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>675</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_CC_STARTED_TIMEOUT_CHANGE_BR</srcid><srcstatus/><internalId>806</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00532</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>440</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00533</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>441</internalId></provcov>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00535</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>443</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>249</internalId></specobject>

      <specobject>
         <id>CanSM.ASR40.SWS_CanSM_00069.Type</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
         <version>1</version>
         <description>
        Development error values shall be of type uint8.
      </description>
         <comment>
        Requirement defines an atomic part of CanSM.ASR40.SWS_CanSM_00069
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_DET_ERROR_VALUE</srcid><srcstatus/><internalId>730</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00069</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>16</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>250</internalId></specobject>

      <specobject>
         <id>CanSM.ASR40.ErrorTable.CANSM_E_UNINIT</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
         <version>1</version>
         <description>
        Type or error             Relevance     Related error code              Value [hex]
        API service used without  Development   CANSM_E_UNINIT                  0x01
        module initialization
      </description>
         <comment>
        Requirement defines an atomic part of CanSM.ASR40.SWS_CanSM_00069
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.SWS_CanSM_00184</srcid><srcstatus/><internalId>302</internalId></linkedfrom><linkedfrom><srcid>CanSM.SWS_CanSM_00188</srcid><srcstatus/><internalId>305</internalId></linkedfrom><linkedfrom><srcid>CanSM.SWS_CanSM_00190</srcid><srcstatus/><internalId>307</internalId></linkedfrom><linkedfrom><srcid>CanSM.SWS_CanSM_00398</srcid><srcstatus/><internalId>323</internalId></linkedfrom><linkedfrom><srcid>CanSM.SWS_CanSM_00401</srcid><srcstatus/><internalId>326</internalId></linkedfrom><linkedfrom><srcid>CanSM.SWS_CanSM_00411</srcid><srcstatus/><internalId>328</internalId></linkedfrom><linkedfrom><srcid>CanSM.SWS_CanSM_00414</srcid><srcstatus/><internalId>331</internalId></linkedfrom><linkedfrom><srcid>CanSM.SWS_CanSM_00417</srcid><srcstatus/><internalId>334</internalId></linkedfrom><linkedfrom><srcid>CanSM.SWS_CanSM_00420</srcid><srcstatus/><internalId>337</internalId></linkedfrom><linkedfrom><srcid>CanSM.SWS_CanSM_00506</srcid><srcstatus/><internalId>417</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00069</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>16</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>251</internalId></specobject>

      <specobject>
         <id>CanSM.ASR40.ErrorTable.CANSM_E_PARAM_POINTER</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
         <version>1</version>
         <description>
        Type or error             Relevance     Related error code              Value [hex]
        API service called with   Development   CANSM_E_PARAM_POINTER           0x02
        wrong pointer
      </description>
         <comment>
        Requirement defines an atomic part of CanSM.ASR40.SWS_CanSM_00069
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.SWS_CanSM_00360</srcid><srcstatus/><internalId>314</internalId></linkedfrom><linkedfrom><srcid>CanSM.SWS_CanSM_00374</srcid><srcstatus/><internalId>319</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00069</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>16</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>252</internalId></specobject>

      <specobject>
         <id>CanSM.ASR40.ErrorTable.CANSM_E_INVALID_NETWORK_HANDLE</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
         <version>1</version>
         <description>
        Type or error             Relevance     Related error code              Value [hex]
        API service called with   Development   CANSM_E_INVALID_NETWORK_HANDLE  0x03
        wrong parameter
      </description>
         <comment>
        Requirement defines an atomic part of CanSM.ASR40.SWS_CanSM_00069
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.SWS_CanSM_00571</srcid><srcstatus/><internalId>83</internalId></linkedfrom><linkedfrom><srcid>CanSM.SWS_CanSM_00183</srcid><srcstatus/><internalId>301</internalId></linkedfrom><linkedfrom><srcid>CanSM.SWS_CanSM_00187</srcid><srcstatus/><internalId>304</internalId></linkedfrom><linkedfrom><srcid>CanSM.SWS_CanSM_00412</srcid><srcstatus/><internalId>329</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00069</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>16</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>253</internalId></specobject>

      <specobject>
         <id>CanSM.ASR40.ErrorTable.CANSM_E_PARAM_CONTROLLER</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
         <version>1</version>
         <description>
        Type or error             Relevance     Related error code              Value [hex]
        API service called with   Development   CANSM_E_PARAM_CONTROLLER        0x04
        wrong parameter
      </description>
         <comment>
        Requirement defines an atomic part of CanSM.ASR40.SWS_CanSM_00069
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.SWS_CanSM_00189</srcid><srcstatus/><internalId>306</internalId></linkedfrom><linkedfrom><srcid>CanSM.SWS_CanSM_00397</srcid><srcstatus/><internalId>322</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00069</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>16</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>254</internalId></specobject>

      <specobject>
         <id>CanSM.ASR40.ErrorTable.CANSM_E_PARAM_TRANSCEIVER</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
         <version>1</version>
         <description>
        Type or error             Relevance     Related error code              Value [hex]
        API service called with   Development   CANSM_E_PARAM_TRANSCEIVER       0x05
        wrong parameter
      </description>
         <comment>
        Requirement defines an atomic part of CanSM.ASR40.SWS_CanSM_00069
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.SWS_CanSM_00400</srcid><srcstatus/><internalId>325</internalId></linkedfrom><linkedfrom><srcid>CanSM.SWS_CanSM_00415</srcid><srcstatus/><internalId>332</internalId></linkedfrom><linkedfrom><srcid>CanSM.SWS_CanSM_00418</srcid><srcstatus/><internalId>335</internalId></linkedfrom><linkedfrom><srcid>CanSM.SWS_CanSM_00421</srcid><srcstatus/><internalId>338</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00069</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>16</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>255</internalId></specobject>

      <specobject>
         <id>CanSM.ASR40.ErrorTable.CANSM_E_BUSOFF_RECOVERY_ACTIVE</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
         <version>1</version>
         <description>
        Type or error             Relevance     Related error code              Value [hex]
        Network mode request      Development   CANSM_E_BUSOFF_RECOVERY_ACTIVE  0x06
        during not finished bus-
        off recovery
      </description>
         <comment>
        Requirement defines an atomic part of CanSM.ASR40.SWS_CanSM_00069
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.SWS_CanSM_00377</srcid><srcstatus/><internalId>45</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00069</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>16</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>256</internalId></specobject>

      <specobject>
         <id>CanSM.ASR40.ErrorTable.CANSM_E_WAIT_MODE_INDICATION</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
         <version>1</version>
         <description>
        Type or error             Relevance     Related error code              Value [hex]
        Network mode request      Development   CANSM_E_WAIT_MODE_INDICATION    0x07
        during pending indication
      </description>
         <comment>
        Requirement defines an atomic part of CanSM.ASR40.SWS_CanSM_00069
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.SWS_CanSM_00395</srcid><srcstatus/><internalId>47</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00069</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>16</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>257</internalId></specobject>

      <specobject>
         <id>CanSM.ASR40.ErrorTable.CANSM_E_INVALID_COMM_REQUEST</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
         <version>1</version>
         <description>
        Type or error             Relevance     Related error code              Value [hex]
        Invalid communication     Development   CANSM_E_INVALID_COMM_REQUEST    0x08
        mode request
      </description>
         <comment>
        Requirement defines an atomic part of CanSM.ASR40.SWS_CanSM_00069
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.SWS_CanSM_00403</srcid><srcstatus/><internalId>50</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00069</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>16</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>258</internalId></specobject>

      <specobject>
         <id>CanSM.ASR40.ErrorTable.CANSM_E_PARAM_INVALID_BAUDRATE</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
         <version>1</version>
         <description>
        Type or error            Relevance     Related error code              Value [hex]
        Invalid BaudrateConfig   Development   CANSM_E_PARAM_INVALID_BAUDRATE  0x09
        for at least one of the
        CAN Controllers of the
        requested CAN Network
      </description>
         <comment>
        Requirement defines an atomic part of CanSM.ASR40.SWS_CanSM_00069
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.SWS_CanSM_00574</srcid><srcstatus/><internalId>86</internalId></linkedfrom></coveredby></needscov>
            <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CANSM.ChangeBaudrateMissing</srcid><srcstatus/><internalId>545</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00069</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>16</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>259</internalId></specobject>

      <specobject>
         <id>CanSM.ASR40.ErrorTable.CANSM_E_MODE_REQUEST_TIMEOUT</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
         <version>1</version>
         <description>
        Type or error             Relevance     Related error code              Value [hex]
        Mode request for a        Development   CANSM_E_MODE_REQUEST_TIMEOUT    0x0A
        network failed more often
        as allowed by
        configuration
      </description>
      <furtherinfo> 
        Justifying rule: WRN.swurs.needscoverage.count violation.
        The requirement is not complete nor consistent All requirement of this kind are coverd by
        more than 10 requirements describing the complete state transition.
      </furtherinfo>
      <comment>
        Requirement defines an atomic part of CanSM.ASR40.SWS_CanSM_00069
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR41.TX_TIMEOUT_EXCEPTION.T_S_CC_STOPPED_PRE_NOCOM.Pn</srcid><srcstatus/><internalId>101</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR41.TX_TIMEOUT_EXCEPTION.T_S_CC_STARTED_PRE_NOCOM.Pn</srcid><srcstatus/><internalId>102</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_FULLCOM_PRE_NOCOM.NoPn</srcid><srcstatus/><internalId>168</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_FULLCOM_PRE_NOCOM.Pn</srcid><srcstatus/><internalId>169</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.NoPn.1</srcid><srcstatus/><internalId>176</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.Pn.1</srcid><srcstatus/><internalId>177</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.NoPn.2</srcid><srcstatus/><internalId>178</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.Pn.2</srcid><srcstatus/><internalId>179</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.NoPn.3</srcid><srcstatus/><internalId>180</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.Pn.3</srcid><srcstatus/><internalId>181</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.NoPn.1</srcid><srcstatus/><internalId>182</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.Pn.1</srcid><srcstatus/><internalId>183</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.NoPn.2</srcid><srcstatus/><internalId>184</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.Pn.2</srcid><srcstatus/><internalId>185</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSMDeInitPn.T_S_PN_CLEAR_WUF_S_PN_CLEAR_WUF.2</srcid><srcstatus/><internalId>199</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSMDeInitPn.T_S_PN_CC_STOPPED_S_PN_CLEAR_WUF</srcid><srcstatus/><internalId>202</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSMDeInitPn.T_S_TRCV_NORMAL_S_PN_CLEAR_WUF</srcid><srcstatus/><internalId>205</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSMDeInitPn.T_S_TRCV_STANDBY_S_PN_CLEAR_WUF</srcid><srcstatus/><internalId>208</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSMDeInitPn.T_S_CHECK_WFLAG_IN_CC_SLEEP_S_PN_CLEAR_WUF</srcid><srcstatus/><internalId>212</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSMDeInitPn.T_S_CHECK_WFLAG_IN_NOT_CC_SLEEP_S_PN_CLEAR_WUF.2</srcid><srcstatus/><internalId>215</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00069</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>16</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>260</internalId></specobject>

      <specobject>
         <id>CanSM.ASR40.ErrorTable.CANSM_E_BUS_OFF</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
         <version>1</version>
         <description>
        Type or error             Relevance     Related error code              Value [hex]
        The bus-off recovery      Production    CANSM_E_BUS_OFF (ref. to        Assigned
        state machine of a CAN                  CANSM070_Conf)                  by DEM
        network has detected a
        certain amount of
        sequential bus-offs
        without successful
        recovery
      </description>
         <comment>
        Requirement defines an atomic part of CanSM.ASR40.SWS_CanSM_00069
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ECUC_CanSM_00070</srcid><srcstatus/><internalId>273</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00069</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>16</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>261</internalId></specobject>

      <specobject>
         <id>CanSM.ASR40.DevelopmentErrors</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
         <version>1</version>
         <description>
        The switch CanSMDevErrorDetect (ref. to CANSM133_Conf) shall activate
        or deactivate the detection of all development errors.
      </description>
      <furtherinfo> 
        Justifying rule: WRN.swurs.needscoverage.count violation.
        Requirement unites redundant DET requirements.
        Requirement is too general and is coverd by more than 10 requirements handling 
        the DET checks
      </furtherinfo>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.SWS_CanSM_00377</srcid><srcstatus/><internalId>45</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.SWS_CanSM_00395</srcid><srcstatus/><internalId>47</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.SWS_CanSM_00403</srcid><srcstatus/><internalId>50</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.SWS_CanSM_00571</srcid><srcstatus/><internalId>83</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.SWS_CanSM_00574</srcid><srcstatus/><internalId>86</internalId></linkedfrom><linkedfrom><srcid>CanSM.SWS_CanSM_00183</srcid><srcstatus/><internalId>301</internalId></linkedfrom><linkedfrom><srcid>CanSM.SWS_CanSM_00184</srcid><srcstatus/><internalId>302</internalId></linkedfrom><linkedfrom><srcid>CanSM.SWS_CanSM_00187</srcid><srcstatus/><internalId>304</internalId></linkedfrom><linkedfrom><srcid>CanSM.SWS_CanSM_00188</srcid><srcstatus/><internalId>305</internalId></linkedfrom><linkedfrom><srcid>CanSM.SWS_CanSM_00189</srcid><srcstatus/><internalId>306</internalId></linkedfrom><linkedfrom><srcid>CanSM.SWS_CanSM_00190</srcid><srcstatus/><internalId>307</internalId></linkedfrom><linkedfrom><srcid>CanSM.SWS_CanSM_00360</srcid><srcstatus/><internalId>314</internalId></linkedfrom><linkedfrom><srcid>CanSM.SWS_CanSM_00374</srcid><srcstatus/><internalId>319</internalId></linkedfrom><linkedfrom><srcid>CanSM.SWS_CanSM_00397</srcid><srcstatus/><internalId>322</internalId></linkedfrom><linkedfrom><srcid>CanSM.SWS_CanSM_00398</srcid><srcstatus/><internalId>323</internalId></linkedfrom><linkedfrom><srcid>CanSM.SWS_CanSM_00400</srcid><srcstatus/><internalId>325</internalId></linkedfrom><linkedfrom><srcid>CanSM.SWS_CanSM_00401</srcid><srcstatus/><internalId>326</internalId></linkedfrom><linkedfrom><srcid>CanSM.SWS_CanSM_00411</srcid><srcstatus/><internalId>328</internalId></linkedfrom><linkedfrom><srcid>CanSM.SWS_CanSM_00412</srcid><srcstatus/><internalId>329</internalId></linkedfrom><linkedfrom><srcid>CanSM.SWS_CanSM_00414</srcid><srcstatus/><internalId>331</internalId></linkedfrom><linkedfrom><srcid>CanSM.SWS_CanSM_00415</srcid><srcstatus/><internalId>332</internalId></linkedfrom><linkedfrom><srcid>CanSM.SWS_CanSM_00417</srcid><srcstatus/><internalId>334</internalId></linkedfrom><linkedfrom><srcid>CanSM.SWS_CanSM_00418</srcid><srcstatus/><internalId>335</internalId></linkedfrom><linkedfrom><srcid>CanSM.SWS_CanSM_00420</srcid><srcstatus/><internalId>337</internalId></linkedfrom><linkedfrom><srcid>CanSM.SWS_CanSM_00421</srcid><srcstatus/><internalId>338</internalId></linkedfrom><linkedfrom><srcid>CanSM.SWS_CanSM_00506</srcid><srcstatus/><internalId>417</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00363</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>37</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00364</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>38</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00365</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>39</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00071</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>17</internalId></provcov>
            <provcov>
               <linksto>CanSM.ECUC_CanSM_00133</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>281</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00028</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>15</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>262</internalId></specobject>

      <specobject>
         <id>CanSM.ASR40.DataTypes.CanSM_BswMCurrentStateType.2</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
         <version>1</version>
         <description>
        Definition of type CanSM_BswMCurrentStateType is enhanced
        with values CANSM_BSWM_BUS_OFF_L1 and CANSM_BSWM_BUS_OFF_L2
        for feature enhanced bus-off reporting.

        Name:         CanSM_BswMCurrentStateType
        Type:         Enumeration
        Range:        CANSM_BSWM_NO_COMMUNICATION
                      CANSM_BSWM_SILENT_COMMUNICATION
                      CANSM_BSWM_FULL_COMMUNICATION
                      CANSM_BSWM_BUS_OFF
                      CANSM_BSWM_CHANGE_BAUDRATE
                      CANSM_BSWM_BUS_OFF_L1
                      CANSM_BSWM_BUS_OFF_L2
        Description:  Can specific communication modes / states notified to the BswM module.
      </description>
         <comment>
        Created from section 8.2.3 CanSM_BswMCurrentStateType.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_BSWMCURRENTSTATETYPE</srcid><srcstatus/><internalId>739</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.SWS_CanSM_00598</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>475</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>263</internalId></specobject>

      <specobject>
         <id>CanSM.ASR40.Api.CanSM_ControllerBusOff.CallContext</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.1.0</source>
         <version>1</version>
         <description>
        The function CanSM_ControllerBusOff must be callable in a task as well as in an
        interrupt context.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dsn.CanSM.CallContext.CanSM_ControllerBusOff</srcid><srcstatus/><internalId>597</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>264</internalId></specobject>

      <specobject>
         <id>CanSM.ASR40.SWS_CanSM_00599.1</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
         <version>1</version>
         <description>
        The standardized common published parameters as required by BSW00402 in the
        General Requirements on Basic Software Modules [3] shall be published within the
        header file of this module.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_COMMON_PUBLISHED_PARAMETERS_HEADER_FILE</srcid><srcstatus/><internalId>603</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00599</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>89</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>265</internalId></specobject>

      <specobject>
         <id>CanSM.ASR40.SWS_CanSM_00599.2</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANStateManager.pdf, V2.2.0</source>
         <version>1</version>
         <description>
        The standardized common published parameters as required by BSW00402 in the
        General Requirements on Basic Software Modules [3] shall be provided in the
        BSW Module Description.
      </description>
         <comment>
        The standardized common published parameters are provided in CanSM_Bswmd.arxml.m4.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>man</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.man.CommonPublishedParameters</srcid><srcstatus/><internalId>536</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00599</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>89</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>266</internalId></specobject>

     <specobject>
        <id>CanSM.EB.CanSMDistributedChannelInit</id>
        <status>approved</status>
        <source>EB</source>
        <version>1</version>
        <description>
           There shall be a pre-compile-time parameter which specifies if CanSM channels Initialization Distribution is enabled,
           this parameter is only available when CanSMDistributedChannelProcessingSupport is ON.
           Name                CanSMDistributedChannelInitEnable
           Description         This parameter enables CanSM channels Initialization Distribution.
           Type                Boolean
           Default value       false
           ConfigurationClass  Pre-compile time   X   All Variants
           Link time           -
           Post-build time     -
           Scope /Dependency   scope: Local
        </description>
        <needscoverage>
           <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanSM_EBParameters.xdm.m4_190</srcid><srcstatus/><internalId>592</internalId></linkedfrom></coveredby></needscov>
           <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_Distribution_INIT</srcid><srcstatus/><internalId>711</internalId></linkedfrom></coveredby></needscov>
        <containerCovstatus>covered</containerCovstatus></needscoverage>
     <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>267</internalId></specobject>

     <specobject>
        <id>CanSM.EB.CanSMDistributedChannelInit_InitFunctions</id>
        <status>approved</status>
        <source>EB</source>
        <version>1</version>
        <description>
           If CanSMDistributedChannelInitEnable is enabled,
           and the optional parameter ComMChannelPartitionRef is configured for the referenced ComMChannel via CanSMComMNetworkHandleRef,
           a CanSM_Init_"SN"() shall be created (where "SN" is the shortName of the EcucPartition).
        </description>
        <needscoverage>
           <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate/src/CanSM_Partitions_Init.c_45</srcid><srcstatus/><internalId>576</internalId></linkedfrom></coveredby></needscov>
           <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_Distribution_INIT</srcid><srcstatus/><internalId>711</internalId></linkedfrom></coveredby></needscov>
        <containerCovstatus>covered</containerCovstatus></needscoverage>
     <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>268</internalId></specobject>

     <specobject>
        <id>CanSM.EB.CanSMDistributedChannels_InitFunctions_Initialization</id>
        <status>approved</status>
        <source>EB</source>
        <version>1</version>
        <description>
           If CanSMDistributedChannelInitEnable is enabled,
           the initialization of all CanSM channels shall be done in the first call of any init function.
        </description>
        <needscoverage>
           <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_Distribution_INIT</srcid><srcstatus/><internalId>711</internalId></linkedfrom></coveredby></needscov>
           <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate/src/CanSM_Partitions_Init.c_91</srcid><srcstatus/><internalId>577</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/CanSM_Init.c_84</srcid><srcstatus/><internalId>583</internalId></linkedfrom></coveredby></needscov>
        <containerCovstatus>covered</containerCovstatus></needscoverage>
     <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>269</internalId></specobject>

     <specobject>
        <id>CanSM.EB.CanSMDistributedChannels_InitFunctions_Re_Init</id>
        <status>approved</status>
        <source>EB</source>
        <version>1</version>
        <description>
           If CanSMDistributedChannelInitEnable is enabled,
           CanSM can be re-initialized only if all init functions were called.
        </description>
        <needscoverage>
           <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_Distribution_INIT</srcid><srcstatus/><internalId>711</internalId></linkedfrom></coveredby></needscov>
           <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate/src/CanSM_Partitions_Init.c_111</srcid><srcstatus/><internalId>578</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/CanSM_Init.c_107</srcid><srcstatus/><internalId>584</internalId></linkedfrom></coveredby></needscov>
        <containerCovstatus>covered</containerCovstatus></needscoverage>
     <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>270</internalId></specobject>

     <specobject>
        <id>CanSM.EB.CanSMDistributedChannels_InitFunctions_StateTransition</id>
        <status>approved</status>
        <source>EB</source>
        <version>1</version>
        <description>
           If CanSMDistributedChannelInitEnable is enabled,
           The Init function related state transition of each CAN network shall be assigned to the
           corresponding CanSM_Init_"SN" based on its ComMChannelPartitionRef.
        </description>
        <needscoverage>
           <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_Distribution_INIT</srcid><srcstatus/><internalId>711</internalId></linkedfrom></coveredby></needscov>
           <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate/src/CanSM_Partitions_Init.c_119</srcid><srcstatus/><internalId>579</internalId></linkedfrom></coveredby></needscov>
        <containerCovstatus>covered</containerCovstatus></needscoverage>
     <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>271</internalId></specobject>

     <specobject>
        <id>CanSM.EB.CanSMDistributedChannels_InitFunctions_StateTransition_Generic</id>
        <status>approved</status>
        <source>EB</source>
        <version>1</version>
        <description>
           If CanSMDistributedChannelInitEnable is enabled,
           CAN networks that do not have ComMChannelPartitionRef configured, state transition will be done
           in the generic CanSM_Init().
        </description>
        <needscoverage>
           <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_Distribution_INIT</srcid><srcstatus/><internalId>711</internalId></linkedfrom></coveredby></needscov>
           <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanSM_Init.c_116</srcid><srcstatus/><internalId>585</internalId></linkedfrom></coveredby></needscov>
        <containerCovstatus>covered</containerCovstatus></needscoverage>
     <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>272</internalId></specobject>

  </specobjects>
    <specobjects doctype="swurs">
    <specobject>
      <id>CanSM.ECUC_CanSM_00070</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name: CANSM_E_BUS_OFF
        Parameter Type: Symbolic name reference to [ DemEventParameter ]
        Parent Containers: CanSMDemEventParameterRefs,
        Description: Reference to configured DEM event to report bus off errors for this CAN network.
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Scope: LOCAL
        Dependency: Dem
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Multiplicity: true
        Post-Build-Variant-Value: true
        Multiplicity-Configuration Class: LINK, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Destination: /AUTOSAR/EcucDefs/Dem/DemConfigSet/DemEventParameter
        Destination type: ECUC-PARAM-CONF-CONTAINER-DEF
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.SWS_CanSM_00498</srcid><srcstatus/><internalId>58</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.SWS_CanSM_00522</srcid><srcstatus/><internalId>65</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.ErrorTable.CANSM_E_BUS_OFF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>261</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>273</internalId></specobject>
    <specobject>
      <id>CanSM.ECUC_CanSM_00123</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name: CanSMConfiguration
        Container Type: Container
        Sub-Containers: CanSMManagerNetwork 
        Description: This container contains the global parameters of the CanSM and sub containers, 
        which are for the CAN network specific configuration.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>274</internalId></specobject>
    <specobject>
      <id>CanSM.ECUC_CanSM_00126</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name: CanSMManagerNetwork
        Container Type: Sub-Container
        Parent Containers: CanSMConfiguration,
        Sub-Containers: CanSMController CanSMDemEventParameterRefs 
        Description: This container contains the CAN network specific parameters of each CAN network
        Lower Multiplicity: 1
        infinite
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>275</internalId></specobject>
    <specobject>
      <id>CanSM.ECUC_CanSM_00127</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name: CanSMDemEventParameterRefs
        Container Type: Sub-Container
        Parent Containers: CanSMManagerNetwork,
        Description: Container for the references to DemEventParameter elements which shall be invoked 
        using the API Dem_SetEventStatus in case the corresponding error occurs. The EventId is taken 
        from the referenced DemEventParameter's DemEventId symbolic value. The standardized errors are 
        provided in this container and can be extended by vendor-specific error references.
        Lower Multiplicity: 0
        Upper Multiplicity: 1
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.ChangedDemFunc</srcid><srcstatus/><internalId>553</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>276</internalId></specobject>
    <specobject>
      <id>CanSM.ECUC_CanSM_00128</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name: CanSMBorTimeL1
        Parameter Type: EcucFloatParamDef
        Parent Containers: CanSMManagerNetwork,
        Description: This time parameter defines in seconds the duration of the bus-off recovery time 
        in level 1 (short recovery time)
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: true
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Max-Value: 65.535 (Type: CLOSED)
        Min-Value: 0 (Type: CLOSED)
      </description>
      <comment>
        Refines Mainfunction period time.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.SWS_CanSM_00514</srcid><srcstatus/><internalId>63</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.ECUC_CanSM_00312</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>4</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>277</internalId></specobject>
    <specobject>
      <id>CanSM.ECUC_CanSM_00129</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name: CanSMBorTimeL2
        Parameter Type: EcucFloatParamDef
        Parent Containers: CanSMManagerNetwork,
        Description: This time parameter defines in seconds the duration of the bus-off recovery time 
        in level 2 (long recovery time)
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: true
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Max-Value: 65.535 (Type: CLOSED)
        Min-Value: 0 (Type: CLOSED)
      </description>
      <comment>
        Refines Mainfunction period time.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.SWS_CanSM_00515</srcid><srcstatus/><internalId>64</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.ECUC_CanSM_00312</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>4</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>278</internalId></specobject>
    <specobject>
      <id>CanSM.ECUC_CanSM_00130</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name: CanSMBorTimeTxEnsured
        Parameter Type: EcucFloatParamDef
        Parent Containers: CanSMManagerNetwork,
        Description: This parameter defines in seconds the duration of the bus-off event check. This 
        check assesses, if the recovery has been successful after the recovery reenables the transmit 
        path. If a new bus-off occurs during this time period, the CanSM assesses this bus-off as 
        sequential bus-off without successful recovery. Because a bus-off only can be detected, when 
        PDUs are transmitted, the time has to be great enough to ensure that PDUs are transmitted again 
        (e. g. time period of the fastest cyclic transmitted PDU of the COM module / 
        ComTxModeTimePeriodFactor)
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Dependency: CANSM_BOR_TX_CONFIRMATION_POLLING disabled
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: true
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Max-Value: 65.535 (Type: CLOSED)
        Min-Value: 0 (Type: CLOSED)
      </description>
      <comment>
        Refines Mainfunction period time.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.SWS_CanSM_00496</srcid><srcstatus/><internalId>408</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.ECUC_CanSM_00312</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>4</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>279</internalId></specobject>
    <specobject>
      <id>CanSM.ECUC_CanSM_00131</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name: CanSMBorCounterL1ToL2
        Parameter Type: EcucIntegerParamDef
        Parent Containers: CanSMManagerNetwork,
        Description: This threshold defines the count of bus-offs until the bus-off recovery switches 
        from level 1 (short recovery time) to level 2 (long recovery time)
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: true
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Max-Value: 255
        Min-Value: 0
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.SWS_CanSM_00514</srcid><srcstatus/><internalId>63</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.SWS_CanSM_00515</srcid><srcstatus/><internalId>64</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>280</internalId></specobject>
    <specobject>
      <id>CanSM.ECUC_CanSM_00133</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name: CanSMDevErrorDetect
        Parameter Type: EcucBooleanParamDef
        Parent Containers: CanSMGeneral,
        Description: Switches the development error detection and notification on or off.
          * true: detection and notification is enabled. * false: detection and 
        notification is disabled.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
      </description>
      <comment>
        Requirement redundant and replaced by a requirement CanSM.ASR40.DevelopmentErrors.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.DevelopmentErrors</srcid><srcstatus/><internalId>262</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>281</internalId></specobject>
    <specobject>
      <id>CanSM.ECUC_CanSM_00137</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name: CanSMTransceiverId
        Parameter Type: Symbolic name reference to [ CanIfTrcvCfg ]
        Parent Containers: CanSMManagerNetwork,
        Description: ID of the CAN transceiver assigned to the configured network handle. Reference to 
        one of the transceivers managed by the CanIf module.
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Scope: LOCAL
        Dependency: CanIf
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Multiplicity: true
        Post-Build-Variant-Value: true
        Multiplicity-Configuration Class: LINK, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Destination: /AUTOSAR/EcucDefs/CanIf/CanIfTrcvDrvCfg/CanIfTrcvCfg
        Destination type: ECUC-PARAM-CONF-CONTAINER-DEF
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>282</internalId></specobject>
    <specobject>
      <id>CanSM.ECUC_CanSM_00141</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name: CanSMControllerId
        Parameter Type: Symbolic name reference to [ CanIfCtrlCfg ]
        Parent Containers: CanSMController,
        Description: Unique handle to identify one certain CAN controller. Reference to one of the CAN 
        controllers managed by the CanIf module.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Dependency: CanIf
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: true
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Destination: /AUTOSAR/EcucDefs/CanIf/CanIfCtrlDrvCfg/CanIfCtrlCfg
        Destination type: ECUC-PARAM-CONF-CONTAINER-DEF
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>283</internalId></specobject>
    <specobject>
      <id>CanSM.ECUC_CanSM_00161</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name: CanSMComMNetworkHandleRef
        Parameter Type: Symbolic name reference to [ ComMChannel ]
        Parent Containers: CanSMManagerNetwork,
        Description: Unique handle to identify one certain CAN network. Reference to one of the network 
        handles configured for the ComM.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Dependency: ComM
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: true
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Destination: /AUTOSAR/EcucDefs/ComM/ComMConfigSet/ComMChannel
        Destination type: ECUC-PARAM-CONF-CONTAINER-DEF
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>284</internalId></specobject>
    <specobject>
      <id>CanSM.ECUC_CanSM_00311</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name: CanSMVersionInfoApi
        Parameter Type: EcucBooleanParamDef
        Parent Containers: CanSMGeneral,
        Description: Activate/Deactivate the version information API (CanSM_GetVersionInfo)
          true: version information API activated
          false: version information API deactivated
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Default value: false
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
      </description>
      <comment>
        Refined by more detailed, textual requirement.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.SWS_CanSM_00368</srcid><srcstatus/><internalId>42</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>285</internalId></specobject>
    <specobject>
      <id>CanSM.ECUC_CanSM_00312</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name: CanSMMainFunctionTimePeriod
        Parameter Type: EcucFloatParamDef
        Parent Containers: CanSMGeneral,
        Description: This parameter defines the cycle time of the function CanSM_MainFunction in 
        seconds
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Max-Value: INF (Type: OPEN)
        Min-Value: 0 (Type: OPEN)
      </description>
      <comment>
        Refined by configuration parameter derived from Mainfunction period.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.MFPeriodUpperLimit</srcid><srcstatus/><internalId>554</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>286</internalId></specobject>
    <specobject>
      <id>CanSM.ECUC_CanSM_00314</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name: CanSMGeneral
        Container Type: Container
        Description: Container for general pre-compile parameters of the CanSM module
        Lower Multiplicity: 1
        Upper Multiplicity: 1
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>287</internalId></specobject>
    <specobject>
      <id>CanSM.ECUC_CanSM_00335</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name: CanSMModeRequestRepetitionMax
        Parameter Type: EcucIntegerParamDef
        Parent Containers: CanSMConfiguration,
        Description: Specifies the maximal amount of mode request repetitions without a respective mode 
        indication from the CanIf module until the CanSM module reports a Development Error to the Det 
        and tries to go back to no communication.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: true
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Max-Value: 255
        Min-Value: 0
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.SWS_CanSM_00463</srcid><srcstatus/><internalId>55</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.SWS_CanSM_00480</srcid><srcstatus/><internalId>56</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.SWS_CanSM_00495</srcid><srcstatus/><internalId>57</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.SWS_CanSM_00523</srcid><srcstatus/><internalId>66</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.SWS_CanSM_00536</srcid><srcstatus/><internalId>68</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>288</internalId></specobject>
    <specobject>
      <id>CanSM.ECUC_CanSM_00336</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name: CanSMModeRequestRepetitionTime
        Parameter Type: EcucFloatParamDef
        Parent Containers: CanSMConfiguration,
        Description: Specifies in which time duration the CanSM module shall repeat mode change 
        requests by using the API of the CanIf module.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: true
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Max-Value: 65.535 (Type: CLOSED)
        Min-Value: 0 (Type: CLOSED)
      </description>
      <furtherinfo> 
        Justifying rule: WRN.swurs.needscoverage.count violation.
        Requirement is covered by more than 10 requirements
      </furtherinfo>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.SWS_CanSM_00443</srcid><srcstatus/><internalId>360</internalId></linkedfrom><linkedfrom><srcid>CanSM.SWS_CanSM_00445</srcid><srcstatus/><internalId>362</internalId></linkedfrom><linkedfrom><srcid>CanSM.SWS_CanSM_00449</srcid><srcstatus/><internalId>366</internalId></linkedfrom><linkedfrom><srcid>CanSM.SWS_CanSM_00454</srcid><srcstatus/><internalId>371</internalId></linkedfrom><linkedfrom><srcid>CanSM.SWS_CanSM_00457</srcid><srcstatus/><internalId>374</internalId></linkedfrom><linkedfrom><srcid>CanSM.SWS_CanSM_00461</srcid><srcstatus/><internalId>378</internalId></linkedfrom><linkedfrom><srcid>CanSM.SWS_CanSM_00467</srcid><srcstatus/><internalId>383</internalId></linkedfrom><linkedfrom><srcid>CanSM.SWS_CanSM_00471</srcid><srcstatus/><internalId>387</internalId></linkedfrom><linkedfrom><srcid>CanSM.SWS_CanSM_00475</srcid><srcstatus/><internalId>391</internalId></linkedfrom><linkedfrom><srcid>CanSM.SWS_CanSM_00479</srcid><srcstatus/><internalId>395</internalId></linkedfrom><linkedfrom><srcid>CanSM.SWS_CanSM_00486</srcid><srcstatus/><internalId>399</internalId></linkedfrom><linkedfrom><srcid>CanSM.SWS_CanSM_00490</srcid><srcstatus/><internalId>403</internalId></linkedfrom><linkedfrom><srcid>CanSM.SWS_CanSM_00494</srcid><srcstatus/><internalId>407</internalId></linkedfrom><linkedfrom><srcid>CanSM.SWS_CanSM_00512</srcid><srcstatus/><internalId>423</internalId></linkedfrom><linkedfrom><srcid>CanSM.SWS_CanSM_00527</srcid><srcstatus/><internalId>435</internalId></linkedfrom><linkedfrom><srcid>CanSM.SWS_CanSM_00535</srcid><srcstatus/><internalId>443</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.TimerUpperLimit</srcid><srcstatus/><internalId>555</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>289</internalId></specobject>
    <specobject>
      <id>CanSM.ECUC_CanSM_00338</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name: CanSMController
        Container Type: Sub-Container
        Parent Containers: CanSMManagerNetwork,
        Description: This container contains the controller IDs assigned to a CAN network.
        Lower Multiplicity: 1
        Upper Multiplicity: infinite
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>290</internalId></specobject>
    <specobject>
      <id>CanSM.ECUC_CanSM_00339</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name: CanSMBorTxConfirmationPolling
        Parameter Type: EcucBooleanParamDef
        Parent Containers: CanSMManagerNetwork,
        Description: This parameter shall configure, if the CanSM polls the 
        CanIf_GetTxConfirmationState API to decide the bus-off state to be recovered instead of using 
        the CanSMBorTimeTxEnsured parameter for this decision.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.SWS_CanSM_00496</srcid><srcstatus/><internalId>408</internalId></linkedfrom><linkedfrom><srcid>CanSM.SWS_CanSM_00497</srcid><srcstatus/><internalId>409</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>291</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00008</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The header file CanSM.h shall export CanSM module specific types and the APIs 
        CanSM_GetVersionInfo and CanSM_Init.
      </description>
      <comment>
        Wording of requirement is inaccurate. It does not define exactly which types and
        APIs shall be exported.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.CANSM008.1</srcid><srcstatus/><internalId>159</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>292</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00023</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        Service Name | CanSM_Init 
        Syntax 
        void CanSM_Init (const CanSM_ConfigType* ConfigPtr)
        Service ID [hex] | 0x00 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | ConfigPtr | Pointer to init structure for the post build parameters of the 
        CanSM 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | None 
        Description | This service initializes the CanSM module 
        Available via | CanSM.h 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_40027</srcid><srcstatus/><internalId>716</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>293</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00024</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        Service Name | CanSM_GetVersionInfo 
        Syntax 
        void CanSM_GetVersionInfo (Std_VersionInfoType* VersionInfo)
        Service ID [hex] | 0x01 
        Sync/Async | Synchronous 
        Reentrancy | Reentrant 
        Parameters (in) | None 
        Parameters (inout) | None 
        Parameters (out) | VersionInfo | Pointer to where to store the version information of this 
        module.
        Return value | None 
        Description | This service puts out the version information of this module (module ID, vendor 
        ID, vendor specific version numbers related to BSW00407)
        Available via | CanSM.h 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_40064</srcid><srcstatus/><internalId>607</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_40027</srcid><srcstatus/><internalId>716</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>294</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00062</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        Service Name | CanSM_RequestComMode 
        Syntax 
        Std_ReturnType CanSM_RequestComMode (NetworkHandleType network, ComM_ModeType ComM_Mode)
        Service ID [hex] | 0x02 
        Sync/Async | Asynchronous 
        Reentrancy | Reentrant (only for different network handles)
        Parameters (in) | network | Handle of destined communication network for request 
        ComM_Mode | Requested communication mode 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | Std_ReturnType | E_OK: Service accepted E_NOT_OK: Service denied 
        Description | This service shall change the communication mode of a CAN network to the 
        requested one.
        Available via | CanSM.h 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_40027</srcid><srcstatus/><internalId>716</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>295</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00063</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        Service Name | CanSM_GetCurrentComMode 
        Syntax 
        Std_ReturnType CanSM_GetCurrentComMode (NetworkHandleType network, ComM_ModeType* ComM_ModePtr)
        Service ID [hex] | 0x03 
        Sync/Async | Synchronous 
        Reentrancy | Reentrant 
        Parameters (in) | network | Network handle, whose current communication mode shall be put out 
        Parameters (inout) | None 
        Parameters (out) | ComM_ModePtr | Pointer, where to put out the current communication mode 
        Return value | Std_ReturnType | E_OK: Service accepted E_NOT_OK: Service denied 
        Description | This service shall put out the current communication mode of a CAN network.
        Available via | CanSM.h 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_40027</srcid><srcstatus/><internalId>716</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>296</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00064</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        Service Name | CanSM_ControllerBusOff 
        Syntax 
        void CanSM_ControllerBusOff (uint8 ControllerId)
        Service ID [hex] | 0x04
        Sync/Async | Synchronous 
        Reentrancy | Reentrant (only for different CanControllers)
        Parameters (in) | ControllerId | CAN controller, which detected a bus-off event 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | None 
        Description | This callback function notifies the CanSM about a bus-off event on a certain CAN 
        controller, which needs to be considered with the specified bus-off recovery handling for the 
        impacted CAN network.
        Available via | CanSM_CanIf.h 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.ExportHeaderForInterfaces</srcid><srcstatus/><internalId>572</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.CANSM011.1</srcid><srcstatus/><internalId>161</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_40027</srcid><srcstatus/><internalId>716</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>297</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00065</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        Service Name | CanSM_MainFunction 
        Syntax 
        void CanSM_MainFunction (void)
        Service ID [hex] | 0x05 
        Description | Scheduled function of the CanSM 
        Available via | SchM_CanSM.h 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.ExportHeaderForMF</srcid><srcstatus/><internalId>573</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_40027</srcid><srcstatus/><internalId>716</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>298</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00167</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The main function of the CanSM module shall operate the effects of the CanSM state machine (ref.
        to chapter [REF]), which the CanSM module shall implement for each configured CAN Network.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.SWS_CanSM_00428</srcid><srcstatus/><internalId>345</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>299</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00182</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        If the function CanSM_RequestComMode accepts the request, the request shall be considered by 
        the CanSM state machine (ref. to SWS_CanSM_00635)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.SWS_CanSM_00427</srcid><srcstatus/><internalId>344</internalId></linkedfrom><linkedfrom><srcid>CanSM.SWS_CanSM_00429</srcid><srcstatus/><internalId>346</internalId></linkedfrom><linkedfrom><srcid>CanSM.SWS_CanSM_00499</srcid><srcstatus/><internalId>411</internalId></linkedfrom><linkedfrom><srcid>CanSM.SWS_CanSM_00542</srcid><srcstatus/><internalId>448</internalId></linkedfrom><linkedfrom><srcid>CanSM.SWS_CanSM_00543</srcid><srcstatus/><internalId>449</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>300</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00183</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The function CanSM_RequestComMode shall call the function Det_ReportError with ErrorId 
        parameter CANSM_E_INVALID_NETWORK_HANDLE, if it does not accept the network handle of the 
        request.
      </description>
      <comment>
        Defines one exact usage of the DET error code CANSM_E_INVALID_NETWORK_HANDLE.
        Precondition: development error detection enabled.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_30004</srcid><srcstatus/><internalId>727</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.ErrorTable.CANSM_E_INVALID_NETWORK_HANDLE</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>253</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.DevelopmentErrors</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>262</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>301</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00184</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        If the CanSM module is not initialized, when the function CanSM_RequestComMode is called, then 
        this function shall call the function Det_ReportError with ErrorId parameter CANSM_E_UNINIT.
      </description>
      <comment>
        Defines one exact usage of the DET error code CANSM_E_UNINIT.
        Precondition: development error detection enabled.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_30004</srcid><srcstatus/><internalId>727</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.ErrorTable.CANSM_E_UNINIT</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>251</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.DevelopmentErrors</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>262</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>302</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00186</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The function CanSM_GetCurrentComMode shall put out the current communication mode for the 
        network handle (ref. to SWS_CanSM_00266) to the designated pointer of type ComM_ModeType, if it 
        accepts the request.
      </description>
      <comment>
        Remark: Because the CAN hardware needs a certain time to proceed with the request
        and there is currently no notification mechanism specified, the real hardware mode
        and the mode notified by the CanSM module might be different until the hardware
        is ready.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_S_RNOCOM_SYNC_NOPN</srcid><srcstatus/><internalId>632</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_FUCO_SYNC_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>653</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_S_RNOCO_SYNC_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>701</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOIN_NOCO_SYNC_PN</srcid><srcstatus/><internalId>746</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_S_RNOCOM_SYNC_PN</srcid><srcstatus/><internalId>763</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_FUCO_SYNC</srcid><srcstatus/><internalId>784</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_S_RNOCO_SYNC</srcid><srcstatus/><internalId>832</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>303</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00187</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The function CanSM_GetCurrentComMode shall call the function Det_ReportError with ErrorId 
        parameter CANSM_E_INVALID_NETWORK_HANDLE, if it does not accept the network handle of the 
        request.
      </description>
      <comment>
        Defines one exact usage of the DET error code CANSM_E_INVALID_NETWORK_HANDLE.
        Precondition: development error detection enabled.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_30002</srcid><srcstatus/><internalId>725</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.ErrorTable.CANSM_E_INVALID_NETWORK_HANDLE</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>253</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.DevelopmentErrors</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>262</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>304</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00188</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        If the CanSM module is not initialized (ref. to SWS_CANSM_00282), when the function 
        CanSM_GetCurrentComMode is called, then this function shall call the function Det_ReportError 
        with ErrorId parameter CANSM_E_UNINIT.
      </description>
      <comment>
        Defines one exact usage of the DET error code CANSM_E_UNINIT.
        Precondition: development error detection enabled.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_30002</srcid><srcstatus/><internalId>725</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.ErrorTable.CANSM_E_UNINIT</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>251</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.DevelopmentErrors</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>262</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>305</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00189</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        If the function CanSM_ControllerBusOff gets a Controller, which is not configured as 
        CanSMControllerId in the configuration of the CanSM module, it shall call the function 
        Det_ReportError with ErrorId parameter CANSM_E_PARAM_CONTROLLER.
      </description>
      <comment>
        Defines one exact usage of the DET error code CANSM_E_PARAM_CONTROLLER.
        Precondition: development error detection enabled.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_30007</srcid><srcstatus/><internalId>737</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.ErrorTable.CANSM_E_PARAM_CONTROLLER</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>254</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.DevelopmentErrors</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>262</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>306</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00190</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        If the CanSM module is not initialized, when the function CanSM_ControllerBusOff is called, 
        then the function CanSM_ControllerBusOff shall call the function Det_ReportError with ErrorId 
        parameter CANSM_E_UNINIT.
      </description>
      <comment>
        Defines one exact usage of the DET error code CANSM_E_UNINIT.
        Precondition: development error detection enabled.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_30007</srcid><srcstatus/><internalId>737</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.ErrorTable.CANSM_E_UNINIT</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>251</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.DevelopmentErrors</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>262</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>307</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00235</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        If the CanSM module is initialized and the input parameter Controller is one of the CAN 
        controllers configured with the parameter CanSMControllerId, this bus-off event shall be 
        considered by the CAN Network state machine (ref. to SWS_CanSM_00500)
      </description>
      <furtherinfo> 
        Justifying rule: WRN.swuts.needscoverage.count violation.
        A requirement can end up being satisified by numerous tests because
        the module can be subject to various scenarios 
      </furtherinfo>
      <comment>
        Additional remarks:
        1.) The call context is either on interrupt level (interrupt mode)
        or on task level (polling mode).
        2.) Reentrancy is necessary for multiple CAN controller usage.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_DEBOUNCE_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>688</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_DEBOUNCE_SYNC_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>689</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_BUS_OFF_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>692</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_L1_TO_L2_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>694</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_SUBSEQUENT_BUSOFF_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>703</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_BUS_OFF_LATE_BUS_OFF_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>705</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_30012</srcid><srcstatus/><internalId>723</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_DEBOUNCE</srcid><srcstatus/><internalId>819</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_DEBOUNCE_SYNC</srcid><srcstatus/><internalId>820</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_BUS_OFF</srcid><srcstatus/><internalId>823</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_L1_TO_L2</srcid><srcstatus/><internalId>825</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_SUBSEQUENT_BUSOFF</srcid><srcstatus/><internalId>834</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_BUS_OFF_LATE_BUS_OFF</srcid><srcstatus/><internalId>836</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>308</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00243</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        Module | Header File | Imported Type 
        Can | Can_GeneralTypes.h | Can_ControllerStateType 
        CanIf | CanIf.h | CanIf_NotifStatusType 
        CanIf.h | CanIf_PduModeType 
        CanTrcv | Can_GeneralTypes.h | CanTrcv_TrcvModeType 
        ComM | Rte_ComM_Type.h | ComM_ModeType 
        ComStack_Types | ComStack_Types.h | NetworkHandleType 
        Dem | Rte_Dem_Type.h | Dem_EventIdType 
        Rte_Dem_Type.h | Dem_EventStatusType 
        Std | Std_Types.h | Std_ReturnType 
        Std_Types.h | Std_VersionInfoType 
      </description>
      <comment>
        This requirement is informational only.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>309</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00266</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The CanSM module shall store the current network mode for each configured CAN network 
        internally (ref. to to ECUC_CanSM_00126)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.StoreNwState</srcid><srcstatus/><internalId>556</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.SWS_CanSM_00266</srcid><srcstatus/><internalId>29</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>310</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00278</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        If the CanSM state machine CANSM_BSM (ref. to Figure 7-1) is in the state 
        CANSM_BSM_S_NOT_INITIALIZED, it shall deny network mode requests from the ComM module (ref. to 
        SWS_CanSM_00062)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_30004</srcid><srcstatus/><internalId>727</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>311</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00282</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The CanSM module shall return E_NOT_OK for the API request CanSM_GetCurrentComMode until the 
        call of the provided API CanSM_Init (ref. to SWS_CANSM_00023)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.FncCallAfterInit</srcid><srcstatus/><internalId>557</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.SWS_CanSM_00282</srcid><srcstatus/><internalId>30</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>312</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00284</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The internally stored network modes of the CanSM module can have the values 
        COMM_NO_COMMUNICATION, COMM_SILENT_COMMUNICATION, COMM_FULL_COMMUNICATION.
      </description>
      <comment>
        This requirement is informational only.
        This requirement is not applicable: As long as the CanSM API functions are
        conformant to the specification, a different internal representation of the
        current communication mode is of no concern.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>313</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00360</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The function CanSM_GetCurrentComMode shall report the development error CANSM_E_PARAM_POINTER 
        to the DET, if the user of this function hands over a NULL-pointer as ComM_ModePtr.
      </description>
      <comment>
        Defines one exact usage of the DET error code CANSM_E_PARAM_POINTER.
        Precondition: development error detection enabled.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_30002</srcid><srcstatus/><internalId>725</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.ErrorTable.CANSM_E_PARAM_POINTER</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>252</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.DevelopmentErrors</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>262</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>314</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00369</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The function CanSM_RequestComMode shall accept its request, if the NetworkHandle parameter of 
        the request is a handle contained in the configuration of the CanSM module (ref. to 
        ECUC_CanSM_00161)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_NOCO_FUCO_SYNC_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>653</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_SICO_FUCO_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>670</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_30004</srcid><srcstatus/><internalId>727</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_FUCO_SYNC</srcid><srcstatus/><internalId>784</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_SICO_FUCO</srcid><srcstatus/><internalId>801</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>315</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00370</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The function CanSM_RequestComMode shall deny its request, if the NetworkHandle parameter of the 
        request is not a handle contained in the configuration of the CanSM module (ref. to 
        ECUC_CanSM_00161)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_30004</srcid><srcstatus/><internalId>727</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>316</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00371</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The function CanSM_GetCurrentComMode shall accept its request, if the NetworkHandle parameter 
        of the request is a handle contained in the configuration of the CanSM module (ref. to 
        ECUC_CanSM_00161)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_NOIN_NOCO_SYNC_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>652</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_FUCO_SYNC_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>653</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_S_RNOCO_SYNC_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>701</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_30003</srcid><srcstatus/><internalId>726</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOIN_NOCO_SYNC</srcid><srcstatus/><internalId>783</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_FUCO_SYNC</srcid><srcstatus/><internalId>784</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_S_RNOCO_SYNC</srcid><srcstatus/><internalId>832</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>317</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00372</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The function CanSM_GetCurrentComMode shall deny its request, if the NetworkHandle parameter of 
        the request is not a handle contained in the configuration of the CanSM module (ref. to 
        ECUC_CanSM_00161)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_30002</srcid><srcstatus/><internalId>725</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>318</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00374</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The function CanSM_GetVersionInfo shall report the development error CANSM_E_PARAM_POINTER to 
        the DET, if the user of this function hands over a NULL-pointer as VersionInfo.
      </description>
      <comment>
        Defines one exact usage of the DET error code CANSM_E_PARAM_POINTER.
        Precondition: development error detection enabled.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_30000</srcid><srcstatus/><internalId>724</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.ErrorTable.CANSM_E_PARAM_POINTER</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>252</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.DevelopmentErrors</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>262</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>319</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00385</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        If CanSM has repeated one of the CanIf API calls CanIf_SetControllerMode, CanIf_SetTrcvMode, 
        CanIf_ClearTrcvWufFlag or CanIf_CheckTrcvWakeFlag more often than CanSMModeRequestRepetitionMax 
        ref. to ECUC_CanSM_00335) without getting the return value E_OK or without getting the 
        corresponding mode indication callbacks CanSM_ControllerModeIndication, 
        CanSM_TransceiverModeIndication, CanSM_ClearTrcvWufFlagIndication or 
        CanSM_CheckTransceiverWakeFlagIndication, CanSM shall call the function Det_ReportRuntimeError 
        with ErrorId parameter CANSM_E_MODE_REQUEST_TIMEOUT.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.DevelopmentRuntimeErrors</srcid><srcstatus/><internalId>558</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>320</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00396</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        Service Name | CanSM_ControllerModeIndication 
        Syntax 
        void CanSM_ControllerModeIndication (uint8 ControllerId, Can_ControllerStateType ControllerMode)
        Service ID [hex] | 0x07
        Sync/Async | Synchronous 
        Reentrancy | Reentrant (only for different CAN controllers)
        Parameters (in) | ControllerId | CAN controller, whose mode has changed 
        ControllerMode | Notified CAN controller mode 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | None 
        Description | This callback shall notify the CanSM module about a CAN controller mode change.
        Available via | CanSM_CanIf.h 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.CtrlModeIndType</srcid><srcstatus/><internalId>559</internalId></linkedfrom><linkedfrom><srcid>dev.CanSM.ExportHeaderForInterfaces</srcid><srcstatus/><internalId>572</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.CANSM011.1</srcid><srcstatus/><internalId>161</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>321</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00397</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        If the function CanSM_ControllerModeIndication gets a ControllerId, which is not configured as 
        CanSMControllerId in the configuration of the CanSM module, it shall call the function 
        Det_ReportError with ErrorId parameter CANSM_E_PARAM_CONTROLLER.
      </description>
      <comment>
        Defines one exact usage of the DET error code CANSM_E_PARAM_CONTROLLER.
        Precondition: development error detection enabled.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_CONTROLLERMODEINDICATION</srcid><srcstatus/><internalId>728</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.ErrorTable.CANSM_E_PARAM_CONTROLLER</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>254</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.DevelopmentErrors</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>262</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>322</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00398</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        If the CanSM module is not initialized, when the function CanSM_ControllerModeIndication is 
        called, then the function CanSM_ControllerModeIndication shall call the function 
        Det_ReportError with ErrorId parameter CANSM_E_UNINIT.
      </description>
      <comment>
        Defines one exact usage of the DET error code CANSM_E_UNINIT.
        Precondition: development error detection enabled.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_CONTROLLERMODEINDICATION</srcid><srcstatus/><internalId>728</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.ErrorTable.CANSM_E_UNINIT</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>251</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.DevelopmentErrors</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>262</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>323</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00399</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        Service Name | CanSM_TransceiverModeIndication 
        Syntax 
        void CanSM_TransceiverModeIndication (uint8 TransceiverId, CanTrcv_TrcvModeType TransceiverMode)
        Service ID [hex] | 0x09
        Sync/Async | Synchronous 
        Reentrancy | Reentrant for different CAN Transceivers 
        Parameters (in) | TransceiverId | CAN transceiver, whose mode has changed 
        TransceiverMode | Notified CAN transceiver mode 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | None 
        Description | This callback shall notify the CanSM module about a CAN transceiver mode change.
        Available via | CanSM_CanIf.h 
      </description>
      <comment>
        Service ID and reentrancy were corrected according to the bugzilla issues
        http://www.autosar.org/bugzilla/show_bug.cgi?id=48693 and
        http://www.autosar.org/bugzilla/show_bug.cgi?id=49389.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.ExportHeaderForInterfaces</srcid><srcstatus/><internalId>572</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.CANSM011.1</srcid><srcstatus/><internalId>161</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_CBK_EXPORTS</srcid><srcstatus/><internalId>608</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>324</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00400</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        If the function CanSM_TransceiverModeIndication gets a TransceiverId, which is not configured 
        as CanSMTransceiverId in the configuration of the CanSM module, it shall call the function 
        Det_ReportError with ErrorId parameter CANSM_E_PARAM_TRANSCEIVER.
      </description>
      <comment>
        Defines one exact usage of the DET error code CANSM_E_PARAM_TRANSCEIVER.
        Precondition: development error detection enabled.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_TRANSCEIVERMODEINDICATION</srcid><srcstatus/><internalId>729</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.ErrorTable.CANSM_E_PARAM_TRANSCEIVER</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>255</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.DevelopmentErrors</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>262</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>325</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00401</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        If the CanSM module is not initialized, when the function CanSM_TransceiverModeIndication is 
        called, then the function CanSM_TransceiverModeIndication shall call the function 
        Det_ReportError with ErrorId parameter CANSM_E_UNINIT.
      </description>
      <comment>
        Defines one exact usage of the DET error code CANSM_E_UNINIT.
        Precondition: development error detection enabled.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_TRANSCEIVERMODEINDICATION</srcid><srcstatus/><internalId>729</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.ErrorTable.CANSM_E_UNINIT</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>251</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.DevelopmentErrors</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>262</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>326</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00410</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        Service Name | CanSM_TxTimeoutException 
        Syntax 
        void CanSM_TxTimeoutException (NetworkHandleType Channel)
        Service ID [hex] | 0x0b 
        Sync/Async | Synchronous 
        Reentrancy | Reentrant 
        Parameters (in) | Channel | Affected CAN network 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | None 
        Description | This function shall notify the CanSM module, that the CanNm has detected for the 
        affected partial CAN network a tx timeout exception, which shall be recovered within the 
        respective network state machine of the CanSM module.
        Available via | CanSM_CanIf.h 
      </description>
      <furtherinfo> 
        Justifying rule: WRN.swuts.needscoverage.count violation.
        A requirement can end up being satisified by numerous tests because
        the module can be subject to various scenarios 
      </furtherinfo>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.ExportHeaderForInterfaces</srcid><srcstatus/><internalId>572</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_PNSUPPORT_ON</srcid><srcstatus/><internalId>618</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_NOCO_TXTIMEOUTEXCEPTION_SYNC_NoPN_DET_ON</srcid><srcstatus/><internalId>633</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_SICO_TXTIMEOUTEXCEPTION_SYNC_NoPN_DET_ON</srcid><srcstatus/><internalId>634</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_FUCO_TXTIMEOUTEXCEPTION_SYNC_NoPN_DET_ON</srcid><srcstatus/><internalId>635</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_NOCO_TXTIMEOUTEXCEPTION_NOPN</srcid><srcstatus/><internalId>636</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_FUCO_TXTIMEOUTEXCEPTION_NOPN</srcid><srcstatus/><internalId>637</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_TXTIMEOUTEXCEPTION_ASYNC_NoPN_DET_ON</srcid><srcstatus/><internalId>638</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_TXTIMEOUTEXCEPTION_SYNC_NoPN_DET_ON</srcid><srcstatus/><internalId>639</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_REPEATED_TXTIMEOUTEXCEPTION_NoPN_DET_ON</srcid><srcstatus/><internalId>646</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_NOCO_TXTIMEOUTEXCEPTION_NOPN_Distribution</srcid><srcstatus/><internalId>648</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_FUCO_TXTIMEOUTEXCEPTION_NOPN_Distribution</srcid><srcstatus/><internalId>649</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_NOCO_TXTIMEOUTEXCEPTION_SYNC</srcid><srcstatus/><internalId>764</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_SICO_TXTIMEOUTEXCEPTION_SYNC</srcid><srcstatus/><internalId>765</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_FUCO_TXTIMEOUTEXCEPTION_SYNC</srcid><srcstatus/><internalId>766</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_FUCO_NOCO_TXTIMEOUTEXCEPTION_PN</srcid><srcstatus/><internalId>767</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_FUCO_TXTIMEOUTEXCEPTION_PN</srcid><srcstatus/><internalId>768</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_TXTIMEOUTEXCEPTION_ASYNC</srcid><srcstatus/><internalId>769</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_TXTIMEOUTEXCEPTION_SYNC</srcid><srcstatus/><internalId>770</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_REPEATED_TXTIMEOUTEXCEPTION</srcid><srcstatus/><internalId>778</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>327</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00411</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The function CanSM_TxTimeoutException shall report CANSM_E_UNINIT to the DET, if the CanSM is 
        not initialized yet.
      </description>
      <comment>
        Defines one exact usage of the DET error code CANSM_E_UNINIT.
        Precondition: development error detection enabled.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_TXTIMEOUTEXCEPTION</srcid><srcstatus/><internalId>734</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.ErrorTable.CANSM_E_UNINIT</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>251</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.DevelopmentErrors</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>262</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>328</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00412</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        If the function CanSM_TxTimeoutException is referenced with a Channel, which is not configured 
        as CanSMNetworkHandle in the CanSM configuration, it shall report 
        CANSM_E_INVALID_NETWORK_HANDLE to the DET.
      </description>
      <comment>
        Defines one exact usage of the DET error code CANSM_E_INVALID_NETWORK_HANDLE.
        Precondition: development error detection enabled.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_TXTIMEOUTEXCEPTION</srcid><srcstatus/><internalId>734</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.ErrorTable.CANSM_E_INVALID_NETWORK_HANDLE</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>253</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.DevelopmentErrors</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>262</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>329</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00413</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        Service Name | CanSM_ClearTrcvWufFlagIndication 
        Syntax 
        void CanSM_ClearTrcvWufFlagIndication (uint8 Transceiver)
        Service ID [hex] | 0x08
        Sync/Async | Synchronous 
        Reentrancy | Reentrant for different CAN Transceivers 
        Parameters (in) | Transceiver | Requested Transceiver 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | None 
        Description | This callback function shall indicate the CanIf_ClearTrcvWufFlag API process end 
        for the notified CAN Transceiver.
        Available via | CanSM_CanIf.h 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.ExportHeaderForInterfaces</srcid><srcstatus/><internalId>572</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.CANSM011.1</srcid><srcstatus/><internalId>161</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_PNSUPPORT_ON</srcid><srcstatus/><internalId>618</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>330</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00414</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The function CanSM_ClearTrcvWufFlagIndication shall report CANSM_E_UNINIT to the DET, if the 
        CanSM is not initialized yet.
      </description>
      <comment>
        Defines one exact usage of the DET error code CANSM_E_UNINIT.
        Precondition: development error detection enabled.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_CLEARTRCVWUFFLAGINDICATION</srcid><srcstatus/><internalId>731</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.ErrorTable.CANSM_E_UNINIT</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>251</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.DevelopmentErrors</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>262</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>331</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00415</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        If the function CanSM_ClearTrcvWufFlagIndication gets a TransceiverId, which is not configured 
        ref. to ECUC_CanSM_00137) in the configuration of the CanSM module, it shall call the function 
        Det_ReportError with ErrorId parameter CANSM_E_PARAM_TRANSCEIVER.
      </description>
      <comment>
        Defines one exact usage of the DET error code CANSM_E_PARAM_TRANSCEIVER.
        Precondition: development error detection enabled.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_CLEARTRCVWUFFLAGINDICATION</srcid><srcstatus/><internalId>731</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.ErrorTable.CANSM_E_PARAM_TRANSCEIVER</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>255</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.DevelopmentErrors</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>262</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>332</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00416</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        Service Name | CanSM_CheckTransceiverWakeFlagIndication 
        Syntax 
        void CanSM_CheckTransceiverWakeFlagIndication (uint8 Transceiver)
        Service ID [hex] | 0x0a
        Sync/Async | Synchronous 
        Reentrancy | Reentrant for different CAN Transceivers 
        Parameters (in) | Transceiver | Requested Transceiver 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | None 
        Description | This callback function indicates the CanIf_CheckTrcvWakeFlag API process end for 
        the notified CAN Transceiver.
        Available via | CanSM_CanIf.h 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.ExportHeaderForInterfaces</srcid><srcstatus/><internalId>572</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.CANSM011.1</srcid><srcstatus/><internalId>161</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_PNSUPPORT_ON</srcid><srcstatus/><internalId>618</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>333</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00417</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The function CanSM_CheckTransceiverWakeFlagIndication shall report CANSM_E_UNINIT to the DET, 
        if the CanSM module is not initialized yet.
      </description>
      <comment>
        Defines one exact usage of the DET error code CANSM_E_UNINIT.
        Precondition: development error detection enabled.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_CHECKTRANSCEIVERWAKEFLAGINDICATION</srcid><srcstatus/><internalId>732</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.ErrorTable.CANSM_E_UNINIT</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>251</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.DevelopmentErrors</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>262</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>334</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00418</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        If the function CanSM_CheckTransceiverWakeFlagIndication gets a TransceiverId, which is not 
        configured (ref. to ECUC_CanSM_00137) in the configuration of the CanSM module, it shall call 
        the function Det_ReportError with ErrorId parameter CANSM_E_PARAM_TRANSCEIVER.
      </description>
      <comment>
        Defines one exact usage of the DET error code CANSM_E_PARAM_TRANSCEIVER.
        Precondition: development error detection enabled.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_CHECKTRANSCEIVERWAKEFLAGINDICATION</srcid><srcstatus/><internalId>732</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.ErrorTable.CANSM_E_PARAM_TRANSCEIVER</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>255</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.DevelopmentErrors</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>262</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>335</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00419</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        Service Name | CanSM_ConfirmPnAvailability 
        Syntax 
        void CanSM_ConfirmPnAvailability (uint8 TransceiverId)
        Service ID [hex] | 0x06
        Sync/Async | Synchronous 
        Reentrancy | Reentrant 
        Parameters (in) | TransceiverId | CAN transceiver, which was checked for PN availability 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | None 
        Description | This callback function indicates that the transceiver is running in PN 
        communication mode.
        Available via | CanSM_CanIf.h 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.ExportHeaderForInterfaces</srcid><srcstatus/><internalId>572</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.CANSM011.1</srcid><srcstatus/><internalId>161</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_PNSUPPORT_ON</srcid><srcstatus/><internalId>618</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>336</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00420</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The function CanSM_ConfirmPnAvailability shall report CANSM_E_UNINIT to the DET, if the CanSM 
        module is not initialized yet.
      </description>
      <comment>
        Defines one exact usage of the DET error code CANSM_E_UNINIT.
        Precondition: development error detection enabled.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_CONFIRMPNAVAILABILITY</srcid><srcstatus/><internalId>733</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.ErrorTable.CANSM_E_UNINIT</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>251</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.DevelopmentErrors</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>262</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>337</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00421</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        If the function CanSM_ConfirmPnAvailability gets a TransceiverId, which is not configured (ref.
        to ECUC_CanSM_00137) in the configuration of the CanSM module, it shall call the function 
        Det_ReportError with ErrorId parameter CANSM_E_PARAM_TRANSCEIVER.
      </description>
      <comment>
        Defines one exact usage of the DET error code CANSM_E_PARAM_TRANSCEIVER.
        Precondition: development error detection enabled.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_CONFIRMPNAVAILABILITY</srcid><srcstatus/><internalId>733</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.ErrorTable.CANSM_E_PARAM_TRANSCEIVER</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>255</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.DevelopmentErrors</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>262</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>338</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00422</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        If the CanIf module notifies PN availability for a configured CAN Transceiver to the CanSM 
        module with the callback function CanSM_ConfirmPnAvailability (ref. to SWS_CanSM_00419), then 
        the CanSM module shall call the API CanNm_ConfirmPnAvailability (ref. to chapter [REF]) with 
        the related CAN network as channel to confirm the PN availability to the CanNm module.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_CONFIRMPNAVAILABILITY</srcid><srcstatus/><internalId>733</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00546</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>450</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>339</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00423</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        If the CanSM module is requested with the function CanSM_Init (ref. to chapter [REF]), this 
        shall trigger the CanSM state machines (ref. to Figure 7-1) for all configured CAN Networks (
        ref. to ECUC_CanSM_00126) with the trigger CanSM_Init.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSM.T_NOT_INITIALIZED_PRE_NOCOM.NoPn</srcid><srcstatus/><internalId>195</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_NOT_INITIALIZED_PRE_NOCOM.Pn</srcid><srcstatus/><internalId>196</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>340</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00424</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        After PowerOn the CanSM state machines (ref. to Figure 7-1) shall be in the state 
        CANSM_BSM_NOT_INITIALIZED.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_T_NOIN_NOCO_SYNC_SingleNetNoTrcv_DET_ON</srcid><srcstatus/><internalId>652</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_30004</srcid><srcstatus/><internalId>727</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOIN_NOCO_SYNC_PN</srcid><srcstatus/><internalId>746</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOIN_NOCO_SYNC</srcid><srcstatus/><internalId>783</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>341</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00425</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The API request CanSM_RequestComMode (ref. to SWS_CanSM_00635) with the parameter ComM_Mode 
        equal to COMM_FULL_COMMUNICATION shall trigger the state machine with T_FULL_COM_MODE_REQUEST, 
        if the function parameter network matches the configuration parameter CANSM_NETWORK_HANDLE (ref.
        to ECUC_CanSM_00161)
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.EB.Transitions.NoTransceiver.3</srcid><srcstatus/><internalId>107</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_SILENTCOM_FULLCOM</srcid><srcstatus/><internalId>174</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_NOCOM_PRE_FULLCOM</srcid><srcstatus/><internalId>175</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>342</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00426</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The API request CanSM_RequestComMode (ref. to SWS_CanSM_00635) with the parameter ComM_Mode 
        equal to COMM_NO_COMMUNICATION shall trigger the state machine with T_NO_COM_MODE_REQUEST, if 
        the function parameter network matches the configuration parameter CANSM_NETWORK_HANDLE (ref. 
        to ECUC_CanSM_00161)
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSM.T_SILENTCOM_PRE_NOCOM.NoPn</srcid><srcstatus/><internalId>189</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_SILENTCOM_PRE_NOCOM.Pn</srcid><srcstatus/><internalId>190</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>343</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00427</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The guarding condition G_FULL_COM_MODE_REQUESTED of the CanSM_BSM state machine (ref. to Figure 
        7-1) shall evaluate, if the latest accepted communication mode request with 
        CanSM_RequestComMode (ref. to SWS_CanSM_00635) for the respective network handle of the state 
        machine has been with the parameter ComM_Mode equal to COMM_FULL_COMMUNICATION.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_FULLCOM</srcid><srcstatus/><internalId>171</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00182</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>300</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>344</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00428</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        All effects of the CanSM state machine CANSM_BSM (ref. to Figure 7-1) shall be operated in the 
        context of the CanSM main function (ref. to SWS_CanSM_00065)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CANSM.StateTransition</srcid><srcstatus/><internalId>547</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00167</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>299</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>345</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00429</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The guarding condition G_SILENT_COM_MODE_REQUESTED of the CanSM_BSM state machine (ref. to 
        Figure 7-1) shall evaluate, if the latest accepted communication mode request with 
        CanSM_RequestComMode (ref. to SWS_CanSM_00635) for the respective network handle of the state 
        machine has been with the parameter ComM_Mode equal to COMM_SILENT_COMMUNICATION.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_SILENTCOM</srcid><srcstatus/><internalId>188</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00182</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>300</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>346</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00430</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The effect E_NOCOM of the CanSM_BSM state machine (ref. to Figure 7-1) shall change the 
        internally stored network mode (ref. to SWS_CanSM_00266) of the addressed CAN network to 
        COMM_NO_COMMUNICATION.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.ENoComIndication</srcid><srcstatus/><internalId>560</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.SWS_CanSM_00430</srcid><srcstatus/><internalId>51</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>347</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00431</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The effect E_PRE_NOCOM of the CanSM_BSM state machine (ref. to Figure 7-1) shall call for the 
        corresponding CAN network the API BswM_CanSM_CurrentState with the parameters Network := 
        CanSMComMNetworkHandleRef and CurrentState := CANSM_BSWM_NO_COMMUNICATION.
      </description>
      <furtherinfo> 
        Justifying rule: WRN.swurs.needscoverage.count violation.
        The requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine, It is not complete nor consistent All requirement of this kind
        are coverd by more than 10 requirements describing the complete state transition.
      </furtherinfo>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR41.TX_TIMEOUT_EXCEPTION.T_S_CC_STOPPED_PRE_NOCOM.Pn</srcid><srcstatus/><internalId>101</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR41.TX_TIMEOUT_EXCEPTION.T_S_CC_STARTED_PRE_NOCOM.Pn</srcid><srcstatus/><internalId>102</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_FULLCOM_PRE_NOCOM.NoPn</srcid><srcstatus/><internalId>168</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_FULLCOM_PRE_NOCOM.Pn</srcid><srcstatus/><internalId>169</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.NoPn.1</srcid><srcstatus/><internalId>182</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.Pn.1</srcid><srcstatus/><internalId>183</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.NoPn.2</srcid><srcstatus/><internalId>184</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.Pn.2</srcid><srcstatus/><internalId>185</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.NoPn.3</srcid><srcstatus/><internalId>186</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.Pn.3</srcid><srcstatus/><internalId>187</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_SILENTCOM_PRE_NOCOM.NoPn</srcid><srcstatus/><internalId>189</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_SILENTCOM_PRE_NOCOM.Pn</srcid><srcstatus/><internalId>190</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_NOT_INITIALIZED_PRE_NOCOM.NoPn</srcid><srcstatus/><internalId>195</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_NOT_INITIALIZED_PRE_NOCOM.Pn</srcid><srcstatus/><internalId>196</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>348</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00432</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The effect E_BR_END_FULL_COM of the CanSM_BSM state machine (ref. to Figure 7-1) shall be the 
        same as E_FULL_COM (ref. to chapter [REF]
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_FULLCOM</srcid><srcstatus/><internalId>171</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>349</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00433</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The effect E_BR_END_SILENT_COM of the CanSM_BSM state machine (ref. to Figure 7-1) shall be the 
        same as E_FULL_TO_SILENT_COM (ref. to chapter [REF]
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_SILENTCOM</srcid><srcstatus/><internalId>188</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>350</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00434</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The effect E_FULL_TO_SILENT_COM of the CanSM_BSM state machine (ref. to Figure 7-1) shall call 
        at 1st place for the corresponding CAN network the API BswM_CanSM_CurrentState with the 
        parameters Network := CanSMComMNetworkHandleRef and CurrentState := 
        CANSM_BSWM_SILENT_COMMUNICATION.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSM.T_FULLCOM_SILENTCOM.BusOffCheck.1</srcid><srcstatus/><internalId>108</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_FULLCOM_SILENTCOM.BusOffCheck.2</srcid><srcstatus/><internalId>109</internalId></linkedfrom><linkedfrom><srcid>CanSM.EB.BSM.T_FULLCOM_SILENTCOM.S_TX_OFF.1</srcid><srcstatus/><internalId>110</internalId></linkedfrom><linkedfrom><srcid>CanSM.EB.BSM.T_FULLCOM_SILENTCOM.S_TX_OFF.2</srcid><srcstatus/><internalId>111</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_FULLCOM_SILENTCOM.1</srcid><srcstatus/><internalId>172</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_FULLCOM_SILENTCOM.2</srcid><srcstatus/><internalId>173</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_SILENTCOM</srcid><srcstatus/><internalId>188</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>351</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00435</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        After considering SWS_CANSM_00539 and SWS_CanSM_00647 in context of the effect E_FULL_COM of 
        the CanSM_BSM state machine (ref. to Figure 7-1), the CanSM module shall call the API 
        ComM_BusSM_ModeIndication for the corresponding CAN network with the parameters Channel := 
        CanSMComMNetworkHandleRef (ref. to ECUC_CanSM_00161) and ComMode := COMM_FULL_COMMUNICATION.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.EFullComOrder</srcid><srcstatus/><internalId>561</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>352</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00436</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The guarding condition CANSM_BSM_G_PN_NOT_SUPPORTED of the sub state machine 
        CANSM_BSM_S_PRE_NO_COM (ref. to Figure 7-3) shall evaluate, if the configuration parameter 
        CanTrcvPnEnabled (ref. to [REF], ECUC_CanTrcv_00172) is FALSE, which is available via the 
        reference CanSMTransceiverId (ref. to ECUC_CanSM_00137) or if no CanSMTransceiverId is 
        configured at all.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.TrcvPnSupport</srcid><srcstatus/><internalId>562</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>353</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00437</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The guarding condition CANSM_BSM_G_PN_SUPPORTED of the sub state machine CANSM_BSM_S_PRE_NO_COM 
        ref. to Figure 7-3) shall evaluate, if a CanSMTransceiverId (ref. to ECUC_CanSM_00137) is 
        configured and if the configuration parameter CanTrcvPnEnabled (ref. to [REF], 
        ECUC_CanTrcv_00172) is TRUE, which is available via the reference CanSMTransceiverId (ref. to 
        ECUC_CanSM_00137)
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.TrcvPnSupport</srcid><srcstatus/><internalId>562</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>354</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00438</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        As long the sub state machine CANSM_BSM_DeinitPnSupported (ref. to Figure 7-4) is in the state 
        S_PN_CLEAR_WUF, the CanSM module operate the do action DO_CLEAR_TRCV_WUF and therefore repeat 
        the API request CanIf_ClrTrcvWufFlag (ref. to chapter [REF]) and use the configured Transceiver 
        ref. to ECUC_CanSM_00137) as API function parameter.
      </description>
      <furtherinfo> 
        Justifying rule: WRN.swurs.needscoverage.count violation.
        The requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine, It is not complete nor consistent All requirement of this kind
        are coverd by more than 10 requirements describing the complete state transition.
      </furtherinfo>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR41.TX_TIMEOUT_EXCEPTION.T_S_CC_STOPPED_PRE_NOCOM.Pn</srcid><srcstatus/><internalId>101</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR41.TX_TIMEOUT_EXCEPTION.T_S_CC_STARTED_PRE_NOCOM.Pn</srcid><srcstatus/><internalId>102</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_FULLCOM_PRE_NOCOM.Pn</srcid><srcstatus/><internalId>169</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.Pn.1</srcid><srcstatus/><internalId>177</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.Pn.2</srcid><srcstatus/><internalId>179</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.Pn.3</srcid><srcstatus/><internalId>181</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.Pn.1</srcid><srcstatus/><internalId>183</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.Pn.2</srcid><srcstatus/><internalId>185</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.Pn.3</srcid><srcstatus/><internalId>187</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_SILENTCOM_PRE_NOCOM.Pn</srcid><srcstatus/><internalId>190</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_NOT_INITIALIZED_PRE_NOCOM.Pn</srcid><srcstatus/><internalId>196</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSMDeInitPn.T_S_PN_CLEAR_WUF_S_PN_CLEAR_WUF.1</srcid><srcstatus/><internalId>198</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSMDeInitPn.T_S_PN_CLEAR_WUF_S_PN_CLEAR_WUF.2</srcid><srcstatus/><internalId>199</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSMDeInitPn.T_S_PN_CC_STOPPED_S_PN_CLEAR_WUF</srcid><srcstatus/><internalId>202</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSMDeInitPn.T_S_TRCV_NORMAL_S_PN_CLEAR_WUF</srcid><srcstatus/><internalId>205</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSMDeInitPn.T_S_TRCV_STANDBY_S_PN_CLEAR_WUF</srcid><srcstatus/><internalId>208</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSMDeInitPn.T_S_CHECK_WFLAG_IN_CC_SLEEP_S_PN_CLEAR_WUF</srcid><srcstatus/><internalId>212</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSMDeInitPn.T_S_CHECK_WFLAG_IN_NOT_CC_SLEEP_S_PN_CLEAR_WUF.1</srcid><srcstatus/><internalId>213</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSMDeInitPn.T_S_CHECK_WFLAG_IN_NOT_CC_SLEEP_S_PN_CLEAR_WUF.2</srcid><srcstatus/><internalId>215</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>355</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00439</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The guarding condition G_PN_CLEAR_WUF_E_OK of the sub state machine CANSM_BSM_DeinitPnSupported 
        ref. to Figure 7-4) shall be passed, if the API call of SWS_CanSM_00438 has returned E_OK.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMDeInitPn.T_S_PN_CLEAR_WUF_S_PN_CLEAR_WUF.1</srcid><srcstatus/><internalId>198</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>356</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00440</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The callback function CanSM_ClearTrcvWufFlagIndication (ref. to SWS_CanSM_00413) shall trigger 
        the sub state machine CANSM_BSM_DeinitPnSupported (ref. to Figure 7-4) of the CAN network with 
        T_CLEAR_WUF_INDICATED, if the function parameter Transceiver of 
        CanSM_ClearTrcvWufFlagIndication matches to the configured CAN Transceiver (ref. to 
        ECUC_CanSM_00137) of the CAN network.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMDeInitPn.T_S_PN_CLEAR_WUF_S_PN_CC_STOPPED</srcid><srcstatus/><internalId>197</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>357</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00441</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        As long the sub state machine CANSM_BSM_DeinitPnSupported (ref. to Figure 7-4) is in the state 
        S_CC_STOPPED, the CanSM module shall operate the do action DO_SET_CC_MODE_STOPPED and therefore 
        repeat for all configured CAN controllers of the CAN network (ref. to ECUC_CanSM_00141) the API 
        request CanIf_SetControllerMode (ref. to chapter [REF]) with ControllerMode equal to 
        CAN_CS_STOPPED, if the current CAN controller mode (ref. to SWS_CanSM_00638) is different.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.CtrlModeReqCheck</srcid><srcstatus/><internalId>574</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMDeInitPn.T_S_PN_CLEAR_WUF_S_PN_CC_STOPPED</srcid><srcstatus/><internalId>197</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSMDeInitPn.T_S_PN_CC_STOPPED_S_PN_CC_STOPPED</srcid><srcstatus/><internalId>201</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>358</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00442</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The guarding condition G_CC_STOPPED_E_OK of the sub state machine CANSM_BSM_DeinitPnSupported (
        ref. to Figure 7-4) shall be passed, if all API calls of SWS_CanSM_00441 have returned E_OK.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMDeInitPn.T_S_PN_CC_STOPPED_S_PN_CC_STOPPED</srcid><srcstatus/><internalId>201</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>359</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00443</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        After a timeout of CANSM_MODEREQ_REPEAT_TIME (ref. to ECUC_CanSM_00336) for the callback 
        function CanSM_ClearTrcvWufFlagIndication (ref. to SWS_CanSM_00440), this condition shall 
        trigger the sub state machine CANSM_BSM_DeinitPnSupported (ref. to Figure 7-4) of the 
        respective network with T_CLEAR_WUF_TIMEOUT.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMDeInitPn.T_S_PN_CLEAR_WUF_S_PN_CLEAR_WUF.1</srcid><srcstatus/><internalId>198</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ECUC_CanSM_00336</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>289</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>360</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00444</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        If CanSM module has got all mode indications (ref. to SWS_CanSM_00396) for the configured CAN 
        controllers of the CAN network (ref. to ECUC_CanSM_00141) after the respective requests to stop 
        the CAN controllers of the CAN network (ref. to SWS_CanSM_00442), this shall trigger the sub 
        state machine CANSM_BSM_DeinitPnSupported (ref. to Figure 7-4) of the CAN network with 
        T_CC_STOPPED_INDICATED.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMDeInitPn.T_S_PN_CC_STOPPED_S_TRCV_NORMAL</srcid><srcstatus/><internalId>200</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>361</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00445</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        After a timeout of CANSM_MODEREQ_REPEAT_TIME (ref. to ECUC_CanSM_00336) for all supposed 
        controller stopped mode indications (ref. to SWS_CanSM_00444), this condition shall trigger the 
        sub state machine CANSM_BSM_DeinitPnSupported (ref. to Figure 7-4) of the respective network 
        with T_CC_STOPPED_TIMEOUT.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMDeInitPn.T_S_PN_CC_STOPPED_S_PN_CC_STOPPED</srcid><srcstatus/><internalId>201</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ECUC_CanSM_00336</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>289</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>362</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00446</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        As long the sub state machine CANSM_BSM_DeinitPnSupported (ref. to Figure 7-4) is in the state 
        S_TRCV_NORMAL, the CanSM module shall operate the do action DO_SET_TRCV_MODE_NORMAL and 
        therefore repeat for the configured CAN Transceiver of the CAN network (ref. to 
        ECUC_CanSM_00137) the API request CanIf_SetTrcvMode (ref. to chapter [REF]) with 
        TransceiverMode equal to CANTRCV_TRCVMODE_NORMAL.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMDeInitPn.T_S_PN_CC_STOPPED_S_TRCV_NORMAL</srcid><srcstatus/><internalId>200</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSMDeInitPn.T_S_TRCV_NORMAL_S_TRCV_NORMAL</srcid><srcstatus/><internalId>204</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>363</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00447</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The guarding condition G_TRCV_NORMAL_E_OK of the sub state machine CANSM_BSM_DeinitPnSupported 
        ref. to Figure 7-4) shall be passed, if the API call of SWS_CanSM_00446 has returned E_OK.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMDeInitPn.T_S_TRCV_NORMAL_S_TRCV_NORMAL</srcid><srcstatus/><internalId>204</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>364</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00448</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        If CanSM module has got the CANTRCV_TRCVMODE_NORMAL mode indication (ref. to SWS_CanSM_00399) 
        for the configured CAN Transceiver of the CAN network (ref. to ECUC_CanSM_00137) after the 
        respective request (ref. to SWS_CanSM_00446), this shall trigger the sub state machine 
        CANSM_BSM_DeinitPnSupported (ref. to Figure 7-4) of the CAN network with 
        T_TRCV_NORMAL_INDICATED.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMDeInitPn.T_S_TRCV_NORMAL_S_TRCV_STANDBY</srcid><srcstatus/><internalId>203</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>365</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00449</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        After a timeout of CANSM_MODEREQ_REPEAT_TIME (ref. to ECUC_CanSM_00336) for the supposed 
        transceiver normal indication (ref. to SWS_CanSM_00448), this condition shall trigger the sub 
        state machine CANSM_BSM_DeinitPnSupported (ref. to Figure 7-4) of the respective network with 
        T_TRCV_NORMAL_TIMEOUT.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMDeInitPn.T_S_TRCV_NORMAL_S_TRCV_NORMAL</srcid><srcstatus/><internalId>204</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ECUC_CanSM_00336</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>289</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>366</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00450</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        As long the sub state machine CANSM_BSM_DeinitPnSupported (ref. to Figure 7-4) is in the state 
        S_TRCV_STANDBY, the CanSM module shall operate the do action DO_SET_TRCV_STANDBY and therefore 
        repeat for the configured CAN Transceiver of the CAN network (ref. to ECUC_CanSM_00137) the API 
        request CanIf_SetTrcvMode (ref. to chapter [REF]) with TransceiverMode equal to 
        CANTRCV_TRCVMODE_STANDBY.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMDeInitPn.T_S_TRCV_NORMAL_S_TRCV_STANDBY</srcid><srcstatus/><internalId>203</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSMDeInitPn.T_S_TRCV_STANDBY_S_TRCV_STANDBY</srcid><srcstatus/><internalId>207</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>367</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00451</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The guarding condition G_TRCV_STANDBY_E_OK of the sub state machine CANSM_BSM_DeinitPnSupported 
        ref. to Figure 7-4) shall be passed, if the API call of SWS_CanSM_00450 has returned E_OK.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMDeInitPn.T_S_TRCV_STANDBY_S_TRCV_STANDBY</srcid><srcstatus/><internalId>207</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>368</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00452</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        If the CanSM module has got the CANTRCV_TRCVMODE_STANDBY mode indication (ref. to 
        SWS_CanSM_00399) for the configured CAN Transceiver of the CAN network (ref. to 
        ECUC_CanSM_00137) after the respective request (ref. to SWS_CanSM_00450), this shall trigger 
        the sub state machine CANSM_BSM_DeinitPnSupported (ref. to Figure 7-4) of the CAN network with 
        T_TRCV_STANDBY_INDICATED.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMDeInitPn.T_S_TRCV_STANDBY_S_CC_SLEEP</srcid><srcstatus/><internalId>206</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>369</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00453</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        As long the sub state machine CANSM_BSM_DeinitPnSupported (ref. to Figure 7-4) is in the state 
        S_CC_SLEEP, the CanSM module shall operate the do action DO_SET_CC_MODE_SLEEP and therefore 
        repeat for all configured CAN controllers of the CAN network (ref. to ECUC_CanSM_00141) the API 
        request CanIf_SetControllerMode (ref. to chapter [REF]) with ControllerMode equal to 
        CAN_CS_SLEEP, if the current CAN controller mode (ref. to SWS_CanSM_00638) is different.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.CtrlModeReqCheck</srcid><srcstatus/><internalId>574</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMDeInitPn.T_S_TRCV_STANDBY_S_CC_SLEEP</srcid><srcstatus/><internalId>206</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>370</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00454</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        After a timeout of CANSM_MODEREQ_REPEAT_TIME (ref. to ECUC_CanSM_00336) for the supposed 
        transceiver standby indication (ref. to SWS_CanSM_00452), this condition shall trigger the sub 
        state machine CANSM_BSM_DeinitPnSupported (ref. to Figure 7-4) of the respective network with 
        T_TRCV_STANDBY_TIMEOUT.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMDeInitPn.T_S_TRCV_STANDBY_S_TRCV_STANDBY</srcid><srcstatus/><internalId>207</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ECUC_CanSM_00336</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>289</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>371</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00455</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The guarding condition G_CC_SLEEP_E_OK of the sub state machine CANSM_BSM_DeinitPnSupported (
        ref. to Figure 7-4) shall be passed, if all API calls of SWS_CanSM_00453 have returned E_OK.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMDeInitPn.T_S_CC_SLEEP_S_CHECK_WFLAG_IN_NOT_CC_SLEEP</srcid><srcstatus/><internalId>210</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>372</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00456</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        If CanSM module has got all mode indications (ref. to SWS_CanSM_00396) for the configured CAN 
        controllers of the CAN network (ref. to ECUC_CanSM_00141) after the respective requests to set 
        the CAN controllers of the CAN network to sleep mode (ref. to SWS_CanSM_00453), this shall 
        trigger the sub state machine CANSM_BSM_DeinitPnSupported (ref. to Figure 7-4) of the CAN 
        network with T_CC_SLEEP_INDICATED.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMDeInitPn.T_S_CC_SLEEP_S_CHECK_WFLAG_IN_CC_SLEEP</srcid><srcstatus/><internalId>209</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>373</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00457</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        After a timeout of CANSM_MODEREQ_REPEAT_TIME (ref. to ECUC_CanSM_00336) for all supposed 
        controller sleep mode indications (ref. to SWS_CanSM_00456), this condition shall trigger the 
        sub state machine CANSM_BSM_DeinitPnSupported (ref. to Figure 7-4Figure 7-4) of the respective 
        network with CANSM_BSM_T_CC_SLEEP_TIMEOUT.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMDeInitPn.T_S_CC_SLEEP_S_CHECK_WFLAG_IN_NOT_CC_SLEEP</srcid><srcstatus/><internalId>210</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ECUC_CanSM_00336</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>289</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>374</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00458</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        As long the sub state machine CANSM_BSM_DeinitPnSupported (ref. to Figure 7-4) is in the state 
        S_CHECK_WFLAG_IN_CC_SLEEP, the CanSM module operate the do action DO_CHECK_WFLAG and therefore 
        repeat the API request CanIf_CheckTrcvWakeFlag (ref. to chapter [REF]) and use the configured 
        CAN Transceiver of the related Network (ref. to ECUC_CanSM_00137) as Transceiver parameter.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMDeInitPn.T_S_CC_SLEEP_S_CHECK_WFLAG_IN_CC_SLEEP</srcid><srcstatus/><internalId>209</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSMDeInitPn.T_S_CHECK_WFLAG_IN_CC_SLEEP_S_CHECK_WFLAG_IN_CC_SLEEP</srcid><srcstatus/><internalId>211</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>375</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00459</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The guarding condition G_CHECK_WFLAG_E_OK of the sub state machine CANSM_BSM_DeinitPnSupported 
        ref. to Figure 7-4) shall be passed, if the API call of SWS_CanSM_00458 or SWS_CanSM_00462 has 
        returned E_OK.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMDeInitPn.T_S_CHECK_WFLAG_IN_CC_SLEEP_S_CHECK_WFLAG_IN_CC_SLEEP</srcid><srcstatus/><internalId>211</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSMDeInitPn.T_S_CHECK_WFLAG_IN_NOT_CC_SLEEP_S_CHECK_WFLAG_IN_NOT_CC_SLEEP</srcid><srcstatus/><internalId>214</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>376</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00460</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The callback function CanSM_CheckTransceiverWakeFlagIndication (ref. to SWS_CanSM_00416) shall 
        trigger the sub state machine CANSM_BSM_DeinitPnSupported (ref. to Figure 7-4) of the CAN 
        network with T_CHECK_WFLAG_INDICATED, if the function parameter Transceiver of 
        CanSM_CheckTransceiverWakeFlagIndication matches to the configured CAN Transceiver (ref. to 
        ECUC_CanSM_00137) of the CAN network.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSM.T_PRE_NOCOM_NOCOM.Pn.1</srcid><srcstatus/><internalId>193</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_PRE_NOCOM_NOCOM.Pn.2</srcid><srcstatus/><internalId>194</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSMDeInitPn.T_S_CHECK_WFLAG_IN_NOT_CC_SLEEP_S_PN_CLEAR_WUF.1</srcid><srcstatus/><internalId>213</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>377</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00461</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        After a timeout of CANSM_MODEREQ_REPEAT_TIME (ref. to ECUC_CanSM_00336) for the callback 
        function CanSM_CheckTransceiverWakeFlagIndication (ref. to SWS_CanSM_00460), this condition 
        shall trigger the sub state machine CANSM_BSM_DeinitPnSupported (ref. to Figure 7-4) of the 
        respective network with T_CHECK_WFLAG_TIMEOUT.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMDeInitPn.T_S_CHECK_WFLAG_IN_CC_SLEEP_S_CHECK_WFLAG_IN_CC_SLEEP</srcid><srcstatus/><internalId>211</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSMDeInitPn.T_S_CHECK_WFLAG_IN_NOT_CC_SLEEP_S_CHECK_WFLAG_IN_NOT_CC_SLEEP</srcid><srcstatus/><internalId>214</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ECUC_CanSM_00336</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>289</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>378</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00462</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        As long the sub state machine CANSM_BSM_DeinitPnSupported (ref. to Figure 7-4) is in the state 
        S_CHECK_WFLAG_IN_NOT_CC_SLEEP, the CanSM module operate the do action DO_CHECK_WFLAG and 
        therefore repeat the API request CanIf_CheckTrcvWakeFlag (ref. to chapter [REF]) and use the 
        configured CAN Transceiver of the related Network (ref. to ECUC_CanSM_00137) as Transceiver 
        parameter.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMDeInitPn.T_S_CC_SLEEP_S_CHECK_WFLAG_IN_NOT_CC_SLEEP</srcid><srcstatus/><internalId>210</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSMDeInitPn.T_S_CHECK_WFLAG_IN_NOT_CC_SLEEP_S_CHECK_WFLAG_IN_NOT_CC_SLEEP</srcid><srcstatus/><internalId>214</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>379</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00464</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        As long the sub state machine CANSM_BSM_DeinitPnNotSupported (ref. to Figure 7-5) is in the 
        state S_CC_STOPPED, the CanSM module shall operate the do action DO_SET_CC_MODE_STOPPED and 
        therefore repeat for all configured CAN controllers of the CAN network (ref. to 
        ECUC_CanSM_00141) the API request CanIf_SetControllerMode (ref. to chapter [REF]) with 
        ControllerMode equal to CAN_CS_STOPPED, if the current CAN controller mode (ref. to 
        SWS_CanSM_00638) is different.
      </description>
      <furtherinfo> 
        Justifying rule: WRN.swurs.needscoverage.count violation.
        The requirement describes only a single trigger or guardian condition or effect of
        the CanSM state machine, It is not complete nor consistent All requirement of this kind
        are coverd by more than 10 requirements describing the complete state transition.
      </furtherinfo>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.CtrlModeReqCheck</srcid><srcstatus/><internalId>574</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSM.T_FULLCOM_PRE_NOCOM.NoPn</srcid><srcstatus/><internalId>168</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.NoPn.1</srcid><srcstatus/><internalId>176</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.NoPn.2</srcid><srcstatus/><internalId>178</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.NoPn.3</srcid><srcstatus/><internalId>180</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.NoPn.1</srcid><srcstatus/><internalId>182</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.NoPn.2</srcid><srcstatus/><internalId>184</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.NoPn.3</srcid><srcstatus/><internalId>186</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_SILENTCOM_PRE_NOCOM.NoPn</srcid><srcstatus/><internalId>189</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_NOT_INITIALIZED_PRE_NOCOM.NoPn</srcid><srcstatus/><internalId>195</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSMDeInitNoPn.T_S_CC_STOPPED_S_CC_STOPPED.1</srcid><srcstatus/><internalId>217</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSMDeInitNoPn.T_S_CC_STOPPED_S_CC_STOPPED.2</srcid><srcstatus/><internalId>218</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSMDeInitNoPn.T_S_CC_SLEEP_S_CC_STOPPED</srcid><srcstatus/><internalId>221</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_NORMAL_S_CC_STOPPED</srcid><srcstatus/><internalId>224</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_STANDBY_S_CC_STOPPED</srcid><srcstatus/><internalId>226</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>380</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00465</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The guarding condition CANSM_BSM_G_CC_STOPPED_OK of the sub state machine 
        CANSM_BSM_DeinitPnNotSupported (ref. to Figure 7-5) shall be passed, if all API calls of 
        SWS_CanSM_00464 have returned E_OK.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMDeInitNoPn.T_S_CC_STOPPED_S_CC_STOPPED.1</srcid><srcstatus/><internalId>217</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>381</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00466</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        If CanSM module has got all mode indications (ref. to SWS_CanSM_00396) for the configured CAN 
        controllers of the CAN network (ref. to ECUC_CanSM_00141) after the respective requests to stop 
        the CAN controllers of the CAN network (ref. to SWS_CanSM_00464), this shall trigger the sub 
        state machine CANSM_BSM_DeinitPnNotSupported (ref. to Figure 7-5) of the CAN network with 
        T_CC_STOPPED_INDICATED.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMDeInitNoPn.T_S_CC_STOPPED_S_CC_SLEEP</srcid><srcstatus/><internalId>216</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSMDeInitNoPn.T_S_CC_STOPPED_S_CC_STOPPED.1</srcid><srcstatus/><internalId>217</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>382</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00467</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        After a timeout of CANSM_MODEREQ_REPEAT_TIME (ref. to ECUC_CanSM_00336) for all supposed 
        controller stopped mode indications (ref. to SWS_CanSM_00466), this condition shall trigger the 
        sub state machine CANSM_BSM_DeinitPnNotSupported (ref. to Figure 7-5) of the respective network 
        with T_CC_STOPPED_TIMEOUT.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMDeInitNoPn.T_S_CC_STOPPED_S_CC_STOPPED.1</srcid><srcstatus/><internalId>217</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ECUC_CanSM_00336</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>289</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>383</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00468</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        As long the sub state machine CANSM_BSM_DeinitPnNotSupported (ref. to Figure 7-5) is in the 
        state S_CC_SLEEP, the CanSM module shall operate the do action DO_SET_CC_MODE_SLEEP and 
        therefore repeat for all configured CAN controllers of the CAN network (ref. to 
        ECUC_CanSM_00141) the API request CanIf_SetControllerMode (ref. to chapter [REF]) with 
        ControllerMode equal to CAN_CS_SLEEP, if the current CAN controller mode (ref. to 
        SWS_CanSM_00638) is different.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.CtrlModeReqCheck</srcid><srcstatus/><internalId>574</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMDeInitNoPn.T_S_CC_STOPPED_S_CC_SLEEP</srcid><srcstatus/><internalId>216</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSMDeInitNoPn.T_S_CC_SLEEP_S_CC_SLEEP</srcid><srcstatus/><internalId>220</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>384</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00469</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The guarding condition G_CC_SLEEP_E_OK of the sub state machine CANSM_BSM_DeinitPnNotSupported 
        ref. to Figure 7-5) shall be passed, if all API calls of SWS_CanSM_00468 have returned E_OK.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMDeInitNoPn.T_S_CC_SLEEP_S_CC_SLEEP</srcid><srcstatus/><internalId>220</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>385</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00470</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        If CanSM module has got all mode indications (ref. to SWS_CanSM_00396) for the configured CAN 
        controllers of the CAN network (ref. to ECUC_CanSM_00141) after the respective requests to set 
        the CAN controllers of the CAN network to sleep mode (ref. to SWS_CanSM_00468), this shall 
        trigger the sub state machine CANSM_BSM_DeinitPnNotSupported (ref. to Figure 7-5) of the CAN 
        network with T_CC_SLEEP_INDICATED.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.EB.Transitions.NoTransceiver.2</srcid><srcstatus/><internalId>106</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSMDeInitNoPn.T_S_CC_SLEEP_S_TRCV_NORMAL</srcid><srcstatus/><internalId>219</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>386</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00471</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        After a timeout of CANSM_MODEREQ_REPEAT_TIME (ref. to ECUC_CanSM_00336) for all supposed 
        controller sleep mode indications (ref. to SWS_CanSM_00470), this condition shall trigger the 
        sub state machine CANSM_BSM_DeinitPnNotSupported (ref. to Figure 7-5) of the respective network 
        with T_CC_SLEEP_TIMEOUT.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMDeInitNoPn.T_S_CC_SLEEP_S_CC_SLEEP</srcid><srcstatus/><internalId>220</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ECUC_CanSM_00336</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>289</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>387</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00472</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        If for the CAN network a CAN Transceiver is configured (ref. to ECUC_CanSM_00137), then as long 
        the sub state machine CANSM_BSM_DeinitPnNotSupported (ref. to Figure 7-5) is in the state 
        S_TRCV_NORMAL, the CanSM module shall operate the do action DO_SET_TRCV_MODE_NORMAL and 
        therefore repeat for the configured CAN Transceiver of the CAN network (ref. to 
        ECUC_CanSM_00137) the API request CanIf_SetTrcvMode (ref. to chapter [REF]) with 
        TransceiverMode equal to CANTRCV_TRCVMODE_NORMAL.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMDeInitNoPn.T_S_CC_SLEEP_S_TRCV_NORMAL</srcid><srcstatus/><internalId>219</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_NORMAL_S_TRCV_NORMAL</srcid><srcstatus/><internalId>223</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>388</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00473</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The guarding condition G_TRCV_NORMAL_E_OK of the sub state machine 
        CANSM_BSM_DeinitPnNotSupported (ref. to Figure 7-5) shall be passed, if the API call of 
        SWS_CanSM_00472 has returned E_OK.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_NORMAL_S_TRCV_NORMAL</srcid><srcstatus/><internalId>223</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>389</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00474</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        If CanSM module has got the CANTRCV_TRCVMODE_NORMAL mode indication (ref. to SWS_CanSM_00399) 
        for the configured CAN Transceiver of the CAN network (ref. to ECUC_CanSM_00137) after the 
        respective request (ref. to SWS_CanSM_00472), this shall trigger the sub state machine 
        CANSM_BSM_DeinitPnNotSupported (ref. to Figure 7-5) of the CAN network with 
        T_TRCV_NORMAL_INDICATED.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_NORMAL_S_TRCV_STANDBY</srcid><srcstatus/><internalId>222</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>390</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00475</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        After a timeout of CANSM_MODEREQ_REPEAT_TIME (ref. to ECUC_CanSM_00336) for the supposed 
        transceiver normal indication (ref. to SWS_CanSM_00474), this condition shall trigger the sub 
        state machine CANSM_BSM_DeinitPnNotSupported (ref. to Figure 7-5) of the respective network 
        with T_TRCV_NORMAL_TIMEOUT.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_NORMAL_S_TRCV_NORMAL</srcid><srcstatus/><internalId>223</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ECUC_CanSM_00336</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>289</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>391</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00476</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        If for the CAN network a CAN Transceiver is configured (ref. to ECUC_CanSM_00137), then as long 
        the sub state machine CANSM_BSM_DeinitPnNotSupported (ref. to Figure 7-5) is in the state 
        S_TRCV_STANDBY, the CanSM module shall operate the do action DO_SET_TRCV_MODE_STANDBY and 
        therefore repeat for the configured CAN Transceiver of the CAN network (ref. to 
        ECUC_CanSM_00137) the API request CanIf_SetTrcvMode (ref. to chapter [REF]) with 
        TransceiverMode equal to CANTRCV_TRCVMODE_STANDBY.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_NORMAL_S_TRCV_STANDBY</srcid><srcstatus/><internalId>222</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_STANDBY_S_TRCV_STANDBY</srcid><srcstatus/><internalId>225</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>392</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00477</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The guarding condition G_TRCV_STANDBY_E_OK of the sub state machine 
        CANSM_BSM_DeinitPnNotSupported (ref. to Figure 7-5) shall be passed, if the API call of 
        SWS_CanSM_00476 has returned E_OK.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_STANDBY_S_TRCV_STANDBY</srcid><srcstatus/><internalId>225</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>393</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00478</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        If CanSM module has got the CANTRCV_TRCVMODE_STANDBY mode indication (ref. to SWS_CanSM_00399) 
        for the configured CAN Transceiver of the CAN network (ref. to ECUC_CanSM_00137) after the 
        respective request (ref. to SWS_CanSM_00476), this shall trigger the sub state machine 
        CANSM_BSM_DeinitPnNotSupported (ref. to Figure 7-5) of the CAN network with 
        T_TRCV_STANDBY_INDICATED.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSM.T_PRE_NOCOM_NOCOM.NoPn.1</srcid><srcstatus/><internalId>191</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_PRE_NOCOM_NOCOM.NoPn.2</srcid><srcstatus/><internalId>192</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>394</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00479</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        After a timeout of CANSM_MODEREQ_REPEAT_TIME (ref. to ECUC_CanSM_00336) for the supposed 
        transceiver standby indication (ref. to SWS_CanSM_00478), this condition shall trigger the sub 
        state machine CANSM_BSM_DeinitPnNotSupported (ref. to Figure 7-5) of the respective network 
        with CANSM_BSM_T_TRCV_STANDBY_TIMEOUT.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_STANDBY_S_TRCV_STANDBY</srcid><srcstatus/><internalId>225</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ECUC_CanSM_00336</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>289</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>395</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00483</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        If for the CAN network a CAN Transceiver is configured (ref. to ECUC_CanSM_00137), then as long 
        the sub state machine CANSM_BSM_S_PRE_FULLCOM (ref. to Figure 7-7) is in the state 
        S_TRCV_NORMAL, the CanSM module shall operate the do action DO_SET_TRCV_MODE_NORMAL and 
        therefore repeat for the configured CAN Transceiver of the CAN network (ref. to 
        ECUC_CanSM_00137) the API request CanIf_SetTrcvMode (ref. to chapter [REF]) with 
        TransceiverMode equal to CANTRCV_TRCVMODE_NORMAL.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSM.T_NOCOM_PRE_FULLCOM</srcid><srcstatus/><internalId>175</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSMPreFull.T_S_TRCV_NORMAL_S_TRCV_NORMAL</srcid><srcstatus/><internalId>228</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>396</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00484</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The guarding condition G_TRCV_NORMAL_E_OK of the sub state machine CANSM_BSM_S_PRE_FULLCOM (ref.
        to Figure 7-7) shall be passed, if the API call of SWS_CanSM_00483 has returned E_OK.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMPreFull.T_S_TRCV_NORMAL_S_TRCV_NORMAL</srcid><srcstatus/><internalId>228</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>397</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00485</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        If CanSM module has got the CANTRCV_TRCVMODE_NORMAL mode indication (ref. to SWS_CanSM_00399) 
        for the configured CAN Transceiver of the CAN network (ref. to ECUC_CanSM_00137) after the 
        respective request (ref. to SWS_CanSM_00483), this shall trigger the sub state machine 
        CANSM_BSM_S_PRE_FULLCOM (ref. to Figure 7-7) of the CAN network with T_TRCV_NORMAL_INDICATED.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMPreFull.T_S_TRCV_NORMAL_S_CC_STOPPED</srcid><srcstatus/><internalId>227</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>398</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00486</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        After a timeout of CANSM_MODEREQ_REPEAT_TIME (ref. to ECUC_CanSM_00336) for the supposed 
        transceiver normal indication (ref. to SWS_CanSM_00485), this condition shall trigger the sub 
        state machine CANSM_BSM_S_PRE_FULLCOM (ref. to Figure 7-7) of the respective network with 
        T_TRCV_NORMAL_TIMEOUT.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMPreFull.T_S_TRCV_NORMAL_S_TRCV_NORMAL</srcid><srcstatus/><internalId>228</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ECUC_CanSM_00336</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>289</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>399</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00487</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        As long the sub state machine CANSM_BSM_S_PRE_FULLCOM (ref. to Figure 7-7) is in the state 
        S_CC_STOPPED, the CanSM module shall operate the do action DO_SET_CC_MODE_STOPPED and therefore 
        repeat for all configured CAN controllers of the CAN network (ref. to ECUC_CanSM_00141) the API 
        request CanIf_SetControllerMode (ref. to chapter [REF]) with ControllerMode equal to 
        CAN_CS_STOPPED, if the current CAN controller mode (ref. to SWS_CanSM_00638) is different.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.CtrlModeReqCheck</srcid><srcstatus/><internalId>574</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.EB.Transitions.NoTransceiver.3</srcid><srcstatus/><internalId>107</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSMPreFull.T_S_TRCV_NORMAL_S_CC_STOPPED</srcid><srcstatus/><internalId>227</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSMPreFull.T_S_CC_STOPPED_S_CC_STOPPED</srcid><srcstatus/><internalId>230</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>400</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00488</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The guarding condition G_CC_STOPPED_OK of the sub state machine CANSM_BSM_S_PRE_FULLCOM (ref. 
        to Figure 7-7) shall be passed, if all API calls of SWS_CanSM_00487 have returned E_OK.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMPreFull.T_S_CC_STOPPED_S_CC_STOPPED</srcid><srcstatus/><internalId>230</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>401</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00489</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        If CanSM module has got all mode indications (ref. to SWS_CanSM_00396) for the configured CAN 
        controllers of the CAN network (ref. to ECUC_CanSM_00141) after the respective requests to stop 
        the CAN controllers of the CAN network (ref. to SWS_CanSM_00487), this shall trigger the sub 
        state machine CANSM_BSM_S_PRE_FULLCOM (ref. to Figure 7-7) of the CAN network with 
        T_CC_STOPPED_INDICATED.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMPreFull.T_S_CC_STOPPED_S_CC_STARTED</srcid><srcstatus/><internalId>229</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>402</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00490</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        After a timeout of CANSM_MODEREQ_REPEAT_TIME (ref. to ECUC_CanSM_00336) for all supposed 
        controller stopped mode indications (ref. to SWS_CanSM_00489), this condition shall trigger the 
        sub state machine CANSM_BSM_S_PRE_FULLCOM (ref. to Figure 7-7) of the respective network with 
        T_CC_STOPPED_TIMEOUT.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMPreFull.T_S_CC_STOPPED_S_CC_STOPPED</srcid><srcstatus/><internalId>230</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ECUC_CanSM_00336</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>289</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>403</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00491</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        As long the sub state machine CANSM_BSM_S_PRE_FULLCOM (ref. to Figure 7-7) is in the state 
        S_CC_STARTED, the CanSM module shall operate the do action DO_SET_CC_MODE_STARTED and therefore 
        repeat for all configured CAN controllers of the CAN network (ref. to ECUC_CanSM_00141) the API 
        request CanIf_SetControllerMode (ref. to chapter [REF]) with ControllerMode equal to 
        CAN_CS_STARTED, if the current CAN controller mode (ref. to SWS_CanSM_00638) is different.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.CtrlModeReqCheck</srcid><srcstatus/><internalId>574</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMPreFull.T_S_CC_STOPPED_S_CC_STARTED</srcid><srcstatus/><internalId>229</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSMPreFull.T_S_CC_STARTED_S_CC_STARTED</srcid><srcstatus/><internalId>231</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>404</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00492</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The guarding condition G_CC_STARTED_OK of the sub state machine CANSM_BSM_S_PRE_FULLCOM (ref. 
        to Figure 7-7) shall be passed, if all API calls of SWS_CanSM_00491 have returned E_OK.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMPreFull.T_S_CC_STARTED_S_CC_STARTED</srcid><srcstatus/><internalId>231</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>405</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00493</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        If CanSM module has got all mode indications (ref. to SWS_CanSM_00396) for the configured CAN 
        controllers of the CAN network (ref. to ECUC_CanSM_00141) after the respective requests to 
        start the CAN controllers of the CAN network (ref. to SWS_CanSM_00491), this shall trigger the 
        sub state machine CANSM_BSM_S_PRE_FULLCOM (ref. to Figure 7-7) of the CAN network with 
        T_CC_STARTED_INDICATED.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSM.T_PRE_FULLCOM_FULLCOM</srcid><srcstatus/><internalId>167</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>406</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00494</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        After a timeout of CANSM_MODEREQ_REPEAT_TIME (ref. to ECUC_CanSM_00336) for all supposed 
        controller started mode indications (ref. to SWS_CanSM_00493), this condition shall trigger the 
        sub state machine CANSM_BSM_S_PRE_FULLCOM (ref. to Figure 7-7) of the respective network with 
        T_CC_STARTED_TIMEOUT.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMPreFull.T_S_CC_STARTED_S_CC_STARTED</srcid><srcstatus/><internalId>231</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ECUC_CanSM_00336</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>289</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>407</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00496</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The guarding condition G_BUS_OFF_PASSIVE of the sub state machine CANSM_BSM_S_FULLCOM (ref. to 
        Figure 7-8) shall be passed, if CANSM_BOR_TX_CONFIRMATION_POLLING is disabled (ref. to 
        ECUC_CanSM_00339) and the time duration since the effect E_TX_ON is greater or equal the 
        configuration parameter CANSM_BOR_TIME_TX_ENSURED (ref. to ECUC_CanSM_00130)
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_NO_BUS_OFF</srcid><srcstatus/><internalId>232</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ECUC_CanSM_00130</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>279</internalId></provcov>
        <provcov>
          <linksto>CanSM.ECUC_CanSM_00339</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>291</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>408</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00497</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The guarding condition G_BUS_OFF_PASSIVE of the sub state machine CANSM_BSM_S_FULLCOM (ref. to 
        Figure 7-8) shall be passed, if CANSM_BOR_TX_CONFIRMATION_POLLING is enabled (ref. to 
        ECUC_CanSM_00339) and the API CanIf_GetTxConfirmationState (ref. to chapter [REF]) returns 
        CANIF_TX_RX_NOTIFICATION for all configured CAN controllers of the CAN network (ref. to 
        ECUC_CanSM_00141)
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_NO_BUS_OFF</srcid><srcstatus/><internalId>232</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ECUC_CanSM_00339</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>291</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>409</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00498</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The effect E_BUS_OFF_PASSIVE of the sub state machine CANSM_BSM_S_FULLCOM (ref. to Figure 7-8) 
        shall invocate Dem_SetEventStatus (ref. to chapter [REF]) with the parameters EventId := 
        CANSM_E_BUS_OFF (ref. to ECUC_CanSM_00070) and EventStatus := DEM_EVENT_STATUS_PASSED.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.ChangedDemFunc</srcid><srcstatus/><internalId>553</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>410</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00499</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The API request CanSM_RequestComMode (ref. to SWS_CanSM_00635) with the parameter ComM_Mode 
        equal to COMM_SILENT_COMMUNICATION shall trigger the sub state machine CANSM_BSM_S_FULLCOM (ref.
        to Figure 7-1) with T_SILENT_COM_MODE_REQUEST, which corresponds to the function parameter 
        network and the configuration parameter CANSM_NETWORK_HANDLE (ref. to ECUC_CanSM_00161)
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSM.T_FULLCOM_SILENTCOM.BusOffCheck.1</srcid><srcstatus/><internalId>108</internalId></linkedfrom><linkedfrom><srcid>CanSM.EB.BSM.T_FULLCOM_SILENTCOM.S_TX_OFF.1</srcid><srcstatus/><internalId>110</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_FULLCOM_SILENTCOM.1</srcid><srcstatus/><internalId>172</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00182</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>300</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>411</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00500</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The callback function CanSM_ControllerBusOff (ref. to SWS_CanSM_00064) shall trigger the sub 
        state machine CANSM_BSM_S_FULLCOM (ref. to Figure 7-8) for the CAN network with T_BUS_OFF, if 
        one of its configured CAN controllers matches to the function parameter ControllerId of the 
        callback function CanSM_ControllerBusOff.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_RESTART_CC</srcid><srcstatus/><internalId>233</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSMFull.T_S_NO_BUS_OFF_S_RESTART_CC</srcid><srcstatus/><internalId>237</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>412</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00502</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The CanSM module shall deny the CanSM_SetBaudrate API request, if the NetworkHandle parameter 
        does not match to the configured Network handles of the CanSM module (ref. to ECUC_CanSM_00161)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.1.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_SETBAUDRATE</srcid><srcstatus/><internalId>736</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>413</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00503</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        If no condition is present to deny the CanSM_SetBaudrate request according to SWS_CANSM_00502 
        and SWS_CANSM_00505, SWS_CANSM_00530, then the CanSM module shall return E_OK and operate the 
        process for the requested baud rate change as specified with SWS_CANSM_00507.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.ChBROperation</srcid><srcstatus/><internalId>563</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>414</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00504</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The function CanSM_SetBaudrate shall call the function Det_ReportError with ErrorId parameter 
        CANSM_E_INVALID_NETWORK_HANDLE (ref. to chapter [REF]), if it does not accept the network 
        handle of the request.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.1.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_SETBAUDRATE</srcid><srcstatus/><internalId>736</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>415</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00505</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The function CanSM_SetBaudrate shall deny its request, if the requested CAN network is not in 
        the communication mode COMM_FULL_COMMUNICATION.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.1.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_SETBAUDRATE</srcid><srcstatus/><internalId>736</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>416</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00506</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        If the function CanSM_SetBaudrate is called and the CanSM module is not initialized, then this 
        function shall call the function Det_ReportError with ErrorId parameter CANSM_E_UNINIT (ref. to 
        chapter [REF]
      </description>
      <comment>
        Defines one exact usage of the DET error code CANSM_E_UNINIT.
        Precondition: development error detection enabled.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.1.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_SETBAUDRATE_DET_UNINIT</srcid><srcstatus/><internalId>735</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.ErrorTable.CANSM_E_UNINIT</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>251</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.DevelopmentErrors</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>262</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>417</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00507</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        If no condition is present to deny the CanSM_SetBaudrate request (ref. to SWS_CANSM_00503), 
        this shall trigger the state machine CANSM_BSM_S_FULLCOM (ref. to Figure 7-8) and respectively 
        the parent state machine CANSM_BSM (ref. to Figure 7-1) with T_CHANGE_BR_REQUEST (causes either 
        a direct baud rate change if possible via CanIf_SetBaudrate or the start of the required 
        asynchronous process to do that
      </description>
      <comment>
        This requirement has been replaced by CanSM.ASR41.SWS_CanSM_00507.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.EFullComOrder</srcid><srcstatus/><internalId>561</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>418</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00508</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The effect E_BUS_OFF of the sub state machine CANSM_BSM_S_FULLCOM (ref. to Figure 7-8) shall 
        call at 1st place for the corresponding CAN network the API BswM_CanSM_CurrentState with the 
        parameters Network := CanSMComMNetworkHandleRef and CurrentState := CANSM_BSWM_BUS_OFF.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.CANSM508.BusOff</srcid><srcstatus/><internalId>244</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.CANSM508.BusOffL1</srcid><srcstatus/><internalId>245</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.CANSM508.BusOffL2</srcid><srcstatus/><internalId>246</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>419</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00509</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        As long the sub state machine CANSM_BSM_S_FULLCOM (ref. to Figure 7-8) is in the state 
        S_RESTART_CC, the CanSM module shall operate the do action DO_SET_CC_MODE_STARTED and therefore 
        repeat for all configured CAN controllers of the CAN network (ref. to ECUC_CanSM_00141) the API 
        request CanIf_SetControllerMode (ref. to chapter [REF]) with ControllerMode equal to 
        CAN_CS_STARTED, if the current CAN controller mode (ref. to SWS_CanSM_00638) is different.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.CtrlModeReqCheck</srcid><srcstatus/><internalId>574</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_RESTART_CC</srcid><srcstatus/><internalId>233</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSMFull.T_S_NO_BUS_OFF_S_RESTART_CC</srcid><srcstatus/><internalId>237</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSMFull.T_S_RESTART_CC_S_RESTART_CC</srcid><srcstatus/><internalId>242</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>420</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00510</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The guarding condition G_RESTART_CC_OK of the sub state machine CANSM_BSM_S_FULLCOM (ref. to 
        Figure 7-8) shall be passed, if all API calls of SWS_CanSM_00509 have returned E_OK.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMFull.T_S_RESTART_CC_S_RESTART_CC</srcid><srcstatus/><internalId>242</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>421</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00511</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        If CanSM module has got all mode indications (ref. to SWS_CanSM_00396) for the configured CAN 
        controllers of the CAN network (ref. to ECUC_CanSM_00141) after the respective requests to 
        start the CAN controllers of the CAN network (ref. to SWS_CanSM_00509), this shall trigger the 
        sub state CANSM_BSM_S_FULLCOM (ref. to Figure 7-8) of the CAN network with 
        T_RESTART_CC_INDICATED.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMFull.T_S_RESTART_CC_S_TX_OFF</srcid><srcstatus/><internalId>240</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>422</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00512</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        After a timeout of CANSM_MODEREQ_REPEAT_TIME (ref. to ECUC_CanSM_00336) for all supposed 
        controller started mode indications (ref. to SWS_CanSM_00511), this condition shall trigger the 
        sub state machine CANSM_BSM_S_FULLCOM (ref. to Figure 7-8) of the respective network with 
        T_RESTART_CC_TIMEOUT.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMFull.T_S_RESTART_CC_S_RESTART_CC</srcid><srcstatus/><internalId>242</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ECUC_CanSM_00336</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>289</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>423</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00514</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        If CanSMEnableBusOffDelay is FALSE, then guarding condition G_TX_ON of the sub state machine 
        CANSM_BSM_S_FULLCOM (ref. to Figure 7-8) shall be passed after a time duration of 
        CanSMBorTimeL1 (ref. to ECUC_CanSM_00128) related to the last T_BUS_OFF, if the count of bus-
        off recovery retries with E_BUS_OFF without passing the guarding condition G_BUS_OFF_PASSIVE is 
        lower than CanSMBorCounterL1ToL2 (ref. to ECUC_CanSM_00131)
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.BODelaySupport</srcid><srcstatus/><internalId>564</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>424</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00515</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        If CanSMEnableBusOffDelay is FALSE, then the guarding condition G_TX_ON of the sub state 
        machine CANSM_BSM_S_FULLCOM (ref. to Figure 7-8) shall be passed after a time duration of 
        CanSMBorTimeL2 (ref. to ECUC_CanSM_00129) related to the last T_BUS_OFF, if the count of bus-
        off recovery retries with E_BUS_OFF without passing the guarding condition G_BUS_OFF_PASSIVE is 
        greater than or equal to CanSMBorCounterL1ToL2 (ref. to ECUC_CanSM_00131)
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.BODelaySupport</srcid><srcstatus/><internalId>564</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>425</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00516</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        If ECU passive is FALSE (ref. to SWS_CanSM_00646), then the effect E_TX_ON of the sub state 
        machine CANSM_BSM_S_FULLCOM (ref. to Figure 7-8) shall call at 1st place for the configured CAN 
        controllers of the CAN network (ref. to ECUC_CanSM_00141) the API function CanIf_SetPduMode (
        ref. to chapter [REF]) with the parameters ControllerId := CanSMControllerId (ref. to 
        ECUC_CanSM_00141) and PduModeRequest := CANIF_ONLINE.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.OfflineActiveSupport</srcid><srcstatus/><internalId>568</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR42.SWS_CANSM_00516</srcid><srcstatus/><internalId>104</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>426</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00648</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        If ECU passive is TRUE (ref. to SWS_CanSM_00646), then 
        the effect E_TX_ON of the sub state machine CANSM_BSM_S_FULLCOM (ref. to 
        Figure 7-8) shall call at 1st place for the configured CAN controllers of the CAN 
        network (ref. to ECUC_CanSM_00141) the API function CanIf_SetPduMode (ref. to 
        chapter 8.5.1) with the parameters ControllerId := CanSMControllerId (ref. 
        to ECUC_CanSM_00141) and PduModeRequest :=
        CANIF_TX_OFFLINE_ACTIVE.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.OfflineActiveSupport</srcid><srcstatus/><internalId>568</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>427</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00517</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The effect E_TX_ON of the sub state machine CANSM_BSM_S_FULLCOM (ref. to Figure 7-8) shall call 
        at 2nd place for the corresponding CAN network the API BswM_CanSM_CurrentState with the 
        parameters Network := CanSMComMNetworkHandleRef and CurrentState := 
        CANSM_BSWM_FULL_COMMUNICATION.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMFull.T_S_TX_OFF_S_BUS_OFF_CHECK</srcid><srcstatus/><internalId>243</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>428</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00518</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The effect E_TX_ON of the sub state machine CANSM_BSM_S_FULLCOM (ref. to Figure 7-8) shall call 
        at 3rd place the API ComM_BusSM_ModeIndication with the parameters Channel := 
        CanSMComMNetworkHandleRef (ref. to ECUC_CanSM_00161) and ComMode := COMM_FULL_COMMUNICATION.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMFull.T_S_TX_OFF_S_BUS_OFF_CHECK</srcid><srcstatus/><internalId>243</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>429</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00521</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The effect E_BUS_OFF of the sub state machine CANSM_BSM_S_FULLCOM (ref. to Figure 7-8) shall 
        call at 2nd place for the corresponding CAN network the API ComM_BusSM_ModeIndication with the 
        parameters Channel := CanSMComMNetworkHandleRef (ref. to ECUC_CanSM_00161) and ComMode := 
        COMM_SILENT_COMMUNICATION.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_RESTART_CC</srcid><srcstatus/><internalId>233</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSMFull.T_S_NO_BUS_OFF_S_RESTART_CC</srcid><srcstatus/><internalId>237</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>430</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00522</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The effect E_BUS_OFF of the sub state machine CANSM_BSM_S_FULLCOM (ref. to Figure 7-8) shall 
        invocate Dem_SetEventStatus (ref. to chapter [REF]) with the parameters EventId := 
        CANSM_E_BUS_OFF (ref. to ECUC_CanSM_00070) and EventStatus := DEM_EVENT_STATUS_PRE_FAILED.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.ChangedDemFunc</srcid><srcstatus/><internalId>553</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>431</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00524</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        As long the sub state machine CANSM_BSM_S_CHANGE_BAUDRATE (ref. to Figure 7-10) is in the state 
        S_CC_STOPPED, the CanSM module shall operate the do action DO_SET_CC_MODE_STOPPED and therefore 
        repeat for all configured CAN controllers of the CAN network (ref. to ECUC_CanSM_00141) the API 
        request CanIf_SetControllerMode (ref. to chapter [REF]) with ControllerMode equal to 
        CAN_CS_STOPPED, if the current CAN controller mode (ref. to SWS_CanSM_00638) is different.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.CtrlModeReqCheck</srcid><srcstatus/><internalId>574</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSM.T_FULLCOM_CHANGE_BAUDRATE</srcid><srcstatus/><internalId>170</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSMBr.T_S_CC_STOPPED_S_CC_STOPPED</srcid><srcstatus/><internalId>248</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>432</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00525</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The guarding condition G_CC_STOPPED_OK of the sub state machine CANSM_BSM_S_CHANGE_BAUDRATE (
        ref. to Figure 7-10) shall be passed, if all API calls of SWS_CanSM_00524 have returned E_OK.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMBr.T_S_CC_STOPPED_S_CC_STOPPED</srcid><srcstatus/><internalId>248</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>433</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00526</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        If CanSM module has got all mode indications (ref. to SWS_CanSM_00396) for the configured CAN 
        controllers of the CAN network (ref. to ECUC_CanSM_00141) after the respective requests to stop 
        the CAN controllers of the CAN network (ref. to SWS_CanSM_00524), this shall trigger the sub 
        state machine CANSM_BSM_S_CHANGE_BAUDRATE (ref. to Figure 7-10) of the CAN network with 
        T_CC_STOPPED_INDICATED.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMBr.T_S_CC_STOPPED_S_CC_STARTED</srcid><srcstatus/><internalId>247</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>434</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00527</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        After a timeout of CANSM_MODEREQ_REPEAT_TIME (ref. to ECUC_CanSM_00336) for all supposed 
        controller stopped mode indications (ref. to SWS_CanSM_00526), this condition shall trigger the 
        sub state machine CANSM_BSM_S_CHANGE_BAUDRATE (ref. to Figure 7-10) of the respective network 
        with T_CC_STOPPED_TIMEOUT.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMBr.T_S_CC_STOPPED_S_CC_STOPPED</srcid><srcstatus/><internalId>248</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ECUC_CanSM_00336</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>289</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>435</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00528</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The effect E_CHANGE_BR_BSWM_MODE of the sub state machine CANSM_BSM_S_FULLCOM (ref. to Figure 7-
        8) shall call for the corresponding CAN network the API BswM_CanSM_CurrentState with the 
        parameters Network := CanSMComMNetworkHandleRef and CurrentState := CANSM_BSWM_CHANGE_BAUDRATE.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSM.T_FULLCOM_CHANGE_BAUDRATE</srcid><srcstatus/><internalId>170</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>436</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00529</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The effect E_CHANGE_BAUDRATE of the sub state machine CANSM_BSM_S_CHANGE_BAUDRATE (ref. to 
        Figure 7-10) shall call at 1st place for the corresponding CAN network the API 
        ComM_BusSM_ModeIndication with the parameters Channel := CanSMComMNetworkHandleRef (ref. to 
        ECUC_CanSM_00161) and ComMode := COMM_NO_COMMUNICATION.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMBr.T_S_CC_STOPPED_S_CC_STARTED</srcid><srcstatus/><internalId>247</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>437</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00530</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The CanSM module shall deny the CanSM_SetBaudrate API request, if the CanSM module is not 
        initialized.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.1.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_SETBAUDRATE_DET_UNINIT</srcid><srcstatus/><internalId>735</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>438</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00531</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The effect E_CHANGE_BAUDRATE of the sub state machine CANSM_BSM_S_CHANGE_BAUDRATE (ref. to 
        Figure 7-10) shall call at 2nd place for all configured CAN controllers of the CAN network (ref.
        to ECUC_CanSM_00141) the API request CanIf_SetBaudrate (ref. to chapter [REF]) with the 
        respective ControllerId parameter and shall use as BaudRateConfigID parameter the remembered 
        BaudRateConfigID from the call CanSM_SetBaudrate
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMBr.T_S_CC_STOPPED_S_CC_STARTED</srcid><srcstatus/><internalId>247</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00531</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>67</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>439</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00532</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        As long the sub state machine CANSM_BSM_S_CHANGE_BAUDRATE (ref. to Figure 7-10) is in the state 
        S_CC_STARTED, the CanSM module shall operate the do action DO_SET_CC_MODE_STARTED and therefore 
        repeat for all configured CAN controllers of the CAN network (ref. to ECUC_CanSM_00141) the API 
        request CanIf_SetControllerMode (ref. to chapter [REF]) with ControllerMode equal to 
        CAN_CS_STARTED, if the current CAN controller mode (ref. to SWS_CanSM_00638) is different.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.CtrlModeReqCheck</srcid><srcstatus/><internalId>574</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMBr.T_S_CC_STOPPED_S_CC_STARTED</srcid><srcstatus/><internalId>247</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSMBr.T_S_CC_STARTED_S_CC_STARTED</srcid><srcstatus/><internalId>249</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>440</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00533</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The guarding condition G_CC_STARTED_OK of the sub state machine CANSM_BSM_S_CHANGE_BAUDRATE (
        ref. to Figure 7-10) shall be passed, if all API calls of SWS_CanSM_00532 have returned E_OK.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMBr.T_S_CC_STARTED_S_CC_STARTED</srcid><srcstatus/><internalId>249</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>441</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00534</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        If CanSM module has got all mode indications (ref. to SWS_CanSM_00396) for the configured CAN 
        controllers of the CAN network (ref. to ECUC_CanSM_00141) after the respective requests to 
        start the CAN controllers of the CAN network (ref. to SWS_CanSM_00532), this shall trigger the 
        sub state machine CANSM_BSM_S_CHANGE_BAUDRATE (ref. to Figure 7-10) of the CAN network with 
        T_CC_STARTED_INDICATED.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_FULLCOM</srcid><srcstatus/><internalId>171</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.NoPn.3</srcid><srcstatus/><internalId>186</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.Pn.3</srcid><srcstatus/><internalId>187</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_SILENTCOM</srcid><srcstatus/><internalId>188</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>442</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00535</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        After a timeout of CANSM_MODEREQ_REPEAT_TIME (ref. to ECUC_CanSM_00336) for all supposed 
        controller started mode indications (ref. toSWS_CanSM_00534), this condition shall trigger the 
        sub state machine CANSM_BSM_S_CHANGE_BAUDRATE (ref. to Figure 7-10) of the respective network 
        with T_CC_STARTED_TIMEOUT.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMBr.T_S_CC_STARTED_S_CC_STARTED</srcid><srcstatus/><internalId>249</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ECUC_CanSM_00336</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>289</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>443</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00538</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The effect E_FULL_TO_SILENT_COM of the CanSM_BSM state machine (ref. to Figure 7-1) shall call 
        at 3th place for the corresponding CAN network the API ComM_BusSM_ModeIndication with the 
        parameters Channel := CanSMComMNetworkHandleRef (ref. to ECUC_CanSM_00161) and ComMode := 
        COMM_SILENT_COMMUNICATION.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.EFullComOrder</srcid><srcstatus/><internalId>561</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>444</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00539</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        If ECU passive is FALSE (ref. to SWS_CanSM_00646), then the effect E_FULL_COM of the CanSM_BSM 
        state machine (ref. to Figure 7-1) shall call at 1st place for each configured CAN controller 
        of the CAN network the API CanIf_SetPduMode with the parameters ControllerId := 
        CanSMControllerId (ref. to ECUC_CanSM_00141) and PduModeRequest := CANIF_ONLINE.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.OfflineActiveSupport</srcid><srcstatus/><internalId>568</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR42.SWS_CANSM_00539</srcid><srcstatus/><internalId>103</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>445</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00540</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        After considering SWS_CANSM_00435 in context of the effect E_FULL_COM of the CanSM_BSM state 
        machine (ref. to Figure 7 1), the CanSM module shall call the API BswM_CanSM_CurrentState for 
        the corresponding CAN network with the parameters Network := CanSMComMNetworkHandleRef and 
        CurrentState := CANSM_BSWM_FULL_COMMUNICATION.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.EFullComOrder</srcid><srcstatus/><internalId>561</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>446</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00541</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The effect E_FULL_TO_SILENT_COM of the CanSM_BSM state machine (ref. to Figure 7-1) shall call 
        at 2nd place for each configured CAN controller of the CAN network the API CanIf_SetPduMode 
        with the parameters ControllerId := CanSMControllerId (ref. to ECUC_CanSM_00141) and 
        PduModeRequest := CANIF_TX_OFFLINE
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSM.T_FULLCOM_SILENTCOM.BusOffCheck.1</srcid><srcstatus/><internalId>108</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_FULLCOM_SILENTCOM.BusOffCheck.2</srcid><srcstatus/><internalId>109</internalId></linkedfrom><linkedfrom><srcid>CanSM.EB.BSM.T_FULLCOM_SILENTCOM.S_TX_OFF.1</srcid><srcstatus/><internalId>110</internalId></linkedfrom><linkedfrom><srcid>CanSM.EB.BSM.T_FULLCOM_SILENTCOM.S_TX_OFF.2</srcid><srcstatus/><internalId>111</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_FULLCOM_SILENTCOM.1</srcid><srcstatus/><internalId>172</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_FULLCOM_SILENTCOM.2</srcid><srcstatus/><internalId>173</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_SILENTCOM</srcid><srcstatus/><internalId>188</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>447</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00542</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The sub state machine CANSM_BSM_S_CHANGE_BAUDRATE (ref. to Figure 7-10) shall pass the guarding 
        condition G_NO_COM_MODE_REQUESTED, if the latest accepted communication mode request with 
        CanSM_RequestComMode (ref. to SWS_CanSM_00635) for the respective network handle of the state 
        machine has been with the parameter ComM_Mode equal to COMM_NO_COMMUNICATION.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.NoPn.3</srcid><srcstatus/><internalId>186</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.Pn.3</srcid><srcstatus/><internalId>187</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00182</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>300</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>448</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00543</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The sub state machine CANSM_BSM_S_CHANGE_BAUDRATE (ref. to Figure 7-10) shall pass the guarding 
        condition G_NO_COM_MODE_NOT_REQUESTED, if the latest accepted communication mode request with 
        CanSM_RequestComMode (ref. to SWS_CanSM_00635) for the respective network handle of the state 
        machine has been with the parameter ComM_Mode equal to COMM_SILENT_COMMUNICATION or 
        COMM_FULL_COMMUNICATION.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_FULLCOM</srcid><srcstatus/><internalId>171</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_SILENTCOM</srcid><srcstatus/><internalId>188</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00182</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>300</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>449</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00546</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The function CanSM_ConfirmPnAvailability shall notify the CanNm module (ref. to SWS_CanSM_00422)
        if it is called with a configured Transceiver as input parameter (ref. to ECUC_CanSM_00137)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.SWS_CanSM_00422</srcid><srcstatus/><internalId>339</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>450</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00550</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The effect E_SILENT_TO_FULL_COM of the CanSM_BSM state machine (ref. to Figure 7-1) shall be 
        the same as E_FULL_COM (ref. to chapter [REF]
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSM.T_SILENTCOM_FULLCOM</srcid><srcstatus/><internalId>174</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>451</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00555</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The CanSM module shall deny the API request CanSM_RequestComMode, if the initial transition for 
        the requested CAN network is not finished yet after the CanSM_Init request (ref. to 
        SWS_CanSM_00423, SWS_CanSM_00430)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CANSM.DenyModeRequest</srcid><srcstatus/><internalId>550</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>452</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00556</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        If no CAN Transceiver is configured for the CAN network, then this shall trigger the sub state 
        machine CANSM_BSM_DeinitPnNotSupported (ref. to Figure 7-5) of the CAN network in the state 
        S_TRCV_NORMAL with T_TRCV_NORMAL_INDICATED.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.EB.Transitions.NoTransceiver.2</srcid><srcstatus/><internalId>106</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>453</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00557</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        If no CAN Transceiver is configured for the CAN network (ref. to ECUC_CanSM_00137), then this 
        shall trigger the sub state machine CANSM_BSM_DeinitPnNotSupported (ref. to Figure 7-5) of the 
        CAN network in the state S_TRCV_STANDBY with T_TRCV_STANDBY_INDICATED.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.EB.Transitions.NoTransceiver.2</srcid><srcstatus/><internalId>106</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>454</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00558</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        If no CAN Transceiver is configured for the CAN network (ref. to ECUC_CanSM_00137), then this 
        shall trigger the sub state machine CANSM_BSM_S_PRE_FULLCOM (ref. to Figure 7-7) of the CAN 
        network in the state S_TRCV_NORMAL with T_TRCV_NORMAL_INDICATED.
      </description>
      <comment>
        This requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine. The requirement is not complete nor consistent.
        All requirement of this kind are replaced by requirements describing the complete
        state transition.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.BSMPreFull.T_S_TRCV_NORMAL_S_CC_STOPPED</srcid><srcstatus/><internalId>227</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>455</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00560</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        If no CanSMTransceiverId (ref. to ECUC_CanSM_00137) is configured for a CAN Network, then the 
        CanSM module shall bypass all specified CanIf_SetTrcvMode (e. g. SWS_CanSM_00446) calls for the 
        CAN Network and proceed in the different state transitions as if it has got the supposed 
        CanSM_TransceiverModeIndication already (e. g. SWS_CanSM_00448)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.EB.Transitions.NoTransceiver.2</srcid><srcstatus/><internalId>106</internalId></linkedfrom><linkedfrom><srcid>CanSM.EB.Transitions.NoTransceiver.3</srcid><srcstatus/><internalId>107</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>456</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00561</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        Service Name | CanSM_SetBaudrate 
        Syntax 
        Std_ReturnType CanSM_SetBaudrate (NetworkHandleType Network, uint16 BaudRateConfigID)
        Service ID [hex] | 0x0d 
        Sync/Async | Synchronous 
        Reentrancy | Reentrant for different Networks. Non reentrant for the same Network.
        Parameters (in) | Network | Handle of the addressed CAN network for the baud rate change 
        BaudRateConfigID | references a baud rate configuration by ID (see 
        CanControllerBaudRateConfigID)
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | Std_ReturnType | E_OK: Service request accepted, setting of (new) baud rate 
        started E_NOT_OK: Service request not accepted 
        Description | This service shall start an asynchronous process to change the baud rate for the 
        configured CAN controllers of a certain CAN network. Depending on necessary baud rate 
        modifications the controllers might have to reset.
        Available via | CanSM.h 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.1.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_40027</srcid><srcstatus/><internalId>716</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>457</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00569</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The CanSM module shall provide the API function CanSM_SetBaudrate, if the 
        CANSM_SET_BAUDRATE_API parameter (ref. to ECUC_CanSM_00343) is configured with the value TRUE.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.1.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_40027</srcid><srcstatus/><internalId>716</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ECUC_CanSM_00343</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>460</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>458</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00570</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The CanSM module shall not provide the API function CanSM_SetBaudrate, if the
        CANSM_SET_BAUDRATE_API parameter (ref. to ECUC_CanSM_00343) is configured with the value FALSE.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.1.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_40064</srcid><srcstatus/><internalId>607</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ECUC_CanSM_00343</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>460</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>459</internalId></specobject>
    <specobject>
      <id>CanSM.ECUC_CanSM_00343</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name: CanSMSetBaudrateApi
        Parameter Type: EcucBooleanParamDef
        Parent Containers: CanSMGeneral,
        Description: The support of the Can_SetBaudrate API is optional. If this parameter is set to 
        true the Can_SetBaudrate API shall be supported. Otherwise the API is not supported.
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Scope: ECU
        Origin: AUTOSAR_ECUC
        Default value: false
        Post-Build-Variant-Multiplicity: false
        Post-Build-Variant-Value: false
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.1.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.SWS_CanSM_00569</srcid><srcstatus/><internalId>458</internalId></linkedfrom><linkedfrom><srcid>CanSM.SWS_CanSM_00570</srcid><srcstatus/><internalId>459</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>460</internalId></specobject>
    <specobject>
      <id>CanSM.ECUC_CanSM_00344</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name: CanSMPncSupport
        Parameter Type: EcucBooleanParamDef
        Parent Containers: CanSMGeneral,
        Description: Enables or disables support of partial networking.
          False: Partial Networking is disabled True: Partial Networking is enabled
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Scope: LOCAL
        Dependency: This parameter shall be available only if ComMPncSupport is 
          enabled in ComM
        Origin: AUTOSAR_ECUC
        Default value: false
        Post-Build-Variant-Multiplicity: false
        Post-Build-Variant-Value: false
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_PNSUPPORT_OFF</srcid><srcstatus/><internalId>616</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_PNSUPPORT_OFF_TXTIMEOUTSUPPORT_ON</srcid><srcstatus/><internalId>617</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_PNSUPPORT_ON</srcid><srcstatus/><internalId>618</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_PNSUPPORT_ON_NOTRCV</srcid><srcstatus/><internalId>619</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>461</internalId></specobject>
    <specobject>
      <id>CanSM.ECUC_CanSM_00346</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name: CanSMEnableBusOffDelay
        Parameter Type: EcucBooleanParamDef
        Parent Containers: CanSMManagerNetwork,
        Description: This parameter defines if the &lt;User_GetBusOffDelay&gt; shall be called for this 
        network.
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Default value: false
        Post-Build-Variant-Multiplicity: false
        Post-Build-Variant-Value: false
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.BODelay</srcid><srcstatus/><internalId>565</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>462</internalId></specobject>
    <specobject>
      <id>CanSM.ECUC_CanSM_00347</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name: CanSMGetBusOffDelayFunction
        Parameter Type: EcucFunctionNameDef
        Parent Containers: CanSMGeneral,
        Description: This parameter configures the name of the &lt;User_GetBusOffDelay&gt; callout function, 
        which is used by CanSM to acquire an additional L1/L2 delay time. This function is only called 
        for channels where CanSMEnableBusOffDelay is enabled.
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Multiplicity: false
        Post-Build-Variant-Value: false
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        FunctionName Def Condition:Max-Length: , Min-Length
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.BODelay</srcid><srcstatus/><internalId>565</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>463</internalId></specobject>
    <specobject>
      <id>CanSM.ECUC_CanSM_00348</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name: CanSMGetBusOffDelayHeader
        Parameter Type: EcucStringParamDef
        Parent Containers: CanSMGeneral,
        Description: This parameter configures the header file containing the prototype of th
        &lt;User_GetBusOffDelay&gt; callout function.
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Multiplicity: false
        Post-Build-Variant-Value: false
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.BODelay</srcid><srcstatus/><internalId>565</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>464</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00576</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        After a timeout of CANSM_MODEREQ_REPEAT_TIME (ref. to ECUC_CanSM_00336) for all supposed 
        controller stopped mode indications (ref. to SWS_CanSM_00579), this condition shall trigger the 
        sub state machine CANSM_BSM_S_TX_TIMEOUT_EXCEPTION (ref. to Figure 7-9) of the respective 
        network with T_CC_STOPPED_TIMEOUT.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR41.TX_TIMEOUT_EXCEPTION.T_S_CC_STOPPED_S_CC_STOPPED</srcid><srcstatus/><internalId>98</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>465</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00577</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The guarding condition G_CC_STOPPED_E_OK of the sub state machine 
        CANSM_BSM_S_TX_TIMEOUT_EXCEPTION (ref. to Figure 7-9) shall be passed, if all API calls of 
        SWS_CanSM_00578 have returned E_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR41.TX_TIMEOUT_EXCEPTION.T_S_CC_STOPPED_S_CC_STARTED</srcid><srcstatus/><internalId>99</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>466</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00578</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        As long the sub state machine CANSM_BSM_S_TX_TIMEOUT_EXCEPTION (ref. to Figure 7-9) is in the 
        state S_CC_STOPPED, the CanSM module shall operate the do action DO_SET_CC_MODE_STOPPED and 
        therefore repeat for all configured CAN controllers of the CAN network (ref. to 
        ECUC_CanSM_00141) the API request CanIf_SetControllerMode (ref. to chapter [REF]) with 
        ControllerMode equal to CAN_CS_STOPPED, if the current CAN controller mode (ref. to 
        SWS_CanSM_00638) is different.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.CtrlModeReqCheck</srcid><srcstatus/><internalId>574</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR41.BSM.T_FULLCOM_TX_TIMEOUT_EXCEPTION</srcid><srcstatus/><internalId>96</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR41.TX_TIMEOUT_EXCEPTION.T_S_CC_STOPPED_S_CC_STOPPED</srcid><srcstatus/><internalId>98</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>467</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00579</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        If CanSM module has got all mode indications (ref. to SWS_CanSM_00396) for the configured CAN 
        controllers of the CAN network (ref. to ECUC_CanSM_00141) after the respective requests to stop 
        the CAN controllers of the CAN network (ref. to SWS_CanSM_00524), this shall trigger the sub 
        state machine CANSM_BSM_S_TX_TIMEOUT_EXCEPTION (ref. to Figure 7-9) of the CAN network with 
        T_CC_STOPPED_INDICATED.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.1.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR41.TX_TIMEOUT_EXCEPTION.T_S_CC_STOPPED_S_CC_STARTED</srcid><srcstatus/><internalId>99</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>468</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00580</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        If CanSM module has got all mode indications (ref. to SWS_CanSM_00396) for the configured CAN 
        controllers of the CAN network (ref. to ECUC_CanSM_00141) after the respective requests to 
        start the CAN controllers of the CAN network (ref. to SWS_CanSM_00582), this shall trigger the 
        sub state machine CANSM_BSM_S_TX_TIMEOUT_EXCEPTION (ref. to Figure 7-9) of the CAN network with 
        T_CC_STARTED_INDICATED.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.1.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR41.BSM.T_TX_TIMEOUT_EXCEPTION_FULLCOM</srcid><srcstatus/><internalId>97</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>469</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00581</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The guarding condition G_CC_STARTED_E_OK of the sub state machine 
        CANSM_BSM_S_TX_TIMEOUT_EXCEPTION (ref. to Figure 7-9) shall be passed, if all API calls of 
        SWS_CanSM_00582 have returned E_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.1.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR41.BSM.T_TX_TIMEOUT_EXCEPTION_FULLCOM</srcid><srcstatus/><internalId>97</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>470</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00582</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        As long the sub state machine CANSM_BSM_S_TX_TIMEOUT_EXCEPTION (ref. to Figure 7-9) is in the 
        state S_CC_STARTED, the CanSM module shall operate the do action DO_SET_CC_MODE_STARTED and 
        therefore repeat for all configured CAN controllers of the CAN network (ref. to 
        ECUC_CanSM_00141) the API request CanIf_SetControllerMode (ref. to chapter [REF]) with 
        ControllerMode equal to CAN_CS_STARTED, if the current CAN controller mode (ref. to 
        SWS_CanSM_00638) is different.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.CtrlModeReqCheck</srcid><srcstatus/><internalId>574</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR41.TX_TIMEOUT_EXCEPTION.T_S_CC_STOPPED_S_CC_STARTED</srcid><srcstatus/><internalId>99</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR41.TX_TIMEOUT_EXCEPTION.T_S_CC_STARTED_S_CC_STARTED</srcid><srcstatus/><internalId>100</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>471</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00584</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The callback function CanSM_TxTimeoutException (ref. to SWS_CANSM_00410) shall trigger the sub 
        state machine CANSM_BSM_S_FULLCOM (ref. to Figure 7-8) with T_TX_TIMEOUT_EXCEPTION.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR41.BSM.T_FULLCOM_TX_TIMEOUT_EXCEPTION</srcid><srcstatus/><internalId>96</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>472</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00596</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanSM_StateType 
        Kind | Enumeration 
        Range | CANSM_INITED 
        CANSM_UNINITED 
        Description | Defines the values of the internal states of the CanSM module 
        Available via | CanSM.h 
      </description>
      <comment>
        This requirement is informational only.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>473</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00597</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanSM_ConfigType 
        Kind | Structure 
        Elements 
        Type 
        Comment 
        Description | This type defines a data structure for the post build parameters of the CanSM. At 
        initialization the CanSM gets a pointer to a structure of this type to get access to its 
        configuration data, which is necessary for initialization.
        Available via | CanSM.h 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dsn.CanSM.PostBuildConfigurationData</srcid><srcstatus/><internalId>599</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_PBSELECTABLE</srcid><srcstatus/><internalId>620</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>474</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00598</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanSM_BswMCurrentStateType 
        Kind | Enumeration 
        Range | CANSM_BSWM_NO_COMMUNICATION 
        CANSM_BSWM_SILENT_COMMUNICATION 
        CANSM_BSWM_FULL_COMMUNICATION 
        CANSM_BSWM_BUS_OFF 
        CANSM_BSWM_CHANGE_BAUDRATE 
        Description | Can specific communication modes / states notified to the BswM module 
        Available via | CanSM.h 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.DataTypes.CanSM_BswMCurrentStateType.2</srcid><srcstatus/><internalId>263</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>475</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00600</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        If CanSM module has got all mode indications (ref. to SWS_CanSM_00396) for the configured CAN 
        controllers of the CAN network (ref. to ECUC_CanSM_00141) after the respective requests to 
        start the CAN controllers of the CAN network (ref. to SWS_CanSM_00604), this shall trigger the 
        sub state CANSM_BSM_S_SILENTCOM_BOR (ref. to Figure 7-6) of the CAN network with 
        T_RESTART_CC_INDICATED.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.SilentComBOR</srcid><srcstatus/><internalId>566</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>476</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00602</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        After a timeout of CANSM_MODEREQ_REPEAT_TIME (ref. to ECUC_CanSM_00336) for all supposed 
        controller started mode indications (ref. to SWS_CanSM_00600), this condition shall trigger the 
        sub state machine CANSM_BSM_S_SILENTCOM_BOR (ref. to Figure 7-6) of the respective network with 
        T_RESTART_CC_TIMEOUT.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.SilentComBOR</srcid><srcstatus/><internalId>566</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>477</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00603</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The guarding condition G_RESTART_CC_OK of the sub state machine CANSM_BSM_S_SILENTCOM_BOR (ref.
        to Figure 7-6) shall be passed, if all API calls of SWS_CanSM_00604 have returned E_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.SilentComBOR</srcid><srcstatus/><internalId>566</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>478</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00604</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        As long the sub state machine CANSM_BSM_S_SILENTCOM_BOR (ref. to Figure 7-6) is in the state 
        S_RESTART_CC, the CanSM module shall operate the do action DO_SET_CC_MODE_STARTED and therefore 
        repeat for all configured CAN controllers of the CAN network (ref. to ECUC_CanSM_00141) the API 
        request CanIf_SetControllerMode (ref. to chapter [REF]) with ControllerMode equal to 
        CAN_CS_STARTED, if the current CAN controller mode (ref. to SWS_CanSM_00638) is different.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.SilentComBOR</srcid><srcstatus/><internalId>566</internalId></linkedfrom><linkedfrom><srcid>dev.CanSM.CtrlModeReqCheck</srcid><srcstatus/><internalId>574</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>479</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00605</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The effect E_BUS_OFF of the sub state machine CANSM_BSM_S_FULLCOM CANSM_BSM_S_SILENTCOM_BOR (
        ref. to Figure 7-6) shall invocate Dem_SetEventStatus (ref. to chapter [REF]) with the 
        parameters EventId := CANSM_E_BUS_OFF (ref. to ECUC_CanSM_00070) and EventStatus := 
        DEM_EVENT_STATUS_PRE_FAILED.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.SilentComBOR</srcid><srcstatus/><internalId>566</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>480</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00606</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The callback function CanSM_ControllerBusOff (ref. to SWS_CanSM_00064) shall trigger the state 
        machine CANSM_BSM (ref. to Figure 7-1) for the CAN network with T_BUS_OFF, if one of its 
        configured CAN controllers matches to the function parameter ControllerId of the callback 
        function CanSM_ControllerBusOff.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.SilentComBOR</srcid><srcstatus/><internalId>566</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>481</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00607</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        If the API request CanSM_StartWakeUpSource (ref. to SWS_CanSM_00609) returns E_OK (ref. to 
        SWS_CanSM_00616), it shall trigger the state machine (ref. to Figure 7-1) with 
        T_START_WAKEUP_SOURCE.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.WUValidation</srcid><srcstatus/><internalId>567</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>482</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00608</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        If the API request CanSM_StopWakeUpSource (ref. to SWS_CanSM_00610) returns E_OK (ref. 
        toSWS_CanSM_00622), it shall trigger the state machine (ref. to Figure 7-1) with 
        T_STOP_WAKEUP_SOURCE.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.WUValidation</srcid><srcstatus/><internalId>567</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>483</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00609</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        Service Name | CanSM_StartWakeupSource 
        Syntax 
        Std_ReturnType CanSM_StartWakeupSource (NetworkHandleType network)
        Service ID [hex] | 0x11 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | network | Affected CAN network 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | Std_ReturnType | E_OK: Request accepted E_NOT_OK: Request denied 
        Description | This function shall be called by EcuM when a wakeup source shall be started.
        Available via | CanSM.h 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.WUValidation</srcid><srcstatus/><internalId>567</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>484</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00610</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        Service Name | CanSM_StopWakeupSource 
        Syntax 
        Std_ReturnType CanSM_StopWakeupSource (NetworkHandleType network)
        Service ID [hex] | 0x12 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | network | Affected CAN network 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | Std_ReturnType | E_OK: Request accepted E_NOT_OK: Request denied 
        Description | This function shall be called by EcuM when a wakeup source shall be stopped.
        Available via | CanSM.h 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.WUValidation</srcid><srcstatus/><internalId>567</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>485</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00611</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The API function CanSM_StartWakeupSource shall return E_NOT_OK, if the CanSM module is not 
        initialized yet with CanSM_Init (ref. to SWS_CANSM_00023)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.WUValidation</srcid><srcstatus/><internalId>567</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>486</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00612</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The function CanSM_StartWakeupSource shall return E_NOT_OK, if the CanSM module is initialized 
        and the network parameter of the request is not a handle contained in the configuration of the 
        CanSM module (ref. to ECUC_CanSM_00161)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.WUValidation</srcid><srcstatus/><internalId>567</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>487</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00613</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The function CanSM_StartWakeupSource shall call the function Det_ReportError with ErrorId 
        parameter CANSM_E_INVALID_NETWORK_HANDLE, if the CanSM module is initialized and the requested 
        handle is invalid concerning the CanSM configuration (ref. to ECUC_CanSM_00161)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.WUValidation</srcid><srcstatus/><internalId>567</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>488</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00616</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The function CanSM_StartWakeupSource shall return E_OK and it shall be considered as trigger (
        ref. to SWS_CanSM_00607) for the state machine of the related network, if the CanSM module is 
        initialized and the requested handle is valid concerning the CanSM configuration (ref. to 
        ECUC_CanSM_00161)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.WUValidation</srcid><srcstatus/><internalId>567</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>489</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00617</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The function CanSM_StartWakeupSource shall call the function Det_ReportError with ErrorId 
        parameter CANSM_E_UNINIT, if the CanSM module is not initialized yet with CanSM_Init (ref. to 
        SWS_CANSM_00023)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.WUValidation</srcid><srcstatus/><internalId>567</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>490</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00618</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The API function CanSM_StopWakeupSource shall return E_NOT_OK, if the CanSM module is not 
        initialized yet with CanSM_Init (ref. to SWS_CANSM_00023)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.WUValidation</srcid><srcstatus/><internalId>567</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>491</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00619</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The function CanSM_StopWakeupSource shall call the function Det_ReportError with ErrorId 
        parameter CANSM_E_UNINIT, if the CanSM module is not initialized yet with CanSM_Init (ref. to 
        SWS_CANSM_00023)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.WUValidation</srcid><srcstatus/><internalId>567</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>492</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00620</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The function CanSM_StopWakeupSource shall return E_NOT_OK, if the CanSM module is initialized 
        and the network parameter of the request is not a handle contained in the configuration of the 
        CanSM module (ref. to ECUC_CanSM_00161)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.WUValidation</srcid><srcstatus/><internalId>567</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>493</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00621</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The function CanSM_StopWakeupSource shall call the function Det_ReportError with ErrorId 
        parameter CANSM_E_INVALID_NETWORK_HANDLE, if the CanSM module is initialized and the requested 
        handle is invalid concerning the CanSM configuration (ref. to ECUC_CanSM_00161)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.WUValidation</srcid><srcstatus/><internalId>567</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>494</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00622</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The function CanSM_StopWakeupSource shall return E_OK and it shall be considered as trigger (
        ref. to SWS_CanSM_00608) for the state machine of the related network, if the CanSM module is 
        initialized and the requested handle is valid concerning the CanSM configuration (ref. to 
        ECUC_CanSM_00161)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.WUValidation</srcid><srcstatus/><internalId>567</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>495</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00623</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        If for the CAN network a CAN Transceiver is configured (ref. to ECUC_CanSM_00137), then as long 
        the sub state machine CANSM_BSM_WUVALIDATION (ref. to Figure 7-2) is in the state S_TRCV_NORMAL,
        the CanSM module shall operate the do action DO_SET_TRCV_MODE_NORMAL and therefore repeat for 
        the configured CAN Transceiver of the CAN network (ref. to ECUC_CanSM_00137) the API request 
        CanIf_SetTrcvMode (ref. to chapter [REF]) with TransceiverMode equal to CANTRCV_TRCVMODE_NORMAL.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.WUValidation</srcid><srcstatus/><internalId>567</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>496</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00624</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The guarding condition G_TRCV_NORMAL_E_OK of the sub state machine CANSM_BSM_WUVALIDATION (ref.
        to Figure 7-2) shall be passed, if the API call of SWS_CanSM_00483 has returned E_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.WUValidation</srcid><srcstatus/><internalId>567</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>497</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00625</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        If CanSM module has got the CANTRCV_TRCVMODE_NORMAL mode indication (ref. to SWS_CanSM_00399) 
        for the configured CAN Transceiver of the CAN network (ref. to ECUC_CanSM_00137) after the 
        respective request (ref. to SWS_CanSM_00623), this shall trigger the sub state machine machine 
        CANSM_BSM_WUVALIDATION (ref. to Figure 7-2) of the CAN network with T_TRCV_NORMAL_INDICATED.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.WUValidation</srcid><srcstatus/><internalId>567</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>498</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00626</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        After a timeout of CANSM_MODEREQ_REPEAT_TIME (ref. to ECUC_CanSM_00336) for the supposed 
        transceiver normal indication (ref. to SWS_CanSM_00625), this condition shall trigger the sub 
        state machine CANSM_BSM_WUVALIDATION (ref. to Figure 7-2) of the respective network with 
        T_TRCV_NORMAL_TIMEOUT.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.WUValidation</srcid><srcstatus/><internalId>567</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>499</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00627</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        As long the sub state machine CANSM_BSM_WUVALIDATION (ref. to Figure 7-2) is in the state 
        S_CC_STOPPED, the CanSM module shall operate the do action DO_SET_CC_MODE_STOPPED and therefore 
        repeat for all configured CAN controllers of the CAN network (ref. to ECUC_CanSM_00141) the API 
        request CanIf_SetControllerMode (ref. to chapter [REF]) with ControllerMode equal to 
        CAN_CS_STOPPED, if the current CAN controller mode (ref. to SWS_CanSM_00638) is different.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.WUValidation</srcid><srcstatus/><internalId>567</internalId></linkedfrom><linkedfrom><srcid>dev.CanSM.CtrlModeReqCheck</srcid><srcstatus/><internalId>574</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>500</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00628</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The guarding condition G_CC_STOPPED_OK of the sub state machine CANSM_BSM_WUVALIDATION (ref. to 
        Figure 7-2) shall be passed, if all API calls of SWS_CanSM_00627 have returned E_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.WUValidation</srcid><srcstatus/><internalId>567</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>501</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00629</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        If the CanSM module has got all mode indications (ref. to SWS_CanSM_00396) for the configured 
        CAN controllers of the CAN network (ref. to ECUC_CanSM_00141) after the respective requests to 
        stop the CAN controllers of the CAN network (ref. to SWS_CanSM_00627), this shall trigger the 
        sub state machine CANSM_BSM_WUVALIDATION (ref. to Figure 7-2) of the CAN network with 
        T_CC_STOPPED_INDICATED.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.WUValidation</srcid><srcstatus/><internalId>567</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>502</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00630</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        After a timeout of CANSM_MODEREQ_REPEAT_TIME (ref. to ECUC_CanSM_00336) for all supposed 
        controller stopped mode indications (ref. toSWS_CanSM_00629), this condition shall trigger the 
        sub state machine CANSM_BSM_WUVALIDATION (ref. to Figure 7-2) of the respective network with 
        T_CC_STOPPED_TIMEOUT.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.WUValidation</srcid><srcstatus/><internalId>567</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>503</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00631</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        As long the sub state machine CANSM_BSM_WUVALIDATION (ref. to Figure 7-2) is in the state 
        S_CC_STARTED, the CanSM module shall operate the do action DO_SET_CC_MODE_STARTED and therefore 
        repeat for all configured CAN controllers of the CAN network (ref. to ECUC_CanSM_00141) the API 
        request CanIf_SetControllerMode (ref. to chapter [REF]) with ControllerMode equal to 
        CAN_CS_STARTED, if the current CAN controller mode (ref. to SWS_CanSM_00638) is different.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.WUValidation</srcid><srcstatus/><internalId>567</internalId></linkedfrom><linkedfrom><srcid>dev.CanSM.CtrlModeReqCheck</srcid><srcstatus/><internalId>574</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>504</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00632</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The guarding condition G_CC_STARTED_OK of the sub state machine CANSM_BSM_WUVALIDATION (ref. to 
        Figure 7-2) shall be passed, if all API calls of SWS_CanSM_00631 have returned E_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.WUValidation</srcid><srcstatus/><internalId>567</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>505</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00633</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        If CanSM module has got all mode indications (ref. to SWS_CanSM_00396) for the configured CAN 
        controllers of the CAN network (ref. to ECUC_CanSM_00141) after the respective requests to 
        start the CAN controllers of the CAN network (ref. to SWS_CanSM_00631), this shall trigger the 
        sub state machine CANSM_BSM_WUVALIDATION (ref. to Figure 7-2) of the CAN network with 
        T_CC_STARTED_INDICATED.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.WUValidation</srcid><srcstatus/><internalId>567</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>506</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00634</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        After a timeout of CANSM_MODEREQ_REPEAT_TIME (ref. to ECUC_CanSM_00336) for all supposed 
        controller started mode indications (ref. toSWS_CanSM_00633), this condition shall trigger the 
        sub state machine CANSM_BSM_WUVALIDATION (ref. to Figure 7-2) of the respective network with 
        T_CC_STARTED_TIMEOUT.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.WUValidation</srcid><srcstatus/><internalId>567</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>507</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00635</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The CanSM module shall store for each configured CAN network (ref. to ECUC_CanSM_00126) the 
        latest communication mode request, which has been accepted by returning E_OK in the API request 
        CanSM_RequestComMode (ref. to SWS_CANSM_00062, SWS_CANSM_00182) and use it as trigger for the 
        state machine of the related CAN network (ref. to Figure 7-1), SWS_CanSM_00427, SWS_CanSM_00429,
        SWS_CanSM_00499, SWS_CanSM_00542, SWS_CanSM_00543, SWS_CANSM_00425, SWS_CANSM_00426, 
        SWS_CANSM_00554)
      </description>
      <furtherinfo> 
        Justifying rule: WRN.swurs.needscoverage.count violation.
        The requirement describes only a single trigger or guardian condition or
        effect of the CanSM state machine, It is not complete nor consistent All requirement of this kind
        are coverd by more than 10 requirements describing the complete state transition.
      </furtherinfo>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.EB.Transitions.NoTransceiver.3</srcid><srcstatus/><internalId>107</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_FULLCOM_SILENTCOM.BusOffCheck.1</srcid><srcstatus/><internalId>108</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_FULLCOM_SILENTCOM.BusOffCheck.2</srcid><srcstatus/><internalId>109</internalId></linkedfrom><linkedfrom><srcid>CanSM.EB.BSM.T_FULLCOM_SILENTCOM.S_TX_OFF.1</srcid><srcstatus/><internalId>110</internalId></linkedfrom><linkedfrom><srcid>CanSM.EB.BSM.T_FULLCOM_SILENTCOM.S_TX_OFF.2</srcid><srcstatus/><internalId>111</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_FULLCOM</srcid><srcstatus/><internalId>171</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_FULLCOM_SILENTCOM.1</srcid><srcstatus/><internalId>172</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_FULLCOM_SILENTCOM.2</srcid><srcstatus/><internalId>173</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_SILENTCOM_FULLCOM</srcid><srcstatus/><internalId>174</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_NOCOM_PRE_FULLCOM</srcid><srcstatus/><internalId>175</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.NoPn.3</srcid><srcstatus/><internalId>186</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.Pn.3</srcid><srcstatus/><internalId>187</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_SILENTCOM</srcid><srcstatus/><internalId>188</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_SILENTCOM_PRE_NOCOM.NoPn</srcid><srcstatus/><internalId>189</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.BSM.T_SILENTCOM_PRE_NOCOM.Pn</srcid><srcstatus/><internalId>190</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>508</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00636</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        If CanSMEnableBusOffDelay is TRUE, then the guarding conditions of SWS_CANSM_00514 and 
        SWS_CANSM_00515 shall be passed after the specified time duration in each case plus the 
        additional random delay value, which shall be requested after the bus-off event with the 
        configured call back function &lt;User_GetBusOffDelay&gt;
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.BODelay</srcid><srcstatus/><internalId>565</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>509</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00637</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        Service Name | &lt;User_GetBusOffDelay&gt;
        Syntax 
        void &lt;User_GetBusOffDelay&gt; (NetworkHandleType network, uint8* delayCyclesPtr)
        Sync/Async | Synchronous 
        Reentrancy | Reentrant for different networks 
        Parameters (in) | network | CAN network where a BusOff occurred.
        Parameters (inout) | None 
        Parameters (out) | delayCyclesPtr | Number of CanSM base cycles to wait additionally to L1/L2 
        after a BusOff occurred.
        Return value | None 
        Description | This callout function returns the number of CanSM base cycles to wait 
        additionally to L1/L2 after a BusOff occurred.
        Available via | configurable 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.BODelay</srcid><srcstatus/><internalId>565</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>510</internalId></specobject>
    <specobject>
      <id>CanSM.ECUC_CanSM_00349</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name: CanSMTxOfflineActiveSupport
        Parameter Type: EcucBooleanParamDef
        Parent Containers: CanSMGeneral,
        Description: Determines whether the ECU passive feature is supported by CanSM.
          True: Enabled False: Disabled
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Scope: LOCAL
        Dependency: CanIfTxOfflineActiveSupport
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Multiplicity: false
        Post-Build-Variant-Value: false
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.OfflineActiveSupport</srcid><srcstatus/><internalId>568</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>511</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00638</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The CanSM module shall store after every successful CAN controller mode change (ref. to 
        SWS_CANSM_00396) or bus-off conditioned change to CAN_CS_STOPPED (ref. to SWS_CANSM_00064), the 
        changed mode internally for each CAN controller.
      </description>
      <comment>
        CanIf accepts controller mode indication both with Can_ControllerStateType and CanIf_ControllerModeType
        and translates the modes for CanSM, so even if this requirement states a Can_ControllerStateType,
        while CanSM only supports CanIf_ControllerModeType for indications, this requirement is still covered,
        since CanSM will store an internally defined mode anyway.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_MODE_REQ_REP_PARTIAL</srcid><srcstatus/><internalId>628</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_TX_ON_DELAYED</srcid><srcstatus/><internalId>629</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_T_NOCO_FUCO_2CC_2NW_Distribution_2EcucPartition</srcid><srcstatus/><internalId>631</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_WRONG_INDICATION</srcid><srcstatus/><internalId>837</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>512</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00639</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The state operation DO_SET_BAUDRATE_DIRECT (ref. to Figure 7-10) shall call the API request 
        CanIf_SetBaudrate (ref. to chapter [REF]) for all configured CAN controllers of the CAN network 
        ref. to ECUC_CanSM_00141 with the respective ControllerId parameter. It shall use as 
        BaudRateConfigID parameter the respective function parameter BaudRateConfigID from the call 
        CanSM_SetBaudrate 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.ChBROperation</srcid><srcstatus/><internalId>563</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>513</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00641</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        If all CanIf_SetBaudrate (ref. to SWS_CanSM_00639) requests returned with E_OK, the guarding 
        condition G_SET_BAUDRATE_DIRECT_OK shall be passed.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.ChBROperation</srcid><srcstatus/><internalId>563</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>514</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00642</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        If any of the CanIf_SetBaudrate (ref. to SWS_CanSM_00639) requests did return with E_NOT_OK, 
        the guarding condition G_SET_BAUDRATE_NOT_OK of the state CANSM_BSM_CHANGE_BR_SYNC (ref. to 
        Figure 7-10) shall be passed.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.ChBROperation</srcid><srcstatus/><internalId>563</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>515</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00644</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        Service Name | CanSM_SetEcuPassive 
        Syntax 
        Std_ReturnType CanSM_SetEcuPassive (boolean CanSM_Passive)
        Service ID [hex] | 0x13 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | CanSM_Passive | TRUE: set all CanSM channels to passive, i.e. receive only 
        FALSE: set all CanSM channels back to non-passive 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | Std_ReturnType | E_OK: Request acceptedE_NOT_OK: Request not accepted 
        Description | This function can be used to set all CanSM channels of the ECU to a receive only 
        mode. This mode will be kept either until it is set back, or the ECU is reset.
        Available via | CanSM.h 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.OfflineActiveSupport</srcid><srcstatus/><internalId>568</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>516</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00645</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The CanSM module shall provide the API function CanSM_SetEcuPassive, if the 
        CanSMTxOfflineActiveSupport parameter (ref. to ECUC_CanSM_00349) is configured with the value 
        TRUE.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.OfflineActiveSupport</srcid><srcstatus/><internalId>568</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>517</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00646</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The CanSM state manager shall store the state of the requested ECU passive mode (ref. to 
        chapter 8: SWS_CanSM_00644)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.OfflineActiveSupport</srcid><srcstatus/><internalId>568</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>518</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00647</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        If ECU passive is TRUE (ref. to SWS_CanSM_00646), then the effect E_FULL_COM of the CanSM_BSM 
        state machine (ref. to Figure 7-1) shall call at 1st place for each configured CAN controller 
        of the CAN network the API CanIf_SetPduMode with the parameters ControllerId := 
        CanSMControllerId (ref. to ECUC_CanSM_00141) and PduModeRequest := CANIF_TX_OFFLINE_ACTIVE.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.OfflineActiveSupport</srcid><srcstatus/><internalId>568</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>519</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00649</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        If CanSM_SetEcuPassive called with CanSM_Passive=true; (ref. to chapter 8: SWS_CanSM_00644), 
        then the CanSM shall change all PDU modes of the configured CAN controllers, which are 
        CANIF_ONLINE at the moment to CANIF_TX_OFFLINE_ACTIVE by calling the API CanIf_SetPduMode (ref.
        to chapter [REF]) with the parameters ControllerId := CanSMControllerId (ref. to 
        ECUC_CanSM_00141) and PduModeRequest := CANIF_TX_OFFLINE_ACTIVE.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.OfflineActiveSupport</srcid><srcstatus/><internalId>568</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>520</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00650</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        If CanSM_SetEcuPassive called with CanSM_Passive=false; (ref. to chapter 8: SWS_CanSM_00644), 
        then the CanSM shall change all PDU modes of the configured CAN controllers, which are 
        CANIF_TX_OFFLINE_ACTIVE at the moment to CANIF_ONLINE by calling the API CanIf_SetPduMode (ref.
        to chapter [REF]) with the parameters ControllerId := CanSMControllerId (ref. to 
        ECUC_CanSM_00141) and PduModeRequest := CANIF_ONLINE.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.OfflineActiveSupport</srcid><srcstatus/><internalId>568</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>521</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00651</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        If a communication mode request for the network is present already (ref. to SWS_CanSM_00635) 
        and the stored communication mode request is COMM_NO_COMMUNICATION, then the effect E_NOCOM of 
        the CanSM_BSM state machine (ref. to Figure 7-1) shall call the API ComM_BusSM_ModeIndication 
        with the parameters Channel := CanSMComMNetworkHandleRef (ref. to ECUC_CanSM_00161) and ComMode 
        COMM_NO_COMMUNICATION.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.ENoComIndication</srcid><srcstatus/><internalId>560</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>522</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00652</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        The following requirements are not applicable to this specification, because they are either 
        general BSW requirements, which apply to all BSW modules and not only especially to the CanSM 
        module or they are not applicable at all.
      </description>
      <comment>
        This requirement is informational only.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>523</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00653</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        If more than one CAN controller belongs to one CAN network and for one of its controllers a bus-
        off is indicated with CanSM_ControllerBusOff, then the CanSM shall stop in context of the 
        effect E_BUS_OFF the other CAN contoller(s) of the CAN network, too.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.BOEffect</srcid><srcstatus/><internalId>569</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>524</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00654</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        Type of error | Related error code | Error value 
        API service used without module initialization | CANSM_E_UNINITCanSM.CANSM_E_UNINIT | 0x01 
        API service called with wrong pointer | CANSM_E_PARAM_POINTERCanSM.CANSM_E_PARAM_POINTER | 0x02 
        API service called with wrong parameter | CANSM_E_INVALID_NETWORK_HANDLECanSM.
        CANSM_E_INVALID_NETWORK_HANDLE | 0x03 
        API service called with wrong parameter | CANSM_E_PARAM_CONTROLLERCanSM.
        CANSM_E_PARAM_CONTROLLER | 0x04 
        API service called with wrong parameter | CANSM_E_PARAM_TRANSCEIVERCanSM.
        CANSM_E_PARAM_TRANSCEIVER | 0x05 
        DeInit API service called when not all CAN networks are in state CANSM_NO_COMMUNICATION | 
        CANSM_E_NOT_IN_NO_COM CanSM.CANSM_E_NOT_IN_NO_COM | 0x0B 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.DevelopmentRuntimeErrors</srcid><srcstatus/><internalId>558</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>525</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00655</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        If the sub state machine CANSM_BSM_S_TX_TIMEOUT_EXCEPTION (ref. to Figure 7-9) is triggered 
        with T_CC_STARTED_INDICATED, the API CanIf_SetPduMode() shall be called with CANIF_ONLINE
      </description>
      <furtherinfo> 
        Justifying rule: WRN.swuts.needscoverage.count violation.
        A requirement can end up being satisified by numerous tests because
        the module can be subject to various scenarios 
      </furtherinfo>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANSM_TXTIMEOUTEXCEPTION_ASYNC_NoPN_DET_ON</srcid><srcstatus/><internalId>638</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_TXTIMEOUTEXCEPTION_SYNC_NoPN_DET_ON</srcid><srcstatus/><internalId>639</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_TXTIMEOUTEXCEPTION_ASYNC_SYNC_1_NoPN_DET_ON</srcid><srcstatus/><internalId>640</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_TXTIMEOUTEXCEPTION_ASYNC_SYNC_2_NoPN_DET_ON</srcid><srcstatus/><internalId>641</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_TXTIMEOUTEXCEPTION_2ND_CALL_NoPN_DET_ON</srcid><srcstatus/><internalId>647</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_TXTIMEOUTEXCEPTION_ASYNC</srcid><srcstatus/><internalId>769</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_TXTIMEOUTEXCEPTION_SYNC</srcid><srcstatus/><internalId>770</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_TXTIMEOUTEXCEPTION_ASYNC_SYNC_1</srcid><srcstatus/><internalId>771</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_TXTIMEOUTEXCEPTION_ASYNC_SYNC_2</srcid><srcstatus/><internalId>772</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_TXTIMEOUTEXCEPTION_TIMEOUT_3</srcid><srcstatus/><internalId>775</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_TXTIMEOUTEXCEPTION_TIMEOUT_5</srcid><srcstatus/><internalId>777</internalId></linkedfrom><linkedfrom><srcid>TS_CANSM_TXTIMEOUTEXCEPTION_2ND_CALL</srcid><srcstatus/><internalId>779</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>526</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00656</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        If the CanSM needs informations about the actual PduMode, the CanSM shall call the API 
        CanIf_GetPduMode to get the current Pdu Mode of the CanIf.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.OfflineActiveSupport</srcid><srcstatus/><internalId>568</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>527</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00658</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        If the CanSM module is requested with the function CanSM_DeInit, this shall trigger the CanSM 
        state machines (ref. to Figure 7-1) for all configured CAN Networks (ref. to ECUC_CanSM_00126) 
        with the trigger CanSM_DeInit.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.DeinitSupport</srcid><srcstatus/><internalId>570</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>528</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00660</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        If development error detection for the CanSM module is enabled: The function CanSM_DeInit shall 
        raise the error CANSM_E_NOT_IN_NO_COM if not all CAN networks are in state 
        CANSM_NO_COMMUNICATION.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.DeinitSupport</srcid><srcstatus/><internalId>570</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>529</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_91001</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        Service Name | CanSM_DeInit 
        Syntax 
        void CanSM_DeInit (void)
        Service ID [hex] | 0x14 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | None 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | None 
        Description | This service de-initializes the CanSM module.
        Available via | CanSM.h 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.DeinitSupport</srcid><srcstatus/><internalId>570</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>530</internalId></specobject>
    <specobject>
      <id>CanSM.ECUC_CanSM_00352</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name: CANSM_E_MODE_REQUEST_TIMEOUT
        Parameter Type: Symbolic name reference to [ DemEventParameter ]
        Parent Containers: CanSMDemEventParameterRefs,
        Description: Reference to configured DEM event to report bus off errors for this CAN network.
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Scope: LOCAL
        Dependency: Dem
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Multiplicity: true
        Post-Build-Variant-Value: true
        Multiplicity-Configuration Class: LINK, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Destination: /AUTOSAR/EcucDefs/Dem/DemConfigSet/DemEventParameter
        Destination type: ECUC-PARAM-CONF-CONTAINER-DEF
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.DemEventModeRequest</srcid><srcstatus/><internalId>571</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>531</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CanSM_00666</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        Error Name: | CANSM_E_BUS_OFF (ref. to ECUC_CanSM_00070)
        Short Description: | Bus-off detection 
        Long Description: | The bus-off recovery state machine of a CAN network has detected a certain 
        amount of sequential bus-offs without successful recovery 
        Recommended DTC: | Assigned by DEM 
        Detection Criteria: | Fail | PRE_FAILED when CanSM_ControllerBusOff is called (T_BUS_OFF/
        E_BUS_OFF), debouncing to be defined by OEM in DEM 
        Pass | After successful transmission of a CAN frame (G_BUS_OFF_PASSIVE/E_BUS_OFF_PASSIVE)
        Secondary Parameters: | None 
        Time Required: | PRE_FAILED immediately (in error interrupt context), FAILED depending on 
        debounce configuration of DEM 
        Monitor Frequency | Continuous 
        MIL illumniation: | Assigned by DEM 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanSM.ASR40.SWS_CanSM_00498</srcid><srcstatus/><internalId>58</internalId></linkedfrom><linkedfrom><srcid>CanSM.ASR40.SWS_CanSM_00522</srcid><srcstatus/><internalId>65</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>532</internalId></specobject>
    <specobject>
      <id>CanSM.ECUC_CanSM_00351</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        Module Name | CanSM
        Module Description | Configuration of the CanSM module 
        Post-Build Variant Support | true 
        Supported Config Variants | VARIANT-LINK-TIME, VARIANT-POST-BUILD, VARIANT-PRE-COMPILE 
        Included containers:
        Container Name | Multiplicity | Scope / Dependency 
        CanSMConfiguration | 1 | This container contains the global parameters of the CanSM and sub 
        containers, which are for the CAN network specific configuration.
        CanSMGeneral | 1 | Container for general pre-compile parameters of the CanSM module 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CANSM.ImplementationConfigVariant</srcid><srcstatus/><internalId>544</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00250</linksto>
               <dstversion>2</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>87</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00251</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>88</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00361</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>35</internalId></provcov>
            <provcov>
               <linksto>CanSM.ASR40.SWS_CanSM_00010</linksto>
               <dstversion>2</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>7</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>533</internalId></specobject>
    <specobject>
      <id>CanSM.SWS_CANSM_00664</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANStateManager.pdf, R20-11</source>
      <version>1</version>
      <description>
        Type of error | Related error code | Error value 
        Mode request for a network failed more often than allowed by configuration | 
        CANSM_E_MODE_REQUEST_TIMEOUTCanSM.CANSM_E_MODE_REQUEST_TIMEOUT | 0x0A 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanSM.DevelopmentRuntimeErrors</srcid><srcstatus/><internalId>558</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>534</internalId></specobject>
  </specobjects>
    <specobjects doctype="man">

    <specobject>
      <id>CanSM.man.MemMap</id>
      <status>approved</status>
      <source>EB manual test</source>
      <version>1</version>
      <description>
        Check that all function definitions and declarations are enclosed by a
        CANSM_START_SEC_CODE and CANSM_STOP_SEC_CODE symbol.
        Check that all global variables are enclosed by a memory section
            according to the respective symbol property, including:
            - constness
            - variable size
            - initializationcharacteristics
      </description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.CANSM016.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>165</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>535</internalId></specobject>

    <specobject>
      <id>CanSM.man.CommonPublishedParameters</id>
      <status>approved</status>
      <source>EB manual test</source>
      <version>1</version>
      <description>
        Open the file CanSM_Bswmd.arxml in the directory generate_swcd/swcd
        of the installed CanSM plugin.
        Check that the attribute node SW-VERSION exists.
        Check that the set value of SW-VERSION is correct.
        Check that the attribute node VENDOR-ID exists.
        Check that the set value of VENDOR-ID is correct.
        Check that the attribute node AR-RELEASE-VERSION exists.
        Check that the set value of AR-RELEASE-VERSION is correct.
        Check that the attribute node MODULE-ID exists.
        Check that the set value of MODULE-ID is correct.
      </description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.SWS_CanSM_00599.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>266</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>536</internalId></specobject>

  </specobjects>
    <specobjects doctype="swurs">

    <specobject>
      <id>CanSM.EB.DBGINST001</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Every public API of the module shall have debug instrumentation.
      </description>
      <comment> </comment>
      <!-- Can be tested by an conformance and a compile test -->
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CanSM_DBGINST_001</srcid><srcstatus/><internalId>600</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>537</internalId></specobject>

    <specobject>
      <id>CanSM.EB.DBGINST002</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The parameter of a API shall be available in the entry instrumentation.
      </description>
      <comment> </comment>
      <!-- Can be tested by an conformance and a compile test -->
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CanSM_DBGINST_001</srcid><srcstatus/><internalId>600</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>538</internalId></specobject>

    <specobject>
      <id>CanSM.EB.DBGINST003</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The parameter of a API shall be available in the exit instrumentation.
        If the API has a return value, the very first parameter of the macro shall contain the expected return value.
      </description>
      <comment> </comment>
      <!-- Can be tested by an conformance and a compile test -->
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CanSM_DBGINST_001</srcid><srcstatus/><internalId>600</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>539</internalId></specobject>

    <specobject>
      <id>CanSM.EB.DBGINST004</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The default implementation of the debug instrumentation shall be an empty macro.
      </description>
      <comment> </comment>
      <!-- Can be tested by an conformance and a compile test -->
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CanSM_DBGINST_001</srcid><srcstatus/><internalId>600</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>540</internalId></specobject>

    <specobject>
      <id>CanSM.EB.DBGINST005</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The module shall include the header files Base_Dbg.h in order to allow changing the default implementation of the debug instrumentation.
      </description>
      <comment> </comment>
      <!-- Can be tested by an conformance and a compile test -->
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CanSM_DBGINST_001</srcid><srcstatus/><internalId>600</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>541</internalId></specobject>

  </specobjects>
    <specobjects doctype="swurs">

    <specobject>
      <id>CanSM.EB.Interface.Consistency</id>
       <status>approved</status>
       <source>EB</source>
       <version>1</version>
       <description>
        The module shall provide a mechanism to guarantee consistency of interfaces and
        types between its implementation and its code stub.
       </description>
       <comment>
        The code stub of a module shall provide the same external view than the module itself.
        This is mandatory because unit test of modules test against the code stubs of
        adjacent modules. Inconsistent stubs may result in the situation that incompatible
        interfaces are not detected as unit test stage.
       </comment>
       <verifycrit>
        Create a compile test with two permutations that call all interfaces of a module
        (in both permutations).
        p0: Behave like a regular compile test; call the module generator and compile against
        the implementation of the module.
        p1: Do not generate module code and do not compile the implementation of the module.
        Instead the module shall be replaced with its own code stub.
       </verifycrit>
       <needscoverage>
          <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CanSM_VerifyCodeStub</srcid><srcstatus/><internalId>601</internalId></linkedfrom></coveredby></needscov>
       <containerCovstatus>covered</containerCovstatus></needscoverage>
       
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>542</internalId></specobject>

  </specobjects>
    <specobjects doctype="dev">
    <specobject>
      <id>dev.CANSM.BusoffCallOrder</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>50</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_RESTART_CC</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>233</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMFull.T_S_NO_BUS_OFF_S_RESTART_CC</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>237</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMFull.T_S_RESTART_CC_S_TX_OFF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>240</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>543</internalId></specobject>
    <specobject>
      <id>dev.CANSM.ImplementationConfigVariant</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>71</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ECUC_CanSM_00351</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>533</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>544</internalId></specobject>
    <specobject>
      <id>dev.CANSM.ChangeBaudrateMissing</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>100</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.SWS_CanSM_00501</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>59</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.SWS_CanSM_00564</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>78</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.SWS_CanSM_00565</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>79</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.SWS_CanSM_00562</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>76</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.SWS_CanSM_00571</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>83</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.SWS_CanSM_00563</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>77</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.SWS_CanSM_00566</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>80</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.SWS_CanSM_00507</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>61</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.ECUC_CanSM_00342</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>5</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.ErrorTable.CANSM_E_PARAM_INVALID_BAUDRATE</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>259</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.SWS_CanSM_00531</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>67</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.SWS_CanSM_00572</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>84</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.SWS_CanSM_00568</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>82</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.SWS_CanSM_00567</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>81</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.SWS_CanSM_00573</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>85</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.SWS_CanSM_00574</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>86</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.SWS_CanSM_00503</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>60</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>545</internalId></specobject>
    <specobject>
      <id>dev.CANSM.ConsChck</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>127</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.SWS_CanSM_00025</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>14</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>546</internalId></specobject>
    <specobject>
      <id>dev.CANSM.StateTransition</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>153</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00428</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>345</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>547</internalId></specobject>
    <specobject>
      <id>dev.CANSM.DebugAndTrace</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>170</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.SWS_CanSM_00310</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>32</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.SWS_CanSM_00309</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>31</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>548</internalId></specobject>
    <specobject>
      <id>dev.CANSM.InitialTransition</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>194</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_PRE_NOCOM_NOCOM.NoPn.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>192</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_PRE_NOCOM_NOCOM.Pn.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>194</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>549</internalId></specobject>
    <specobject>
      <id>dev.CANSM.DenyModeRequest</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>220</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.SWS_CanSM_00375</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>43</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.SWS_CanSM_00376</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>44</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.SWS_CanSM_00377</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>45</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.SWS_CanSM_00395</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>47</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00555</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>452</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.SWS_CanSM_00402</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>49</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>550</internalId></specobject>
    <specobject>
      <id>dev.CANSM.PNFilter</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>248</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.SWS_CanSM_00537</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>69</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.SWS_CanSM_00513</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>62</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>551</internalId></specobject>
    <specobject>
      <id>dev.CANSM.MainHeader</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>269</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.SWS_CanSM_00013</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>9</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>552</internalId></specobject>
    <specobject>
      <id>dev.CanSM.ChangedDemFunc</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>282</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00498</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>410</internalId></provcov>
        <provcov>
          <linksto>CanSM.ECUC_CanSM_00127</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>276</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00522</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>431</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>553</internalId></specobject>
    <specobject>
      <id>dev.CanSM.MFPeriodUpperLimit</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>297</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ECUC_CanSM_00312</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>286</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>554</internalId></specobject>
    <specobject>
      <id>dev.CanSM.TimerUpperLimit</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>310</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ECUC_CanSM_00336</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>289</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>555</internalId></specobject>
    <specobject>
      <id>dev.CanSM.StoreNwState</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>323</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00266</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>310</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>556</internalId></specobject>
    <specobject>
      <id>dev.CanSM.FncCallAfterInit</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>336</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00282</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>312</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>557</internalId></specobject>
    <specobject>
      <id>dev.CanSM.DevelopmentRuntimeErrors</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>349</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00385</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>320</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00654</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>525</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CANSM_00664</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>534</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>558</internalId></specobject>
    <specobject>
      <id>dev.CanSM.CtrlModeIndType</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>364</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00396</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>321</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>559</internalId></specobject>
    <specobject>
      <id>dev.CanSM.ENoComIndication</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>377</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00651</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>522</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00430</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>347</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>560</internalId></specobject>
    <specobject>
      <id>dev.CanSM.EFullComOrder</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>391</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00540</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>446</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00435</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>352</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00538</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>444</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00507</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>418</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>561</internalId></specobject>
    <specobject>
      <id>dev.CanSM.TrcvPnSupport</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>407</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00437</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>354</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00436</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>353</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>562</internalId></specobject>
    <specobject>
      <id>dev.CanSM.ChBROperation</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>421</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00642</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>515</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00641</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>514</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00503</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>414</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00639</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>513</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>563</internalId></specobject>
    <specobject>
      <id>dev.CanSM.BODelaySupport</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>437</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00514</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>424</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00515</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>425</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>564</internalId></specobject>
    <specobject>
      <id>dev.CanSM.BODelay</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>451</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ECUC_CanSM_00348</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>464</internalId></provcov>
        <provcov>
          <linksto>CanSM.ECUC_CanSM_00347</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>463</internalId></provcov>
        <provcov>
          <linksto>CanSM.ECUC_CanSM_00346</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>462</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00637</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>510</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00636</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>509</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>565</internalId></specobject>
    <specobject>
      <id>dev.CanSM.SilentComBOR</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>468</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00600</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00602</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>477</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00604</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>479</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00603</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>478</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00606</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>481</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00605</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>480</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>566</internalId></specobject>
    <specobject>
      <id>dev.CanSM.WUValidation</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>486</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00619</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>492</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00618</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>491</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00611</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>486</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00633</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>506</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00610</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>485</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00632</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>505</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00613</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>488</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00612</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>487</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00634</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>507</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00617</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>490</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00616</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>489</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00631</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>504</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00630</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>503</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00608</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>483</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00607</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>482</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00629</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>502</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00609</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>484</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00622</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>495</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00621</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>494</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00624</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>497</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00623</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>496</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00626</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>499</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00625</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>498</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00628</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>501</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00627</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>500</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00620</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>493</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>567</internalId></specobject>
    <specobject>
      <id>dev.CanSM.OfflineActiveSupport</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>524</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00650</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>521</internalId></provcov>
        <provcov>
          <linksto>CanSM.ECUC_CanSM_00349</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>511</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00516</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>426</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00539</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>445</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00644</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>516</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00646</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>518</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00645</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>517</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00656</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>527</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00647</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>519</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00648</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>427</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00649</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>520</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>568</internalId></specobject>
    <specobject>
      <id>dev.CanSM.BOEffect</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>547</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00653</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>524</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>569</internalId></specobject>
    <specobject>
      <id>dev.CanSM.DeinitSupport</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>560</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00660</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>529</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_91001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>530</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00658</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>528</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>570</internalId></specobject>
    <specobject>
      <id>dev.CanSM.DemEventModeRequest</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>575</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ECUC_CanSM_00352</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>531</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>571</internalId></specobject>
    <specobject>
      <id>dev.CanSM.ExportHeaderForInterfaces</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>588</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00064</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>297</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00396</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>321</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00399</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>324</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00410</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>327</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00413</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>330</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00416</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>333</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00419</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>336</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>572</internalId></specobject>
    <specobject>
      <id>dev.CanSM.ExportHeaderForMF</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>607</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00065</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>298</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>573</internalId></specobject>
    <specobject>
      <id>dev.CanSM.CtrlModeReqCheck</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>620</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00441</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>358</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00453</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>370</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00464</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>380</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00468</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>384</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00487</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>400</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00491</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>404</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00509</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>420</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00524</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>432</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00532</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>440</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00578</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>467</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00582</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>471</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00604</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>479</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00627</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>500</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00631</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>504</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>574</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/generate/include/CanSM_Partitions_MainFunction.h_25</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/src/Autosar/generate/include/CanSM_Partitions_MainFunction.h</sourcefile>
      <sourceline>25</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanSM.EB.CanSMDistributedChannels_MainFunctions</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>151</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>575</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/generate/src/CanSM_Partitions_Init.c_45</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/src/Autosar/generate/src/CanSM_Partitions_Init.c</sourcefile>
      <sourceline>45</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanSM.EB.CanSMDistributedChannelInit_InitFunctions</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>268</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>576</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate/src/CanSM_Partitions_Init.c_91</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/src/Autosar/generate/src/CanSM_Partitions_Init.c</sourcefile>
      <sourceline>91</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanSM.EB.CanSMDistributedChannels_InitFunctions_Initialization</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>269</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>577</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate/src/CanSM_Partitions_Init.c_111</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/src/Autosar/generate/src/CanSM_Partitions_Init.c</sourcefile>
      <sourceline>111</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanSM.EB.CanSMDistributedChannels_InitFunctions_Re_Init</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>270</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>578</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate/src/CanSM_Partitions_Init.c_119</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/src/Autosar/generate/src/CanSM_Partitions_Init.c</sourcefile>
      <sourceline>119</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanSM.EB.CanSMDistributedChannels_InitFunctions_StateTransition</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>271</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>579</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/generate/src/CanSM_Partitions_MainFunction.c_43</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/src/Autosar/generate/src/CanSM_Partitions_MainFunction.c</sourcefile>
      <sourceline>43</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanSM.EB.CanSMDistributedChannels_MainFunctions_Processing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>152</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>580</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/src/CanSM_Cbk.c_71</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/src/Autosar/src/CanSM_Cbk.c</sourcefile>
      <sourceline>71</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>dsn.CanSM.CallContext.CanSM_ControllerBusOff</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>597</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>581</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanSM_Cbk.c_79</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/src/Autosar/src/CanSM_Cbk.c</sourcefile>
      <sourceline>79</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanSM.EB.BusOffRecovery.RestartCtrl</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>126</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>582</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/src/CanSM_Init.c_84</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/src/Autosar/src/CanSM_Init.c</sourcefile>
      <sourceline>84</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanSM.EB.CanSMDistributedChannels_InitFunctions_Initialization</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>269</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>583</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanSM_Init.c_107</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/src/Autosar/src/CanSM_Init.c</sourcefile>
      <sourceline>107</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanSM.EB.CanSMDistributedChannels_InitFunctions_Re_Init</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>270</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>584</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanSM_Init.c_116</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/src/Autosar/src/CanSM_Init.c</sourcefile>
      <sourceline>116</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanSM.EB.CanSMDistributedChannels_InitFunctions_StateTransition_Generic</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>272</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>585</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/src/CanSM_MainFunction.c_59</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/src/Autosar/src/CanSM_MainFunction.c</sourcefile>
      <sourceline>59</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanSM.EB.Api.CanSM_MainFunction.Uninitialized</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>112</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>586</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanSM_MainFunction.c_66</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/src/Autosar/src/CanSM_MainFunction.c</sourcefile>
      <sourceline>66</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanSM.EB.CanSMDistributedChannels_MainFunctions_Processing_Generic</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>153</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>587</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/src/CanSM_StateMachine.c_2325</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/src/Autosar/src/CanSM_StateMachine.c</sourcefile>
      <sourceline>2325</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanSM.EB.BusOffRecovery.RestartCtrl</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>126</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>588</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/config/CanSM_EBParameters.xdm.m4_157</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/src/Autosar/config/CanSM_EBParameters.xdm.m4</sourcefile>
      <sourceline>157</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanSM.EB.CanSMDistributedChannelProcessing</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>589</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanSM_EBParameters.xdm.m4_182</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/src/Autosar/config/CanSM_EBParameters.xdm.m4</sourcefile>
      <sourceline>182</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanSM.EB.CanSMDistributedChannels_NoPartitionRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>590</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanSM_EBParameters.xdm.m4_185</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/src/Autosar/config/CanSM_EBParameters.xdm.m4</sourcefile>
      <sourceline>185</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanSM.EB.CanSMDistributedChannels_Same_Partition_Referencing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>156</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>591</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanSM_EBParameters.xdm.m4_190</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/src/Autosar/config/CanSM_EBParameters.xdm.m4</sourcefile>
      <sourceline>190</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanSM.EB.CanSMDistributedChannelInit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>267</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>592</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/config/CanSM_Extension.xdm.m4_138</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/src/Autosar/config/CanSM_Extension.xdm.m4</sourcefile>
      <sourceline>138</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanSM.EB.CanSMDistributedChannels_No_CanControllerEcucPartitionRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>157</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>593</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanSM_Extension.xdm.m4_146</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/src/Autosar/config/CanSM_Extension.xdm.m4</sourcefile>
      <sourceline>146</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanSM.EB.CanSMDistributedChannels_CanTrcvChannel_Mapping</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>154</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>594</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanSM_Extension.xdm.m4_507</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/src/Autosar/config/CanSM_Extension.xdm.m4</sourcefile>
      <sourceline>507</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanSM.EB.CanSMDistributedChannels_ComM_And_Controller_Mapping</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>158</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>595</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/generate_var/xgen/CanSM.xgen_101</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/src/Autosar/generate_var/xgen/CanSM.xgen</sourcefile>
      <sourceline>101</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>dsn.CanSM.PostBuildConfigurationData</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>599</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>596</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd" title="Operating system task(s) for SchM">
    <specobject>
      <id>dsn.CanSM.CallContext.CanSM_ControllerBusOff</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/doc/project/design/pdf/CanSM_Design-profiled.xml</sourcefile>
      <sourceline>1888</sourceline>
      <version>1</version>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanSM_Cbk.c_71</srcid><srcstatus/><internalId>581</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.Api.CanSM_ControllerBusOff.CallContext</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>264</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>597</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd" title="CanTrcv dependencies">
    <specobject>
      <id>dsn.CanSM.CanTrcvDependency</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/doc/project/design/pdf/CanSM_Design-profiled.xml</sourcefile>
      <sourceline>2212</sourceline>
      <version>1</version>
      <needscoverage>
        <needscov><needsobj>lim</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>lim.CanSM.EB_INTREQ_CanSM_0001</srcid><srcstatus/><internalId>0</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>598</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd" title="Post-build time configuration">
    <specobject>
      <id>dsn.CanSM.PostBuildConfigurationData</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/doc/project/design/pdf/CanSM_Design-profiled.xml</sourcefile>
      <sourceline>2727</sourceline>
      <version>1</version>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate_var/xgen/CanSM.xgen_101</srcid><srcstatus/><internalId>596</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00597</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>474</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>599</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CanSM_DBGINST_001</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/build/reqm/common_req/CanSM_DbgInst_Trace_APIs.c</sourcefile>
      <sourceline>40</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
   Test Dbg
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
  VP: Successful compilation test.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.EB.DBGINST001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>537</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.DBGINST002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>538</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.DBGINST003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>539</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.DBGINST004</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>540</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.DBGINST005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>541</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>600</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CanSM_VerifyCodeStub</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/build/reqm/common_req/CanSM_VerifyStub_testspec.h</sourcefile>
      <sourceline>7</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that the code stub of the module is consistent with the
    implementation.
  
Test Object: 
    Relocatable post-build configuration macros generation.
  
Test Precondition: 
    Permutation [VerifyStub == true]:
      - Unit test contains its own code stub
      - Module is excluded from generation and compilation
    Permutation [VerifyStub == false]:
      - unit test excludes its own code stub
  
Test Execution: 
    01: Invoke all module APIs
    02: VP(CanSM.EB.Interface.Consistency):
        Unit test compiles (implicitly tested)
  
Test Input: 
  
Test Output: 
    Test is correctly generated and compiled.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.EB.Interface.Consistency</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>542</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>601</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANSM_40074</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Compile/IN/CanSM_Compile12/source/application/Application.c</sourcefile>
      <sourceline>34</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test CanSM_BswMCurrentStateType declared in CanSM_BswM.h
  
Test Object: 
    Compile test
  
Test Precondition: 
    Only CanSM_BswM.h included
  
Test Execution: 
    Compile
  
Test Input: 
    na
  
Test Output: 
    Compiles successfully
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.SWS_CanSM_00347</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>33</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>602</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANSM_COMMON_PUBLISHED_PARAMETERS_HEADER_FILE</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Compile/IN/CanSM_Compile13/source/application/Tests.c</sourcefile>
      <sourceline>19</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify symbols for common published parameters
  
Test Object: 
  
Test Precondition: 
    Of the CanSM header files, only CanSM.h is included
  
Test Execution: 
    01: VP (CanSM.ASR40.SWS_CanSM_00599.1)
        Check if the standardized common published parameters are published
        within the header file of the module.
    02: VP (CanSM.ASR40.CANSM238)
        Check if ComStack_Types.h is included using macro when only CanSM.h is included
  
Test Input: 
  
Test Output: 
    Compiles successfully
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.SWS_CanSM_00599.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>265</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.SWS_CanSM_00238</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>23</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>603</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANSM_CHECK_CANSM_DCM_H</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Compile/IN/CanSM_Compile14/source/application/Tests.c</sourcefile>
      <sourceline>22</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test shall verify that CanSM_Dcm.h exports the interface CanSM_SetBaudrate() which is
    required for the DCM.
  
Test Object: 
    Compile test
  
Test Precondition: 
    Configuration as described
  
Test Execution: 
    Compile
  
Test Input: 
    na
  
Test Output: 
    Compiles successfully
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.SWS_CanSM_00547</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>72</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>604</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANSM_MERGE_COMPILE_OFF</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Compile/IN/CanSM_Compile15_MergeCompileOFF/source/application/Tests.c</sourcefile>
      <sourceline>25</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test shall verify that no warning is reported when TS_CANSM_MERGED_COMPILE
    is set to FALSE.
  
Test Object: 
    Compile test
  
Test Precondition: 
    - Disable the TS_CANSM_MERGED_COMPILE
    - Configuration parameters CanSMVersionInfoApi, CanSMTxTimeoutException, CanSMActivatePN,
      CanSMPncSupport, CanSMSetBaudrateApi, CanSMBusDeactivatedBusOff enabled
  
Test Execution: 
    - 01: VP: Invoke CanSM_Init
    - 02: VP: Invoke CanSM_GetVersionInfo
    - 03: VP: Invoke CanSM_MainFunction
    - 04: VP: Invoke CanSM_RequestComMode
    - 05: VP: Invoke CanSM_GetCurrentComMode
    - 06: VP: Invoke CanSM_TxTimeoutException
    - 07: VP: Invoke CanSM_SetBaudrate
    - 08: VP: Invoke CanSM_ControllerBusOff
    - 09: VP: Invoke CanSM_ControllerModeIndication
    - 10: VP: Invoke CanSM_ClearTrcvWufFlagIndication
    - 11: VP: Invoke CanSM_CheckTransceiverWakeFlagIndication
    - 12: VP: Invoke CanSM_ConfirmPnAvailability
    - 13: VP: Invoke CanSM_TransceiverModeIndication
  
Test Input: 
  
Test Output: 
    Compiles successfully and without warnings
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.CANSM008.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>159</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>605</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANSM_40037_6_1N1C0T</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Compile/IN/CanSM_Compile6_1N1C0T/source/application/Application.c</sourcefile>
      <sourceline>21</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    DET: on
    Multiple networks: no
    Consecutive network handles: n.a.
    Multiple controllers per network: no
    Networks without transceivers: yes
  
Test Object: 
    Compile test
  
Test Precondition: 
    Configuration as described
  
Test Execution: 
    Compile
  
Test Input: 
    na
  
Test Output: 
    Compiles successfully
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.SWS_CanSM_00252</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>26</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>606</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANSM_40064</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Compile/IN/CanSM_Compile8/source/application/Tests.c</sourcefile>
      <sourceline>57</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    DET: on
    DEM event E_BUS_OFF forwarded to DET
    Multiple networks: yes
    Consecutive network handles: no
    Multiple controllers per network: yes
    Networks without transceivers: no
    CanSMVersionInfoApi: false
  
Test Object: 
    Compile test
  
Test Precondition: 
    - Configuration as described
    - Dem stub (especially Dem.h) must be deleted
  
Test Execution: 
    Compile
  
Test Input: 
    na
  
Test Output: 
    Compiles successfully
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00024</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>294</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.SWS_CanSM_00368</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>42</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.CANSM014.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>163</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00570</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>459</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>607</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANSM_CBK_EXPORTS</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Compile/IN/CanSM_Compile_CbkExports/source/application/testCbkExports.c</sourcefile>
      <sourceline>21</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanSM_Cbk.h declares the callback notification functions of the CanSM module
  
Test Object: 
    CanSM_Cbk.h
  
Test Precondition: 
    - Of the CanSM header files, only CanSM_Cbk.h is included
  
Test Execution: 
    - 01: VP: Invoke CanSM_ControllerBusOff
    - 02: VP: Invoke CanSM_ControllerModeIndication
    - 03: VP: Invoke CanSM_TransceiverModeIndication
  
Test Input: 
  
Test Output: 
    Compiles successfully and without warnings.
    This implicitly covers requirement CanSM.ASR40.SWS_CanSM_00016.1
    which relies on successful MemMap generation.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.CANSM011.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>161</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.SWS_CanSM_00396</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>48</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00399</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>324</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.SWS_CanSM_00016.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>164</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>608</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANSM_COMM_DEDICATED_EXPORTS</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Compile/IN/CanSM_Compile_ComMDedicatedHeaderExports/source/application/testComMDedicatedExports.c</sourcefile>
      <sourceline>21</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanSM_ComM.h exports the CanSM module's API dedicated to the ComM module.
  
Test Object: 
    CanSM_ComM.h
  
Test Precondition: 
    - Of the CanSM header files, only CanSM_ComM.h is included
  
Test Execution: 
    - 01: VP: Invoke CanSM_RequestComMode
    - 02: VP: Invoke CanSM_GetCurrentComMode
  
Test Input: 
  
Test Output: 
    Compiles successfully and without warnings
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.SWS_CanSM_00009</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>6</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.CANSM174.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>160</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>609</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANSM_HEADER_INCLUSION</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Compile/IN/CanSM_Compile_HeaderInclusion/source/application/testHeaderInclusion.c</sourcefile>
      <sourceline>18</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the CanSM implementation file(s) imports the C headers as
    stated in the AUTOSAR SWS.
  
Test Object: 
    Header inclusion
  
Test Precondition: 
    - DET enabled
    - DEM enabled (and forwarded to module DEM)
    - Partial networking enabled
  
Test Execution: 
    01: VP (CanSM.ASR40.SWS_CanSM_00254):
        Check that module implementation includes header file CanSM_Cfg.h
    02: VP (CanSM.ASR40.SWS_CanSM_00014.1):
        Check that module implementation includes header file Dem.h
    03: VP (CanSM.ASR40.SWS_CanSM_00015):
        Check that module implementation includes header file Det.h
    04: VP (CanSM.ASR40.SWS_CanSM_00017):
        Check that module implementation includes header file CanIf.h
    05: VP (CanSM.ASR40.SWS_CanSM_00191):
        Check that module implementation includes header file ComM_BusSm.h
    06: VP (CanSM.ASR40.SWS_CanSM_00348):
        Check that module implementation includes header file CanSM_BswM.h
    07: VP (CanSM.ASR40.SWS_CanSM_00548.1):
        Check that module implementation includes header file CanNm.h
  
Test Input: 
  
Test Output: 
    Compiles successfully and without warnings
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.SWS_CanSM_00254</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>28</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.SWS_CanSM_00014.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>162</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.SWS_CanSM_00015</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>11</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.SWS_CanSM_00017</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>13</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.SWS_CanSM_00191</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>22</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.SWS_CanSM_00348</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>34</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.SWS_CanSM_00548.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>166</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>610</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANSM_SymbolicNameValues</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Compile/IN/CanSM_Compile_LegacySymbolicNameValues/source/application/Tst_CanSM_LegacySymbolicNameValues.c</sourcefile>
      <sourceline>29</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check that macros are generated for configuration parameters which are specified as
    SYMBOLICNAMEVALUES.
  
Test Object: 
    Symbolic name value config parameters
  
Test Precondition: 
    CANSM_PROVIDE_LEGACY_SYMBOLIC_NAMES shall be defined.
  
Test Execution: 
    01: Check that macros are generated with the names and the values listed in output.
  
Test Input: 
  
Test Output: 
    CanSM_CanNetwork_0 3U
    CanSM_CanNetwork_1 4U
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.EB.LegacySymbolicNameValue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>143</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>611</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANSM_MULTICORE_ENABLED_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Compile/IN/CanSM_Compile_MultiCoreSupportON/source/application/Tests.c</sourcefile>
      <sourceline>22</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test pre-compile-time configuration parameter CANSM_MULTICORE_ENABLED.
  
Test Object: 
  
Test Precondition: 
    CANSM_MULTICORE_ENABLED must be set to TRUE
  
Test Execution: 
    01: VP (CanSM.Config.SchM_Call_CanSM_ModeIndication)
        CANSM_MULTICORE_ENABLED is set to STD_ON
    02: VP 
        The following API function is available:
          CANSM_NW_CONFIG(nw).ModeIndication(nw,mode)
  
Test Input: 
  
Test Output: 
    Compiles successfully
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.Config.SchM_Call_CanSM_ModeIndication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>145</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>612</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANSM_NoEcucPartition</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Compile/IN/CanSM_Compile_NoEcucPartition/source/application/Tst_CanSM_Comp_NoEcucPartition.c.m4</sourcefile>
      <sourceline>59</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that module compile successfully when no EcuC partition configured. 
  
Test Object: 
    Calling MainFunction.
  
Test Precondition: 
    Module initialization
  
Test Execution: 
    01: Call CanSM_MainFunction().
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.EB.CanSMDistributedChannels_NoPartitionRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>613</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANSM_NonLegacySymbolicNameValues</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Compile/IN/CanSM_Compile_NonLegacySymbolicNameValues/source/application/Tst_CanSM_NonLegacySymbolicNameValues.c</sourcefile>
      <sourceline>60</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Checking the symbolic name macros are not generated when
    CANSM_PROVIDE_LEGACY_SYMBOLIC_NAMES is not defined.
  
Test Object: 
  
Test Precondition: 
    CANSM_PROVIDE_LEGACY_SYMBOLIC_NAMES shall not be defined.
  
Test Execution: 
    01: Check that macros are not generated.
  
Test Input: 
  
Test Output: 
   Symbolic name Macros generated should not be defined if
   CANSM_PROVIDE_LEGACY_SYMBOLIC_NAMES is not defined.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.EB.NonLegacySymbolicNameValue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>144</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>614</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANSM_NOT_DEDICATED_EXPORTS</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Compile/IN/CanSM_Compile_NotDedicatedHeaderExports/source/application/testNotDedicatedExports.c</sourcefile>
      <sourceline>19</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanSM.h exports CanSM module specific types and the API of the CanSM module,
    which is not dedicated to a certain module.
  
Test Object: 
    CanSM.h
  
Test Precondition: 
    - Of the CanSM header files, only CanSM.h is included
    - Configuration parameter CanSMVersionInfoApi enabled
  
Test Execution: 
    - 01: VP: Invoke CanSM_Init
    - 02: VP: Invoke CanSM_GetVersionInfo
    - 03: VP: Invoke CanSM_MainFunction
  
Test Input: 
  
Test Output: 
    Compiles successfully and without warnings
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.CANSM008.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>159</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>615</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANSM_PNSUPPORT_OFF</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Compile/IN/CanSM_Compile_PNSupportOFF/source/application/Tests.c</sourcefile>
      <sourceline>22</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test pre-compile-time configuration parameter CANSM_PNSUPPORT.
  
Test Object: 
  
Test Precondition: 
    CanSMPncSupport must be set to FALSE
  
Test Execution: 
    01: VP (CanSM.ECUC_CanSM_00344)
        CANSM_PNSUPPORT is set to STD_OFF
    02: VP (CanSM.ECUC_CanSM_00344, CanSM.EB.TxTimeoutException.TurnOff)
        The following API functions are NOT available:
          CanSM_ClearTrcvWufFlagIndication
          CanSM_CheckTransceiverWakeFlagIndication
          CanSM_ConfirmPnAvailability
          CanSM_TxTimeoutException
  
Test Input: 
  
Test Output: 
    Compiles successfully
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ECUC_CanSM_00344</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>461</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.TxTimeoutException.TurnOff</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>616</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANSM_PNSUPPORT_OFF_TXTIMEOUTSUPPORT_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Compile/IN/CanSM_Compile_PNSupportOFFTxTimeoutON/source/application/Tests.c</sourcefile>
      <sourceline>22</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test pre-compile-time configuration parameter CANSM_TX_TIMEOUT_EXCEPTION_API.
  
Test Object: 
  
Test Precondition: 
    CanSMPncSupport must be set to FALSE
    CanSMTxTimeoutException must be set to TRUE
  
Test Execution: 
    01: VP (CanSM.ECUC_CanSM_00344)
        CANSM_PNSUPPORT is set to STD_OFF
    02: VP (CanSM.EB.TxTimeoutException.TurnOff)
        CANSM_TX_TIMEOUT_EXCEPTION_API is set to STD_ON
    03: VP (CanSM.ECUC_CanSM_00344)
        The following API functions are NOT available:
          CanSM_ClearTrcvWufFlagIndication
          CanSM_CheckTransceiverWakeFlagIndication
          CanSM_ConfirmPnAvailability
    04: VP (CanSM.EB.TxTimeoutException.TurnOff)
        The CanSM_TxTimeoutException API function is available
  
Test Input: 
  
Test Output: 
    Compiles successfully
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ECUC_CanSM_00344</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>461</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.TxTimeoutException.TurnOff</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>617</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANSM_PNSUPPORT_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Compile/IN/CanSM_Compile_PNSupportON/source/application/Tests.c</sourcefile>
      <sourceline>22</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test pre-compile-time configuration parameter CANSM_PNSUPPORT.
  
Test Object: 
  
Test Precondition: 
    CanSMPncSupport must be set to TRUE
  
Test Execution: 
    01: VP (CanSM.ECUC_CanSM_00344)
        CANSM_PNSUPPORT is set to STD_ON
    02: VP (CanSM.ECUC_CanSM_00344, CanSM.ASR40.CANSM011.1, CanSM.ASR40.CANSM413,
            CanSM.ASR40.CANSM549, CanSM.ASR40.CANSM416, CanSM.ASR40.CANSM419, CanSM.SWS_CanSM_00410)
        The following API functions are available:
          CanSM_ClearTrcvWufFlagIndication
          CanSM_CheckTransceiverWakeFlagIndication
          CanSM_ConfirmPnAvailability
          CanSM_TxTimeoutException
  
Test Input: 
  
Test Output: 
    Compiles successfully
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ECUC_CanSM_00344</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>461</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.CANSM011.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>161</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.SWS_CanSM_00549</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>74</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00413</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>330</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00416</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>333</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00419</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>336</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00410</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>327</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.TxTimeoutException.TurnOff</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>618</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANSM_PNSUPPORT_ON_NOTRCV</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Compile/IN/CanSM_Compile_PNSupportOnNoTrcv/source/application/Tests.c</sourcefile>
      <sourceline>21</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test pre-compile-time configuration parameter CANSM_PNSUPPORT and CANSM_USE_TRANSCEIVER.
    The configuration shall enabled the partial network feature without using any transceiver.
  
Test Object: 
  
Test Precondition: 
    CanSMPncSupport must be set to TRUE
    No transceiver shall be configured
  
Test Execution: 
    01: VP (CanSM.ECUC_CanSM_00344)
        CANSM_PNSUPPORT is set to STD_ON
    02: VP:
        CANSM_USE_TRANSCEIVER is set to STD_OFF
    03: VP:
        The following PN and transceiver related API functions shall be
        removed from CanSM code:
        - CanSM_ClearTrcvWufFlagIndication
        - CanSM_CheckTransceiverWakeFlagIndication
        - CanSM_ConfirmPnAvailability
        - CanSM_TransceiverModeIndication
        The following PN-related API functions shall remain in code:
        - CanSM_TxTimeoutException
  
Test Input: 
  
Test Output: 
    Compiles successfully
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ECUC_CanSM_00344</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>461</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>619</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANSM_PBSELECTABLE</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Compile/IN/CanSM_Compile_PostBuildSelectable/source/application/CanSM_PostBuild.c</sourcefile>
      <sourceline>25</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test case verifies that when PostBuildSelectable is enabled the generated files are the same
    as expected. The expected files have been place in the directory reference and if there is 
    no difference at all between the generated post build configuration files and those from the directory
    reference this test will be successful.
  
Test Object: 
    PostBuildSelectable.
  
Test Precondition: 
   Expected postbuild configuration files have been placed in directory reference.
   Postbuild selectable is enabled. 
  
Test Execution: 
    Compile test
  
Test Input: 
  
Test Output: 
    Test correctly generates and compiles.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.EB.PBSelectable.FileName</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>146</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.PBSelectable.TypeName</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>147</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.PBSelectable.Master</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>148</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.CanSMMaxNumberOfTransceivers</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>149</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.SWS_CanSM_00362</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>36</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00597</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>474</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.SWS_CanSM_00252</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>26</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>620</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANSM_SCHM</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Compile/IN/CanSM_Compile_SchM/source/application/CanSM_Compile_BSWMD_SchM.c</sourcefile>
      <sourceline>27</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
   This test checks that the CanSM module's generator generates a
   syntactically and semantically valid basic software module
   description (BSWMD) when the generator mode "generate_swcd" is
   invoked. It further tests that the SchM exclusive area API is
   correctly generated by the RTE generator based on the CanSM module's
   generated BSWMD.

Test Object: 

Test Precondition: 

Test Execution: 
  Ts5 build environment steps:
    The module configuration generator produces the BSWMD containing
    the information on the required exclusive areas.  This information
    is then used by the RTE generator to create the required SchM API
    for these exclusive areas. This implicitly verifies that the BSWMD
    is syntactically and semantically correct.  CanSM's static code
    makes use of this API (and the respective #defines) thus causing
    compile/link errors if the BSWMD does not contain the correct
    information.

Test Input: 
  Usage of a common ASR configuration having all adjacent ASR modules
  configured.

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.EB.BSWMDGeneration_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.BSWMDGeneration_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>122</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.BSWMDGeneration_3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>621</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANSM_GEN_001_ERR_ALL_CANSMTRANSCEIVERID_DISABLED</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Compile/IN/CanSM_GenTest_01_InvalidConfiguration/source/application/Test.h</sourcefile>
      <sourceline>27</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall prove that an error will be thrown in case no CanSMTransceiverId is found in the configuration
&lt;/para&gt;

Test Object: None.
Test Precondition: 
        -run manualRunTest.sh

Test Execution: 
    The test run is successful when the error is thrown.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.EB.CanSMTransceiverId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>137</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>622</internalId></specobject>
    <specobject>
      <id>TS_CANSM_GEN_002_ERR_MAXTRCV_CONFIG</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Compile/IN/CanSM_GenTest_01_InvalidConfiguration/source/application/Test.h</sourcefile>
      <sourceline>48</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall prove that an error will be thrown in case CanSMMaxNumberOfTransceivers
    is lower than the actual number of transceivers.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
        -run manualRunTest.sh

Test Execution: 
    The test run is successful when the error is thrown.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.EB.CanSMMaxNumberOfTransceivers</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>149</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>623</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_GenTest_002_Err_CAN_Controller_Mapping</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Compile/IN/CanSM_GenTest_02_InvalidConfiguration/source/application/Test.h</sourcefile>
      <sourceline>27</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall prove that an error will be thrown in case all CAN Networks are not mapped to the same partition as the ComM channel.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
        -run manualRunTest.sh

Test Execution: 
    The test run is successful when the error is thrown.

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.EB.CanSMDistributedChannels_ComM_And_Controller_Mapping</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>158</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>624</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_GenTest_003_Warning_CAN_Trcv_Mapping</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Compile/IN/CanSM_GenTest_03_InvalidConfiguration/source/application/Test.h</sourcefile>
      <sourceline>27</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall prove that a warning will be thrown in case that Can Transceiver Channel (CanSMTransceiverId) is not mapped to the same EcucPartition as the ComMChannelPartition.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
        -run manualRunTest.sh

Test Execution: 
    The test run is successful when the warning is thrown.

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.EB.CanSMDistributedChannels_CanTrcvChannel_Mapping</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>154</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>625</internalId></specobject>
    <specobject>
      <id>TS_GenTest_003_Warning_No_ComMChannelPartitionRef</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Compile/IN/CanSM_GenTest_03_InvalidConfiguration/source/application/Test.h</sourcefile>
      <sourceline>48</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall prove that a warning  will be thrown in case CanSMDistributedChannelProcessingSupport is ON and no ComMChannelPartitionRef is configured or parameter doesn't exist
&lt;/para&gt;

Test Object: None.
Test Precondition: 
        -run manualRunTest.sh

Test Execution: 
    The test run is successful when the warning is thrown.

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.EB.CanSMDistributedChannels_NoPartitionRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>626</internalId></specobject>
    <specobject>
      <id>TS_GenTest_003_Warning_Same_ComMChannelPartitionRef</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Compile/IN/CanSM_GenTest_03_InvalidConfiguration/source/application/Test.h</sourcefile>
      <sourceline>69</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall prove that a warning will be thrown in case CanSMDistributedChannelProcessingSupport is ON and all ComMChannelPartitionRef are referencing the same partition.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
        -run manualRunTest.sh

Test Execution: 
    The test run is successful when the warning is thrown.

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.EB.CanSMDistributedChannels_Same_Partition_Referencing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>156</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>627</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANSM_MODE_REQ_REP_PARTIAL</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_0003/source/application/Tst_CanSM_Conf_0003.c.m4</sourcefile>
      <sourceline>61</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks that CanSM only repeats a mode request for those controllers which
    don't report a mode indication.
  
Test Object: 
    mode request repetition
  
Test Precondition: 
    - CanSM module is in state S_NOCO
  
Test Execution: 
    01: Call CanSM_RequestComMode with:
        network := &lt;id of network 0&gt;
        ComM_Mode := COMM_FULL_COMMUNICATION.
    02: VP:
        CanSM called the following API function:
        CanIf_SetTrcvMode for TransceiverId 2 with:
        TransceiverMode := CANTRCV_TRCVMODE_NORMAL
    03: Call CanSM_TransceiverModeIndication for each Transceiver with:
        TransceiverMode := CANTRCV_TRCVMODE_NORMAL
    04: Call the MainFunction of CanSM
    05: VP:
        CanSM called the following API function:
        CanIf_SetControllerMode for ControllerId 6 and PM_ctrlId with:
        ControllerMode := CANIF_CS_STOPPED
    06: VP (CanSM.SWS_CanSM_00638):
        Call CanSM_ControllerModeIndication with:
        ControllerId := PM_ctrlId
        ControllerMode := CANIF_CS_STOPPED
    07: Repeat MainFunction PM_repCount times to trigger a new mode request
    08: VP (CanSM.ASR40.BSMPreFull.T_S_TRCV_NORMAL_S_CC_STOPPED,
            CanSM.ASR40.BSMPreFull.T_S_TRCV_NORMAL_S_TRCV_NORMAL):
        CanSM called CanIf_SetControllerMode with:
        ControllerId := 6
        ControllerMode := CANIF_CS_STOPPED
    09: VP (CanSM.SWS_CanSM_00638):
        Simulate the remaining mode indication and continue transition to S_FUCO.
    10: VP:
        CanSM is in state COMM_FULL_COMMUNICATION
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_NOCOM_PRE_FULLCOM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>175</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMPreFull.T_S_TRCV_NORMAL_S_CC_STOPPED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>227</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMPreFull.T_S_TRCV_NORMAL_S_TRCV_NORMAL</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>228</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00638</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>512</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>628</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_TX_ON_DELAYED</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_0003/source/application/Tst_CanSM_Conf_0003.c.m4</sourcefile>
      <sourceline>192</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks that a transition from S_RESTART_CC to S_TX_OFF
    (and the consecutive T_TX_ON transition) is delayed if time
    CanSMBorTimeL1 elapses and CanSM still waits for the controller
    mode indication.
  
Test Object: 
    delayed T_TX_OFF transition
  
Test Precondition: 
    - CanSM module is in S_FUCO in substate S_BUS_OFF_CHECK or S_NO_BUS_OFF
  
Test Execution: 
    01: VP (CanSM.SWS_CanSM_00638):
        Call CanSM_ControllerBusOff with:
        ControllerId := 6
    02: Call the MainFunction of CanSM
    03: VP:
        CanSM called the following API functions in defined order for both controller:
        1. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_BUS_OFF
           Network := 3
        2. Dem_ReportErrorStatus with:
           EventId := CANSM_E_BUS_OFF
           EventStatus := DEM_EVENT_STATUS_PREFAILED
        3. CanIf_SetPduMode with:
           PduModeRequest := CANIF_TX_OFFLINE
           ControllerId := PM_ctrlId/6
        4. CanIf_SetControllerMode with:
           ControllerMode := CANIF_CS_STARTED
           ControllerId := 6
    04: Call CanSM_MainFunction 99 times to simulate a time larger than CanSMBorTimeL1
    05: VP:
        CanSM does not call any API function
        (which means that no transition T_TX_ON or T_TX_OFF is performed although
        CanSMBorTimeL1 is elapsed)
    06: Call CanSM_ControllerModeIndication for both controller with:
        ControllerId := PM_ctrlId/6
           ControllerMode := CANIF_CS_STARTED
    07: Call CanSM_MainFunction to trigger the next transition
    08: VP (CanSM.ASR40.BSMFull.T_S_RESTART_CC_S_RESTART_CC,
            CanSM.ASR40.BSMFull.T_S_RESTART_CC_S_TX_OFF.2):
        CanSM did the delayed transition T_TX_OFF and called the following
        API function:
        ComM_BusSM_ModeIndication/SchM_Call (in case of multicore support) with:
           ComMode := COMM_SILENT_COMMUNICATION
           Network := 3
    09: Call CanSM_MainFunction to trigger the next transition
    10: VP (CanSM.ASR40.BSMFull.T_S_TX_OFF_S_BUS_OFF_CHECK):
        CanSM did the delayed transition T_TX_ON and called the following
        API functions in defined order:
        1. CanIf_SetPduMode for both controller with:
           PduModeRequest := CANIF_ONLINE
           ControllerId := PM_ctrlId/6
        2. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_FULL_COMMUNICATION
           Network := 3
        3. ComM_BusSM_ModeIndication/SchM_Call (in case of multicore support) with:
           ComMode := COMM_FULL_COMMUNICATION
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSMFull.T_S_NO_BUS_OFF_S_RESTART_CC.BusOff</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>238</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMFull.T_S_RESTART_CC_S_RESTART_CC</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>242</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMFull.T_S_RESTART_CC_S_TX_OFF.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>241</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMFull.T_S_TX_OFF_S_BUS_OFF_CHECK</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>243</internalId></provcov>
        <provcov>
          <linksto>CanSM.Config.SchM_Call_CanSM_ModeIndication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>145</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00638</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>512</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>629</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANSM_T_NOCO_FUCO_2CC_2NW_Distribution</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_NoPNTxTimeoutExceptionON_2NW/source/application/Tst_CanSM_Conf_NoPN_T_NOCO_FUCO_2NW.c.m4</sourcefile>
      <sourceline>76</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    This test checks the correct Transition of communication mode from
    CANSM_BSM_S_NOCOM to CANSM_BSM_S_FULLCOM
    with multiple (2) controller for network 0 if only one
    controller calls the ModeIndication while DistributedChannelProcessing is enabled.
    All mode indications shall be asynchron.
  
Test Object: 
    Module initialization
  
Test Precondition: 
  
Test Execution: 
    01: Initialize CanSM
    02: VP (CanSM.ASR40.BSM.T_NOT_INITIALIZED_PRE_NOCOM.NoPn):
        CanSM called the following API function in defined order:
        1. BswM_CanSM_CurrentState (NW0) with:
           CurrentState := CANSM_BSWM_NO_COMMUNICATION
           Network := &lt;id of nw0&gt;
        2. CanIf_SetControllerMode (twice) with:
           ControllerMode := CANIF_CS_STOPPED
           ControllerId := 6 (NW0), 4 (NW0)
        3. BswM_CanSM_CurrentState (NW1) with:
           CurrentState := CANSM_BSWM_NO_COMMUNICATION
           Network := &lt;id of nw1&gt;
        4. CanIf_SetControllerMode with:
           ControllerMode := CANIF_CS_STOPPED
           ControllerId := 1 (NW1)
    03: Call CanSM_ControllerModeInidcation for ControllerId 5 and 2 (the controller configured for CanNetwork_0) with:
        ControllerMode := CANIF_CS_STOPPED
    04: Call the generic CanSM_MainFunction().
	05: VP:
        CanSM does not call CanIf_SetControllerMode for ControllerId 5 and 2, as CanNetwork_0 is configured to process on EcucPartition_0.
	06: Call the CanSM_MainFunction_EcucPartition_0.
	07: VP:
        CanSM calls CanIf_SetControllerMode for ControllerId 5 and 2, as CanNetwork_0 is configured to process on EcucPartition_0.
	08: Call CanSM_ControllerModeInidcation for ControllerId 6 (the controller configured for CanNetwork_1) with:
        ControllerMode := CANIF_CS_STOPPED
    09: Call the CanSM_MainFunction_EcucPartition_0.
	10: VP:
        CanSM does not call CanIf_SetControllerMode for ControllerId 6, as CanNetwork_1 is configured to process on generic mainFunction.
	11: Call the CanSM_MainFunction.
	12: VP:
        CanSM calls CanIf_SetControllerMode for ControllerId 6.
    13: Call CanSM_ControllerModeInidcation for ControllerId 5, 2 and 6 with:
        ControllerMode := CANIF_CS_SLEEP
    14: Call the CanSM_MainFunction.
	15: VP:
        CanSM does not call CanIf_SetTrcvMode for TransceiverId 3, as CanNetwork_0 is configured to process on CanSM_MainFunction_EcucPartition_0.
	16: Call the CanSM_MainFunction_EcucPartition_0.
    17: VP (CanSM.ASR40.BSMDeInitNoPn.T_S_CC_SLEEP_S_TRCV_NORMAL):
        CanSM called only the following API function:
        CanIf_SetTrcvMode for TransceiverId 3 with:
        TransceiverMode := CANTRCV_TRCVMODE_NORMAL
    18: Call CanSM_TransceiverModeInidcation for TransceiverId 3with:
        TransceiverMode := CANTRCV_TRCVMODE_NORMAL
    19: Call the CanSM_MainFunction.
	20: VP: CanSM does not call CanIf_SetTrcvMode, as CanNetwork_0 is configured to process on CanSM_MainFunction_EcucPartition_0.
	21: Call the CanSM_MainFunction_EcucPartition_0.
    22: VP (CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_NORMAL_S_TRCV_STANDBY):
        CanSM called only the following API function:
        CanIf_SetTrcvMode for TransceiverId 2 and 0 with:
        TransceiverMode := CANTRCV_TRCVMODE_STANDBY
    23: Call CanSM_TransceiverModeInidcation for TransceiverId 2 and 0 with:
        TransceiverMode := CANTRCV_TRCVMODE_STANDBY
    24: Call the CanSM_MainFunction, and CanSM_MainFunction_EcucPartition_0.
    25: VP (CanSM.ASR40.BSM.T_PRE_NOCOM_NOCOM.NoPn.2):
        No other API function called
    26: Call CanSM_GetCurrentComMode to read the current CanSM mode
    27: VP:
        CanSM_GetCurrentComMode returns E_OK
    28: VP:
        CanSM is in state COMM_NO_COMMUNICATION
    29: VP: no further API calls were done
    30: Call CanSM_RequestComMode with:
        network := &lt;id of network 0&gt;
        ComM_Mode := COMM_FULL_COMMUNICATION.
    31: VP (CanSM.ASR40.BSM.T_NOCOM_PRE_FULLCOM):
        CanSM called the following API function:
        CanIf_SetTrcvMode for TransceiverId 2 with:
        TransceiverMode := CANTRCV_TRCVMODE_NORMAL
    32: Call CanSM_TransceiverModeIndication for each Transceiver with:
        TransceiverMode := CANTRCV_TRCVMODE_NORMAL
    33: Call the CanSM_MainFunction twice.
	34: VP: CanSM does not call CanIf_SetControllerMode, as CanNetwork_0 is configured to process on CanSM_MainFunction_EcucPartition_0.
	35: Call CanSM_MainFunction_EcucPartition_0().
    36: VP (CanSM.ASR40.BSMPreFull.T_S_TRCV_NORMAL_S_CC_STOPPED):
        CanSM called the following API function:
        CanIf_SetControllerMode for ControllerId 5 and 2 with:
        ControllerMode := CANIF_CS_STOPPED	
    37: Call CanSM_ControllerModeIndication with:
        ControllerId := 5
        ControllerMode := CANIF_CS_STOPPED
    38: Call the MainFunction of CanSM 5 times
    39: VP (CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.NoPn.2):
          CanSM called Det_ReportError with:
          ErrorId: 10
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_NOCOM_PRE_FULLCOM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>175</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMPreFull.T_S_TRCV_NORMAL_S_CC_STOPPED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>227</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.NoPn.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>178</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.CanSMDistributedChannels_MainFunctions_Processing_Generic</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>153</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.CanSMDistributedChannels_MainFunctions_Processing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>152</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>630</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANSM_T_NOCO_FUCO_2CC_2NW_Distribution_2EcucPartition</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_NoPN_TxTimeoutException_DET_2NW_2EcucPartition/source/application/Tst_CanSM_Conf_NoPNTxTimeoutExceptionON_2NW_2EcucPartition.c.m4</sourcefile>
      <sourceline>75</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    This test checks the correct Transition of communication mode from
    CANSM_BSM_S_NOCOM to CANSM_BSM_S_FULLCOM
    with multiple (2) controller for network 0 if only one
    controller calls the ModeIndication while DistributedChannelProcessing is enabled.
    All mode indications shall be asynchron.
  
Test Object: 
    Module initialization
  
Test Precondition: 
  
Test Execution: 
    01: Initialize CanSM
    02: VP (CanSM.ASR40.BSM.T_NOT_INITIALIZED_PRE_NOCOM.NoPn):
        CanSM called the following API function in defined order:
        1. BswM_CanSM_CurrentState (NW0) with:
           CurrentState := CANSM_BSWM_NO_COMMUNICATION
           Network := &lt;id of nw0&gt;
        2. CanIf_SetControllerMode (twice) with:
           ControllerMode := CANIF_CS_STOPPED
           ControllerId := 6 (NW0), 4 (NW0)
        3. BswM_CanSM_CurrentState (NW1) with:
           CurrentState := CANSM_BSWM_NO_COMMUNICATION
           Network := &lt;id of nw1&gt;
        4. CanIf_SetControllerMode with:
           ControllerMode := CANIF_CS_STOPPED
           ControllerId := 1 (NW1)
    03: Call CanSM_ControllerModeInidcation for ControllerId 5 and 2 (the controller configured for CanNetwork_0) with:
        ControllerMode := CANIF_CS_STOPPED
    04: Call the CanSM_MainFunction_EcucPartition_1().
	05: VP:
        CanSM does not call CanIf_SetControllerMode for ControllerId 5 and 2, as CanNetwork_0 is configured to process on EcucPartition_0.
	06: Call the CanSM_MainFunction_EcucPartition_0.
	07: VP:
        CanSM calls CanIf_SetControllerMode for ControllerId 5 and 2, as CanNetwork_0 is configured to process on EcucPartition_0.
	08: Call CanSM_ControllerModeInidcation for ControllerId 6 (the controller configured for CanNetwork_1) with:
        ControllerMode := CANIF_CS_STOPPED
    09: Call the CanSM_MainFunction_EcucPartition_0.
	10: VP:
        CanSM does not call CanIf_SetControllerMode for ControllerId 6, as CanNetwork_1 is configured to process on generic mainFunction.
	11: Call the _EcucPartition_1.
	12: VP:
        CanSM calls CanIf_SetControllerMode for ControllerId 6.
    13: VP (CanSM.SWS_CanSM_00638):
        Call CanSM_ControllerModeInidcation for ControllerId 5, 2 and 6 with:
        ControllerMode := CANIF_CS_SLEEP
    14: Call the _EcucPartition_1.
	15: VP:
        CanSM does not call CanIf_SetTrcvMode for TransceiverId 3, as CanNetwork_0 is configured to process on CanSM_MainFunction_EcucPartition_0.
	16: Call the CanSM_MainFunction_EcucPartition_0.
    17: VP (CanSM.ASR40.BSMDeInitNoPn.T_S_CC_SLEEP_S_TRCV_NORMAL):
        CanSM called only the following API function:
        CanIf_SetTrcvMode for TransceiverId 3 with:
        TransceiverMode := CANTRCV_TRCVMODE_NORMAL
    18: Call CanSM_TransceiverModeInidcation for TransceiverId 3with:
        TransceiverMode := CANTRCV_TRCVMODE_NORMAL
    19: Call the _EcucPartition_1.
	20: VP: CanSM does not call CanIf_SetTrcvMode, as CanNetwork_0 is configured to process on CanSM_MainFunction_EcucPartition_0.
	21: Call the CanSM_MainFunction_EcucPartition_0.
    22: VP (CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_NORMAL_S_TRCV_STANDBY):
        CanSM called only the following API function:
        CanIf_SetTrcvMode for TransceiverId 2 and 0 with:
        TransceiverMode := CANTRCV_TRCVMODE_STANDBY
    23: Call CanSM_TransceiverModeInidcation for TransceiverId 2 and 0 with:
        TransceiverMode := CANTRCV_TRCVMODE_STANDBY
    24: Call the _EcucPartition_1, and CanSM_MainFunction_EcucPartition_0.
    25: VP (CanSM.ASR40.BSM.T_PRE_NOCOM_NOCOM.NoPn.2):
        No other API function called
    26: Call CanSM_GetCurrentComMode to read the current CanSM mode
    27: VP:
        CanSM_GetCurrentComMode returns E_OK
    28: VP:
        CanSM is in state COMM_NO_COMMUNICATION
    29: VP: no further API calls were done
    30: Call CanSM_RequestComMode with:
        network := &lt;id of network 0&gt;
        ComM_Mode := COMM_FULL_COMMUNICATION.
    31: VP (CanSM.ASR40.BSM.T_NOCOM_PRE_FULLCOM):
        CanSM called the following API function:
        CanIf_SetTrcvMode for TransceiverId 2 with:
        TransceiverMode := CANTRCV_TRCVMODE_NORMAL
    32: Call CanSM_TransceiverModeIndication for each Transceiver with:
        TransceiverMode := CANTRCV_TRCVMODE_NORMAL
    33: Call the CanSM_MainFunction_EcucPartition_1 twice.
	34: VP: CanSM does not call CanIf_SetControllerMode, as CanNetwork_0 is configured to process on CanSM_MainFunction_EcucPartition_0.
	35: Call CanSM_MainFunction_EcucPartition_0().
    36: VP (CanSM.ASR40.BSMPreFull.T_S_TRCV_NORMAL_S_CC_STOPPED):
        CanSM called the following API function:
        CanIf_SetControllerMode for ControllerId 5 and 2 with:
        ControllerMode := CANIF_CS_STOPPED	
    37: Call CanSM_ControllerModeIndication with:
        ControllerId := 5
        ControllerMode := CANIF_CS_STOPPED
    38: Call the MainFunction of CanSM 5 times
    39: VP (CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.NoPn.2):
          CanSM called Det_ReportError with:
          ErrorId: 10
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_NOCOM_PRE_FULLCOM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>175</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMPreFull.T_S_TRCV_NORMAL_S_CC_STOPPED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>227</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.NoPn.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>178</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.CanSMDistributedChannels_MainFunctions_Processing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>152</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00638</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>512</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>631</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANSM_S_RNOCOM_SYNC_NOPN</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_NoPN_TxTimeoutException_DET_ON/source/application/Tst_CanSM_Conf_NoPNTxTimeoutExceptionON.c.m4</sourcefile>
      <sourceline>87</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct behaviour of execution of the CANSM_BSM_S_PRE_NOCOM
    state (State Request NO COMmunication).
    All mode indications shall be synchron.
    Partial Networking is deactivated for the network under test.
    Note: Although this test validates only the network with index 0
    it shall be taken into account that during CanSM_Init API function
    calls for other configured networks happens.
  
Test Object: 
    Module initialization
  
Test Precondition: 
    - CanSM module is NOT initialized
  
Test Execution: 
    01: Prepare the CanIf stub to indicate the requested transceiver mode
        transition from inside the context of CanIf_SetTrcvMode.
    02: Prepare the CanIf stub to indicate the requested controller mode
        transition from inside the context of CanIf_SetControllerMode.
    03: Initialize CanSM
    04: Call the MainFunction of CanSM
    05: VP:
        CanSM called the following API function in defined order:
        1. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_NO_COMMUNICATION
           Network := 3
           (CanSM.ASR40.BSM.T_NOT_INITIALIZED_PRE_NOCOM.NoPn)

        2. CanIf_SetControllerMode with:
           ControllerMode := CANIF_CS_STOPPED
           ControllerId := 5
           (CanSM.ASR40.BSM.T_NOT_INITIALIZED_PRE_NOCOM.NoPn)
        3. CanIf_SetControllerMode with:
           ControllerMode := CANIF_CS_SLEEP
           ControllerId := 5
           (CanSM.ASR40.BSMDeInitNoPn.T_S_CC_STOPPED_S_CC_SLEEP)
        4. CanIf_SetTrcvMode with:
           TransceiverMode := CANTRCV_TRCVMODE_NORMAL
           TransceiverId := 3
           (CanSM.ASR40.BSMDeInitNoPn.T_S_CC_SLEEP_S_TRCV_NORMAL)
        5. CanIf_SetTrcvMode with:
           TransceiverMode := CANTRCV_TRCVMODE_STANDBY
           TransceiverId := 3
           (CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_NORMAL_S_TRCV_STANDBY)
    06: Call CanSM_GetCurrentComMode to read the current CanSM mode
        network := &lt;id&gt; of network 0
    07: VP:
        CanSM_GetCurrentComMode return E_OK
    08: VP (CanSM.SWS_CanSM_00186):
        CanSM is in state COMM_NO_COMMUNICATION
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_NOT_INITIALIZED_PRE_NOCOM.NoPn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>195</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_PN_CLEAR_WUF_S_PN_CC_STOPPED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>197</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_PN_CC_STOPPED_S_TRCV_NORMAL</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>200</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_TRCV_NORMAL_S_TRCV_STANDBY</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>203</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_TRCV_STANDBY_S_CC_SLEEP</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>206</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00186</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>303</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.CanSMActivatePN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>105</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>632</internalId></specobject>
    <specobject>
      <id>TS_CANSM_NOCO_TXTIMEOUTEXCEPTION_SYNC_NoPN_DET_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_NoPN_TxTimeoutException_DET_ON/source/application/Tst_CanSM_Conf_NoPNTxTimeoutExceptionON.c.m4</sourcefile>
      <sourceline>219</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks that tx timeout recovery (CanSM_TxTimeoutException) does not
    have any effect if invoked in state "NO COMMUNICATION".
    All mode indications shall be synchron.
    Note: TxTimeoutException is implemented as specified in AUTOSAR SWS 4.1 rev3!
  
Test Object: 
    - Mode transition
    - CanSM_TxTimeoutException()
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_NOCOM
  
Test Execution: 
    01: Preparation of CanIf stub to be synchronous.
    02: Call CanSM_TxTimeoutException() with a valid network handle.
    03: Call main function once.
    04: VP (CanSM.EB.TxTimeoutException.Ignore):
        Verify that there were no state transition or recovery.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.EB.TxTimeoutException.Ignore</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>133</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00410</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>327</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>633</internalId></specobject>
    <specobject>
      <id>TS_CANSM_SICO_TXTIMEOUTEXCEPTION_SYNC_NoPN_DET_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_NoPN_TxTimeoutException_DET_ON/source/application/Tst_CanSM_Conf_NoPNTxTimeoutExceptionON.c.m4</sourcefile>
      <sourceline>294</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks that tx timeout recovery (CanSM_TxTimeoutException) does not
    have any effect if invoked in state "SILENT COMMUNICATION".
    All mode indications shall be synchron.
    Note: TxTimeoutException is implemented as specified in AUTOSAR SWS 4.1 rev3!
  
Test Object: 
    - Mode transition
    - CanSM_TxTimeoutException()
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_SILENTCOM
  
Test Execution: 
    01: Preparation of CanIf stub to be synchronous.
    02: Call CanSM_TxTimeoutException() with a valid network handle.
    03: Call main function once.
    04: VP (CanSM.EB.TxTimeoutException.Ignore):
        Verify that there were no state transition or recovery.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.EB.TxTimeoutException.Ignore</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>133</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00410</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>327</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>634</internalId></specobject>
    <specobject>
      <id>TS_CANSM_FUCO_TXTIMEOUTEXCEPTION_SYNC_NoPN_DET_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_NoPN_TxTimeoutException_DET_ON/source/application/Tst_CanSM_Conf_NoPNTxTimeoutExceptionON.c.m4</sourcefile>
      <sourceline>369</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks that tx timeout recovery (CanSM_TxTimeoutException) does not
    have any effect if invoked in state CANSM_S_BUSOFF_CHECK in "FULL COMMUNICATION".
    All mode indications shall be synchron.
    Note: TxTimeoutException is implemented as specified in AUTOSAR SWS 4.1 rev3!
  
Test Object: 
    - Mode transition
    - CanSM_TxTimeoutException()
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_FULLCOM, substate CANSM_S_BUSOFF_CHECK
  
Test Execution: 
    01: Preparation of CanIf stub to be synchronous.
    02: Call CanSM_TxTimeoutException() with a valid network handle.
    03: Call main function once.
    04: VP (CanSM.EB.TxTimeoutException.Ignore):
        Verify that there were no state transition or recovery.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00410</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>327</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.TxTimeoutException.Ignore</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>133</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>635</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_FUCO_NOCO_TXTIMEOUTEXCEPTION_NOPN</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_NoPN_TxTimeoutException_DET_ON/source/application/Tst_CanSM_Conf_NoPNTxTimeoutExceptionON.c.m4</sourcefile>
      <sourceline>446</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct transition of communication mode from CANSM_BSM_S_FULLCOM
     to CANSM_BSM_S_NOCOM by CanSM_RequestComMode(), which ignores invocation of
     CanSM_TxTimeoutException() as there is no further recovery process required.
    All mode indications shall be asynchron.
    Partial Networking is deactivated for the network under test.
    Note: Although this test validates only the network with index 0
    it shall be taken into account that API function
    calls for other configured networks happen.
  
Test Object: 
    - Module initialization
    - CanSM_TxTimeoutException()
  
Test Precondition: 
    - CanSM module is in COMM_FULL_COMMUNICATION (substate S_BUS_OFF_CHECK)
    - All indications from CanIf stubs shall be asynchronous.
  
Test Execution: 
    01: Request S_NOCO
    02: Call CanSM_TxTimeoutException() with a valid network handle
    03: Call the MainFunction of CanSM
    04: VP (CanSM.ASR40.BSM.T_FULLCOM_SILENTCOM.BusOffCheck.2,
            CanSM.ASR40.BSM.T_SILENTCOM_PRE_NOCOM.NoPn):
        CanSM calls the following API functions in defined order:
        ----- to silent com -----
        1. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_SILENT_COMMUNICATION
           Network := 3

        2. CanIf_SetPduMode with:
           PduModeRequest := CANIF_TX_OFFLINE
           ControllerId := 5
        3. ComM_BusSM_ModeIndication/SchM_Call (in case of multicore support) with:
           ComMode := COMM_SILENT_COMMUNICATION
        ----- to pre no-com -----
        4. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_NO_COMMUNICATION
           Network := 3
        5. CanIf_SetControllerMode with:
           ControllerId := 5
    05: Simulate CanSM_ControllerModeIndication after another MainFunction call
    06: Call CanSM_TxTimeoutException() with a valid network handle
    07: Call the MainFunction of CanSM
    08: VP (CanSM.ASR40.BSMDeInitNoPn.T_S_CC_STOPPED_S_CC_SLEEP):
        CanIf_SetControllerMode is called
    09: Simulate CanSM_ControllerModeIndication with CANIF_CS_SLEEP
        after another MainFunction call
    10: Call CanSM_TxTimeoutException() with a valid network handle
    11: Call the MainFunction of CanSM
    12: VP (CanSM.ASR40.BSMDeInitNoPn.T_S_CC_SLEEP_S_TRCV_NORMAL):
        CanIf_SetTrcvMode is called
    13: Call CanSM_TxTimeoutException() with a valid network handle
    14: Simulate CanSM_TransceiverModeIndication with CANTRCV_TRCVMODE_NORMAL
        after another MainFunction call
    15: Call the MainFunction of CanSM
    16: VP (CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_NORMAL_S_TRCV_STANDBY):
        CanIf_SetTrcvMode is called
    17: Call the MainFunction of CanSM
    18: Call CanSM_TxTimeoutException() with a valid network handle
    19: Simulate CanSM_TransceiverModeIndication with CANTRCV_TRCVMODE_STANDBY
        after another MainFunction call
    20: Call the MainFunction of CanSM
    21: VP (CanSM.ASR40.BSM.T_PRE_NOCOM_NOCOM.NoPn.1):
        ComM_BusSM_ModeIndication/SchM_Call (in case of multicore support)
		is called with COMM_NO_COMMUNICATION
    22: Call CanSM_GetCurrentComMode to read the current CanSM mode
        network := &lt;id&gt; of network 0
    23: VP:
        CanSM_GetCurrentComMode returns E_OK
    24: VP(CanSM.SWS_CanSM_00410):
        CanSM is in state COMM_NO_COMMUNICATION
    25: One MainFunction call to ensure no change in states.
    26: VP(CanSM.EB.TxTimeoutException.NoCom):
        Verify if CanSM_TxTimeoutException() is ignored and there were no other state transition.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_FULLCOM_SILENTCOM.BusOffCheck.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>109</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_SILENTCOM_PRE_NOCOM.NoPn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>189</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_CC_STOPPED_S_CC_SLEEP</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>216</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_CC_SLEEP_S_TRCV_NORMAL</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>219</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_NORMAL_S_TRCV_STANDBY</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>222</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_PRE_NOCOM_NOCOM.NoPn.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>191</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.CanSMActivatePN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>105</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.TxTimeoutException.Ignore</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>133</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00410</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>327</internalId></provcov>
        <provcov>
          <linksto>CanSM.Config.SchM_Call_CanSM_ModeIndication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>145</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>636</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_NOCO_FUCO_TXTIMEOUTEXCEPTION_NOPN</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_NoPN_TxTimeoutException_DET_ON/source/application/Tst_CanSM_Conf_NoPNTxTimeoutExceptionON.c.m4</sourcefile>
      <sourceline>697</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks that tx timeout recovery (CanSM_TxTimeoutException) does not
    have any effect if invoked during a transition from state "NO COMMUNICATION"
    towards state "FULL COMMUNICATION".
    Note: TxTimeoutException is implemented as specified in AUTOSAR SWS 4.1 rev3!
  
Test Object: 
    - Module initialization
    - CanSM_TxTimeoutException
  
Test Precondition: 
    - CanSM is in state S_NOCO
    - All indications from CanIf stubs shall be asynchronous.
  
Test Execution: 
    01: Call CanSM_RequestComMode with:
        network := &lt;id&gt; of network 0
        ComM_Mode := COMM_FULL_COMMUNICATION.
    02: CanSM called only the following API function:
        CanIf_SetTrcvMode with:
        TransceiverMode := CANTRCV_TRCVMODE_NORMAL
    03: VP(CanSM.EB.TxTimeoutException.RFUCO):
        Call CanSM_TxTimeoutException() with a valid network handle
    04: Call CanSM_TransceiverModeIndication with:
        TransceiverId := 3
        TransceiverMode := CANTRCV_TRCVMODE_NORMAL
    05: Call the MainFunction of CanSM
    06: CanSM_MainFunction called only the following API function:
        CanIf_SetControllerMode with:
        ControllerMode := CANIF_CS_STOPPED
    07: VP(CanSM.EB.TxTimeoutException.RFUCO):
        Call CanSM_TxTimeoutException() with a valid network handle
    08: Call CanSM_ControllerModeIndication with:
        ControllerId := 5
        ControllerMode := CANIF_CS_STOPPED
    09: Call the MainFunction of CanSM
    10: CanSM_MainFunction called only the following API function:
        CanIf_SetControllerMode with:
        ControllerMode := CANIF_CS_STARTED
    11: VP(CanSM.EB.TxTimeoutException.RFUCO):
        Call CanSM_TxTimeoutException() with a valid network handle
    12: Call CanSM_ControllerModeIndication with:
        ControllerId := 5
        ControllerMode := CANIF_CS_STARTED
    13: VP(CanSM.EB.TxTimeoutException.RFUCO):
        Call CanSM_TxTimeoutException() with a valid network handle
    14: Call the MainFunction of CanSM
    15: CanSM called the following API functions in defined order:

        1. CanIf_SetPduMode with:
           PduModeRequest := CANIF_ONLINE
		2. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_FULL_COMMUNICATION
           Network := 3
        3. ComM_BusSM_ModeIndication/SchM_Call (in case of multicore support) with:
           ComMode := COMM_FULL_COMMUNICATION
    16: Call CanSM_GetCurrentComMode to read the current CanSM mode
        network := &lt;id&gt; of network 0
    17: CanSM_GetCurrentComMode returns E_OK
    18: VP (CanSM.SWS_CanSM_00410, CanSM.EB.TxTimeoutException.RFUCO):
        CanSM is in state COMM_FULL_COMMUNICATION
    19: One MainFunction call to ensure no change in states
    20: VP (CanSM.EB.TxTimeoutException.Ignore):
        Verify that there were no state transition or recovery.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.EB.TxTimeoutException.Ignore</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>133</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00410</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>327</internalId></provcov>
        <provcov>
          <linksto>CanSM.Config.SchM_Call_CanSM_ModeIndication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>145</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>637</internalId></specobject>
    <specobject>
      <id>TS_CANSM_TXTIMEOUTEXCEPTION_ASYNC_NoPN_DET_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_NoPN_TxTimeoutException_DET_ON/source/application/Tst_CanSM_Conf_NoPNTxTimeoutExceptionON.c.m4</sourcefile>
      <sourceline>891</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct transitions (good-case) of the state machine
    CANSM_BSM_S_TX_TIMEOUT_EXCEPTION when all Indications are done asynchronous.
    Note: TxTimeoutException is implemented as specified in AUTOSAR SWS 4.1 rev3!
  
Test Object: 
    - Mode transition
    - CanSM_TxTimeoutException
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_FULLCOM, substate CANSM_S_NO_BUS_OFF
  
Test Execution: 
    01: Trigger Tx-Timeout-Exception
    02: VP (CanSM.ASR41.BSM.T_FULLCOM_TX_TIMEOUT_EXCEPTION):
        CanSM calls CanIf_SetControllerMode with
        ControllerMode := CANIF_CS_STOPPED
        ControllerId := 5
    03: Trigger indication for the controller
    04: VP:
        No transition takes place, since all transition are done asynchronous
    05: Trigger on MainFunction period.
    06: VP (CanSM.ASR41.TX_TIMEOUT_EXCEPTION.T_S_CC_STOPPED_S_CC_STARTED):
        CanSM calls CanIf_SetControllerMode with
        ControllerMode := CANIF_CS_STARTED
        ControllerId := 5
    07: Trigger indication for the controller
    08: VP:
        No transition takes place, since all transition are done asynchronous
    09: Trigger on MainFunction period.
    10: VP (CanSM.SWS_CanSM_00655):
        CanSM sets the Pdu mode back to ONLINE
    11: VP (CanSM.ASR41.BSM.T_TX_TIMEOUT_EXCEPTION_FULLCOM):
        CanSM enters state CANSM_S_NO_BUS_OFF
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00410</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>327</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR41.BSM.T_FULLCOM_TX_TIMEOUT_EXCEPTION</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>96</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR41.TX_TIMEOUT_EXCEPTION.T_S_CC_STOPPED_S_CC_STARTED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>99</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR41.BSM.T_TX_TIMEOUT_EXCEPTION_FULLCOM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>97</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00655</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>526</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>638</internalId></specobject>
    <specobject>
      <id>TS_CANSM_TXTIMEOUTEXCEPTION_SYNC_NoPN_DET_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_NoPN_TxTimeoutException_DET_ON/source/application/Tst_CanSM_Conf_NoPNTxTimeoutExceptionON.c.m4</sourcefile>
      <sourceline>1019</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct transitions (good-case) of the state machine
    CANSM_BSM_S_TX_TIMEOUT_EXCEPTION when all Indications are done synchronous.
    Note: TxTimeoutException is implemented as specified in AUTOSAR SWS 4.1 rev3!
  
Test Object: 
    - Mode transition
    - CanSM_TxTimeoutException
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_FULLCOM, substate CANSM_S_NO_BUS_OFF
  
Test Execution: 
    01: Prepare the CanIf stub (controller functions) to make all indications synchronous
    02: Trigger Tx-Timeout-Exception
    03: VP (CanSM.ASR41.BSM.T_FULLCOM_TX_TIMEOUT_EXCEPTION):
        CanSM calls CanIf_SetControllerMode with
        ControllerMode := CANIF_CS_STOPPED
        ControllerId := 5
    04: VP (CanSM.ASR41.TX_TIMEOUT_EXCEPTION.T_S_CC_STOPPED_S_CC_STARTED):
        CanSM calls CanIf_SetControllerMode with
        ControllerMode := CANIF_CS_STARTED
        ControllerId := 5
    05: VP (CanSM.SWS_CanSM_00655):
           CanSM sets the Pdu mode to ONLINE
    06: VP (CanSM.ASR41.BSM.T_TX_TIMEOUT_EXCEPTION_FULLCOM):
        CanSM enters state CANSM_S_NO_BUS_OFF
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00410</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>327</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR41.BSM.T_FULLCOM_TX_TIMEOUT_EXCEPTION</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>96</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR41.TX_TIMEOUT_EXCEPTION.T_S_CC_STOPPED_S_CC_STARTED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>99</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR41.BSM.T_TX_TIMEOUT_EXCEPTION_FULLCOM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>97</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00655</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>526</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>639</internalId></specobject>
    <specobject>
      <id>TS_CANSM_TXTIMEOUTEXCEPTION_ASYNC_SYNC_1_NoPN_DET_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_NoPN_TxTimeoutException_DET_ON/source/application/Tst_CanSM_Conf_NoPNTxTimeoutExceptionON.c.m4</sourcefile>
      <sourceline>1125</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct transitions of the state machine
    CANSM_BSM_S_TX_TIMEOUT_EXCEPTION when the first retry of setting the
    controller mode (S_CC_STOPPED) after a timeout gets a synchronous indication.
    Note: TxTimeoutException is implemented as specified in AUTOSAR SWS 4.1 rev3!
  
Test Object: 
    - Mode transition
    - CanSM_TxTimeoutException
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_FULLCOM, substate CANSM_S_NO_BUS_OFF
  
Test Execution: 
    01: Trigger Tx-Timeout-Exception
    02: VP:
        CanSM calls CanIf_SetControllerMode with
        ControllerMode := CANIF_CS_STOPPED
        ControllerId := 5
    03: Let time CanSMModeRequestRepetitionTime-1 elapse
    04: Set the CanIf stub to give a synchronous indication
    05: Let an additional MainFunction cycle pass
    06: VP (CanSM.ASR41.TX_TIMEOUT_EXCEPTION.T_S_CC_STOPPED_S_CC_STARTED):
        CanSM calls CanIf_SetControllerMode with
        ControllerMode := CANIF_CS_STARTED
        ControllerId := 5
    07: VP (CanSM.SWS_CanSM_00655):
        CanSM sets the Pdu mode to ONLINE
    08: VP:
        CanSM enters state CANSM_S_NO_BUS_OFF
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR41.TX_TIMEOUT_EXCEPTION.T_S_CC_STOPPED_S_CC_STARTED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>99</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00655</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>526</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>640</internalId></specobject>
    <specobject>
      <id>TS_CANSM_TXTIMEOUTEXCEPTION_ASYNC_SYNC_2_NoPN_DET_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_NoPN_TxTimeoutException_DET_ON/source/application/Tst_CanSM_Conf_NoPNTxTimeoutExceptionON.c.m4</sourcefile>
      <sourceline>1241</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct transitions of the state machine
    CANSM_BSM_S_TX_TIMEOUT_EXCEPTION when the first retry of setting the
    controller mode S_CC_STARTED) after a timeout gets a synchronous indication.
    Note: TxTimeoutException is implemented as specified in AUTOSAR SWS 4.1 rev3!
  
Test Object: 
    - Mode transition
    - CanSM_TxTimeoutException
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_FULLCOM, substate CANSM_S_NO_BUS_OFF
  
Test Execution: 
    01: Trigger Tx-Timeout-Exception
    02: Continue with Tx-Timeout-Exception until CanSM reaches state S_CC_STARTED
    03: Let time CanSMModeRequestRepetitionTime-1 elapse
    04: Set the CanIf stub to give a synchronous indication
    05: Let an additional MainFunction cycle pass
    06: VP (CanSM.SWS_CanSM_00655):
        CanSM sets the Pdu mode to ONLINE
    06: VP (CanSM.ASR41.BSM.T_TX_TIMEOUT_EXCEPTION_FULLCOM):
        CanSM enters state CANSM_S_NO_BUS_OFF
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR41.BSM.T_TX_TIMEOUT_EXCEPTION_FULLCOM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>97</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00655</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>526</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>641</internalId></specobject>
    <specobject>
      <id>TS_CANSM_TXTIMEOUTEXCEPTION_TIMEOUT_1_NoPN_DET_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_NoPN_TxTimeoutException_DET_ON/source/application/Tst_CanSM_Conf_NoPNTxTimeoutExceptionON.c.m4</sourcefile>
      <sourceline>1347</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the behavior of the CANSM_BSM_S_TX_TIMEOUT_EXCEPTION
    state machine if a timeout for the controller mode indication (stop) occurs.
    Note: TxTimeoutException is implemented as specified in AUTOSAR SWS 4.1 rev3!
  
Test Object: 
    - CanSM_TxTimeoutException
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_FULLCOM, substate CANSM_S_NO_BUS_OFF
  
Test Execution: 
    01: Trigger Tx-Timeout-Exception
    02: VP:
        CanSM calls CanIf_SetControllerMode with
        ControllerMode := CANIF_CS_STOPPED
        ControllerId := 5
    03: Let time CanSMModeRequestRepetitionTime elapse
    04: VP (CanSM.ASR41.TX_TIMEOUT_EXCEPTION.T_S_CC_STOPPED_S_CC_STOPPED):
        CanSM repeated the call to CanIf_SetControllerMode because of
        the elapsed timeout with
        ControllerMode := CANIF_CS_STOPPED
        ControllerId := 5
    05: Finish Tx-Timeout-Exception
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR41.TX_TIMEOUT_EXCEPTION.T_S_CC_STOPPED_S_CC_STOPPED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>98</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>642</internalId></specobject>
    <specobject>
      <id>TS_CANSM_TXTIMEOUTEXCEPTION_TIMEOUT_2_NoPN_DET_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_NoPN_TxTimeoutException_DET_ON/source/application/Tst_CanSM_Conf_NoPNTxTimeoutExceptionON.c.m4</sourcefile>
      <sourceline>1434</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the behavior of the CANSM_BSM_S_TX_TIMEOUT_EXCEPTION
    state machine if a timeout for the controller mode indication (start) occurs.
    Note: TxTimeoutException is implemented as specified in AUTOSAR SWS 4.1 rev3!
  
Test Object: 
    - CanSM_TxTimeoutException
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_FULLCOM, substate CANSM_S_NO_BUS_OFF
  
Test Execution: 
    01: Trigger Tx-Timeout-Exception
    02: Simulate mode indication for the CanIf_SetControllerMode request with
        ControllerMode := CANIF_CS_STOPPED
    03: VP:
        CanSM calls CanIf_SetControllerMode with
        ControllerMode := CANIF_CS_STARTED
        ControllerId := 5
    04: Let time CanSMModeRequestRepetitionTime elapse
    05: VP (CanSM.ASR41.TX_TIMEOUT_EXCEPTION.T_S_CC_STARTED_S_CC_STARTED):
        CanSM repeated the call to CanIf_SetControllerMode because of
        the elapsed timeout with
        ControllerMode := CANIF_CS_STARTED
        ControllerId := 5
    06: Finish Tx-Timeout-Exception
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR41.TX_TIMEOUT_EXCEPTION.T_S_CC_STARTED_S_CC_STARTED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>100</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>643</internalId></specobject>
    <specobject>
      <id>TS_CANSM_TXTIMEOUTEXCEPTION_TIMEOUT_3_NoPN_DET_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_NoPN_TxTimeoutException_DET_ON/source/application/Tst_CanSM_Conf_NoPNTxTimeoutExceptionON.c.m4</sourcefile>
      <sourceline>1526</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the behavior of the state machine CANSM_BSM_S_TX_TIMEOUT_EXCEPTION
    if CanSM gets no indication for the request of setting the controller to mode
    CANIF_CS_STOPPED ( = timeout elapses)
    If DET is enabled, CanSM shall report DET error CANSM_E_MODE_REQUEST_TIMEOUT
    and make a transition to CANSM_BSM_S_NOCOM.
    Mode indications shall happen asynchronous.
  
Test Object: 
    - CanSM_TxTimeoutException
    - T_REPEAT_MAX
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_FULLCOM, substate CANSM_S_NO_BUS_OFF
  
Test Execution: 
    01: Trigger Tx-Timeout-Exception
    02: Triger MainFunctions to continue in time until one Mainfunction
        before trigger T_REPEAT_MAX occurs.
    03: VP:
        CanSM must not call Det_ReportError
    04: Trigger T_REPEAT_MAX
    05: VP (CanSM.ASR41.TX_TIMEOUT_EXCEPTION.T_S_CC_STOPPED_PRE_NOCOM.Pn):
        If development error detection is enabled,
        CanSM called Det_ReportError with:
        ErrorId: CANSM_E_MODE_REQUEST_TIMEOUT
    06: VP (CanSM.ASR41.TX_TIMEOUT_EXCEPTION.T_S_CC_STOPPED_PRE_NOCOM.Pn):
        CanSM shall start a transition to CANSM_BSM_S_NOCOM
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR41.TX_TIMEOUT_EXCEPTION.T_S_CC_STOPPED_PRE_NOCOM.Pn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>101</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>644</internalId></specobject>
    <specobject>
      <id>TS_CANSM_TXTIMEOUTEXCEPTION_TIMEOUT_4_NoPN_DET_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_NoPN_TxTimeoutException_DET_ON/source/application/Tst_CanSM_Conf_NoPNTxTimeoutExceptionON.c.m4</sourcefile>
      <sourceline>1618</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the behavior of the state machine CANSM_BSM_S_TX_TIMEOUT_EXCEPTION
    if CanSM gets no indication for the request of setting the controller to mode
    CANIF_CS_STARTED ( = timeout elapses)
    If DET is enabled, CanSM shall report DET error CANSM_E_MODE_REQUEST_TIMEOUT
    and make a transition to CANSM_BSM_S_NOCOM.
    Mode indications shall happen asynchronous.
  
Test Object: 
    - CanSM_TxTimeoutException
    - T_REPEAT_MAX
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_FULLCOM, substate CANSM_S_NO_BUS_OFF
  
Test Execution: 
    01: Trigger Tx-Timeout-Exception
    02: Continue until CanSM makes a controller mode request with
        mode CANIF_CS_STARTED.
    03: Triger MainFunctions to continue in time until one Mainfunction
        before trigger T_REPEAT_MAX occurs.
    04: VP:
        CanSM must not call Det_ReportError
    05: Trigger T_REPEAT_MAX
    06: VP (CanSM.ASR41.TX_TIMEOUT_EXCEPTION.T_S_CC_STARTED_PRE_NOCOM.Pn):
        If development error detection is enabled,
        CanSM called Det_ReportError with:
        ErrorId: CANSM_E_MODE_REQUEST_TIMEOUT
    07: VP (CanSM.ASR41.TX_TIMEOUT_EXCEPTION.T_S_CC_STARTED_PRE_NOCOM.Pn):
        CanSM shall start a transition to CANSM_BSM_S_NOCOM
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR41.TX_TIMEOUT_EXCEPTION.T_S_CC_STARTED_PRE_NOCOM.Pn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>102</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>645</internalId></specobject>
    <specobject>
      <id>TS_CANSM_REPEATED_TXTIMEOUTEXCEPTION_NoPN_DET_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_NoPN_TxTimeoutException_DET_ON/source/application/Tst_CanSM_Conf_NoPNTxTimeoutExceptionON.c.m4</sourcefile>
      <sourceline>1720</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test performs 2 subsequent Tx-Timeout-exception recoveries.
    There must no be any differences between both recoveries.
    Note: TxTimeoutException is implemented as specified in AUTOSAR SWS 4.1 rev3!
  
Test Object: 
    - Mode transition
    - CanSM_TxTimeoutException()
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_SILENTCOM
  
Test Execution: 
    01: Trigger Tx-Timeout-Exception
    02: VP:
        Check that Tx-Timeout recovery works
        (analog to TS_CANSM_TXTIMEOUTEXCEPTION_SYNC_NoPN_DET_ON
         or TS_CANSM_TXTIMEOUTEXCEPTION_ASYNC_NoPN_DET_ON)
    03: Trigger a second Tx-Timeout-Exception
    04: VP:
        Check that Tx-Timeout recovery works again
        (analog to TS_CANSM_TXTIMEOUTEXCEPTION_SYNC_NoPN_DET_ON
         or TS_CANSM_TXTIMEOUTEXCEPTION_ASYNC_NoPN_DET_ON)
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00410</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>327</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>646</internalId></specobject>
    <specobject>
      <id>TS_CANSM_TXTIMEOUTEXCEPTION_2ND_CALL_NoPN_DET_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_NoPN_TxTimeoutException_DET_ON/source/application/Tst_CanSM_Conf_NoPNTxTimeoutExceptionON.c.m4</sourcefile>
      <sourceline>1788</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks that a call to CanSM_TxTimeoutException has no effect
    if there is already an ongoing Tx-Timeout-Exception recovery.
  
Test Object: 
    - CanSM_TxTimeoutException
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_FULLCOM, substate CANSM_S_NO_BUS_OFF
  
Test Execution: 
    01: Trigger Tx-Timeout-Exception
    02: VP:
        CanSM calls CanIf_SetControllerMode with
        ControllerMode := CANIF_CS_STOPPED
        ControllerId := 5
    03: Trigger Tx-Timeout-Exception a 2nd time
    04: Finish Tx-Timeout-Exception
    05: VP (CanSM.EB.TxTimeoutException.OngoingRecovery):
        CanSM shall be in state COMM_FULL_COMMUNICATION
    06: Trigger a MainFunction cycle
    07: VP (CanSM.SWS_CanSM_00655):
           CanSM sets the Pdu mode to ONLINE
    08: VP (CanSM.EB.TxTimeoutException.OngoingRecovery):
        No additional transition shall happen.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.EB.TxTimeoutException.OngoingRecovery</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>132</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00655</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>526</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>647</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANSM_T_FUCO_NOCO_TXTIMEOUTEXCEPTION_NOPN_Distribution</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_NoPN_TxTimeoutException_DET_ON_Distribution/source/application/Tst_CanSM_Conf_NoPNTxTimeoutExceptionON_Distribution.c.m4</sourcefile>
      <sourceline>83</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct transition of communication mode from CANSM_BSM_S_FULLCOM
    to CANSM_BSM_S_NOCOM by CanSM_RequestComMode(), which ignores invocation of
    CanSM_TxTimeoutException() as there is no further recovery process required,
	While the Can NW is configured to be allocated on EcucPartition_0.
    All mode indications shall be asynchron.
    Partial Networking is deactivated for the network under test.
    Note: Although this test validates only the network with index 0
    it shall be taken into account that API function
    calls for other configured networks happen.
  
Test Object: 
    - Module initialization
    - CanSM_TxTimeoutException()
  
Test Precondition: 
    - CanSM module is in COMM_FULL_COMMUNICATION (substate S_BUS_OFF_CHECK)
    - All indications from CanIf stubs shall be asynchronous.
  
Test Execution: 
    01: Request S_NOCO
    02: Call CanSM_TxTimeoutException() with a valid network handle
    03: Call the CanSM_MainFunction_EcucPartition_0 of CanSM
    04: VP (CanSM.ASR40.BSM.T_FULLCOM_SILENTCOM.BusOffCheck.2,
            CanSM.ASR40.BSM.T_SILENTCOM_PRE_NOCOM.NoPn):
        CanSM calls the following API functions in defined order:
        ----- to silent com -----
        1. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_SILENT_COMMUNICATION
           Network := 3

        2. CanIf_SetPduMode with:
           PduModeRequest := CANIF_TX_OFFLINE
           ControllerId := 5
        3. ComM_BusSM_ModeIndication/SchM_Call (in case of multicore support) with:
           ComMode := COMM_SILENT_COMMUNICATION
        ----- to pre no-com -----
        4. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_NO_COMMUNICATION
           Network := 3
        5. CanIf_SetControllerMode with:
           ControllerId := 5
    05: Simulate CanSM_ControllerModeIndication after another CanSM_MainFunction_EcucPartition_0 call
    06: Call CanSM_TxTimeoutException() with a valid network handle
    07: Call the CanSM_MainFunction_EcucPartition_0
    08: VP (CanSM.ASR40.BSMDeInitNoPn.T_S_CC_STOPPED_S_CC_SLEEP):
        CanIf_SetControllerMode is called
    09: Simulate CanSM_ControllerModeIndication with CANIF_CS_SLEEP
        after another CanSM_MainFunction_EcucPartition_0 call
    10: Call CanSM_TxTimeoutException() with a valid network handle
    11: Call the CanSM_MainFunction_EcucPartition_0
    12: VP (CanSM.ASR40.BSMDeInitNoPn.T_S_CC_SLEEP_S_TRCV_NORMAL):
        CanIf_SetTrcvMode is called
    13: Call CanSM_TxTimeoutException() with a valid network handle
    14: Simulate CanSM_TransceiverModeIndication with CANTRCV_TRCVMODE_NORMAL
        after another CanSM_MainFunction_EcucPartition_0 call
    15: Call the CanSM_MainFunction_EcucPartition_0
    16: VP (CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_NORMAL_S_TRCV_STANDBY):
        CanIf_SetTrcvMode is called
    17: Call the CanSM_MainFunction_EcucPartition_0
    18: Call CanSM_TxTimeoutException() with a valid network handle
    19: Simulate CanSM_TransceiverModeIndication with CANTRCV_TRCVMODE_STANDBY
        after another CanSM_MainFunction_EcucPartition_0 call
    20: Call the CanSM_MainFunction_EcucPartition_0
    21: VP (CanSM.ASR40.BSM.T_PRE_NOCOM_NOCOM.NoPn.1):
        ComM_BusSM_ModeIndication/SchM_Call (in case of multicore support)
        is called with COMM_NO_COMMUNICATION
    22: Call CanSM_GetCurrentComMode to read the current CanSM mode
        network := &lt;id&gt; of network 0
    23: VP:
        CanSM_GetCurrentComMode returns E_OK
    24: VP(CanSM.SWS_CanSM_00410):
        CanSM is in state COMM_NO_COMMUNICATION
    25: One CanSM_MainFunction_EcucPartition_0 call to ensure no change in states.
    26: VP(CanSM.EB.TxTimeoutException.NoCom):
        Verify if CanSM_TxTimeoutException() is ignored and there were no other state transition.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_FULLCOM_SILENTCOM.BusOffCheck.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>109</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_SILENTCOM_PRE_NOCOM.NoPn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>189</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_CC_STOPPED_S_CC_SLEEP</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>216</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_CC_SLEEP_S_TRCV_NORMAL</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>219</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_NORMAL_S_TRCV_STANDBY</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>222</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_PRE_NOCOM_NOCOM.NoPn.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>191</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.CanSMActivatePN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>105</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.TxTimeoutException.Ignore</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>133</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00410</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>327</internalId></provcov>
        <provcov>
          <linksto>CanSM.Config.SchM_Call_CanSM_ModeIndication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>145</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.CanSMDistributedChannels_MainFunctions_Processing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>152</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>648</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_NOCO_FUCO_TXTIMEOUTEXCEPTION_NOPN_Distribution</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_NoPN_TxTimeoutException_DET_ON_Distribution/source/application/Tst_CanSM_Conf_NoPNTxTimeoutExceptionON_Distribution.c.m4</sourcefile>
      <sourceline>322</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks that tx timeout recovery (CanSM_TxTimeoutException) does not
    have any effect if invoked during a transition from state "NO COMMUNICATION"
    towards state "FULL COMMUNICATION",
	While the Can NW is configured to be allocated on EcucPartition_0.
    Note: TxTimeoutException is implemented as specified in AUTOSAR SWS 4.1 rev3!
  
Test Object: 
    - Module initialization
    - CanSM_TxTimeoutException
  
Test Precondition: 
    - CanSM is in state S_NOCO
    - All indications from CanIf stubs shall be asynchronous.
  
Test Execution: 
    01: Call CanSM_RequestComMode with:
        network := &lt;id&gt; of network 0
        ComM_Mode := COMM_FULL_COMMUNICATION.
    02: CanSM called only the following API function:
        CanIf_SetTrcvMode with:
        TransceiverMode := CANTRCV_TRCVMODE_NORMAL
    03: VP(CanSM.EB.TxTimeoutException.RFUCO):
        Call CanSM_TxTimeoutException() with a valid network handle
    04: Call CanSM_TransceiverModeIndication with:
        TransceiverId := 3
        TransceiverMode := CANTRCV_TRCVMODE_NORMAL
    05: Call the CanSM_MainFunction_EcucPartition_0
    06: CanSM_MainFunction called only the following API function:
        CanIf_SetControllerMode with:
        ControllerMode := CANIF_CS_STOPPED
    07: VP(CanSM.EB.TxTimeoutException.RFUCO):
        Call CanSM_TxTimeoutException() with a valid network handle
    08: Call CanSM_ControllerModeIndication with:
        ControllerId := 5
        ControllerMode := CANIF_CS_STOPPED
    09: Call the CanSM_MainFunction_EcucPartition_0
    10: CanSM_MainFunction called only the following API function:
        CanIf_SetControllerMode with:
        ControllerMode := CANIF_CS_STARTED
    11: VP(CanSM.EB.TxTimeoutException.RFUCO):
        Call CanSM_TxTimeoutException() with a valid network handle
    12: Call CanSM_ControllerModeIndication with:
        ControllerId := 5
        ControllerMode := CANIF_CS_STARTED
    13: VP(CanSM.EB.TxTimeoutException.RFUCO):
        Call CanSM_TxTimeoutException() with a valid network handle
    14: Call the CanSM_MainFunction_EcucPartition_0
    15: CanSM called the following API functions in defined order:

        1. CanIf_SetPduMode with:
           PduModeRequest := CANIF_ONLINE
        2. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_FULL_COMMUNICATION
           Network := 3
        3. ComM_BusSM_ModeIndication/SchM_Call (in case of multicore support) with:
           ComMode := COMM_FULL_COMMUNICATION
    16: Call CanSM_GetCurrentComMode to read the current CanSM mode
        network := &lt;id&gt; of network 0
    17: CanSM_GetCurrentComMode returns E_OK
    18: VP (CanSM.SWS_CanSM_00410, CanSM.EB.TxTimeoutException.RFUCO):
        CanSM is in state COMM_FULL_COMMUNICATION
    19: One CanSM_MainFunction_EcucPartition_0 call to ensure no change in states
    20: VP (CanSM.EB.TxTimeoutException.Ignore):
        Verify that there were no state transition or recovery.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.EB.TxTimeoutException.Ignore</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>133</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00410</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>327</internalId></provcov>
        <provcov>
          <linksto>CanSM.Config.SchM_Call_CanSM_ModeIndication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>145</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>649</internalId></specobject>
    <specobject>
      <id>TS_CANSM_TXTIMEOUTEXCEPTION_TIMEOUT_3_NoPN_DET_ON_Distribution</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_NoPN_TxTimeoutException_DET_ON_Distribution/source/application/Tst_CanSM_Conf_NoPNTxTimeoutExceptionON_Distribution.c.m4</sourcefile>
      <sourceline>510</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the behavior of the state machine CANSM_BSM_S_TX_TIMEOUT_EXCEPTION
    if CanSM gets no indication for the request of setting the controller to mode
    CANIF_CS_STOPPED ( = timeout elapses)
    If DET is enabled, CanSM shall report DET error CANSM_E_MODE_REQUEST_TIMEOUT
    and make a transition to CANSM_BSM_S_NOCOM.
    Mode indications shall happen asynchronous.
  
Test Object: 
    - CanSM_TxTimeoutException
    - T_REPEAT_MAX
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_FULLCOM, substate CANSM_S_NO_BUS_OFF
  
Test Execution: 
    01: Trigger Tx-Timeout-Exception
    02: Triger CanSM_MainFunction_EcucPartition_0 many times
        before trigger T_REPEAT_MAX occurs.
    03: VP:
        CanSM must not call Det_ReportError
    04: Trigger T_REPEAT_MAX
    05: VP (CanSM.ASR41.TX_TIMEOUT_EXCEPTION.T_S_CC_STOPPED_PRE_NOCOM.Pn):
        If development error detection is enabled,
        CanSM called Det_ReportError with:
        ErrorId: CANSM_E_MODE_REQUEST_TIMEOUT
    06: VP (CanSM.ASR41.TX_TIMEOUT_EXCEPTION.T_S_CC_STOPPED_PRE_NOCOM.Pn):
        CanSM shall start a transition to CANSM_BSM_S_NOCOM
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR41.TX_TIMEOUT_EXCEPTION.T_S_CC_STOPPED_PRE_NOCOM.Pn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>101</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>650</internalId></specobject>
    <specobject>
      <id>TS_CANSM_TXTIMEOUTEXCEPTION_TIMEOUT_4_NoPN_DET_ON_Distribution</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_NoPN_TxTimeoutException_DET_ON_Distribution/source/application/Tst_CanSM_Conf_NoPNTxTimeoutExceptionON_Distribution.c.m4</sourcefile>
      <sourceline>599</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the behavior of the state machine CANSM_BSM_S_TX_TIMEOUT_EXCEPTION
    if CanSM gets no indication for the request of setting the controller to mode
    CANIF_CS_STARTED ( = timeout elapses)
    If DET is enabled, CanSM shall report DET error CANSM_E_MODE_REQUEST_TIMEOUT
    and make a transition to CANSM_BSM_S_NOCOM.
    Mode indications shall happen asynchronous.
  
Test Object: 
    - CanSM_TxTimeoutException
    - T_REPEAT_MAX
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_FULLCOM, substate CANSM_S_NO_BUS_OFF
  
Test Execution: 
    01: Trigger Tx-Timeout-Exception
    02: Continue until CanSM makes a controller mode request with
        mode CANIF_CS_STARTED.
    03: Triger CanSM_MainFunction_EcucPartition_0 many times
        before trigger T_REPEAT_MAX occurs.
    04: VP:
        CanSM must not call Det_ReportError
    05: Trigger T_REPEAT_MAX
    06: VP (CanSM.ASR41.TX_TIMEOUT_EXCEPTION.T_S_CC_STARTED_PRE_NOCOM.Pn):
        If development error detection is enabled,
        CanSM called Det_ReportError with:
        ErrorId: CANSM_E_MODE_REQUEST_TIMEOUT
    07: VP (CanSM.ASR41.TX_TIMEOUT_EXCEPTION.T_S_CC_STARTED_PRE_NOCOM.Pn):
        CanSM shall start a transition to CANSM_BSM_S_NOCOM
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR41.TX_TIMEOUT_EXCEPTION.T_S_CC_STARTED_PRE_NOCOM.Pn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>102</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>651</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANSM_T_NOIN_NOCO_SYNC_SingleNetNoTrcv_DET_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_SingleNetNoTrcv_DET_ON/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>80</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct transition of communication mode from
    CANSM_BSM_S_NOT_INITIALIZED to CANSM_BSM_S_NOCOM.
    All mode indications shall be synchron.
    Note: Although this test validates only the first network
    it shall be taken into account that during CanSM_Init API function
    calls for other configured networks happens.
  
Test Object: 
    Module initialization
  
Test Precondition: 
    - CanSM module is NOT initialized
    - Test is executed for a configuration with and one without a transceiver
  
Test Execution: 
    IF transceiver is configured
        01: Prepare the CanIf stub to indicate the requested transceiver mode
            transition from inside the context of CanIf_SetTrcvMode.
    ENDIF
    02: Prepare the CanIf stub to indicate the requested controller mode
        transition from inside the context of CanIf_SetControllerMode.
    03: Initialize CanSM with NULL_PTR
    04: VP: Check that if DET is on, CanSM_Init will report pointer error
    05: Initialize CanSM
    06: VP:
        CanSM called the following API function in defined order:
        1. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_NO_COMMUNICATION
           Network := 3
           (CanSM.ASR40.BSM.T_NOT_INITIALIZED_PRE_NOCOM.NoPn)
        2. CanIf_SetControllerMode with:
           ControllerMode := CANIF_CS_STOPPED
           ControllerId := 5
           (CanSM.ASR40.BSM.T_NOT_INITIALIZED_PRE_NOCOM.NoPn)
        3. CanIf_SetControllerMode with:
           ControllerMode := CANIF_CS_SLEEP
           ControllerId := 5
           (CanSM.ASR40.BSMDeInitNoPn.T_S_CC_STOPPED_S_CC_SLEEP)
        IF transceiver is configured
            4. CanIf_SetTrcvMode with:
               TransceiverMode := CANTRCV_TRCVMODE_NORMAL
               TransceiverId := 3
               (CanSM.ASR40.BSMDeInitNoPn.T_S_CC_SLEEP_S_TRCV_NORMAL)
            5. CanIf_SetTrcvMode with:
               TransceiverMode := CANTRCV_TRCVMODE_STANDBY
               TransceiverId := 3
               (CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_NORMAL_S_TRCV_STANDBY)
            (CanSM.EB.Transitions.NoTransceiver.2)
        ENDIF
    07: VP (CanSM.ASR40.BSM.T_PRE_NOCOM_NOCOM.NoPn.2):
        CanSM does not indicate ComM_BusSM_ModeIndication
    08: Call CanSM_GetCurrentComMode to read the current CanSM mode
        network := &lt;id&gt; of network 0
    09: VP (CanSM.SWS_CanSM_00371):
        CanSM_GetCurrentComMode returns E_OK
    10: VP (CanSM.SWS_CanSM_00186):
        CanSM is in state COMM_NO_COMMUNICATION
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_NOT_INITIALIZED_PRE_NOCOM.NoPn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>195</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_CC_STOPPED_S_CC_SLEEP</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>216</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_CC_SLEEP_S_TRCV_NORMAL</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>219</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_NORMAL_S_TRCV_STANDBY</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>222</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_PRE_NOCOM_NOCOM.NoPn.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>192</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.Transitions.NoTransceiver.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>106</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00371</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>317</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00424</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>341</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.SWS_CanSM_00179</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>21</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>652</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_NOCO_FUCO_SYNC_SingleNetNoTrcv_DET_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_SingleNetNoTrcv_DET_ON/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>242</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct transition of communication mode from
    CANSM_BSM_S_NOCOM to CANSM_BSM_S_FULLCOM.
    All mode indications shall be synchron.
  
Test Object: 
    Mode transition
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_NOCOM
    - Test is executed for a configuration with and one without a transceiver
  
Test Execution: 
    IF transceiver is configured
        01: Prepare the CanIf stub to indicate the requested transceiver mode
            transition from inside the context of CanIf_SetTrcvMode.
    ENDIF
    02: Prepare the CanIf stub to indicate the requested controller mode
        transition from inside the context of CanIf_SetControllerMode.
    03: Call CanSM_RequestComMode with:
        network := &lt;id&gt; of network 0
        ComM_Mode := COMM_FULL_COMMUNICATION.
    04: VP (CanSM.ASR40.SWS_CanSM_00369):
        CanSM_RequestComMode returned E_OK
    05: VP:
        CanSM called the following API functions in defined order:
        IF transceiver is configured
            1. CanIf_SetTrcvMode with:
               TransceiverMode := CANTRCV_TRCVMODE_NORMAL
               TransceiverId := 3
               (CanSM.ASR40.BSM.T_NOCOM_PRE_FULLCOM)
               (CanSM.EB.Transitions.NoTransceiver.3)
        ENDIF
        2. CanIf_SetControllerMode with:
           ControllerMode := CANIF_CS_STOPPED
           ControllerId := 5
           (CanSM.ASR40.BSMPreFull.T_S_TRCV_NORMAL_S_CC_STOPPED)
        3. CanIf_SetControllerMode with:
           ControllerMode := CANIF_CS_STARTED
           ControllerId := 5
           (CanSM.ASR40.BSMPreFull.T_S_CC_STOPPED_S_CC_STARTED)
        4. CanIf_SetPduMode with:
           PduModeRequest := CANIF_ONLINE
           ControllerId := 5
           (CanSM.ASR40.BSM.T_PRE_FULLCOM_FULLCOM)
        5. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_FULL_COMMUNICATION
           Network := 3
           (CanSM.ASR40.BSM.T_PRE_FULLCOM_FULLCOM) 
		6. ComM_BusSM_ModeIndication with:
           ComMode := COMM_FULL_COMMUNICATION
           (CanSM.ASR40.BSM.T_PRE_FULLCOM_FULLCOM)
    06: Call CanSM_GetCurrentComMode to read the current CanSM mode
        network := &lt;id&gt; of network 0
    07: VP (CanSM.SWS_CanSM_00371):
        CanSM_GetCurrentComMode returns E_OK
    08: VP (CanSM.SWS_CanSM_00186):
        CanSM is in state COMM_FULL_COMMUNICATION
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_NOCOM_PRE_FULLCOM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>175</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMPreFull.T_S_TRCV_NORMAL_S_CC_STOPPED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>227</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMPreFull.T_S_CC_STOPPED_S_CC_STARTED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>229</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_PRE_FULLCOM_FULLCOM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>167</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00369</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>315</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00371</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>317</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00186</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>303</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>653</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_NOCO_FUCO_ASYNC_SingleNetNoTrcv_DET_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_SingleNetNoTrcv_DET_ON/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>389</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct transition of communication mode from
    CANSM_BSM_S_NOCOM to CANSM_BSM_S_FULLCOM.
    All mode indications shall be asynchron.
  
Test Object: 
    Module initialization
  
Test Precondition: 
    - CanSM is in state S_NOCO
    - Test is executed for a configuration with and one without a transceiver
  
Test Execution: 
    01: Call CanSM_RequestComMode with:
        network := &lt;id&gt; of network 0
        ComM_Mode := COMM_FULL_COMMUNICATION.
    IF transceiver is configured:
        02: VP (CanSM.ASR40.BSM.T_NOCOM_PRE_FULLCOM, CanSM.EB.Transitions.NoTransceiver.3):
            CanSM called only the following API function:
            CanIf_SetTrcvMode with:
            TransceiverMode := CANTRCV_TRCVMODE_NORMAL
        03: Call CanSM_TransceiverModeIndication with:
            TransceiverId := 3
            TransceiverMode := CANTRCV_TRCVMODE_NORMAL
        04: Call the MainFunction of CanSM
    ENDIF
    05: VP (CanSM.ASR40.BSMPreFull.T_S_TRCV_NORMAL_S_CC_STOPPED):
        CanSM_MainFunction called only the following API function:
        CanIf_SetControllerMode with:
        ControllerMode := CANIF_CS_STOPPED
    06: Call CanSM_ControllerModeIndication with:
        ControllerId := 5
        ControllerMode := CANIF_CS_STOPPED
    07: Call the MainFunction of CanSM
    08: VP (CanSM.ASR40.BSMPreFull.T_S_CC_STOPPED_S_CC_STARTED):
        CanSM_MainFunction called only the following API function:
        CanIf_SetControllerMode with:
        ControllerMode := CANIF_CS_STARTED
    09: Call CanSM_ControllerModeIndication with:
        ControllerId := 5
        ControllerMode := CANIF_CS_STARTED
    10: Call the MainFunction of CanSM
    11: VP (CanSM.ASR40.BSM.T_PRE_FULLCOM_FULLCOM):
        CanSM called the following API functions in defined order:
        1. CanIf_SetPduMode with:
           PduModeRequest := CANIF_ONLINE
        2. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_FULL_COMMUNICATION
           Network := 3
		3. ComM_BusSM_ModeIndication with:
           ComMode := COMM_FULL_COMMUNICATION
    12: Call CanSM_GetCurrentComMode to read the current CanSM mode
        network := &lt;id&gt; of network 0
    13: VP:
        CanSM_GetCurrentComMode returns E_OK
    14: VP:
        CanSM is in state COMM_FULL_COMMUNICATION
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_NOCOM_PRE_FULLCOM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>175</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMPreFull.T_S_TRCV_NORMAL_S_CC_STOPPED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>227</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMPreFull.T_S_CC_STOPPED_S_CC_STARTED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>229</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_PRE_FULLCOM_FULLCOM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>167</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.Transitions.NoTransceiver.3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>107</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>654</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_FUCO_TIMEOUT_SYNC_1_SingleNetNoTrcv_DET_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_SingleNetNoTrcv_DET_ON/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>548</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct transition of communication mode from
    CANSM_BSM_S_NOCOM to CANSM_BSM_S_FULLCOM when the mode indications are
    synchronous after timeout for CanIf_SetTrcvMode and CanIf_SetControllerMode.
    All mode indications shall be initially asynchron after timeout it will be synchron.
  
Test Object: 
    Module transition
  
Test Precondition: 
    - CanSM is in state S_NOCO
    - Test is executed for a configuration with and one without a transceiver
  
Test Execution: 
    01: Call CanSM_RequestComMode with:
        network := &lt;id&gt; of network 0
        ComM_Mode := COMM_FULL_COMMUNICATION.
    IF transceiver is configured:
        02: VP (CanSM.ASR40.BSM.T_NOCOM_PRE_FULLCOM, CanSM.EB.Transitions.NoTransceiver.3):
            CanSM called only the following API function:
            CanIf_SetTrcvMode with:
            TransceiverMode := CANTRCV_TRCVMODE_NORMAL
        03: Call MainFunction 5 times to simulate timeout
        04: Change TrcvModeIndication to be synchronous
        05: Call the MainFunction of CanSM
        06: VP (CanSM.ASR40.BSM.T_NOCOM_PRE_FULLCOM):
            CanSM called only the following API function after timeout cycle:
            CanIf_SetTrcvMode with:
            TransceiverMode := CANTRCV_TRCVMODE_NORMAL
    ENDIF
    07: VP (CanSM.ASR40.BSMPreFull.T_S_TRCV_NORMAL_S_CC_STOPPED):
        CanSM_MainFunction called only the following API function:
        CanIf_SetControllerMode with:
        ControllerMode := CANIF_CS_STOPPED
    IF transceiver is configured:
        08: Call MainFunction 4 times to simulate timeout
    ELSE:
        09: Call MainFunction 5 times to simulate timeout
    ENDIF
    10: Change ControllerModeIndication to be synchronous
    11: Call the MainFunction of CanSM
    12: VP (CanSM.ASR40.BSMPreFull.T_S_TRCV_NORMAL_S_CC_STOPPED):
        CanSM_MainFunction called the following API function:
        CanIf_SetControllerMode with:
        ControllerMode := CANIF_CS_STOPPED
    13: VP (CanSM.ASR40.BSMPreFull.T_S_CC_STOPPED_S_CC_STARTED):
        CanSM_MainFunction called the following API function:
        CanIf_SetControllerMode with:
        ControllerMode := CANIF_CS_STARTED
    14: VP (CanSM.ASR40.BSM.T_PRE_FULLCOM_FULLCOM):
        CanSM called the following API functions in defined order:
        1. CanIf_SetPduMode with:
           PduModeRequest := CANIF_ONLINE
		2. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_FULL_COMMUNICATION
           Network := 3
        3. ComM_BusSM_ModeIndication with:
           ComMode := COMM_FULL_COMMUNICATION
    IF transceiver is configured:
        15: Restore TrcvModeIndication to be asynchronous
    ENDIF
    16: Restore ControllerModeIndication to be asynchronous
    17: Call CanSM_GetCurrentComMode to read the current CanSM mode
        network := &lt;id&gt; of network 0
    18: VP:
        CanSM_GetCurrentComMode returns E_OK
    19: VP:
        CanSM is in state COMM_FULL_COMMUNICATION
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_NOCOM_PRE_FULLCOM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>175</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMPreFull.T_S_TRCV_NORMAL_S_CC_STOPPED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>227</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMPreFull.T_S_CC_STOPPED_S_CC_STARTED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>229</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_PRE_FULLCOM_FULLCOM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>167</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.Transitions.NoTransceiver.3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>107</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>655</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_FUCO_TIMEOUT_SYNC_2_SingleNetNoTrcv_DET_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_SingleNetNoTrcv_DET_ON/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>732</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct transition of communication mode from
    CANSM_BSM_S_NOCOM to CANSM_BSM_S_FULLCOM when the mode indications are
    synchronous after timeout for CanIf_SetControllerMode from sub state S_CC_STARTED.
    All mode indications shall be initially asynchron after timeout it can be synchron.
  
Test Object: 
    Module initialization
  
Test Precondition: 
    - CanSM is in state S_NOCO
    - Test is executed for a configuration with and one without a transceiver
  
Test Execution: 
    01: Call CanSM_RequestComMode with:
        network := &lt;id&gt; of network 0
        ComM_Mode := COMM_FULL_COMMUNICATION.
    IF transceiver is configured:
        02: VP (CanSM.ASR40.BSM.T_NOCOM_PRE_FULLCOM, CanSM.EB.Transitions.NoTransceiver.3):
            CanSM called only the following API function:
            CanIf_SetTrcvMode with:
            TransceiverMode := CANTRCV_TRCVMODE_NORMAL
        03: Call CanSM_TransceiverModeIndication with:
            TransceiverId := 3
            TransceiverMode := CANTRCV_TRCVMODE_NORMAL
        04: Call the MainFunction of CanSM
    ENDIF
    05: VP (CanSM.ASR40.BSMPreFull.T_S_TRCV_NORMAL_S_CC_STOPPED):
        CanSM_MainFunction called only the following API function:
        CanIf_SetControllerMode with:
        ControllerMode := CANIF_CS_STOPPED
    06: Call CanSM_ControllerModeIndication with:
        ControllerId := 5
        ControllerMode := CANIF_CS_STOPPED
    07: Call MainFunction 5 times to simulate timeout
    08: Change ControllerModeIndication to be synchronous
    09: Call the MainFunction of CanSM
    10: VP (CanSM.ASR40.BSMPreFull.T_S_CC_STOPPED_S_CC_STARTED):
        CanSM_MainFunction called twice the following API function:
        CanIf_SetControllerMode with:
        ControllerMode := CANIF_CS_STARTED
    11: VP (CanSM.ASR40.BSM.T_PRE_FULLCOM_FULLCOM):
        CanSM called the following API functions in defined order:
        1. CanIf_SetPduMode with:
           PduModeRequest := CANIF_ONLINE
	    2. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_FULL_COMMUNICATION
           Network := 3
        3. ComM_BusSM_ModeIndication with:
           ComMode := COMM_FULL_COMMUNICATION
    12: Restore to asynchronous ControllerModeIndication
    13: Call CanSM_GetCurrentComMode to read the current CanSM mode
        network := &lt;id&gt; of network 0
    14: VP:
        CanSM_GetCurrentComMode returns E_OK
    15: VP:
        CanSM is in state COMM_FULL_COMMUNICATION
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_NOCOM_PRE_FULLCOM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>175</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMPreFull.T_S_TRCV_NORMAL_S_CC_STOPPED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>227</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMPreFull.T_S_CC_STOPPED_S_CC_STARTED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>229</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_PRE_FULLCOM_FULLCOM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>167</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.Transitions.NoTransceiver.3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>107</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>656</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_NOCO_FUCO_FAILED_1_SingleNetNoTrcv_DET_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_SingleNetNoTrcv_DET_ON/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>892</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the transition of communication mode from
    CANSM_BSM_S_NOCOM to CANSM_BSM_S_FULLCOM
    if the mode request timeout expires during requesting transceiver
    mode Normal and the maximum number of mode request repetitions is reached.
  
Test Object: 
    Module initialization
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_NOCOM
  
Test Execution: 
    01: Call CanSM_RequestComMode with:
        network := &lt;id&gt; of network 0
        ComM_Mode := COMM_FULL_COMMUNICATION.
    02: Call the MainFunction of CanSM 10 times
    IF transceiver is configured
        03: VP (CanSM.ASR40.BSMPreFull.T_S_TRCV_NORMAL_S_TRCV_NORMAL):
            Verify if No API service except the retry of CanIf_SetTrcvMode was called
    ELSE
        03: VP (CanSM.ASR40.BSMPreFull.T_S_CC_STOPPED_S_CC_STOPPED):
            Verify if No API service except the retry of CanIf_SetControllerMode was called
    ENDIF
    04: Call the MainFunction of CanSM
    05: VP (CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.NoPn.1,
            CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.NoPn.2):
        If development error detection is enabled,
        CanSM calls Det_ReportError with:
        ErrorId: CANSM_E_MODE_REQUEST_TIMEOUT
    06: VP (CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.NoPn.1,
            CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.NoPn.2):
        CanSM called the following API function:
        CanIf_SetControllerMode with:
        ControllerMode := CANIF_CS_STOPPED
        ControllerId := 5
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSMPreFull.T_S_TRCV_NORMAL_S_TRCV_NORMAL</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>228</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMPreFull.T_S_CC_STOPPED_S_CC_STOPPED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>230</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.NoPn.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>176</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.NoPn.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>178</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>657</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_NOCO_FUCO_FAILED_2_SingleNetNoTrcv_DET_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_SingleNetNoTrcv_DET_ON/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>999</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the transition of communication mode from
    CANSM_BSM_S_NOCOM (state NO COmmunication) to CANSM_BSM_S_FULLCOM (state FUll COmmunication)
    if the mode request timeout expires during requesting controller
    mode Stopped and the maximum number of mode request repetitions is reached.
  
Test Object: 
    Module initialization
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_NOCOM
  
Test Execution: 
    01: Call CanSM_RequestComMode with:
        network := &lt;id&gt; of network 0
        ComM_Mode := COMM_FULL_COMMUNICATION.
    IF transceiver is configured
        02: Call CanSM_TransceiverModeIndication with:
            TransceiverId := 3
            TransceiverMode := CANTRCV_TRCVMODE_NORMAL
    ENDIF
    03: Call the MainFunction of CanSM 10 times
    04: VP (CanSM.ASR40.BSMPreFull.T_S_CC_STOPPED_S_CC_STOPPED):
        CanIf_SetControllerMode was called two times (once as initial call and once
        because of a CanSMModeRequestRepetitionMax of 1)
    05: VP:
        Verify if CanSM did not call Det_ReportError
    06: Call the MainFunction of CanSM
    07: VP (CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.NoPn.2):
        If development error detection is enabled,
        CanSM called Det_ReportError with:
        ErrorId: CANSM_E_MODE_REQUEST_TIMEOUT
    08: VP (CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.NoPn.2):
        CanSM called the following API function:
        CanIf_SetControllerMode with:
        ControllerMode := CANIF_CS_STOPPED
        ControllerId := 5
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSMPreFull.T_S_CC_STOPPED_S_CC_STOPPED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>230</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.NoPn.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>178</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>658</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_NOCO_FUCO_FAILED_3_SingleNetNoTrcv_DET_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_SingleNetNoTrcv_DET_ON/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>1106</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the transition of communication mode from
    CANSM_BSM_S_NOCOM (state NO COmmunication) to CANSM_BSM_S_FULLCOM (state FUll COmmunication)
    if the mode request timeout expires during requesting controller
    mode Started and the maximum number of mode request repetitions is reached.
  
Test Object: 
    Module initialization
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_NOCOM
  
Test Execution: 
    01: Call CanSM_RequestComMode with:
        network := &lt;id&gt; of network 0
        ComM_Mode := COMM_FULL_COMMUNICATION.
    IF transceiver is configured
        02: Call CanSM_TransceiverModeIndication with:
            TransceiverId := 3
            TransceiverMode := CANTRCV_TRCVMODE_NORMAL
    ENDIF
    03: Call the MainFunction of CanSM
    04: Call CanSM_ControllerModeIndication with:
        ControllerId := 5
        ControllerMode := CANIF_CS_STOPPED
    05: Call the MainFunction of CanSM 10 times
    06: VP (CanSM.ASR40.BSMPreFull.T_S_CC_STARTED_S_CC_STARTED):
        CanIf_SetControllerMode was called two times (once as initial call and once
        because of a CanSMModeRequestRepetitionMax of 1)
    07: VP:
        Verify if CanSM did not call Det_ReportError
    08: Call the MainFunction of CanSM
    09: VP (CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.NoPn.3):
        If Development error detection is enabled,
        CanSM calls Det_ReportError with:
        ErrorId: CANSM_E_MODE_REQUEST_TIMEOUT
    10: VP (CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.NoPn.3):
        CanSM called the following API function:
        CanIf_SetControllerMode with:
        ControllerMode := CANIF_CS_STOPPED
        ControllerId := 5
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSMPreFull.T_S_CC_STARTED_S_CC_STARTED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>231</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.NoPn.3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>180</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>659</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_NOCO_FUCO_TRCV_IND_SingleNetNoTrcv_DET_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_SingleNetNoTrcv_DET_ON/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>1221</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks behavior of CanSM_TransceiverModeIndication if called
    with a wrong transceiver mode after a mode request.
    In test configurations without transceiver support it just performs a
    transition to FULL communication.
  
Test Object: 
    Module initialization
  
Test Precondition: 
    - CanSM is in state S_NOCO
  
Test Execution: 
    01: Call CanSM_RequestComMode with:
        network := &lt;id&gt; of network 0
        ComM_Mode := COMM_FULL_COMMUNICATION.
    IF transceiver is configured
        02: VP:
            CanSM called the following API function:
            CanIf_SetTrcvMode with:
            TransceiverMode := CANTRCV_TRCVMODE_NORMAL
        03: Call CanSM_TransceiverModeIndication with:
            TransceiverId := 3
            TransceiverMode := CANTRCV_TRCVMODE_STANDBY (= wrong mode indication)
        04: Call the MainFunction of CanSM 5 times (once to apply the indication,
            confer CanSM.Design.20122, and 4 times as long as timer does not elapse)
        05: VP:
            Main function does not not call any API function
        06: Call MainFunction to elapse timer
        07: VP (CanSM.ASR40.BSMPreFull.T_S_TRCV_NORMAL_S_CC_STOPPED):
            CanSM repeats its request and calls:
            CanIf_SetTrcvMode with:
            TransceiverMode := CANTRCV_TRCVMODE_NORMAL
        08: Call CanSM_TransceiverModeIndication with:
            TransceiverId := 3
            TransceiverMode := CANTRCV_TRCVMODE_NORMAL
        09: Call the MainFunction of CanSM
    ENDIF
    10: VP if CanSM called the following API function:
        CanIf_SetControllerMode with:
        ControllerMode := CANIF_CS_STOPPED
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSMPreFull.T_S_TRCV_NORMAL_S_CC_STOPPED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>227</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>660</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_NOCO_FUCO_CC_IND_SingleNetNoTrcv_DET_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_SingleNetNoTrcv_DET_ON/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>1336</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks behavior of CanSM_ControllerModeIndication if indication
    a wrong controller mode after a mode request.
  
Test Object: 
    Module initialization
  
Test Precondition: 
    - CanSM is in state S_NOCO
  
Test Execution: 
    IF transceiver is configured
        01: Prepare the CanIf stub to indicate the requested transceiver mode
            transition from inside the context of CanIf_SetTrcvMode.
    ENDIF
    02: Call CanSM_RequestComMode with:
        network := &lt;id&gt; of network 0
        ComM_Mode := COMM_FULL_COMMUNICATION.
    03: VP:
        CanSM called the following API functions in defined order:
        IF transceiver is configured
            1. CanIf_SetTrcvMode with TransceiverMode := CANTRCV_TRCVMODE_NORMAL
        ENDIF
        2. CanIf_SetControllerMode with ControllerMode := CANIF_CS_STOPPED
    04: Call CanSM_ControllerModeIndication with:
        ControllerId := 5
        ControllerMode := CANIF_CS_STARTED
    05: Call the MainFunction of CanSM
    06: VP (CanSM.ASR40.BSMPreFull.T_S_CC_STOPPED_S_CC_STARTED):
        CanSM called no API function
    07: Call CanSM_ControllerModeIndication with:
        ControllerId := 5
        ControllerMode := CANIF_CS_STOPPED
    08: Call the MainFunction of CanSM
    09: VP:
        CanSM called the following API function:
        CanIf_SetControllerMode with:
        ControllerMode := CANIF_CS_STARTED
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSMPreFull.T_S_CC_STOPPED_S_CC_STARTED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>229</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>661</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_SICO_NOCO_SYNC_SingleNetNoTrcv_DET_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_SingleNetNoTrcv_DET_ON/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>1451</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct transition of communication mode from
    S_SICO (state SIlent COmmunication) to S_NOCO (state NO COmmunication).
    All mode indications shall be synchron.
  
Test Object: 
    Mode transition
  
Test Precondition: 
    - CanSM is in state S_SICO
    - Test is executed for a configuration with and one without a transceiver
  
Test Execution: 
    IF transceiver is configured
        01: Prepare the CanIf stub to indicate the requested transceiver mode
            transition from inside the context of CanIf_SetTrcvMode.
    ENDIF
    02: Prepare the CanIf stub to indicate the requested controller mode
        transition from inside the context of CanIf_SetControllerMode.
    03: Call CanSM_RequestComMode with:
        network := &lt;id&gt; of network 0
        ComM_Mode := COMM_NO_COMMUNICATION.
    04: VP:
        CanSM_RequestComMode returned E_OK
    05: VP:
        CanSM called the following API function in defined order:
        1. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_NO_COMMUNICATION
           Network := 3
           (CanSM.ASR40.BSM.T_SILENTCOM_PRE_NOCOM.NoPn)
        2. CanIf_SetControllerMode with:
           ControllerMode := CANIF_CS_STOPPED
           ControllerId := 5
           (CanSM.ASR40.BSM.T_SILENTCOM_PRE_NOCOM.NoPn)
        3. CanIf_SetControllerMode with:
           ControllerMode := CANIF_CS_SLEEP
           ControllerId := 5
           (CanSM.ASR40.BSMDeInitNoPn.T_S_CC_STOPPED_S_CC_SLEEP)
        IF transceiver is configured
            4. CanIf_SetTrcvMode with:
               TransceiverMode := CANTRCV_TRCVMODE_NORMAL
               TransceiverId := 3
               (CanSM.ASR40.BSMDeInitNoPn.T_S_CC_SLEEP_S_TRCV_NORMAL)
            5. CanIf_SetTrcvMode with:
               TransceiverMode := CANTRCV_TRCVMODE_STANDBY
               TransceiverId := 3
               (CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_NORMAL_S_TRCV_STANDBY)
               (CanSM.EB.Transitions.NoTransceiver.2)
        ENDIF
        7. ComM_BusSM_ModeIndication with:
           ComMode := COMM_NO_COMMUNICATION
           (CanSM.ASR40.BSM.T_PRE_NOCOM_NOCOM.NoPn.1)
    06: Call CanSM_GetCurrentComMode to read the current CanSM mode
        network := &lt;id&gt; of network 0
    07: VP:
        CanSM_GetCurrentComMode returns E_OK
    08: VP:
        CanSM is in state COMM_NO_COMMUNICATION
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_SILENTCOM_PRE_NOCOM.NoPn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>189</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_CC_STOPPED_S_CC_SLEEP</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>216</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_CC_SLEEP_S_TRCV_NORMAL</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>219</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_NORMAL_S_TRCV_STANDBY</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>222</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_PRE_NOCOM_NOCOM.NoPn.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>191</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.Transitions.NoTransceiver.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>106</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>662</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_SICO_NOCO_ASYNC_SingleNetNoTrcv_DET_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_SingleNetNoTrcv_DET_ON/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>1599</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct transition of communication mode from
    CANSM_BSM_S_SILENTCOM to CANSM_BSM_S_NOCOM and also test the self transition
    for all states when CanSM is in CANSM_BSM_DeinitPnNotSupportedProceed.
    All mode indications shall be asynchron.
  
Test Object: 
    Mode transition
    Self transition
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_SILENTCOM
    - Test is executed for a configuration with and one without a transceiver
  
Test Execution: 
    01: Call CanSM_RequestComMode with:
        network := &lt;id&gt; of network 0
        ComM_Mode := COMM_NO_COMMUNICATION.
    02: VP (CanSM.ASR40.BSM.T_NOT_INITIALIZED_PRE_NOCOM.NoPn):
        CanSM called the following API function in defined order:
        1. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_NO_COMMUNICATION
           Network := 3
        2. CanIf_SetControllerMode with:
           ControllerMode := CANIF_CS_STOPPED
           ControllerId := 5
    03: Call main function to expire CanSMModeRequestRepetitionTime
    04: VP (CanSM.ASR40.BSMDeInitNoPn.T_S_CC_STOPPED_S_CC_STOPPED.1):
        CanSM called only the following API function:
        CanIf_SetControllerMode with:
        ControllerMode := CANIF_CS_STOPPED
    05: Call CanSM_ControllerModeIndication with:
        ControllerId := 5
        ControllerMode := CANIF_CS_STOPPED
    06: Call the MainFunction of CanSM
    07: VP (CanSM.ASR40.BSMDeInitNoPn.T_S_CC_STOPPED_S_CC_SLEEP):
        CanSM called only the following API function:
        CanIf_SetControllerMode with:
        ControllerMode := CANIF_CS_SLEEP
    08: Call main function to expire CanSMModeRequestRepetitionTime
    09: VP (CanSM.ASR40.BSMDeInitNoPn.T_S_CC_SLEEP_S_CC_SLEEP):
        CanSM called only the following API function:
        CanIf_SetControllerMode with:
        ControllerMode := CANIF_CS_SLEEP
    10: Call CanSM_ControllerModeIndication with:
        ControllerId := 5
        ControllerMode := CANIF_CS_SLEEP
    11: Call the MainFunction of CanSM
    IF transceiver is configured
        12: VP (CanSM.ASR40.BSMDeInitNoPn.T_S_CC_SLEEP_S_TRCV_NORMAL):
            CanSM called only the following API function:
            CanIf_SetTrcvMode with:
            TransceiverMode := CANTRCV_TRCVMODE_NORMAL
        13: Call main function to expire CanSMModeRequestRepetitionTime
        14: VP (CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_NORMAL_S_TRCV_NORMAL):
            CanSM called only the following API function:
            CanIf_SetTrcvMode with:
            TransceiverMode := CANTRCV_TRCVMODE_NORMAL
        15: Call CanSM_TransceiverModeIndication with:
            TransceiverId := 3
            TransceiverMode := CANTRCV_TRCVMODE_NORMAL
        16: Call the MainFunction of CanSM
        17: VP (CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_NORMAL_S_TRCV_STANDBY):
            CanSM called only the following API function:
            CanIf_SetTrcvMode with:
            TransceiverMode := CANTRCV_TRCVMODE_STANDBY
        18: Call main function to expire CanSMModeRequestRepetitionTime
        19: VP (CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_STANDBY_S_TRCV_STANDBY):
            CanSM called only the following API function:
            CanIf_SetTrcvMode with:
            TransceiverMode := CANTRCV_TRCVMODE_STANDBY
        20: Call CanSM_TransceiverModeIndication with:
            TransceiverId := 3
            TransceiverMode := CANTRCV_TRCVMODE_STANDBY
        21: Call the MainFunction of CanSM
    ENDIF
    22: VP (CanSM.ASR40.BSM.T_PRE_NOCOM_NOCOM.NoPn.1):
        CanSM called the following API function:
        ComM_BusSM_ModeIndication with:
           ComMode := COMM_NO_COMMUNICATION
    23: Call CanSM_GetCurrentComMode to read the current CanSM mode
        network := &lt;id&gt; of network 0
    24: VP:
        CanSM_GetCurrentComMode return E_OK
    25: VP:
        CanSM is in state COMM_NO_COMMUNICATION
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_NOT_INITIALIZED_PRE_NOCOM.NoPn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>195</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_CC_STOPPED_S_CC_STOPPED.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>217</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_CC_STOPPED_S_CC_SLEEP</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>216</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_CC_SLEEP_S_CC_SLEEP</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>220</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_CC_SLEEP_S_TRCV_NORMAL</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>219</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_NORMAL_S_TRCV_NORMAL</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>223</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_NORMAL_S_TRCV_STANDBY</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>222</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_STANDBY_S_TRCV_STANDBY</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>225</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_PRE_NOCOM_NOCOM.NoPn.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>191</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>663</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_NOCO_TIMEOUT_SYNC_1_SingleNetNoTrcv_DET_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_SingleNetNoTrcv_DET_ON/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>1822</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct transition of communication mode from
    CANSM_BSM_S_SILENTCOM to CANSM_BSM_S_NOCOM when the mode indications are
    synchronous after timeout for CanIf_SetTrcvMode and CanIf_SetControllerMode.
    All mode indications shall be initially asynchron after timeout it will be synchron.
  
Test Object: 
    Mode transition
    Self transition
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_SILENTCOM
    - Test is executed for a configuration with and one without a transceiver
  
Test Execution: 
    01: Call CanSM_RequestComMode with:
        network := &lt;id&gt; of network 0
        ComM_Mode := COMM_NO_COMMUNICATION.
    02: VP (CanSM.ASR40.BSM.T_NOT_INITIALIZED_PRE_NOCOM.NoPn):
        CanSM called the following API function in defined order:
        1. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_NO_COMMUNICATION
           Network := 3
        2. CanIf_SetControllerMode with:
           ControllerMode := CANIF_CS_STOPPED
           ControllerId := 5
    03: Call main function to expire CanSMModeRequestRepetitionTime
    04: Change ControllerModeIndication to be synchronous
    05: Call the MainFunction of CanSM
    06: VP (CanSM.ASR40.BSMDeInitNoPn.T_S_CC_STOPPED_S_CC_STOPPED.1,
            CanSM.ASR40.BSMDeInitNoPn.T_S_CC_STOPPED_S_CC_SLEEP):
        CanSM called the following API function in defined order:
        1.  CanIf_SetControllerMode with:
            ControllerMode := CANIF_CS_STOPPED
        2.  CanIf_SetControllerMode with:
            ControllerMode := CANIF_CS_SLEEP
    IF transceiver is configured
        07: Call main function CanSMModeRequestRepetitionTime -1 times
        08: Change TransceiverModeIndication to be synchronous
        09: Call the MainFunction of CanSM
        10: VP (CanSM.ASR40.BSMDeInitNoPn.T_S_CC_SLEEP_S_TRCV_NORMAL,
                CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_NORMAL_S_TRCV_NORMAL,
                CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_NORMAL_S_TRCV_STANDBY):
            CanSM called the following API function in defined order:
            1.  CanIf_SetTrcvMode with:
                TransceiverMode := CANTRCV_TRCVMODE_NORMAL
            2.  CanIf_SetTrcvMode with:
                TransceiverMode := CANTRCV_TRCVMODE_NORMAL
            3.  CanIf_SetTrcvMode with:
                TransceiverMode := CANTRCV_TRCVMODE_STANDBY
    ENDIF
    11: VP (CanSM.ASR40.BSM.T_PRE_NOCOM_NOCOM.NoPn.1):
        CanSM called the following API function:
        ComM_BusSM_ModeIndication with:
           ComMode := COMM_NO_COMMUNICATION
    IF transceiver is configured:
        12: Restore TrcvModeIndication to be asynchronous
    ENDIF
    13: Restore ControllerModeIndication to be asynchronous
    14: Call CanSM_GetCurrentComMode to read the current CanSM mode
        network := &lt;id&gt; of network 0
    15: VP:
        CanSM_GetCurrentComMode return E_OK
    16: VP:
        CanSM is in state COMM_NO_COMMUNICATION
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_NOT_INITIALIZED_PRE_NOCOM.NoPn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>195</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_CC_STOPPED_S_CC_STOPPED.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>217</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_CC_STOPPED_S_CC_SLEEP</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>216</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_CC_SLEEP_S_TRCV_NORMAL</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>219</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_NORMAL_S_TRCV_NORMAL</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>223</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_NORMAL_S_TRCV_STANDBY</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>222</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_PRE_NOCOM_NOCOM.NoPn.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>191</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>664</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_NOCO_TIMEOUT_SYNC_2_SingleNetNoTrcv_DET_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_SingleNetNoTrcv_DET_ON/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>1994</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct transition of communication mode from
    CANSM_BSM_S_SILENTCOM to CANSM_BSM_S_NOCOM when the mode indications are
    synchronous after timeout for CanIf_SetTrcvMode from sub state S_TRCV_STANDBY
    and for CanIf_SetControllerMode from substate S_CC_SLEEP.
    All mode indications shall be initially asynchron after timeout it will be synchron.
  
Test Object: 
    Mode transition
    Self transition
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_SILENTCOM
    - Test is executed for a configuration with and one without a transceiver
  
Test Execution: 
    01: Call CanSM_RequestComMode with:
        network := &lt;id&gt; of network 0
        ComM_Mode := COMM_NO_COMMUNICATION.
    02: VP (CanSM.ASR40.BSM.T_NOT_INITIALIZED_PRE_NOCOM.NoPn):
        CanSM called the following API function in defined order:
        1. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_NO_COMMUNICATION
           Network := 3
        2. CanIf_SetControllerMode with:
           ControllerMode := CANIF_CS_STOPPED
           ControllerId := 5
    03: Call CanSM_ControllerModeIndication with after a MainFunction call:
        ControllerId := 5
        ControllerMode := CANIF_CS_STOPPED
    04: Call the MainFunction of CanSM to process the indication
    05: Call main function CanSMModeRequestRepetitionTime - 1 times
    06: Change ControllerModeIndication to be synchronous
    07: Call the MainFunction of CanSM
    08: VP (CanSM.ASR40.BSMDeInitNoPn.T_S_CC_STOPPED_S_CC_SLEEP,
            CanSM.ASR40.BSMDeInitNoPn.T_S_CC_SLEEP_S_CC_SLEEP):
        CanSM called twice the following API function:
        CanIf_SetControllerMode with:
        ControllerMode := CANIF_CS_SLEEP
    IF transceiver is configured
        09: VP (CanSM.ASR40.BSMDeInitNoPn.T_S_CC_SLEEP_S_TRCV_NORMAL):
            CanSM called only the following API function:
            CanIf_SetTrcvMode with:
            TransceiverMode := CANTRCV_TRCVMODE_NORMAL
        10: Call CanSM_TransceiverModeIndication after a MainFunction call with:
            TransceiverId := 3
            TransceiverMode := CANTRCV_TRCVMODE_NORMAL
        11: Call the MainFunction of CanSM to process the indication
        12: Call main function CanSMModeRequestRepetitionTime - 1 times
        13: Change TransceiverModeIndication to be synchronous
        14: Call the MainFunction of CanSM
        15: VP (CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_NORMAL_S_TRCV_STANDBY,
                CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_STANDBY_S_TRCV_STANDBY):
            CanSM called twice the following API function:
            CanIf_SetTrcvMode with:
            TransceiverMode := CANTRCV_TRCVMODE_STANDBY
    ENDIF
    16: VP (CanSM.ASR40.BSM.T_PRE_NOCOM_NOCOM.NoPn.1):
        CanSM called the following API function:
        ComM_BusSM_ModeIndication with:
           ComMode := COMM_NO_COMMUNICATION
    IF transceiver is configured:
        17: Restore TrcvModeIndication to be asynchronous
    ENDIF
    18: Restore ControllerModeIndication to be asynchronous
    19: Call CanSM_GetCurrentComMode to read the current CanSM mode
        network := &lt;id&gt; of network 0
    20: VP:
        CanSM_GetCurrentComMode return E_OK
    21: VP:
        CanSM is in state COMM_NO_COMMUNICATION
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_NOT_INITIALIZED_PRE_NOCOM.NoPn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>195</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_CC_STOPPED_S_CC_SLEEP</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>216</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_CC_SLEEP_S_CC_SLEEP</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>220</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_CC_SLEEP_S_TRCV_NORMAL</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>219</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_NORMAL_S_TRCV_STANDBY</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>222</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_STANDBY_S_TRCV_STANDBY</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>225</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_PRE_NOCOM_NOCOM.NoPn.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>191</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>665</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_REPEAT_MAX_DEINIT_NOPN_1_SingleNetNoTrcv_DET_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_SingleNetNoTrcv_DET_ON/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>2187</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks if DET is reported when triggered with T_REPEAT_MAX in state S_CC_STOPPED
    of CANSM_BSM_DeinitPnNotSupportedProceed.
    All mode indications shall be asynchron.
  
Test Object: 
    T_REPEAT_MAX
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_SILENTCOM
  
Test Execution: 
    01: Call CanSM_RequestComMode with:
        network := &lt;id&gt; of network 0
        ComM_Mode := COMM_NO_COMMUNICATION.
    02: VP:
        CanSM called the following API function in defined order:
        1. BswM_CanSM_CurrentState
        2. CanIf_SetControllerMode with:
           ControllerMode := CANIF_CS_STOPPED
    03: Call the MainFunction of CanSM 10 times
    04: VP (CanSM.ASR40.BSMDeInitNoPn.T_S_CC_STOPPED_S_CC_STOPPED.1):
        CanIf_SetControllerMode was called second time with controller mode CANIF_CS_STOPPED
        (once as initial call and once because of a CanSMModeRequestRepetitionMax of 1)
    05: VP:
        Verify if CanSM did not call Det_ReportError
    06: Call the MainFunction of CanSM
    07: VP (CanSM.ASR40.BSMDeInitNoPn.T_S_CC_STOPPED_S_CC_STOPPED.2):
        If development error detection is enabled,
        CanSM called Det_ReportError with:
        ErrorId: CANSM_E_MODE_REQUEST_TIMEOUT
    08: VP (CanSM.ASR40.BSMDeInitNoPn.T_S_CC_STOPPED_S_CC_STOPPED.2):
        CanSM called CanIf_SetControllerMode with:
        ControllerMode := CANIF_CS_STOPPED
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_CC_STOPPED_S_CC_STOPPED.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>217</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_CC_STOPPED_S_CC_STOPPED.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>218</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>666</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_REPEAT_MAX_DEINIT_NOPN_2_SingleNetNoTrcv_DET_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_SingleNetNoTrcv_DET_ON/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>2291</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks if DET is reported when triggered with T_REPEAT_MAX in state S_CC_SLEEP
    of CANSM_BSM_DeinitPnNotSupportedProceed.
    All mode indications shall be asynchron.
  
Test Object: 
    T_REPEAT_MAX
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_SILENTCOM
  
Test Execution: 
    01: Call CanSM_RequestComMode with:
        network := &lt;id&gt; of network 0
        ComM_Mode := COMM_NO_COMMUNICATION.
    02: Call CanSM_ControllerModeIndication with:
        ControllerId := 5
        ControllerMode := CANIF_CS_STOPPED
    03: Call the MainFunction of CanSM 10 times
    04: VP (CanSM.ASR40.BSMDeInitNoPn.T_S_CC_SLEEP_S_CC_SLEEP):
        CanIf_SetControllerMode was called two times (once as initial call and once
        because of a CanSMModeRequestRepetitionMax of 1)
    05: VP:
        Verify if CanSM did not call Det_ReportError
    06: Call the MainFunction of CanSM
    07: VP (CanSM.ASR40.BSMDeInitNoPn.T_S_CC_SLEEP_S_CC_STOPPED):
        If development error detection is enabled,
        CanSM called Det_ReportError with:
        ErrorId: CANSM_E_MODE_REQUEST_TIMEOUT
    08: VP (CanSM.ASR40.BSMDeInitNoPn.T_S_CC_SLEEP_S_CC_STOPPED):
        CanSM called CanIf_SetControllerMode with:
        ControllerMode := CANIF_CS_STOPPED
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_CC_SLEEP_S_CC_SLEEP</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>220</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_CC_SLEEP_S_CC_STOPPED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>221</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>667</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_REPEAT_MAX_DEINIT_NOPN_3_SingleNetNoTrcv_DET_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_SingleNetNoTrcv_DET_ON/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>2392</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks if DET is reported when triggered with T_REPEAT_MAX in state S_TRCV_NORMAL
    of CANSM_BSM_DeinitPnNotSupportedProceed.
    All mode indications shall be asynchron.
  
Test Object: 
    T_REPEAT_MAX
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_SILENTCOM
    - Test is executed only for a configuration with a transceiver
      for configuration without transceiver it returns SUCCESS as default
  
Test Execution: 
    IF transceiver is configured
      01: Call CanSM_RequestComMode with:
          network := &lt;id&gt; of network 0
          ComM_Mode := COMM_NO_COMMUNICATION.
      02: Call CanSM_ControllerModeIndication with:
          ControllerId := 5
          ControllerMode := CANIF_CS_STOPPED
      03: Call MainFunction once to process the indication and
          call CanSM_ControllerModeIndication with:
          ControllerId := 5
          ControllerMode := CANIF_CS_SLEEP
      04: Call the MainFunction of CanSM 10 times
      05: VP (CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_NORMAL_S_TRCV_NORMAL):
          CanIf_SetTrcvMode was called twice (once as initial call and once
          because of a CanSMModeRequestRepetitionMax of 1)
      06: VP:
          Verify if CanSM did not call Det_ReportError
      07: Call the MainFunction of CanSM
      08: VP (CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_NORMAL_S_CC_STOPPED):
          If development error detection is enabled,
          CanSM called Det_ReportError with:
          ErrorId: CANSM_E_MODE_REQUEST_TIMEOUT
      09: VP (CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_NORMAL_S_CC_STOPPED):
          CanSM called CanIf_SetControllerMode with:
          ControllerMode := CANIF_CS_STOPPED
    ENDIF
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_NORMAL_S_TRCV_NORMAL</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>223</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_NORMAL_S_CC_STOPPED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>224</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>668</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_REPEAT_MAX_DEINIT_NOPN_4_SingleNetNoTrcv_DET_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_SingleNetNoTrcv_DET_ON/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>2507</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks if DET is reported when triggered with T_REPEAT_MAX in state S_TRCV_STANDBY
    of CANSM_BSM_DeinitPnNotSupportedProceed.
    All mode indications shall be asynchron.
  
Test Object: 
    T_REPEAT_MAX
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_SILENTCOM
    - Test is executed only for a configuration with a transceiver
      for configuration without transceiver it returns SUCCESS as default
  
Test Execution: 
    IF transceiver is configured
      01: Call CanSM_RequestComMode with:
          network := &lt;id&gt; of network 0
          ComM_Mode := COMM_NO_COMMUNICATION.
      02: Call CanSM_ControllerModeIndication with:
          ControllerId := 5
          ControllerMode := CANIF_CS_STOPPED
      03: Call MainFunction once to process the indication and
          call CanSM_ControllerModeIndication with:
          ControllerId := 5
          ControllerMode := CANIF_CS_SLEEP
      04: Call MainFunction once to process the indication and
          call CanSM_TransceiverModeIndication with:
            TransceiverId := 3
            TransceiverMode := CANTRCV_TRCVMODE_NORMAL
      05: Call the MainFunction of CanSM 10 times
      06: VP (CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_STANDBY_S_TRCV_STANDBY):
          CanIf_SetTrcvMode was called twice (once as initial call and once
          because of a CanSMModeRequestRepetitionMax of 1)
      07: VP:
          Verify if CanSM did not call Det_ReportError
      08: Call the MainFunction of CanSM
      09: VP (CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_STANDBY_S_CC_STOPPED):
          If development error detection is enabled,
          CanSM called Det_ReportError with:
          ErrorId: CANSM_E_MODE_REQUEST_TIMEOUT
      10: VP (CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_STANDBY_S_CC_STOPPED):
          CanSM called CanIf_SetControllerMode with:
          ControllerMode := CANIF_CS_STOPPED
    ENDIF
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_STANDBY_S_TRCV_STANDBY</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>225</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_STANDBY_S_CC_STOPPED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>226</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>669</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_SICO_FUCO_SingleNetNoTrcv_DET_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_SingleNetNoTrcv_DET_ON/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>2632</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct transition of communication mode from
    CANSM_BSM_S_SILENTCOM to CANSM_BSM_S_FULLCOM.
  
Test Object: 
    Mode transition
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_SILENTCOM
  
Test Execution: 
    01: Call CanSM_RequestComMode with:
        network := &lt;id&gt; of network 0
        ComM_Mode := COMM_FULL_COMMUNICATION.
    02: VP (CanSM.SWS_CanSM_00369):
        CanSM_RequestComMode returned E_OK
    03: VP (CanSM.ASR40.BSM.T_SILENTCOM_FULLCOM):
        CanSM called the following API function in defined order:
        1. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_FULL_COMMUNICATION
           Network := 3
        2. CanIf_SetPduMode with:
           PduModeRequest := CANIF_ONLINE
        3. ComM_BusSM_ModeIndication with:
           ComMode := COMM_FULL_COMMUNICATION
    04: Call CanSM_GetCurrentComMode to read the current CanSM mode
        network := &lt;id&gt; of network 0
    05: VP:
        CanSM_GetCurrentComMode return E_OK
    06: VP:
        CanSM is in state COMM_FULL_COMMUNICATION
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_SILENTCOM_FULLCOM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>174</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00369</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>315</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>670</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_CHANGE_BR_REQUEST_SYNC_SingleNetNoTrcv_DET_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_SingleNetNoTrcv_DET_ON/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>2719</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test shall verify the transition T_CHANGE_BR_REQUEST from state S_NO_BUS_OFF of
    CANSM_BSM_S_FULLCOM to S_CC_STOPPED of CANSM_BSM_S_CHANGE_BAUDRATE with following constraints:
    - CanSM_ControllerModeIndications() are synchronous
    - No CanSM_RequestComMode() call while processing
  
Test Object: 
    Mode transition
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_FULLCOM; substate S_NO_BUS_OFF
  
Test Execution: 
    01: Enable synchronous controller mode indication. Effect: CanSM_ControllerModeIndication() will
        called in the callout of CanIf_SetControllerMode().
    02: Trigger transition T_CHANGE_BR_REQUEST (S_NO_BUS_OFF to S_CC_STOPPED). Call
        CanSM_SetBaudrate() with new baud rate for corresponding CAN network successfully.
    03 VP(CanSM.ASR41.SWS_CanSM_00503): API shall return E_OK.
    04: VP(CanSM.ASR40.BSM.T_FULLCOM_CHANGE_BAUDRATE): Verify that effect E_CHANGE_BR_BSWM_MODE is
        executed. BswM_CanSM_CurrentState() is called with CurrentState set to CANIF_CS_STOPPED for
        the corresponding CAN network.
    05: VP(CanSM.ASR40.BSM.T_FULLCOM_CHANGE_BAUDRATE): Verify that do action DO_SET_CC_MODE_STOPPED
        is executed. CanIf_SetControllerMode() is called with controller mode CANIF_CS_STOPPED for
        the corresponding CAN network.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_FULLCOM_CHANGE_BAUDRATE</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>170</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR41.SWS_CanSM_00503</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>91</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>671</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_CC_STOPPED_INDICATED_CHANGE_BR_SYNC_SingleNetNoTrcv_DET_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_SingleNetNoTrcv_DET_ON/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>2811</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test shall verify the transition T_CC_STOPPED_INDICATED from state S_CC_STOPPED to
    S_CC_STARTED within CANSM_BSM_S_CHANGE_BAUDRATE with following constraints:
    - CanSM_ControllerModeIndications() are synchronous
    - No CanSM_RequestComMode() call while processing
  
Test Object: 
    Mode transition
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_FULLCOM; substate S_NO_BUS_OFF
  
Test Execution: 
    01: Enable synchronous controller mode indication. Effect: CanSM_ControllerModeIndication() will
        called in the callout of CanIf_SetControllerMode().
    02: Trigger transition T_CHANGE_BR_REQUEST (S_NO_BUS_OFF to S_CC_STOPPED). Call
        CanSM_SetBaudrate() with new baud rate for corresponding CAN network.
    03: VP(CanSM.ASR40.BSMBr.T_S_CC_STOPPED_S_CC_STARTED) Verify that do action
        DO_SET_CC_MODE_STOPPED is executed. CanIf_SetControllerMode() is called with controller mode
        CANIF_CS_STOPPED for the corresponding CAN network which will trigger the transition
        T_CC_STOPPED_INDICATED (S_CC_STOPPED to S_CC_STARTED) in its callout function.
    04: VP(CanSM.ASR40.BSMBr.T_S_CC_STOPPED_S_CC_STARTED): Verify that effect E_CHANGE_BAUDRATE is
        executed. ComM_BusSM_ModeIndication() is called with ComMode set to COMM_NO_COMMUNICATION.
    05: VP(CanSM.ASR40.BSMBr.T_S_CC_STOPPED_S_CC_STARTED): Verify that effect E_CHANGE_BAUDRATE is
        executed. CanIf_SetBaudrate() is called with new baud rate for corresponding CAN network.
    06: VP(CanSM.ASR40.BSMBr.T_S_CC_STOPPED_S_CC_STARTED): Verify that do action
        DO_SET_CC_MODE_STARTED is executed. CanIf_SetControllerMode is called with controller mode
        CANIF_CS_STARTED for the corresponding CAN network.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSMBr.T_S_CC_STOPPED_S_CC_STARTED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>247</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>672</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_CC_STOPPED_INDICATED_CHANGE_BR_ASYNC_SingleNetNoTrcv_DET_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_SingleNetNoTrcv_DET_ON/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>2914</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test shall verify the transition T_CC_STOPPED_INDICATED from state S_CC_STOPPED to
    S_CC_STARTED within CANSM_BSM_S_CHANGE_BAUDRATE with following constraints:
    - CanSM_ControllerModeIndications() are asynchronous
    - No CanSM_RequestComMode() call while processing
  
Test Object: 
    Mode transition
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_FULLCOM; substate S_NO_BUS_OFF
  
Test Execution: 
    01: Disable synchronous controller mode indication.
    02: Trigger transition T_CHANGE_BR_REQUEST (S_NO_BUS_OFF to S_CC_STOPPED). Call
        CanSM_SetBaudrate() with new baud rate for corresponding CAN network.
    03: Call CanSM_MainFunction() to simulate time passing.
    04: Call CanSM_ControllerModeIndication() to perform controller mode indication.
    05: Call CanSM_MainFunction() continue.
    06: VP(CanSM.ASR40.BSMBr.T_S_CC_STOPPED_S_CC_STARTED): Verify that effect E_CHANGE_BAUDRATE is
        executed. ComM_BusSM_ModeIndication() is called with ComMode set to COMM_NO_COMMUNICATION.
    07: VP(CanSM.ASR40.BSMBr.T_S_CC_STOPPED_S_CC_STARTED): Verify that effect E_CHANGE_BAUDRATE is
        executed. CanIf_SetBaudrate() is called with new baud rate for corresponding CAN network.
    08: VP(CanSM.ASR40.BSMBr.T_S_CC_STOPPED_S_CC_STARTED): Verify that do action
        DO_SET_CC_MODE_STARTED is executed. CanIf_SetControllerMode is called with controller mode
        CANIF_CS_STARTED for the corresponding CAN network.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSMBr.T_S_CC_STOPPED_S_CC_STARTED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>247</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>673</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_CC_STOPPED_TIMEOUT_CHANGE_BR_SingleNetNoTrcv_DET_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_SingleNetNoTrcv_DET_ON/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>3020</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test shall verify the transition T_CC_STOPPED_TIMEOUT from state S_CC_STOPPED_WAIT to
    S_CC_STOPPED within CANSM_BSM_S_CHANGE_BAUDRATE with following constraints:
    - No CanSM_RequestComMode() call while processing

    Note: After the timeout the controller mode indication shall be provided synchronously to
    trigger transition to next state.
  
Test Object: 
    Mode transition
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_FULLCOM; substate S_NO_BUS_OFF
  
Test Execution: 
    01: Disable synchronous controller mode indication.
    02: Trigger transition T_CHANGE_BR_REQUEST (S_NO_BUS_OFF to S_CC_STOPPED). Call
        CanSM_SetBaudrate() with new baud rate for corresponding CAN network.
    03: Call CanSM_MainFunction() CANSM_MODEREQ_REPEAT_TIME times.
    04: Enable synchronous controller mode indication.
    05: Call CanSM_MainFunction() to let timeout CANSM_MODEREQ_REPEAT_TIME elapse.
    06: VP: Verify that do action DO_SET_CC_MODE_STOPPED is executed. CanIf_SetControllerMode() is
        called with controller mode CANIF_CS_STOPPED for the corresponding CAN network.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSMBr.T_S_CC_STOPPED_S_CC_STOPPED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>248</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>674</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_CC_STARTED_TIMEOUT_CHANGE_BR_SingleNetNoTrcv_DET_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_SingleNetNoTrcv_DET_ON/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>3135</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test shall verify the transition T_CC_STARTED_TIMEOUT from state S_CC_STARTED_WAIT to
    S_CC_STARTED within CANSM_BSM_S_CHANGE_BAUDRATE with following constraints:
    - No CanSM_RequestComMode() call while processing

    Note: After the timeout the controller mode indication shall be provided synchronously to
    trigger transition to next state.
  
Test Object: 
    Mode transition
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_FULLCOM; substate S_NO_BUS_OFF
  
Test Execution: 
    01: Disable synchronous controller mode indication.
    02: Trigger transition T_CHANGE_BR_REQUEST (S_NO_BUS_OFF to S_CC_STOPPED). Call
        CanSM_SetBaudrate() with new baud rate for corresponding CAN network.
    03: Call CanSM_ControllerModeIndication() to trigger transition T_CC_STOPPED_INDICATED.
    04: Call CanSM_MainFunction() to continue.
    05: Call CanSM_MainFunction() CANSM_MODEREQ_REPEAT_TIME times.
    06: Enable synchronous controller mode indication.
    07: Call CanSM_MainFunction() to let timeout CANSM_MODEREQ_REPEAT_TIME elapse.
    08: VP: Verify that do action DO_SET_CC_MODE_STARTED is executed. CanIf_SetControllerMode() is
        called with controller mode CANIF_CS_STARTED for the corresponding CAN network.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSMBr.T_S_CC_STARTED_S_CC_STARTED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>249</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>675</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_CC_STARTED_INDICATED_CHANGE_BR_FUCO_SYNC_SingleNetNoTrcv_DET_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_SingleNetNoTrcv_DET_ON/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>3264</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test shall verify the transition T_CC_STARTED_INDICATED from state S_CC_STARTED of
    CANSM_BSM_S_CHANGE_BAUDRATE to CANSM_BSM_S_FULLCOM with following constraints:
    - CanSM_ControllerModeIndications() are synchronous
    - No CanSM_RequestComMode() call while processing
  
Test Object: 
    Mode transition
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_FULLCOM; substate S_NO_BUS_OFF
  
Test Execution: 
    01: Enable synchronous controller mode indication. Effect: CanSM_ControllerModeIndication() will
        called in the callout of CanIf_SetControllerMode().
    02: Trigger transition T_CHANGE_BR_REQUEST (S_NO_BUS_OFF to S_CC_STOPPED). Call
        CanSM_SetBaudrate() with new baud rate for corresponding CAN network.
    03: VP(CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_FULLCOM) Verify that CanIf_SetControllerMode() is
        called with controller mode CANIF_CS_STARTED for the corresponding CAN network which will
        trigger the transition T_CC_STARTED_INDICATED (S_CC_STOPPED to CANSM_BSM_S_FULLCOM) in its
        callback function.
    04: VP(CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_FULLCOM): Verify that guarding condition
        G_NO_COM_MODE_NOT_REQUESTED and G_FULL_COM_MODE_REQUESTED applies.
    05: VP(CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_FULLCOM): Verify that effect E_BR_END_FULL_COM is
        executed. CanIf_SetPduMode() is called with PduModeRequest set to
        CANIF_ONLINE for the corresponding CAN network.
    06: VP(CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_FULLCOM): Verify that effect E_BR_END_FULL_COM is
        executed. BswM_CanSM_CurrentState() is called with CurrentState set to
        CANSM_BSWM_FULL_COMMUNICATION for the corresponding CAN network.
    07: VP(CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_FULLCOM): Verify that effect E_BR_END_FULL_COM is
        executed. ComM_BusSM_ModeIndication() is called with ComMode set to
        COMM_FULL_COMMUNICATION for the corresponding CAN network.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_FULLCOM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>171</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>676</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_CC_STARTED_INDICATED_CHANGE_BR_SICO_ASYNC_SingleNetNoTrcv_DET_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_SingleNetNoTrcv_DET_ON/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>3381</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test shall verify the transition T_CC_STARTED_INDICATED from state S_CC_STARTED of
    CANSM_BSM_S_CHANGE_BAUDRATE to CANSM_BSM_S_SILENTCOM with following constraints:
    - CanSM_ControllerModeIndications() are asynchronous
    - CanSM_RequestComMode() shall put the COM mode to COMM_SILENT_COMMUNICATION
  
Test Object: 
    Mode transition
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_FULLCOM; substate S_NO_BUS_OFF
  
Test Execution: 
    01: Disable synchronous controller mode indication.
    02: Trigger transition T_CHANGE_BR_REQUEST (S_NO_BUS_OFF to S_CC_STOPPED). Call
        CanSM_SetBaudrate() with new baud rate for corresponding CAN network.

    03: Perform controller mode indication.
    04: Call CanSM_MainFunction() to continue.
    05: Call CanSM_RequestComMode() with ComM_Mode set to COMM_SILENT_COMMUNICATION for the
        corresponding CAN network.
    06: Perform controller mode indication.
    07: Call CanSM_MainFunction() to continue.

    08: VP(CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_SILENTCOM): Verify that guarding condition
        G_NO_COM_MODE_NOT_REQUESTED and G_SILENT_COM_MODE_REQUESTED applies.
    09: VP(CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_FULLCOM): Verify that effect E_BR_END_SILENT_COM is
        executed. BswM_CanSM_CurrentState() is called with CurrentState set to
        CANSM_BSWM_SILENT_COMMUNICATION for the corresponding CAN network.
    10: VP(CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_FULLCOM): Verify that effect E_BR_END_SILENT_COM is
        executed. CanIf_SetPduMode() is called with PduModeRequest set to CANIF_TX_OFFLINE for the
       corresponding CAN network.
    11: VP(CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_FULLCOM): Verify that effect E_BR_END_SILENT_COM is
        executed. ComM_BusSM_ModeIndication() is called with ComMode set to
        COMM_SILENT_COMMUNICATION for the corresponding CAN network.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_SILENTCOM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>188</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>677</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_CC_STARTED_INDICATED_CHANGE_BR_NOCO_NOPN_ASYNC_SingleNetNoTrcv_DET_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_SingleNetNoTrcv_DET_ON/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>3512</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test shall verify the transition T_CC_STARTED_INDICATED from state S_CC_STARTED of
    CANSM_BSM_S_CHANGE_BAUDRATE to CANSM_BSM_S_PRE_NOCOM with following constraints:
    - CanSM_ControllerModeIndications() are asynchronous
    - CanSM_RequestComMode() shall put the COM mode to COMM_NO_COMMUNICATION
    - Partial network not supported
  
Test Object: 
    Mode transition
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_FULLCOM; substate S_NO_BUS_OFF
  
Test Execution: 
    01: Disable synchronous controller mode indication.
    02: Trigger transition T_CHANGE_BR_REQUEST (S_NO_BUS_OFF to S_CC_STOPPED). Call
        CanSM_SetBaudrate() with new baud rate for corresponding CAN network.

    03: Perform controller mode indication.
    04: Call CanSM_MainFunction() to continue.
    05: Call CanSM_RequestComMode() with ComM_Mode set to COMM_NO_COMMUNICATION for the
        corresponding CAN network.
    06: Perform controller mode indication.
    07: Call CanSM_MainFunction() to continue.

    08: VP(CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.NoPn.3): Verify that effect E_PRE_NOCOM is
        executed. BswM_CanSM_CurrentState() is called with CurrentState set to
        CANSM_BSWM_SILENT_COMMUNICATION for the corresponding CAN network.

    09: VP(CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.NoPn.3): Verify that do operation
        DO_SET_CC_MODE_STOPPED is executed (Guard CANSM_BSM_G_PN_NOT_SUPPORTED and
        CANSM_BSM_G_PN_SUPPORTED passed). CanIf_SetControllerMode() is called with controller mode
        CANIF_CS_STOPPED for the corresponding CAN network.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.NoPn.3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>186</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>678</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_REPEAT_MAX_CHANGE_BR_S_CC_STOPPED_NOPN_SingleNetNoTrcv_DET_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_SingleNetNoTrcv_DET_ON/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>3627</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks if DET is reported when triggered with T_REPEAT_MAX in state S_CC_STOPPED
    of CANSM_BSM_S_CHANGE_BAUDRATE and verify the correctness of the triggered transition with
    following constraints:
    - CanSM_ControllerModeIndications() are asynchronous
    - Partial network not supported
  
Test Object: 
    T_REPEAT_MAX
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_FULLCOM; substate S_NO_BUS_OFF
  
Test Execution: 
    01: Disable synchronous controller mode indication.
    02: Trigger transition T_CHANGE_BR_REQUEST (S_NO_BUS_OFF to S_CC_STOPPED). Call
        CanSM_SetBaudrate() with new baud rate for corresponding CAN network.

    03: Call the MainFunction of CanSM 10 times
    04: VP(CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.NoPn.1): CanIf_SetControllerMode was called
        second time with controller mode CANIF_CS_STOPPED (once as initial call and once because of
        a CanSMModeRequestRepetitionMax of 1).
    05: Call the MainFunction to continue.
    06: VP(CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.NoPn.1): If development error detection is
        enabled, CanSM called Det_ReportError() with error code CANSM_E_MODE_REQUEST_TIMEOUT.
    07: VP(CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.NoPn.1): Verify that effect E_PRE_NOCOM is
        executed. BswM_CanSM_CurrentState() is called with CurrentState set to
        CANSM_BSWM_SILENT_COMMUNICATION for the corresponding CAN network.

    08: VP(CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.NoPn.1): Verify that do operation
        DO_SET_CC_MODE_STOPPED is executed (Guard CANSM_BSM_G_PN_NOT_SUPPORTED is passed).
        CanIf_SetControllerMode() is called with controller mode CANIF_CS_STOPPED for the
         corresponding CAN network.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.NoPn.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>182</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>679</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_REPEAT_MAX_CHANGE_BR_S_CC_STARTED_NOPN_SingleNetNoTrcv_DET_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_SingleNetNoTrcv_DET_ON/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>3741</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks if DET is reported when triggered with T_REPEAT_MAX in state S_CC_STARTED
    of CANSM_BSM_S_CHANGE_BAUDRATE and verify the correctness of the triggered transition with
    following constraints:
    - CanSM_ControllerModeIndications() are asynchronous
    - Partial network not supported
  
Test Object: 
    T_REPEAT_MAX
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_FULLCOM; substate S_NO_BUS_OFF
  
Test Execution: 
    01: Disable synchronous controller mode indication.
    02: Trigger transition T_CHANGE_BR_REQUEST (S_NO_BUS_OFF to S_CC_STOPPED). Call
        CanSM_SetBaudrate() with new baud rate for corresponding CAN network.

    03: Perform controller mode indication.
    04: Call CanSM_MainFunction() to continue.

    05: Call the MainFunction of CanSM 10 times
    06: VP(CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.NoPn.2): CanIf_SetControllerMode was called
        second time with controller mode CANIF_CS_STOPPED (once as initial call and once because of
        a CanSMModeRequestRepetitionMax of 1).
    07: Call the MainFunction to continue.
    08: VP(CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.NoPn.2): If development error detection is
        enabled, CanSM called Det_ReportError() with error code CANSM_E_MODE_REQUEST_TIMEOUT.
    09: VP(CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.NoPn.2): Verify that effect E_PRE_NOCOM is
        executed with respect to the corresponding deviation. BswM_CanSM_CurrentState() is called
        with CurrentState set to CANSM_BSWM_SILENT_COMMUNICATION for the corresponding CAN network.
    10: VP(CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.NoPn.2): Verify that do operation
        DO_SET_CC_MODE_STOPPED is executed (Guard CANSM_BSM_G_PN_NOT_SUPPORTED is passed).
        CanIf_SetControllerMode() is called with controller mode CANIF_CS_STOPPED for the
        corresponding CAN network.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.NoPn.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>184</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>680</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_FUCO_SICO_1_SingleNetNoTrcv_DET_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_SingleNetNoTrcv_DET_ON/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>3871</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct transition of communication mode from
    CANSM_BSM_S_FULLCOM to CANSM_BSM_S_SILENTCOM.
  
Test Object: 
    Mode transition
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_FULLCOM; substate S_NO_BUS_OFF
  
Test Execution: 
    01: Call CanSM_RequestComMode with:
        network := &lt;id&gt; of network 0
        ComM_Mode := COMM_SILENT_COMMUNICATION.
    02: VP (CanSM.ASR40.BSM.T_FULLCOM_SILENTCOM.1):
        CanSM called the following API function in defined order:
        1. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_SILENT_COMMUNICATION
           Network := 3
        2. CanIf_SetPduMode with:
           PduModeRequest := CANIF_TX_OFFLINE
           ControllerId := 5
        3. ComM_BusSM_ModeIndication with:
           ComMode := COMM_SILENT_COMMUNICATION
    03: Call CanSM_GetCurrentComMode to read the current CanSM mode
        network := &lt;id&gt; of network 0
    04: VP:
        CanSM_GetCurrentComMode return E_OK
    05: VP:
        CanSM is in state COMM_SILENT_COMMUNICATION
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_FULLCOM_SILENTCOM.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>172</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>681</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_FUCO_SICO_2_SingleNetNoTrcv_DET_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_SingleNetNoTrcv_DET_ON/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>3959</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct transition of communication mode from
    CANSM_BSM_S_FULLCOM to CANSM_BSM_S_SILENTCOM upon a request for COMM_NO_COMMUNICATION.
    Note: The transition to silent communication happens instanly.
    To trigger the subsequent transition to no communication a MainFunction cycle
    is necessary.
  
Test Object: 
    Mode transition
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_FULLCOM; substate S_NO_BUS_OFF
  
Test Execution: 
    01: Call CanSM_RequestComMode with:
        network := &lt;id&gt; of network 0
        ComM_Mode := COMM_NO_COMMUNICATION.
    02: VP (CanSM.ASR40.BSM.T_FULLCOM_SILENTCOM.2):
        CanSM called the following API function in defined order:
        1. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_SILENT_COMMUNICATION
           Network := 3
        2. CanIf_SetPduMode with:
           PduModeRequest := CANIF_TX_OFFLINE
           ControllerId := 5
        3. ComM_BusSM_ModeIndication with:
           ComMode := COMM_SILENT_COMMUNICATION
    03: Perform one MainFunction cycle
    04: VP (CanSM.ASR40.BSM.T_FULLCOM_SILENTCOM.2):
        CanSM called the following API function in defined order:
        1. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_NO_COMMUNICATION
           Network := 3
        2. CanIf_SetControllerMode with:
           ControllerMode := CANIF_CS_STOPPED
           ControllerId := 5
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_FULLCOM_SILENTCOM.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>173</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>682</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_FUCO_SICO_3_SingleNetNoTrcv_DET_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_SingleNetNoTrcv_DET_ON/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>4057</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct transition of communication mode from
    CANSM_BSM_S_FULLCOM to CANSM_BSM_S_SILENTCOM.
  
Test Object: 
    Mode transition
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_FULLCOM; substate S_BUS_OFF_CHECK
  
Test Execution: 
    01: Call CanSM_RequestComMode with:
        network := &lt;id&gt; of network 0
        ComM_Mode := COMM_SILENT_COMMUNICATION.
    02: VP (CanSM.ASR40.BSM.T_FULLCOM_SILENTCOM.BusOffCheck.1):
        CanSM called the following API function in defined order:
        1. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_SILENT_COMMUNICATION
           Network := 3
        2. CanIf_SetPduMode with:
           PduModeRequest := CANIF_TX_OFFLINE
           ControllerId := 5
        3. ComM_BusSM_ModeIndication with:
           ComMode := COMM_SILENT_COMMUNICATION
    03: Call CanSM_GetCurrentComMode to read the current CanSM mode
        network := &lt;id&gt; of network 0
    04: VP:
        CanSM_GetCurrentComMode return E_OK
    05: VP:
        CanSM is in state COMM_SILENT_COMMUNICATION
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_FULLCOM_SILENTCOM.BusOffCheck.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>108</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>683</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_FUCO_SICO_4_SingleNetNoTrcv_DET_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_SingleNetNoTrcv_DET_ON/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>4144</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks if CanSM does a transition to CANSM_BSM_S_SILENTCOM
    upon a request for COMM_SILENT_COMMUNICATION if the actual (sub-)state is
    S_TX_OFF.
    Note: This transition is implemented in addition to the Autosar SWS.
  
Test Object: 
    Mode transition
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_FULLCOM; substate S_TX_OFF
  
Test Execution: 
    01: Call CanSM_RequestComMode with:
        network := &lt;id&gt; of network 0
        ComM_Mode := COMM_SILENT_COMMUNICATION.
    02: VP (CanSM.EB.BSM.T_FULLCOM_SILENTCOM.S_TX_OFF.1):
        CanSM shall call the following API function in defined order:
        1. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_SILENT_COMMUNICATION
           Network := 3
        2. CanIf_SetPduMode with:
           PduModeRequest := CANIF_TX_OFFLINE
           ControllerId := 5
        3. ComM_BusSM_ModeIndication with:
           ComMode := COMM_SILENT_COMMUNICATION
    03: VP (CanSM.EB.BSM.T_FULLCOM_SILENTCOM.S_TX_OFF.1):
        CanSM is in state COMM_SILENT_COMMUNICATION
    04: Perform one MainFunction cycle
    05: VP:
        No additional transition shall happen.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.EB.BSM.T_FULLCOM_SILENTCOM.S_TX_OFF.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>110</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>684</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_FUCO_SICO_5_SingleNetNoTrcv_DET_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_SingleNetNoTrcv_DET_ON/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>4237</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks if CanSM does a transition to CANSM_BSM_S_NOCOM
    upon a request for COMM_NO_COMMUNICATION if the actual (sub-)state is
    S_TX_OFF.
    Note: This transition is implemented in addition to the Autosar SWS.
    Note: The transition to silent communication happens instanly.
    To trigger the subsequent transition to no communication a MainFunction cycle
    is necessary.
  
Test Object: 
    Mode transition
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_FULLCOM; substate S_TX_OFF
  
Test Execution: 
    01: Call CanSM_RequestComMode with:
        network := &lt;id&gt; of network 0
        ComM_Mode := COMM_NO_COMMUNICATION.
    02: VP (CanSM.EB.BSM.T_FULLCOM_SILENTCOM.S_TX_OFF.2):
        CanSM called the following API function in defined order:
        1. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_SILENT_COMMUNICATION
           Network := 3
        2. CanIf_SetPduMode with:
           PduModeRequest := CANIF_TX_OFFLINE
           ControllerId := 5
        3. ComM_BusSM_ModeIndication with:
           ComMode := COMM_SILENT_COMMUNICATION
    03: Perform one MainFunction cycle
    04: VP (CanSM.EB.BSM.T_FULLCOM_SILENTCOM.S_TX_OFF.2):
        CanSM called the following API function in defined order:
        1. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_NO_COMMUNICATION
           Network := 3
        2. CanIf_SetControllerMode with:
           ControllerMode := CANIF_CS_STOPPED
           ControllerId := 5
    05: VP (CanSM.EB.BSM.T_FULLCOM_SILENTCOM.S_TX_OFF.2):
        CanSM is in state COMM_NO_COMMUNICATION
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.EB.BSM.T_FULLCOM_SILENTCOM.S_TX_OFF.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>111</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>685</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_NOCO_SICO_SingleNetNoTrcv_DET_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_SingleNetNoTrcv_DET_ON/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>4344</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks if CanSM does a transition to CANSM_BSM_S_SILENTCOM
    upon a request for COMM_SILENT_COMMUNICATION if the actual state is
    CANSM_BSM_S_NOCOM.
    Note: This transition is implemented in addition to the Autosar SWS.
  
Test Object: 
    Mode transition
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_NOCOM
    - Controller and Transceiver indications are synchroneous
  
Test Execution: 
    01: Call CanSM_RequestComMode with:
        network := &lt;id&gt; of network 0
        ComM_Mode := COMM_SILENT_COMMUNICATION.
    02: VP (CanSM.EB.NoComToSilentCom):
        CanSM shall accept the request.
    03: VP (CanSM.EB.NoComToSilentCom):
        CanSM shall be in state CANSM_BSM_S_FULLCOM
    04: Perform one MainFunction cycle
    05: VP (CanSM.EB.NoComToSilentCom):
        CanSM shall be in state CANSM_BSM_S_SILENTCOM
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.EB.NoComToSilentCom</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>136</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>686</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_BUS_OFF_PASSIVE_TIMER_SingleNetNoTrcv_DET_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_SingleNetNoTrcv_DET_ON/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>4448</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct transition from substate S_BUS_OFF_CHECK
    to substate S_NO_BUS_OFF in state CANSM_BSM_S_FULLCOM.
    Bus-off detection is done via timeout
  
Test Object: 
    Mode transition
  
Test Precondition: 
    - Transition from S_RFUCO to S_FUCO just happened
    - Dem reporting forwarded to Dem
    - CanSMBorTxConfirmationPolling := false
    - CanSMBorTimeTxEnsured := 20,5x CanSMMainFunctionTimePeriod
  
Test Execution: 
    01: Call the MainFunction of CanSM 20 times
    02: VP:
        CanSM called no API functions
    03: Call the MainFunction of CanSM
    04: VP (CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_NO_BUS_OFF):
        CanSM called Dem_ReportErrorStatus with:
        EventId := CANSM_E_BUS_OFF
        EventStatus := DEM_EVENT_STATUS_PASSED
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_NO_BUS_OFF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>232</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>687</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_DEBOUNCE_SingleNetNoTrcv_DET_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_SingleNetNoTrcv_DET_ON/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>4520</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct transition from substate S_BUS_OFF_CHECK
    to substate S_RESTART_CC in state CANSM_BSM_S_FULLCOM
    via trigger T_BUS_OFF.
  
Test Object: 
    Mode transition
  
Test Precondition: 
    - CanSM is in substate S_BUS_OFF_CHECK
  
Test Execution: 
    01: Call CanSM_ControllerBusOff with:
        ControllerId := 5
    02: Call the MainFunction of CanSM
    03: VP (CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_RESTART_CC.BusOff,
            CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_RESTART_CC.BusOffL1):
        CanSM called the following API functions in defined order:
        1. BswM_CanSM_CurrentState with:
    IF CANSM_ENHANCED_BUSOFF_REPORTING enabled
           CurrentState := CANSM_BSWM_BUS_OFF_L1
    ELSE
           CurrentState := CANSM_BSWM_BUS_OFF
    ENDIF
           Network := 3
        2. Dem_ReportErrorStatus with:
           EventId := CANSM_E_BUS_OFF
           EventStatus := DEM_EVENT_STATUS_PREFAILED
        3. CanIf_SetPduMode with:
           PduModeRequest := CANIF_TX_OFFLINE
           ControllerId := 5
        4. CanIf_SetControllerMode with:
        ControllerMode := CANIF_CS_STARTED
           ControllerId := 5
    04: Call CanSM_GetCurrentComMode to read the current CanSM mode
        network := &lt;id&gt; of network 0
    05: VP:
        CanSM_GetCurrentComMode return E_OK
    06: VP:
        CanSM is in state COMM_FULL_COMMUNICATION
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_RESTART_CC.BusOff</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>234</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_RESTART_CC.BusOffL1</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>235</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00235</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>308</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>688</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_DEBOUNCE_SYNC_SingleNetNoTrcv_DET_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_SingleNetNoTrcv_DET_ON/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>4629</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct transition from substate S_BUS_OFF_CHECK
    to substate S_RESTART_CC in state CANSM_BSM_S_FULLCOM
    via trigger T_BUS_OFF.
    All mode indications shall be synchron.
  
Test Object: 
    Mode transition
  
Test Precondition: 
    - CanSM is in substate S_BUS_OFF_CHECK
    - CanSM is in bus-off recovery level 2
  
Test Execution: 
    01: Prepare the CanIf stub to indicate the requested controller mode
        transition from inside the context of CanIf_SetControllerMode.
    02: Call CanSM_ControllerBusOff with:
        ControllerId := 5
    03: Call the MainFunction of CanSM
    04: VP (CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_RESTART_CC.BusOff,
            CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_RESTART_CC.BusOffL2,
            CanSM.ASR40.BSMFull.T_S_RESTART_CC_S_TX_OFF.2):
        CanSM called the following API functions in defined order:
        1. BswM_CanSM_CurrentState with:
    IF CANSM_ENHANCED_BUSOFF_REPORTING enabled
           CurrentState := CANSM_BSWM_BUS_OFF_L2
    ELSE
           CurrentState := CANSM_BSWM_BUS_OFF
    ENDIF
           Network := 3
        2. Dem_ReportErrorStatus with:
           EventId := CANSM_E_BUS_OFF
           EventStatus := DEM_EVENT_STATUS_PREFAILED
        3. CanIf_SetPduMode with:
           PduModeRequest := CANIF_TX_OFFLINE
           ControllerId := 5
        4. CanIf_SetControllerMode with:
           ControllerMode := CANIF_CS_STARTED
           ControllerId := 5
        5. ComM_BusSM_ModeIndication with:
           ComMode := COMM_SILENT_COMMUNICATION
    05: Call CanSM_GetCurrentComMode to read the current CanSM mode
        network := &lt;id&gt; of network 0
    06: VP:
        CanSM_GetCurrentComMode returns E_OK
    07: VP (CanSM.EB.BusOffRecovery.SetNetworkModeSilentCommunication):
        CanSM is in state COMM_SILENT_COMMUNICATION
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_RESTART_CC.BusOff</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>234</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_RESTART_CC.BusOffL2</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>236</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMFull.T_S_RESTART_CC_S_TX_OFF.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>241</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.BusOffRecovery.SetNetworkModeSilentCommunication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>124</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00235</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>308</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>689</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_TX_OFF_SingleNetNoTrcv_DET_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_SingleNetNoTrcv_DET_ON/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>4761</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct transition from substate S_RESTART_CC
    to substate S_TX_OFF in state CANSM_BSM_S_FULLCOM and if CanSM denies a mode request
    when CanSM waits for CanSM_ControllerModeIndication in state S_RESTART_CC.
  
Test Object: 
    Mode transition
    Denial of CanSM_RequestComMode
  
Test Precondition: 
    - CanSM is in substate S_RESTART_CC
  
Test Execution: 
    01: Call CanSM_ControllerModeIndication with:
        ControllerId := 5
        ControllerMode := CANIF_CS_STARTED
    02: Call the MainFunction of CanSM
    03: VP (CanSM.ASR40.BSMFull.T_S_RESTART_CC_S_TX_OFF.2):
        CanSM called the following API function:
        ComM_BusSM_ModeIndication with:
           ComMode := COMM_SILENT_COMMUNICATION
    04: Call CanSM_GetCurrentComMode to read the current CanSM mode
        network := &lt;id&gt; of network 0
    05: VP:
        CanSM_GetCurrentComMode return E_OK
    06: VP (CanSM.EB.BusOffRecovery.SetNetworkModeSilentCommunication):
        CanSM is in state COMM_SILENT_COMMUNICATION
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.EB.BusOffRecovery.SetNetworkModeSilentCommunication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>124</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMFull.T_S_RESTART_CC_S_TX_OFF.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>241</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>690</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_FUCO_SRNOCO_SingleNetNoTrcv_DET_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_SingleNetNoTrcv_DET_ON/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>4847</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct transition from substate S_RESTART_CC
    in state CANSM_BSM_S_FULLCOM to CANSM_BSM_S_PRE_NOCOM.
  
Test Object: 
    Mode transition
  
Test Precondition: 
    - CanSM is in substate S_RESTART_CC
  
Test Execution: 
    01: Call the MainFunction of CanSM 4 times
        (equates CanSMModeRequestRepetitionTime - 1 in MainFunction periods)
    02: VP:
        No API function was called (CanSMModeRequestRepetitionTime not elapsed)
    03: Call the MainFunction of CanSM
    04: VP (CanSM.ASR40.BSMFull.T_S_RESTART_CC_S_RESTART_CC):
        CanSM calls CanIf_SetControllerMode
        (first and last retry, because CanSMModeRequestRepetitionMax equals 1) with:
        ControllerMode := CANIF_CS_STARTED
        ControllerId := 5
    05: Call the MainFunction of CanSM 4 times
        (equates CanSMModeRequestRepetitionTime - 1 in MainFunction periods)
    06: VP:
        CanSM did not call neither Dem_ReportErrorStatus nor CanIf_SetControllerMode
    07: Call the MainFunction of CanSM
    08: VP (CanSM.ASR40.BSM.T_FULLCOM_PRE_NOCOM.NoPn):
        If development error detection is enabled,
        CanSM called Det_ReportError with:
        ErrorId: CANSM_E_MODE_REQUEST_TIMEOUT
    09: VP (CanSM.ASR40.BSM.T_FULLCOM_PRE_NOCOM.NoPn):
            CanIf_SetControllerMode was called with
            ControllerMode := CANIF_CS_STOPPED
            ControllerId := 5
    10: Call CanSM_GetCurrentComMode to read the current CanSM mode
        network := &lt;id&gt; of network 0
    11: VP:
        CanSM_GetCurrentComMode return E_OK
    12: VP:
        CanSM is in state COMM_FULL_COMMUNICATION
    13: Finish transition to no communication by running through state S_RNOCO
        Hint: Use function TS_CANSM_S_RNOCO_SYNC for transition to S_NOCO
    14: VP:
        CanSM is in state COMM_NO_COMMUNICATION
        Hint: check is part of function TS_CANSM_S_RNOCO_SYNC (see step 13)
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSMFull.T_S_RESTART_CC_S_RESTART_CC</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>242</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_FULLCOM_PRE_NOCOM.NoPn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>168</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>691</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_BUS_OFF_SingleNetNoTrcv_DET_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_SingleNetNoTrcv_DET_ON/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>4981</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct transition from substate S_NO_BUS_OFF
    to substate S_RESTART_CC in state CANSM_BSM_S_FULLCOM.
  
Test Object: 
    Mode transition
  
Test Precondition: 
    - CanSM is in substate S_NO_BUS_OFF
  
Test Execution: 
    01: Call CanSM_ControllerBusOff with:
        ControllerId := 5
    02: Call the MainFunction of CanSM
    03: VP (CanSM.ASR40.BSMFull.T_S_NO_BUS_OFF_S_RESTART_CC.BusOff,
            CanSM.ASR40.BSMFull.T_S_NO_BUS_OFF_S_RESTART_CC.BusOffL1):
        CanSM called the following API functions in defined order:
        1. BswM_CanSM_CurrentState with:
    IF CANSM_ENHANCED_BUSOFF_REPORTING enabled
           CurrentState := CANSM_BSWM_BUS_OFF_L1
    ELSE
           CurrentState := CANSM_BSWM_BUS_OFF
    ENDIF
           Network := 3
        2. Dem_ReportErrorStatus with:
           EventId := CANSM_E_BUS_OFF
           EventStatus := DEM_EVENT_STATUS_PREFAILED
        3. CanIf_SetPduMode with:
           PduModeRequest := CANIF_TX_OFFLINE
           ControllerId := 5
        4. CanIf_SetControllerMode with:
           ControllerMode := CANIF_CS_STARTED
           ControllerId := 5
    04: Call CanSM_GetCurrentComMode to read the current CanSM mode
        network := &lt;id&gt; of network 0
    05: VP:
        CanSM_GetCurrentComMode return E_OK
    06: VP:
        CanSM is in state COMM_FULL_COMMUNICATION
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSMFull.T_S_NO_BUS_OFF_S_RESTART_CC.BusOff</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>238</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMFull.T_S_NO_BUS_OFF_S_RESTART_CC.BusOffL1</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>239</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00235</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>308</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>692</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_TX_ON_L1_SingleNetNoTrcv_DET_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_SingleNetNoTrcv_DET_ON/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>5092</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct transition from substate S_TX_OFF
    to substate S_BUS_OFF_CHECK in state CANSM_BSM_S_FULLCOM.
    The bus-off event counter is below CanSMBorCounterL1ToL2.
    Note: CanSMBorTimeL1 elapses after 15 MainFunction periods (see precondition).
    But remember that CanSMBorTimeL1 begins with a indication of a bus-off event.
    If this test begins the state machine is in substate S_TX_OFF (precondition) and
    therefore already ran through the state S_RESTART_CC (sequence TS_CANSM_T_TX_OFF)
    which lasts one MainFunction period.
    Which means, when this test sequence starts CanSMBorTimeL1 shall elapse after 14
    MainFunction periods.
  
Test Object: 
    Mode transition
  
Test Precondition: 
    - CanSM is in substate S_TX_OFF
    - CanSMBorTimeL1 := 14,5x CanSMMainFunctionTimePeriod
  
Test Execution: 
    01: Call the MainFunction of CanSM 13 times
        (Time until CanSMBorTimeL1 elapsed - 1 MainFunction period)
    02: VP:
        CanSM called no API functions
    03: Call the MainFunction of CanSM (CanSMBorTimeL1 elapses now)
    04: VP (CanSM.ASR40.BSMFull.T_S_TX_OFF_S_BUS_OFF_CHECK):
        CanSM called the following API functions in defined order:
        1. CanIf_SetPduMode with:
           PduModeRequest := CANIF_ONLINE
           ControllerId := 5
        2. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_FULL_COMMUNICATION
           Network := 3
        3. ComM_BusSM_ModeIndication with:
           ComMode := COMM_FULL_COMMUNICATION
    05: Call CanSM_GetCurrentComMode to read the current CanSM mode
        network := &lt;id&gt; of network 0
    06: VP:
        CanSM_GetCurrentComMode return E_OK
    07: Verify if CanSM is in state COMM_FULL_COMMUNICATION
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSMFull.T_S_TX_OFF_S_BUS_OFF_CHECK</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>243</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>693</internalId></specobject>
    <specobject>
      <id>TS_CANSM_L1_TO_L2_SingleNetNoTrcv_DET_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_SingleNetNoTrcv_DET_ON/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>5195</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct transition from substate S_BUS_OFF_CHECK
    (initial after S_RFUCO) to substate S_BUS_OFF_CHECK in error level 2.
  
Test Object: 
    Mode transition
  
Test Precondition: 
    - Transition from CANSM_BSM_S_PRE_FULLCOM to CANSM_BSM_S_FULLCOM just happened
    - CanSMBorTimeL1 := 14,5x CanSMMainFunctionTimePeriod
  
Test Execution: 
    01: Repeat steps 02 - 09 for (CanSMBorCounterL1ToL2) times:
    02: Call CanSM_ControllerBusOff with:
        ControllerId := 5
    03: Call the MainFunction of CanSM to start recovery counter
    04: VP (CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_RESTART_CC.BusOff,
            CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_RESTART_CC.BusOffL1):
        CanSM called the following API functions in defined order:
        1. BswM_CanSM_CurrentState with:
    IF CANSM_ENHANCED_BUSOFF_REPORTING enabled
           CurrentState := CANSM_BSWM_F_BUS_OFF_L1
    ELSE
           CurrentState := CANSM_BSWM_F_BUS_OFF
    ENDIF
           Network := 3
        2. Dem_ReportErrorStatus with:
           EventId := CANSM_E_BUS_OFF
           EventStatus := DEM_EVENT_STATUS_PREFAILED
        3. CanIf_SetPduMode with:
           PduModeRequest := CANIF_TX_OFFLINE
           ControllerId := 5
        4. CanIf_SetControllerMode with:
           ControllerMode := CANIF_CS_STARTED
           ControllerId := 5
    05: Call CanSM_ControllerModeIndication with:
        ControllerId := 5
        ControllerMode := CANIF_CS_STARTED
    06: Call the MainFunction of CanSM to trigger state machine
    07: VP (CanSM.ASR40.BSMFull.T_S_RESTART_CC_S_TX_OFF.2):
        CanSM called the following API function:
        ComM_BusSM_ModeIndication with:
           ComMode := COMM_SILENT_COMMUNICATION
    08: Call the MainFunction of CanSM 14 times
    09: VP (CanSM.ASR40.BSMFull.T_S_TX_OFF_S_BUS_OFF_CHECK):
        CanSM called the following API functions in defined order:
        1. CanIf_SetPduMode with:
           PduModeRequest := CANIF_ONLINE
           ControllerId := 5
        2. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_FULL_COMMUNICATION
           Network := 3
        3. ComM_BusSM_ModeIndication with:
           ComMode := COMM_FULL_COMMUNICATION
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_RESTART_CC.BusOff</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>234</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_RESTART_CC.BusOffL1</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>235</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMFull.T_S_RESTART_CC_S_TX_OFF.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>241</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMFull.T_S_TX_OFF_S_BUS_OFF_CHECK</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>243</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00235</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>308</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>694</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_TX_ON_L2_SingleNetNoTrcv_DET_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_SingleNetNoTrcv_DET_ON/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>5345</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct transition from substate S_TX_OFF
    to substate S_BUS_OFF_CHECK in state CANSM_BSM_S_FULLCOM.
    The bus-off event counter is greater than or equal to CanSMBorCounterL1ToL2.
  
Test Object: 
    Mode transition
  
Test Precondition: 
    - CanSM is in substate S_TX_OFF
    - CanSM has reached error level 2
    - CanSMBorTimeL2 := 25x CanSMMainFunctionTimePeriod
  
Test Execution: 
    01: Call the MainFunction of CanSM 24 times
        (Time until CanSMBorTimeL2 elapsed minus 1 MainFunction period)
    02: VP:
        CanSM called no API functions
    03: Call the MainFunction of CanSM (CanSMBorTimeL2 elapsed now)
    04: VP (CanSM.ASR40.BSMFull.T_S_TX_OFF_S_BUS_OFF_CHECK):
        CanSM called the following API functions in defined order:
        1. CanIf_SetPduMode with:
           PduModeRequest := CANIF_ONLINE
           ControllerId := 5
        2. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_FULL_COMMUNICATION
           Network := 3
        3. ComM_BusSM_ModeIndication with:
           ComMode := COMM_FULL_COMMUNICATION
    05: Call CanSM_GetCurrentComMode to read the current CanSM mode
        network := &lt;id&gt; of network 0
    06: VP:
        CanSM_GetCurrentComMode returns E_OK
    07: VP (CanSM.EB.BusOffRecovery.SetTxOnline):
        CanSM is in state COMM_FULL_COMMUNICATION
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSMFull.T_S_TX_OFF_S_BUS_OFF_CHECK</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>243</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.BusOffRecovery.SetTxOnline</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>125</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>695</internalId></specobject>
    <specobject>
      <id>TS_CANSM_TIME_TX_ENSURE_VIO_SingleNetNoTrcv_DET_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_SingleNetNoTrcv_DET_ON/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>5448</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the behavior of CanSM if a bus-off event during
    time CanSMBorTimeTxEnsured is reported.
  
Test Object: 
    Mode transition
  
Test Precondition: 
    - Transition from CANSM_BSM_S_PRE_FULLCOM to CANSM_BSM_S_FULLCOM just happened
    - Dem reporting forwarded to Dem
    - CanSMBorTxConfirmationPolling := false
    - CanSMBorTimeTxEnsured := 20,5x CanSMMainFunctionTimePeriod
  
Test Execution: 
    01: Execute following test sequences in consecutive order:
        1. TS_CANSM_T_DEBOUNCE
        2. TS_CANSM_T_TX_OFF
        3. TS_CANSM_T_TX_ON_L1
    02: Call the MainFunction of CanSM 20 times
    03: Call CanSM_ControllerBusOff with:
        ControllerId := 5
    04: Call the MainFunction of CanSM
    05: VP (CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_NO_BUS_OFF,
            CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_RESTART_CC.BusOff,
            CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_RESTART_CC.BusOff):
        CanSM called the following API functions in defined order:
        1. BswM_CanSM_CurrentState with:
    IF CANSM_ENHANCED_BUSOFF_REPORTING enabled
           CurrentState := CANSM_BSWM_BUS_OFF_L1
    ELSE
           CurrentState := CANSM_BSWM_BUS_OFF
    ENDIF
           Network := 3
        2. Dem_ReportErrorStatus with:
           EventId := CANSM_E_BUS_OFF
           EventStatus := DEM_EVENT_STATUS_PREFAILED
        3. CanIf_SetPduMode with:
           PduModeRequest := CANIF_TX_OFFLINE
           ControllerId := 5
        4. CanIf_SetControllerMode with:
        ControllerMode := CANIF_CS_STARTED
           ControllerId := 5
    06: VP:
        CanSM did not call Dem_ReportErrorStatus
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_NO_BUS_OFF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>232</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_RESTART_CC.BusOff</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>234</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_RESTART_CC.BusOffL1</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>235</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>696</internalId></specobject>
    <specobject>
      <id>TS_CANSM_L1_TO_RECOVERY_SingleNetNoTrcv_DET_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_SingleNetNoTrcv_DET_ON/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>5561</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct handling of short recovery from
    bus-off in level 1.
  
Test Object: 
    Mode transition
  
Test Precondition: 
    - Transition from CANSM_BSM_S_PRE_FULLCOM to CANSM_BSM_S_FULLCOM just happened
    - CanSMBorTimeTxEnsured := 20,5x CanSMMainFunctionTimePeriod
  
Test Execution: 
    01: Execute following test sequences in consecutive order:
        1. TS_CANSM_T_DEBOUNCE
        2. TS_CANSM_T_TX_OFF
        3. TS_CANSM_T_TX_ON_L1
    02: Call the MainFunction of CanSM 20 times
    03: Verify if CanSM called no API functions
    04: Call the MainFunction of CanSM
    05: VP (CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_NO_BUS_OFF):
        CanSM called Dem_ReportErrorStatus with:
        EventId := CANSM_E_BUS_OFF
        EventStatus := DEM_EVENT_STATUS_PASSED
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_NO_BUS_OFF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>232</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>697</internalId></specobject>
    <specobject>
      <id>TS_CANSM_L2_TO_RECOVERY_SingleNetNoTrcv_DET_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_SingleNetNoTrcv_DET_ON/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>5636</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct handling of long recovery from
    bus-off in level 2.
  
Test Object: 
    Mode transition
  
Test Precondition: 
    - Transition from CANSM_BSM_S_PRE_FULLCOM to CANSM_BSM_S_FULLCOM just happened
    - CanSMBorTimeTxEnsured := 20,5x CanSMMainFunctionTimePeriod
  
Test Execution: 
    01: Execute following test sequences in consecutive order
        for (CanSMBorCounterL1ToL2) times:
        1. TS_CANSM_T_DEBOUNCE
        2. TS_CANSM_T_TX_OFF
        3. TS_CANSM_T_TX_ON_L1
    02: Execute following test sequences in consecutive order:
        1. TS_CANSM_T_DEBOUNCE_SYNC
        2. TS_CANSM_T_TX_ON_L2
    03: Call the MainFunction of CanSM 20 times
    04: VP:
        CanSM called no API functions
    05: Call the MainFunction of CanSM
    06: VP (CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_NO_BUS_OFF):
        CanSM called Dem_ReportErrorStatus with:
        EventId := CANSM_E_BUS_OFF
        EventStatus := DEM_EVENT_STATUS_PASSED
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_NO_BUS_OFF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>232</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>698</internalId></specobject>
    <specobject>
      <id>TS_CANSM_BUSOFF_COUNT_RESET_SingleNetNoTrcv_DET_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_SingleNetNoTrcv_DET_ON/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>5728</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the reset of the BusOffEvent counter to '0', when there is a transition
    from CANSM_BSM_S_NOCOM to CANSM_BSM_S_FULLCOM.
    Note: 1. Done by checking if bus-off enters level 2 only after 128 (CanSMBorCounterL1ToL2)
    times the BusOffEvent occurs(This could happen only if the counter is reset to '0').
          2. BusOffEvent is called more than 255 times initially before the rest condition occurs, just to
    ensure it was reset to 0 when having some initial value.
  
Test Object: 
    Mode transition
  
Test Precondition: 
    - CanSMBorTimeTxEnsured := 20,5x CanSMMainFunctionTimePeriod
    - CanSMBorCounterL1ToL2 := 128
  
Test Execution: 
    01: Execute following test sequences in consecutive order
        for (CanSMBorCounterL1ToL2) times to make BusOffCount = 127:
        1. TS_CANSM_T_DEBOUNCE
        2. TS_CANSM_T_TX_OFF
        3. TS_CANSM_T_TX_ON_L1
    02: Execute following test sequences in consecutive order
        for (CanSMBorCounterL1ToL2) times to make BusOffCount = 255:
        1. TS_CANSM_T_DEBOUNCE_SYNC
        2. TS_CANSM_T_TX_ON_L2
    03: Make transition from S_NOCOM to S_FULLCOM that will reset the BusOffCounter
    04: Execute following test sequences in consecutive order
        for (CanSMBorCounterL1ToL2) times:
        1. TS_CANSM_T_DEBOUNCE
        2. TS_CANSM_T_TX_OFF
        3. TS_CANSM_T_TX_ON_L1
    05: Execute following test sequences in consecutive order:
        1. TS_CANSM_T_DEBOUNCE_SYNC
        2. TS_CANSM_T_TX_ON_L2
    06: Call the MainFunction of CanSM 20 times
    07: VP (CanSM.EB.BusOffEventsCount.NOCO_FUCO):
        CanSM called no API functions
    08: Call the MainFunction of CanSM
    09: VP (CanSM.EB.BusOffEventsCount.NOCO_FUCO):
        CanSM called Dem_ReportErrorStatus with:
        EventId := CANSM_E_BUS_OFF
        EventStatus := DEM_EVENT_STATUS_PASSED
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.EB.BusOffEventsCount.NOCO_FUCO</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>114</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>699</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_FUCO_NOCO_SYNC_SingleNetNoTrcv_DET_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_SingleNetNoTrcv_DET_ON/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>5859</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct transition of communication mode from
    S_FUCO (state FUll COmmunication) to S_NOCO (state NO COmmunication).
    All mode indications shall be synchron.
  
Test Object: 
    Module initialization
  
Test Precondition: 
    - Transition from CANSM_BSM_S_PRE_FULLCOM to CANSM_BSM_S_FULLCOM just happened
    - Test is executed for a configuration with and one without a transceiver
  
Test Execution: 
    01: Call TS_CANSM_T_DEBOUNCE to go to substate S_RESTART_CC
    02: Call the MainFunction of CanSM 10 times (to trigger T_FUCO_SRNOCO)
    03: VP:
        CanSM called the following API function in defined order:
        1. CanIf_SetControllerMode with:
           ControllerMode := CANIF_CS_STARTED
           ControllerId := 5
           NOTE: This call is the retry after CANSM_MODEREQ_REPEAT_TIME in state S_RESTART_CC
        2. If CanSMDevErrorDetect is enbled:
           CanSM called Det_ReportError with:
           ErrorId: 0x0A (CANSM_E_MODE_REQUEST_TIMEOUT)
           ApiId: 0x05
           If CanSMDevErrorDetect is disbled:
           CanSM does not call Det_ReportError
        3. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_NO_COMMUNICATION
           Network := 3
           (CanSM.ASR40.BSM.T_SILENTCOM_PRE_NOCOM.NoPn)
        4. CanIf_SetControllerMode with:
           ControllerMode := CANIF_CS_STOPPED
           ControllerId := 5
           (CanSM.ASR40.BSM.T_SILENTCOM_PRE_NOCOM.NoPn)
    IF transceiver is configured
        04: Prepare the CanIf stub to indicate the requested transceiver mode
            transition from inside the context of CanIf_SetTrcvMode.
    ENDIF
    05: Prepare the CanIf stub to indicate the requested controller mode
        transition from inside the context of CanIf_SetControllerMode.
    06: Call CanSM_ControllerModeIndication to confirm CanSM_SetControllerMode
            (sent because of the timeout) with:
            ControllerMode := CANIF_CS_STOPPED
            ControllerId := 5
    07: Call the MainFunction of CanSM
    08: VP:
        CanSM called the following API function in defined order:
        1. CanIf_SetControllerMode with:
           ControllerMode := CANIF_CS_SLEEP
           ControllerId := 5
           (CanSM.ASR40.BSMDeInitNoPn.T_S_CC_STOPPED_S_CC_SLEEP)
        IF transceiver is configured
            2. CanIf_SetTrcvMode with:
               TransceiverMode := CANTRCV_TRCVMODE_NORMAL
               TransceiverId := 3
               (CanSM.ASR40.BSMDeInitNoPn.T_S_CC_SLEEP_S_TRCV_NORMAL)
            3. CanIf_SetTrcvMode with:
               TransceiverMode := CANTRCV_TRCVMODE_STANDBY
               TransceiverId := 3
               (CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_NORMAL_S_TRCV_STANDBY)
               (CanSM.EB.Transitions.NoTransceiver.2)
        ENDIF
        4. ComM_BusSM_ModeIndication with:
           ComMode := COMM_NO_COMMUNICATION
           (CanSM.ASR40.BSM.T_PRE_NOCOM_NOCOM.NoPn.1)
    09: Call CanSM_GetCurrentComMode to read the current CanSM mode
        network := &lt;id&gt; of network 0
    10: VP:
        CanSM_GetCurrentComMode returns E_OK
    11: VP:
        CanSM is in state COMM_NO_COMMUNICATION
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_SILENTCOM_PRE_NOCOM.NoPn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>189</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_CC_STOPPED_S_CC_SLEEP</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>216</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_CC_SLEEP_S_TRCV_NORMAL</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>219</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_NORMAL_S_TRCV_STANDBY</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>222</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.Transitions.NoTransceiver.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>106</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_PRE_NOCOM_NOCOM.NoPn.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>191</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>700</internalId></specobject>
    <specobject>
      <id>TS_CANSM_S_RNOCO_SYNC_SingleNetNoTrcv_DET_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_SingleNetNoTrcv_DET_ON/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>6042</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct behavior of execution of the CANSM_BSM_S_PRE_NOCOM
    state (State Request NO COmmunication).
    All mode indications shall be synchron.
  
Test Object: 
    Module initialization
  
Test Precondition: 
    - Transition to CANSM_BSM_S_PRE_NOCOM triggered
      (There are two possible trigger conditions:
       a) Maximum allowed wait time for a mode request expired
       b) A mode transition from silent to no communication was requested)
      This means that
      - the call to BswM_CanSM_CurrentState, CanIf_SetPduMode and CanIf_SetControllerMode
        was done by CanSM and traces were checked
    - function trace buffer contains no unchecked function pointer (in counter equals out counter)
      when precondition above was triggered
    - Test is executed for a configuration with and one without a transceiver
  
Test Execution: 
    IF transceiver is configured
        01: Prepare the CanIf stub to indicate the requested transceiver mode
            transition from inside the context of CanIf_SetTrcvMode.
    ENDIF
    02: Prepare the CanIf stub to indicate the requested controller mode
        transition from inside the context of CanIf_SetControllerMode.
    03: Call CanSM_ControllerModeIndication to confirm CanSM_SetControllerMode which
        was the precondition for this test sequence (CanSM_ControllerMode was called
        when entering S_RNOCO). Use following arguments:
        ControllerMode := CANIF_CS_STOPPED
        ControllerId := 5
    04: Call the MainFunction of CanSM
    05: VP:
        CanSM called the following API function in defined order:
        1. CanIf_SetControllerMode with:
           ControllerMode := CANIF_CS_SLEEP
           ControllerId := 5
           (CanSM.ASR40.BSMDeInitNoPn.T_S_CC_STOPPED_S_CC_SLEEP)
        IF transceiver is configured
            2. CanIf_SetTrcvMode with:
               TransceiverMode := CANTRCV_TRCVMODE_NORMAL
               TransceiverId := 3
               (CanSM.ASR40.BSMDeInitNoPn.T_S_CC_SLEEP_S_TRCV_NORMAL)
            3. CanIf_SetTrcvMode with:
               TransceiverMode := CANTRCV_TRCVMODE_STANDBY
               TransceiverId := 3
               (CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_NORMAL_S_TRCV_STANDBY)
               (CanSM.EB.Transitions.NoTransceiver.2)
        ENDIF
        4. ComM_BusSM_ModeIndication with:
           ComMode := COMM_NO_COMMUNICATION
           (CanSM.ASR40.BSM.T_PRE_NOCOM_NOCOM.NoPn.1)
    06: Call CanSM_GetCurrentComMode to read the current CanSM mode
        network := &lt;id&gt; of network 0
    07: VP (CanSM.SWS_CanSM_00371):
        CanSM_GetCurrentComMode returns E_OK
    08: VP (CanSM.SWS_CanSM_00186):
        CanSM is in state COMM_NO_COMMUNICATION
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_CC_STOPPED_S_CC_SLEEP</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>216</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_CC_SLEEP_S_TRCV_NORMAL</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>219</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_NORMAL_S_TRCV_STANDBY</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>222</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.Transitions.NoTransceiver.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>106</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_PRE_NOCOM_NOCOM.NoPn.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>191</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00371</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>317</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00186</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>303</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>701</internalId></specobject>
    <specobject>
      <id>TS_CANSM_SETPDUMODE_FAILURE_1_SingleNetNoTrcv_DET_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_SingleNetNoTrcv_DET_ON/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>6185</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct behavior of CanSm when the call to CanIf_SetPduMode fails.
    Mode transition is from S_NOCO to S_FUCO.
  
Test Object: 
    Failed call to CanIf_SetPduMode
  
Test Precondition: 
    - CanSM is in state S_NOCO
  
Test Execution: 
    01: Prepare the CanIf stub so that CanIf_SetPduMode returns E_NOT_OK
    IF transceiver is configured
        02: Prepare the CanIf stub to indicate the requested transceiver mode
            transition from inside the context of CanIf_SetTrcvMode.
    ENDIF
    03: Prepare the CanIf stub to indicate the requested controller mode
        transition from inside the context of CanIf_SetControllerMode.
    04: Call CanSM_RequestComMode with:
        network := &lt;id&gt; of network 0
        ComM_Mode := COMM_FULL_COMMUNICATION.
    05: VP (CanSM.EB.Api.NegativeReturn.CanIf_SetPduMode):
        CanSM shall not call Det_ReportError
    06: Call CanSM_GetCurrentComMode to read the current CanSM mode
        network := &lt;id&gt; of network 0
    07: VP (CanSM.EB.Api.NegativeReturn.CanIf_SetPduMode):
        CanSM_GetCurrentComMode returns E_OK
    08: VP (CanSM.EB.Api.NegativeReturn.CanIf_SetPduMode):
        CanSM is in state COMM_FULL_COMMUNICATION
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.EB.Api.NegativeReturn.CanIf_SetPduMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>116</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>702</internalId></specobject>
    <specobject>
      <id>TS_CANSM_SUBSEQUENT_BUSOFF_SingleNetNoTrcv_DET_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_SingleNetNoTrcv_DET_ON/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>6278</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct behavior of CanSM when a new bus-off event is detected
    immediately after restart of the CC (state S_RESTART_CC) and before finishing with
    bus-off recovery.
    CanSM shall store the 2nd bus-off event and start another recovery cycle after
    the first one finishes.
    This test belongs to bugticket ASCCANSM-366.
  
Test Object: 
    busoff
  
Test Precondition: 
    - CanSM just finished to restart the communication controller in state S_RESTART_CC
      (this means that all mode indication and the consecutive MainFunction are executed)
  
Test Execution: 
    01: Call CanSM_ControllerBusOff with:
        ControllerId := 5
    02: Call the MainFunction of CanSM
    03: VP:
        CanSM does not report any DET error.
    04: Finishing bus-off recovery by waiting Bor time for L1.
    05: VP:
        CanSM finishes bus-off recovery by calling the following API functions in defined order:
        1. CanIf_SetPduMode with:
           PduModeRequest := CANIF_ONLINE
           ControllerId := 5
        2. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_FULL_COMMUNICATION
           Network := 3
        3. ComM_BusSM_ModeIndication with:
           ComMode := COMM_FULL_COMMUNICATION
    06: Call the MainFunction of CanSM to trigger the 2nd recovery.
    07: VP:
        CanSM starts a 2nd bus-off recovery.
        This means CanSM calls the following API functions in defined order:
        1. BswM_CanSM_CurrentState with:
    IF CANSM_ENHANCED_BUSOFF_REPORTING enabled
           CurrentState := CANSM_BSWM_BUS_OFF_L1
    ELSE
           CurrentState := CANSM_BSWM_BUS_OFF
    ENDIF
           Network := 3
        2. Dem_ReportErrorStatus with:
           EventId := CANSM_E_BUS_OFF
           EventStatus := DEM_EVENT_STATUS_PREFAILED
        3. CanIf_SetPduMode with:
           PduModeRequest := CANIF_TX_OFFLINE
           ControllerId := 5
        4. CanIf_SetControllerMode with:
        ControllerMode := CANIF_CS_STARTED
           ControllerId := 5
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00235</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>308</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>703</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_NOCO_FUCO_LATE_IND_SingleNetNoTrcv_DET_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_SingleNetNoTrcv_DET_ON/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>6414</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct transition of communication mode from
    CANSM_BSM_S_NOCOM to CANSM_BSM_S_FULLCOM.
    The first controller mode indication for the mode request is received
    at the same time as the mode request repetition timeout expires.
  
Test Object: 
    Module initialization
  
Test Precondition: 
    - CanSM is in state S_NOCO
    - Test is executed for a configuration with and one without a transceiver
  
Test Execution: 
    01: Call CanSM_RequestComMode with:
        network := &lt;id&gt; of network 0
        ComM_Mode := COMM_FULL_COMMUNICATION.
    IF transceiver is configured
        02: VP:
            CanSM called only the following API function:
            CanIf_SetTrcvMode with:
            TransceiverMode := CANTRCV_TRCVMODE_NORMAL
    ELSE
        02: VP:
            CanSM called only the following API function:
            CanIf_SetControllerMode with:
            ControllerMode := CANIF_CS_STOPPED
    ENDIF
    03: Call the MainFunction of CanSM several times (i.e. one time less than
        CanSMModeRequestRepetitionTime expires)
    IF transceiver is configured
        04: Call CanSM_TransceiverModeIndication with:
            TransceiverId := 3
            TransceiverMode := CANTRCV_TRCVMODE_NORMAL
    ELSE
        04: Call CanSM_ControllerModeIndication with:
            ControllerId := 5
            ControllerMode := CANIF_CS_STOPPED
    ENDIF
    IF transceiver is configured
        05: Prepare the CanIf stub to indicate the requested transceiver mode
            transition from inside the context of CanIf_SetTrcvMode.
    ENDIF
    06: Prepare the CanIf stub to indicate the requested controller mode
        transition from inside the context of CanIf_SetControllerMode.
    07: Call the MainFunction of CanSM (i.e. let CanSMModeRequestRepetitionTime
        expire together with previous mode indication)
    08: VP ():
        CanSM called the following API functions in defined order:
        IF transceiver is configured
            1. CanIf_SetControllerMode with:
               ControllerMode := CANIF_CS_STOPPED
               ControllerId := 5
        ENDIF
        2. CanIf_SetControllerMode with:
           ControllerMode := CANIF_CS_STARTED
           ControllerId := 5
        3. CanIf_SetPduMode with:
           PduModeRequest := CANIF_ONLINE
           ControllerId := 5
           (CanSM.ASR40.BSM.T_PRE_FULLCOM_FULLCOM)
		4. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_FULL_COMMUNICATION
           Network := 3
           (CanSM.ASR40.BSM.T_PRE_FULLCOM_FULLCOM)

        5. ComM_BusSM_ModeIndication with:
           ComMode := COMM_FULL_COMMUNICATION
           (CanSM.ASR40.BSM.T_PRE_FULLCOM_FULLCOM)
    09: Call CanSM_GetCurrentComMode to read the current CanSM mode
        network := &lt;id&gt; of network 0
    10: VP:
        CanSM_GetCurrentComMode return E_OK
    11: VP:
        CanSM is in state COMM_FULL_COMMUNICATION
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSMPreFull.T_S_TRCV_NORMAL_S_CC_STOPPED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>227</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMPreFull.T_S_CC_STOPPED_S_CC_STARTED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>229</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>704</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_BUS_OFF_LATE_BUS_OFF_SingleNetNoTrcv_DET_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_SingleNetNoTrcv_DET_ON/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>6603</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct transition from substate S_BUS_OFF_CHECK
    to substate S_RESTART_CC in state S_FUCO (state FUll COmmunication), if
    the bus-off event is recognized and handled during the main function
    call, during which CanSMBorTimeTxEnsured would expire for the transition
    T_BUS_OFF_PASSIVE.
  
Test Object: 
    Mode transition
  
Test Precondition: 
    - Transition from S_RFUCO to S_FUCO just happened
  
Test Execution: 
    01: Call CanSM_MainFunction several times, i.e. as often, that the next
        call would trigger the transition T_BUS_OFF_PASSIVE.
    02: VP:
        No APIs called
    03: Call CanSM_ControllerBusOff with:
        ControllerId := 5
    04: Call CanSM_MainFunction
    05: VP (CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_RESTART_CC.BusOff,
            CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_RESTART_CC.BusOffL1):
        CanSM called the following API functions in defined order:
        1. BswM_CanSM_CurrentState with:
    IF CANSM_ENHANCED_BUSOFF_REPORTING enabled
           CurrentState := CANSM_BSWM_BUS_OFF_L1
    ELSE
           CurrentState := CANSM_BSWM_BUS_OFF
    ENDIF
           Network := 3
        2. Dem_ReportErrorStatus with:
           EventId := CANSM_E_BUS_OFF
           EventStatus := DEM_EVENT_STATUS_PREFAILED
        3. CanIf_SetPduMode with:
           PduModeRequest := CANIF_TX_OFFLINE
           ControllerId := 5
        4. CanIf_SetControllerMode with:
           ControllerMode := CANIF_CS_STARTED
           ControllerId := 5
    06: Call CanSM_GetCurrentComMode to read the current CanSM mode
        network := &lt;id&gt; of network 0
    07: VP:
        CanSM_GetCurrentComMode return E_OK
    08: VP:
        CanSM is in state COMM_FULL_COMMUNICATION
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_RESTART_CC.BusOff</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>234</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_RESTART_CC.BusOffL1</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>235</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00235</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>308</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>705</internalId></specobject>
    <specobject>
      <id>TS_CANSM_WRONG_INDICATION_SingleNetNoTrcv_DET_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_SingleNetNoTrcv_DET_ON/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>6735</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the behavior of:
    a) an indication done with a wrong controller mode as reaction to CanIf_SetControllerMode
    b) an indication done with a wrong transceiver mode as reaction to CanIf_SetTrcvMode
    In both cases the wrong indication shall be silently ignored.
  
Test Object: 
    Indication APIs CanSM_ControllerModeIndication and CanSM_TransceiverModeIndication.
  
Test Precondition: 
    - CanSM is in state S_NOCO
  
Test Execution: 
    01: Call CanSM_RequestComMode with:
        network := &lt;id&gt; of network 0
        ComM_Mode := COMM_FULL_COMMUNICATION.
    IF transceiver is configured:
        02: Call CanSM_TransceiverModeIndication with:
            TransceiverId := 3
            TransceiverMode := CANTRCV_TRCVMODE_SLEEP
        03: Call the MainFunction of CanSM
        04: VP (CanSM.EB.TransceiverModeIndication.WrongIndication):
            CanSM does not continue its transition (no call to CanIf_SetControllerMode)
        05: Call CanSM_TransceiverModeIndication with:
            TransceiverId := 3
            TransceiverMode := CANTRCV_TRCVMODE_NORMAL
        06: Call the MainFunction of CanSM
    ENDIF
    07: VP (CanSM.EB.TransceiverModeIndication.WrongIndication):
        CanSM continues with transition by calling CanIf_SetControllerMode
    08: Call CanSM_ControllerModeIndication with:
        ControllerId := 5
        ControllerMode := CANIF_CS_UNINIT
    09: Call the MainFunction of CanSM
    10: VP (CanSM.EB.ControllerModeIndication.WrongIndication):
        CanSM does not continue its transition (no further call to CanIf_SetControllerMode)
    11: Call CanSM_ControllerModeIndication with:
        ControllerId := 5
        ControllerMode := CANIF_CS_STOPPED
    12: Call the MainFunction of CanSM
    13: VP (CanSM.EB.ControllerModeIndication.WrongIndication):
        CanSM continues with transition by calling CanIf_SetControllerMode
    14: Continue with the (correct) transition to mode FULLCOM.
    15: VP:
        CanSM reached FULLCOM mode
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.EB.ControllerModeIndication.WrongIndication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>127</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.TransceiverModeIndication.WrongIndication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>706</internalId></specobject>
    <specobject>
      <id>TS_CANSM_STAY_IN_MODE_SingleNetNoTrcv_DET_ON</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_01_SingleNetNoTrcv_DET_ON/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>6872</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks that CanSM silently ignores a mode request
    if the requested mode equals the current state.
  
Test Object: 
    CanSM_RequestComMode
  
Test Precondition: 
    - CanSM is in state S_NOCO
  
Test Execution: 
    01: Call CanSM_RequestComMode with:
        network := &lt;id&gt; of network 0
        ComM_Mode := COMM_NO_COMMUNICATION.
    02: Call the MainFunction of CanSM
    03: VP (CanSM.EB.RequestComMode.NoTransition):
        CanSM does not call any API function
    04: VP (CanSM.EB.RequestComMode.NoTransition):
        CanSM is in state COMM_NO_COMMUNICATION
    05: Enter state COMM_FULL_COMMUNICATION
    06: Call CanSM_RequestComMode with:
        network := &lt;id&gt; of network 0
        ComM_Mode := COMM_FULL_COMMUNICATION.
    07: Call the MainFunction of CanSM
    08: VP (CanSM.EB.RequestComMode.NoTransition):
        CanSM does not call any API function
    09: VP (CanSM.EB.RequestComMode.NoTransition):
        CanSM is in state COMM_FULL_COMMUNICATION
    10: Enter state COMM_SILENT_COMMUNICATION
    11: Call CanSM_RequestComMode with:
        network := &lt;id&gt; of network 0
        ComM_Mode := COMM_SILENT_COMMUNICATION.
    12: Call the MainFunction of CanSM
    13: VP (CanSM.EB.RequestComMode.NoTransition):
        CanSM does not call any API function
    14: VP (CanSM.EB.RequestComMode.NoTransition):
        CanSM is in state COMM_SILENT_COMMUNICATION
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.EB.RequestComMode.NoTransition</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>129</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>707</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANSM_MULT_TRANSITIONS_2NW</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_04_MultiNetMisc/source/application/Tst_Tests.c</sourcefile>
      <sourceline>99</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct handling of state transitions that happen in
    parallel on two networks. It tries to simulate some different timing issues
    like the network with two controllers waiting for one of the controllers.
    Transitions:
    Network 0: NO COM(munication) -&gt; FULL COM -&gt; SILENT COM -&gt; NO COM
               During first transition, a controller mode request repetition
               timeout happens.
    Network 1: NO COM -&gt; FULL COM -&gt; SILENT COM -&gt; FULL COM -&gt; SILENT COM -&gt; NO COM
  
Test Object: 
    Parallel state transitions
  
Test Precondition: 
    - CanSM networks are in state CANSM_BSM_S_NOCOM
    - Network 1 has no transceiver configured while network 0 has one
    - CanSMModeRequestRepetitionTime &gt; 1
    - CanSMModeRequestRepetitionMax &gt;= 1
  
Test Execution: 
    01-15: Mode transition CANSM_BSM_S_NOCOM -&gt; CANSM_BSM_S_FULLCOM for both networks
           . During this time parallel mode indications for both networks as well as mode
           indications for a single network happen. Furthermore a mode
           repetition timeout is triggered for a controller mode request on
           network 0 (compare steps 12 and 13).
    16-18: Mode transition CANSM_BSM_S_FULLCOM -&gt; CANSM_BSM_S_SILENTCOM for both networks.
    19-33: While network 0 performs the transition CANSM_BSM_S_SILENTCOM -&gt; CANSM_BSM_S_NOCOM,
           network 1 performs the following transitions: CANSM_BSM_S_SILENTCOM -&gt;
           CANSM_BSM_S_FULLCOM -&gt; CANSM_BSM_S_SILENTCOM -&gt; CANSM_BSM_S_NOCOM.
           Mode indications are handled in the way, that
           network 1 finishes its transition before the final transitions of
           network 0.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.SWS_CanSM_00266</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>29</internalId></provcov>
        <provcov>
          <linksto>CanSM.Config.SchM_Call_CanSM_ModeIndication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>145</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.BusOffRecovery.RestartCtrl</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>126</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>708</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANSM_BUSDEACTIVATED_SUCCESSFUL_RECOVERY</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_BusDeactivated_BusOff/source/application/Tst_Tests.c.m4</sourcefile>
      <sourceline>102</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct handling of bus-off recovery for a network
    containing 2 underlying CanSMController.
    Only one controller reports bus-off, the other stays fully operational.
    Bus-off recovery shall be correctly performed after the bus communication
    was deactivated.
    The controller in bus-off shall be restarted, the other controller must
    not be restarted.
  
Test Object: 
    Bus-Off recovery for multiple controller per network.
  
Test Precondition: 
    - CanSM networks are in state S_BUS_OFF_CHECK or S_NO_BUS_OFF
    - CanSM networks under test has at least 2 underlying CanSMController
  
Test Execution: 
    01: Simulate a bus-off for one controller.
    02: Call the MainFunction of CanSM to start bus-off recovery.
    03: VP(CanSM.EB.BusOffRecovery.E_OFF.SetPduToOffline, CanSM.EB.BusOffRecovery.E_BUS_OFF.NoCom)
        CanSM called the following API functions in defined order (sanity check):
        1. BswM_CanSM_CurrentState
        2. Dem_ReportErrorStatus
        3. VP(CanSM.EB.BusOffRecovery.E_OFF.SetPduToOffline):
           CanIf_SetPduMode for all controllers of the network
        4. VP(CanSM.EB.BusOffRecovery.E_BUS_OFF.NoCom):
           ComM_BusSM_ModeIndication/SchM_Call (in case of multicore support) with COMM_NO_COMMUNICATION
    04: Elapse L1 recovery time.
    05: VP(CanSM.EB.BusOffRecovery.G_WAIT_TIME_RECOVERY, CanSM.EB.BusOffRecovery.S_RESTART_CC):
        Controller is set to CANIF_CS_STARTED and indication arrives.
    06: Check if controller was restarted.
    07: Check that Pdus were set to CANIF_ONLINE after receiving indication
        that controller was indeed started.
    08: Check that BswM_CanSM_CurrentState was called to inform BswM about CanSM current state.
    09: Check that ComM_BusSM_ModeIndication/SchM_Call (in case of multicore support) was called.
    10: Simulate a bus-off for one controller
    11: Call the MainFunction of CanSM to start bus-off recovery
    12: VP: sanity checks
    13: Set PDU modes for both controllers!
    14: Elapse L1 recovery time
    15: Mode indication is asynchronous
    16: Set controller to CANIF_CS_STARTED
    17: Simulate the controller indication for the restarted controller
    18: Indication that controller was successfully started was received asynchronous
    19: Simulate main function to process the indication
    20: Check that Pdus were set to CANIF_ONLINE after receiving indication
        that controller was indeed started
    21: Check that BswM_CanSM_CurrentState was called to inform BswM about CanSM current state
    22: CanSM successfully completes bus-off recovery
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.EB.BusOffRecovery.E_BUS_OFF.NoCom</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>139</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.BusOffRecovery.E_OFF.SetPduToOffline</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>140</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.BusOffRecovery.G_WAIT_TIME_RECOVERY</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>141</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.BusOffRecovery.S_RESTART_CC</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>142</internalId></provcov>
        <provcov>
          <linksto>CanSM.Config.SchM_Call_CanSM_ModeIndication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>145</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>709</internalId></specobject>
    <specobject>
      <id>TS_CANSM_BUSDEACTIVATED_FAILED_RECOVERY</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_BusDeactivated_BusOff/source/application/Tst_Tests.c.m4</sourcefile>
      <sourceline>334</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct handling of bus-off recovery for a network
    containing 2 underlying CanSMController.
    Only one controller reports bus-off, the other stays fully operational.
    Bus-off recovery shall be correctly performed with the new behavior.
    The controller in bus-off will be set to STARTED, but indication is not received
    and T_REPEAT_MAX will be reached.
  
Test Object: 
    CanSM module does not complete BUS-OFF recovery, because indication that controller was
    successfully started does not arrive.
  
Test Precondition: 
    - CanSM networks are in state S_BUS_OFF_CHECK or S_NO_BUS_OFF
    - CanSM networks under test has at least 2 underlying CanSMController
  
Test Execution: 
    01: Simulate a bus-off for one controller.
    02: Call the MainFunction of CanSM to start bus-off recovery.
    03: VP(CanSM.EB.BusOffRecovery.E_OFF.SetPduToOffline, CanSM.EB.BusOffRecovery.E_BUS_OFF.NoCom)
        CanSM called the following API functions in defined order (sanity check):
        1. BswM_CanSM_CurrentState
        2. Dem_ReportErrorStatus
        3. VP(CanSM.EB.BusOffRecovery.E_OFF.SetPduToOffline):
           CanIf_SetPduMode for all controllers of the network
        4. VP(CanSM.EB.BusOffRecovery.E_BUS_OFF.NoCom):
           ComM_BusSM_ModeIndication/SchM_Call (in case of multicore support) with COMM_NO_COMMUNICATION
    04: Set PDU modes for both controllers!
    05: VP(CanSM.EB.BusOffRecovery.G_WAIT_TIME_RECOVERY, CanSM.EB.BusOffRecovery.S_RESTART_CC):
        Elapse L1 recovery time.
    06: Set the controller to CANIF_CS_STARTED
    07: VP (CanSM.EB.BusOffRecovery.E_BUS_OFF.NoCom):
        Check ComM mode is still COMM_NO_COMMUNICATION
    07: Simulate main function to process the indication.
    08: Trying 10 times to start controllers, but no indication that controllers were successfully
        STARTED arrives and T_REPEAT_MAX will be reached. CanSM does not recover after a bus-off.
    09: Check that CanSM does not recover after a bus-off, because T_REPEAT_MAX is reached,
        no indication that controller was successfully STARTED has arrived
    10: Check that BswM_CanSM_CurrentState was called to inform BswM about CanSM current state
	11: Check that controllers were set to CANIF_CS_STOPPED
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.EB.BusOffRecovery.E_BUS_OFF.NoCom</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>139</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.BusOffRecovery.E_OFF.SetPduToOffline</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>140</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.BusOffRecovery.G_WAIT_TIME_RECOVERY</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>141</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.BusOffRecovery.S_RESTART_CC</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>142</internalId></provcov>
        <provcov>
          <linksto>CanSM.Config.SchM_Call_CanSM_ModeIndication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>145</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>710</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANSM_Distribution_INIT</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_MultiPartitions_Distributed_Init_Functions/source/application/Test.c</sourcefile>
      <sourceline>61</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    This test checks that CanSM will create an init function for every partition referenced by ComM channel
    that associated by CanSM channel, and The state transition of each CanSM network CanSM_DoTransitionSequence() shall be
    assigned to the corresponding CanSM_Init_&lt;SN&gt; based on its ComMChannelPartitionRef, and CAN networks that do not have
    ComMChannelPartitionRef configured shall do the state transition in the generic CanSM_Init().
  
Test Object: 
    Module initialization
  
Test Precondition: 
  
Test Execution: 
    01: Call init function for Partition 0 by calling CanSM_Init_EcucPartition_0().
    02: VP(CanSMDistributedChannels_InitFunctions_StateTransition) make sure that only configured CAN channel
        will be processed TST_CANSM_NETWORK_0_ID.
    03: Call init function for Partition 1 by calling CanSM_Init_EcucPartition_1().
    04: VP(CanSMDistributedChannels_InitFunctions_StateTransition) make sure that only configured CAN channel
        will be processed TST_CANSM_NETWORK_1_ID.
    05: Call generic init function CanSM_Init().
    06: VP(CanSMDistributedChannels_InitFunctions_StateTransition_Generic) make sure that only configured CAN channel
        will be processed TST_CANSM_NETWORK_2_ID.
    07: VP(CanSMDistributedChannels_InitFunctions_Re_Init) Re-Initialize the module.
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.EB.CanSMDistributedChannelInit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>267</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.CanSMDistributedChannelInit_InitFunctions</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>268</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.CanSMDistributedChannels_InitFunctions_Initialization</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>269</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.CanSMDistributedChannels_InitFunctions_Re_Init</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>270</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.CanSMDistributedChannels_InitFunctions_StateTransition</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>271</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.CanSMDistributedChannels_InitFunctions_StateTransition_Generic</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>272</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>711</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANSM_PN_NOPN_MIXED</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_PnNoPnMixed/source/application/Tst_CanSM_Conf_PnNoPnMixed.c</sourcefile>
      <sourceline>85</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the independence of a network with partial network enabled
    from a network with partial network disabled.
    Network 0 (Pn) shall transit its Deinit sequence according to CANSM_BSM_DeinitPnSupported.
    Network 1 (NoPn) shall transit its Deinit sequence according to CANSM_BSM_DeinitPnNotSupported.
    Note: Network 0 is processed first in Mainfunction (fist network in configuration).
  
Test Object: 
    Network independence
  
Test Precondition: 
    - CanSM module is NOT initialized
  
Test Execution: 
    01: Initialize CanSM
    02: VP:
        CanSM called the following API services for the network with partial network
        enabled in defined order:
        1. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_NO_COMMUNICATION
           Network := &lt;ComM channel Id of NW0&gt;
        2. CanIf_ClearTrcvWufFlag with:
           TransceiverId := &lt;Trcv Id of NW 0&gt;
    03: VP:
        CanSM called the following API services for the network with partial network
        disabled in defined order:
        1. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_NO_COMMUNICATION
           Network := &lt;ComM channel Id of NW1&gt;
        2. CanIf_SetControllerMode with:
           ControllerMode := CANIF_CS_STOPPED
           ControllerId := &lt;Controller Id of NW1&gt;
    04: Simulate the outstanding mode indications for both networks
        and trigger the next transition.
    05: VP:
        CanSM called the following API services for the network with partial network
        enabled in defined order:
        1. CanIf_SetControllerMode with:
           ControllerMode := CANIF_CS_STOPPED
           ControllerId := &lt;1st Controller Id of NW0&gt;
        2. CanIf_SetControllerMode with:
           ControllerMode := CANIF_CS_STOPPED
           ControllerId := &lt;2nd Controller Id of NW0&gt;
    06: VP:
        CanSM called the following API services for the network with partial network
        disabled in defined order:
        1. CanIf_SetControllerMode with:
           ControllerMode := CANIF_CS_SLEEP
           ControllerId := &lt;Controller Id of NW1&gt;
    07: Switch the test to synchronous mode indications
    08: Simulate the outstanding mode indications for both networks
        and trigger the next transition.
    09: VP:
        CanSM called the following API services for the network with partial network
        enabled in defined order:
        1. CanIf_SetTrcvMode with:
           TransceiverMode := CANTRCV_TRCVMODE_NORMAL
           TransceiverId := &lt;Trcv Id of NW 0&gt;
        2. CanIf_SetTrcvMode with:
           TransceiverMode := CANTRCV_TRCVMODE_STANDBY
           TransceiverId := &lt;Trcv Id of NW 0&gt;
        3. CanIf_SetControllerMode with:
           ControllerMode := CANIF_CS_SLEEP
           ControllerId := &lt;1st Controller Id of NW0&gt;
        4. CanIf_SetControllerMode with:
           ControllerMode := CANIF_CS_SLEEP
           ControllerId := &lt;2nd Controller Id of NW0&gt;
        5. CanIf_CheckTrcvWakeFlag with:
           TransceiverId := &lt;Trcv Id of NW 0&gt;
    10: VP:
        CanSM does not call further API services for the network with partial network
        disabled (there is no underlying transceiver configured)
    11: Check the communication mode of both networks.
    12: VP:
        CanSM accepts the request and both networks are in state COMM_NO_COMMUNICATION.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.EB.CanSMActivatePN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>105</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.SWS_CanSM_00266</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>29</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>712</internalId></specobject>
    <specobject>
      <id>TS_CANSM_INDEP_MODE_IND</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Conformance/IN/CanSM_Conf_PnNoPnMixed/source/application/Tst_CanSM_Conf_PnNoPnMixed.c</sourcefile>
      <sourceline>285</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the independence of mode indications for two networks.
    Mode indications shall be simulated in different stage of the mode
    repetition counter.
  
Test Object: 
    Network independence
  
Test Precondition: 
    - CanSM module is NOT initialized
    - Both networks are in state CANSM_BSM_S_NOCOM
  
Test Execution: 
    01: Request COMM_FULL_COMMUNICATION for both networks.
    02: Let the mode repetition timer expire (the initial calls of transition
        to COMM_FULL_COMMUNICATION are not subject of this test and need not
        to be checked.
    03: VP:
        CanSM repeated its mode requests after the expired timer and called the
        following API function in defined order:
        1. CanIf_SetTrcvMode with:
           TransceiverMode := CANTRCV_TRCVMODE_NORMAL
           TransceiverId := &lt;Trcv Id of NW 0&gt;
        2. CanIf_SetControllerMode (no underlying transceiver!) with:
           ControllerMode := CANIF_CS_STOPPED
           ControllerId := &lt;Controller Id of NW1&gt;
    04: Simulate the outstanding transceiver indication and trigger next transition.
    05: VP:
        CanSM continues the transition for the network with partial networking and called the
        following API function 2 times:
        2x CanIf_SetControllerMode with:
        ControllerMode := CANIF_CS_STOPPED
        ControllerId := &lt;Controller Ids of NW0&gt;
    06: Simulate the outstanding controller indications and trigger next transition.
    07: VP:
        CanSM continues the transition for the network with partial networking and called the
        following API function 2 times:
        2x CanIf_SetControllerMode with:
        ControllerMode := CANIF_CS_STARTED
        ControllerId := &lt;Controller Ids of NW0&gt;
    08: The mode repetition timers of both networks have different values now.
        Timer of NW0 was reset in step 06 (transition),
        timer of NW1 was reset in step 02 (retry).
        Let the repetition timer of NW1 expire.
    09: VP:
        CanSM repeated the mode request for the network without partial networking and
        called the following API function:
        CanIf_SetControllerMode with:
           ControllerMode := CANIF_CS_STOPPED
        ControllerId := &lt;Controller Ids of NW1&gt;
    10: Simulate the outstanding controller indication from the previous step
        and trigger next transition.
    11: VP:
        CanSM continues the transition for the network without partial networking and
        called the following API function:
        CanIf_SetControllerMode with:
        ControllerMode := CANIF_CS_STARTED
        ControllerId := &lt;Controller Ids of NW1&gt;
    12: The mode repetition timers of both networks have different values now.
        Timer of NW0 was reset in step 06 (transition),
        timer of NW1 was reset in step 10 (transition).
        Let the repetition timer of NW0 expire.
    13: VP:
        CanSM repeated the mode request for the network with partial networking and
        called the following API function 2times:
        CanIf_SetControllerMode with:
        ControllerMode := CANIF_CS_STARTED
        ControllerId := &lt;Controller Ids of NW0&gt;
    14: Simulate the outstanding controller indication of ONLY ONE controller of NW0.
    15: Let the repetition timer of NW0 expire.
    16: VP:
        CanSM repeated the mode request for the network with partial networking and
        called the following API function ONCE:
        CanIf_SetControllerMode with:
        ControllerMode := CANIF_CS_STARTED
        ControllerId := &lt;Outstanding controller Id of NW0&gt;
        CanSM repeated the mode request for the network without partial networking and
        called the following API function:
        CanIf_SetControllerMode with:
        ControllerMode := CANIF_CS_STARTED
        ControllerId := &lt;Controller Ids of NW1&gt;
    17: Simulate the outstanding controller indications of both networks and
        continue transition to FULLCOM.
    18: VP:
        Check if FULLCOM is reached for both networks.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.SWS_CanSM_00266</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>29</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>713</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANSM_MAIN_INTERRUPTION</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Implementation/IN/CanSM_ImpTest_MainfunctionInterruption/source/application/Appl.c</sourcefile>
      <sourceline>97</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the interruption of a Mainfunction by CanSM_RequestComMode().
    The test subject is concurrent transition to S_SICO (triggered by CanSM_RequestComMode)
    and S_NO_BUS_OFF (initiated by Mainfunction).
    --------------------------------------------
    During the Mainfunction CanSM following sequence shall happen:
    - CanSM in state S_BUS_OFF_CHECK
    - the trigger for transition to S_NO_BUS_OFF occurs
    - CanSM prepares to make this transition
    *** now the interruption by CanSM_RequestComMode occurs ****
    - CanSM_RequestComMode requests a transition to silent communication.
    - Mainfunction locks the transition. Transition to S_NO_BUS_OFF takes place.
    - Transition to SICO is "queued" and performed with the next Mainfunction cycle.
  
Test Object: 
    Concurrency transition to state S_SICO and S_NO_BUS_OFF
  
Test Precondition: 
    - CanSM is initialized
    - CanSMBorTxConfirmationPolling enabled (configuration constraint)
    - CanSM is in state S_FUCO, substate S_BUS_OFF_CHECK
  
Test Execution: 
    01: Prepare to code stub of CanIf_GetTxConfirmationState():
        The function shall return CANIF_TX_RX_NOTIFICATION for all controller.
    02: Prepare the code stub callout function of CanIf_GetTxConfirmationState():
        The callout function shall initiate following function call ONCE:
        CanSM_RequestComMode with ComM_Mode := COMM_SILENT_COMMUNICATION
    03: Trigger CanSM Mainfunction.
    04: VP (CanSM.EB.ComMMode):
        CanSM shall make a transition towards S_NO_BUS_OFF.
    05: Trigger CanSM Mainfunction.
    06: VP (CanSM.ASR40.BSM.T_FULLCOM_SILENTCOM.1):
        CanSM shall make a transition to SICO.
        This means CanSM shall call the following API service:
        1. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_SILENT_COMMUNICATION
        2. CanIf_SetPduMode with:
           PduModeRequest := CANIF_TX_OFFLINE
        3. ComM_BusSM_ModeIndication with:
           ComMode := COMM_SILENT_COMMUNICATION
    07: Call CanSM_GetCurrentComMode to read the current CanSM mode
    08: VP (CanSM.ASR40.BSM.T_FULLCOM_SILENTCOM.1):
        CanSM_GetCurrentComMode return E_OK
    09: VP (CanSM.ASR40.BSM.T_FULLCOM_SILENTCOM.1):
        CanSM is in state COMM_SILENT_COMMUNICATION
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.EB.ComMMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>135</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>714</internalId></specobject>
    <specobject>
      <id>TS_CANSM_ONGOING_TRANSITION</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Implementation/IN/CanSM_ImpTest_MainfunctionInterruption/source/application/Appl.c</sourcefile>
      <sourceline>213</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks that all API function which can trigger a transition
    do nothing if the TransitionOngoing flag is set in the runtime config
    structure.
    The functions are:
    - CanSM_RequestComMode
    - CanSM_TxTimeoutException
    - CanSM_SetBaudrate
    - CanSM_MainFunction
    In the second part of the test the flag is reset and the listed functions
    are called again.
  
Test Object: 
    Lock of synchronous transitions
  
Test Precondition: 
    CanSM is in state S_BUS_OFF_CHECK and one MainFunction away from
    switching to state S_NO_BUS_OFF
  
Test Execution: 
    01: Lock the ransitionOngoing flag to simulate that there is a transition
        ongoing.
    02: VP:
        Check that a MainFunction call does not trigger a transition to
        S_NO_BUF_OFF (nor any other transition)
    03: Proceed to state S_NO_BUS_OFF
    04: VP:
        Check that a CanSM_RequestComMode call does not trigger any transition
    05: VP:
        Check that a CanSM_TxTimeoutException call does not trigger any transition
    06: VP:
        Check that a CanSM_SetBaudrate call does not trigger any transition
    07: reset the ransitionOngoing flag
    08: VP:
        Check that a CanSM_TxTimeoutException call performs Tx-Timeout-Exception
        handling now
    09: VP:
        Check that a CanSM_SetBaudrate call changes the baud rate now
    10: VP:
        Check that a CanSM_RequestComMode call triggers a mode change now
    11: VP:
        Check that a CanSM_MainFunction call continue a asynchronous transition
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.EB.ComMMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>135</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>715</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANSM_40027</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_CompileCommon/source/application/Application.c</sourcefile>
      <sourceline>21</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    DET: on
    Multiple networks: yes
    Consecutive network handles: no
    Multiple controllers per network: yes
    Networks without transceivers: no
    CanSMSetBaudrateApi: enabled
  
Test Object: 
    Compile test
  
Test Precondition: 
    Configuration as described
  
Test Execution: 
    Compile
  
Test Input: 
    na
  
Test Output: 
    Compiles successfully
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.SWS_CanSM_00252</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>26</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00023</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>293</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00024</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>294</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00062</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>295</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00063</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>296</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00064</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>297</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00065</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>298</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00561</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>457</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00569</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>458</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>716</internalId></specobject>
    <specobject>
      <id>TS_CANSM_40029</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_CompileCommon/source/application/Application.c</sourcefile>
      <sourceline>66</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    DET: off
    Multiple networks: yes
    Consecutive network handles: no
    Multiple controllers per network: yes
    Networks without transceivers: no
  
Test Object: 
    Compile test
  
Test Precondition: 
    Configuration as described
    No Det code stub provided
  
Test Execution: 
    Compile
  
Test Input: 
    na
  
Test Output: 
    compiles successfully
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.SWS_CanSM_00252</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>26</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>717</internalId></specobject>
    <specobject>
      <id>TS_CANSM_40031</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_CompileCommon/source/application/Application.c</sourcefile>
      <sourceline>103</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    DET: on
    Multiple networks: no
    Consecutive network handles: n.a.
    Multiple controllers per network: yes
    Networks without transceivers: no
  
Test Object: 
    Compile test
  
Test Precondition: 
    Configuration as described
  
Test Execution: 
    Compile
  
Test Input: 
    na
  
Test Output: 
    Compiles successfully
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.SWS_CanSM_00252</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>26</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>718</internalId></specobject>
    <specobject>
      <id>TS_CANSM_40033</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_CompileCommon/source/application/Application.c</sourcefile>
      <sourceline>139</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    DET: on
    Multiple networks: no
    Consecutive network handles: n.a.
    Multiple controllers per network: no
    Networks without transceivers: no
  
Test Object: 
    Compile test
  
Test Precondition: 
    Configuration as described
  
Test Execution: 
    Compile
  
Test Input: 
    na
  
Test Output: 
    Compiles successfully
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.SWS_CanSM_00252</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>26</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>719</internalId></specobject>
    <specobject>
      <id>TS_CANSM_40035</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_CompileCommon/source/application/Application.c</sourcefile>
      <sourceline>175</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    DET: on
    Multiple networks: yes
    Consecutive network handles: no
    Multiple controllers per network: no
    Networks without transceivers: no
  
Test Object: 
    Compile test
  
Test Precondition: 
    Configuration as described
  
Test Execution: 
    Compile
  
Test Input: 
    na
  
Test Output: 
    Compiles successfully
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.SWS_CanSM_00252</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>26</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>720</internalId></specobject>
    <specobject>
      <id>TS_CANSM_40039</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_CompileCommon/source/application/Application.c</sourcefile>
      <sourceline>211</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    DET: on
    Multiple networks: yes
    Consecutive network handles: yes
    Multiple controllers per network: no
    Networks without transceivers: yes
  
Test Object: 
    Compile test
  
Test Precondition: 
    Configuration as described
  
Test Execution: 
    Compile
  
Test Input: 
    na
  
Test Output: 
    Compiles successfully
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.SWS_CanSM_00252</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>26</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>721</internalId></specobject>
    <specobject>
      <id>TS_CANSM_40041</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_CompileCommon/source/application/Application.c</sourcefile>
      <sourceline>247</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    DET: on
    Multiple networks: yes
    Consecutive network handles: yes
    Multiple controllers per network: yes
    Networks without transceivers: no
  
Test Object: 
    Compile test
  
Test Precondition: 
    Configuration as described
  
Test Execution: 
    Compile
  
Test Input: 
    na
  
Test Output: 
    Compiles successfully
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.EB.CanIf_GetTxConfirmationState.Optional</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>113</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>722</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANSM_30012</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conf_Bor_MultiNet/source/application/test_30012.c</sourcefile>
      <sourceline>132</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test bus off recovery, Several networks (valid)
    Use uniform/semi-uniform bus-off recovery timer/counter parameters for each network
    Synchronous trcv/ctrl mode indications
    Step through network state machines
    Test bus off counter limit 255
  
Test Object: 
    Bus off recovery state machine
  
Test Precondition: 
    Module uninit
    5 networks configured, one to five controllers per net (ref below as net1 .. net5,
      ctrl1 ..ctrl5)
    Timer/counter settings: (index omitted for brevity)
    - CANSM_BOR_TIME_TX_ENSURED
    - CANSM_BOR_TIME_L1
    - CANSM_BOR_COUNTER_L1_TO_L2
    - CANSM_BOR_TIME_L2
    - CANSM_BOR_TX_CONFIRMATION_POLLING
  
Test Execution: 
    Call CanSM_Init()

    For each net, execute the following steps, using net-specific timer/counter settings:

    The test steps for all nets are executed in parallel.
    CanSM_MainFunction() invocations are not network specific; each CanSM_MainFunction() invocation causes progress
      for all nets.

    Stage 1: In each invocation, call CanSM_RequestComMode() with mode COMM_FULL_COMMUNICATION for
      a network

    Stage 2: Get to L1:
    - net1:
      -- Call CanSM_MainFunction() &amp;lt; CANSM_BOR_TIME_TX_ENSURED+1 times
      -- Call CanSM_ControllerBusOff() with valid controller ID for the net
    - all other nets:
      -- Call CanSM_MainFunction() a specific number of times (tick without bus off until state change)
         -- Call it CANSM_BOR_TIME_TX_ENSURED+1 times if CANSM_BOR_TX_CONFIRMATION_POLLING is false,
            else an arbitrary number of times
      -- Let CanIf_GetTxConfirmationState() for current net return CANIF_TX_RX_NOTIFICATION only on
         last invocation
      -- Call CanSM_ControllerBusOff() with valid controller ID for the net

    Stage 3: Cycle through the following:
    (until L2 reached for all nets except net3, for net3 until L2 would be reached on another
      bus-off)
    - Call CanSM_MainFunction() CANSM_BOR_TIME_L1+1 times (tick without bus off until state change)
    - Call CanSM_MainFunction() &amp;lt; CANSM_BOR_TIME_TX_ENSURED times (tick without bus off but no state
      change)
    - Call CanSM_ControllerBusOff() with valid controller ID (state change)
    For net3:
    - Call CanSM_MainFunction() CANSM_BOR_TIME_L1+1 times (tick without bus off until state change)

    Stage 4:
    For net2 and net5 cycle through the following until ERR reached (DEM reported):
    - Call CanSM_MainFunction() CANSM_BOR_TIME_L2+1 times (tick without bus off until state change)
    - Call CanSM_MainFunction() &amp;lt; CANSM_BOR_TIME_TX_ENSURED times
    - Call CanSM_ControllerBusOff() with valid controller ID for net 2 and net 5 (state change)

    Stage 5:
    For net1, net2, net4 and net5:
    - Call CanSM_MainFunction() CANSM_BOR_TIME_L2+1 times (tick without bus off until state change)
    For all nets:
    - Call CanSM_MainFunction() a specific number of times (tick without bus off until state change)
      -- Call it CANSM_BOR_TIME_TX_ENSURED times if CANSM_BOR_TX_CONFIRMATION_POLLING is false,
         else an arbitrary number of times
      -- Let CanIf_GetTxConfirmationState() for current net return CANIF_TX_RX_NOTIFICATION only on
         last invocation

    Stage 6: Terminate SM for each net
    - Call CanSM_RequestComMode() with mode NOT equal to COMM_FULL_COMMUNICATION (disable bus off
      recovery SM)
    - Call CanSM_GetCurrentComMode() for configured network handle
  
Test Input: 
    na
  
Test Output: 
    Return value: E_OK for each call
    While state machine is in state S_FUCO:
      - No stubs listed in Tst_CanSM_ValidateGlobalReferences() are called unless listed here

    Stage 1:
    All nets:
    - transition to full communication (not tested here)

    Stage 2: Get to L1:
    - net 1:
      -- On bus off:
        &gt; CanIf_SetControllerMode with mode CANIF_CS_STARTED called
        &gt; CanIf_SetPduMode with mode CANIF_TX_OFFLINE called
        &gt; ComM_BusSM_ModeIndication with mode COMM_SILENT_COMMUNICATION called
        &gt; BswM_CanSM_CurrentState with mode CANSM_BSWM_BUS_OFF called
    - all other nets:
      -- DEM called with status DEM_EVENT_STATUS_PASSED
      -- On bus off:
        &gt; CanIf_SetControllerMode with mode CANIF_CS_STARTED called
        &gt; CanIf_SetPduMode with mode CANIF_TX_OFFLINE called
        &gt; ComM_BusSM_ModeIndication with mode COMM_SILENT_COMMUNICATION called
        &gt; BswM_CanSM_CurrentState with mode CANSM_BSWM_BUS_OFF called

    Stage 3:
    - On CANSM_BOR_TIME_L1+1 ticks:
      -- CanIf_SetPduMode with mode CANIF_TX_ONLINE called
      -- ComM_BusSM_ModeIndication with mode COMM_FULL_COMMUNICATION called
      -- BswM_CanSM_CurrentState with mode CANSM_BSWM_FULL_COMMUNICATION called
    - On bus off:
      -- CanIf_SetControllerMode with mode CANIF_CS_STARTED called
      -- CanIf_SetPduMode with mode CANIF_TX_OFFLINE called
      -- ComM_BusSM_ModeIndication with mode COMM_SILENT_COMMUNICATION called
      -- BswM_CanSM_CurrentState with mode CANSM_BSWM_BUS_OFF called
    For net3:
    - On CANSM_BOR_TIME_L1+1 ticks:
      -- CanIf_SetPduMode with mode CANIF_TX_ONLINE called
      -- ComM_BusSM_ModeIndication with mode COMM_FULL_COMMUNICATION called
      -- BswM_CanSM_CurrentState with mode CANSM_BSWM_FULL_COMMUNICATION called

    Stage 4:
    For net2 and net5:
    - On CANSM_BOR_TIME_L2+1 ticks:
      -- CanIf_SetPduMode with mode CANIF_TX_ONLINE called
      -- ComM_BusSM_ModeIndication with mode COMM_FULL_COMMUNICATION called
      -- BswM_CanSM_CurrentState with mode CANSM_BSWM_FULL_COMMUNICATION called
    - On bus off:
      -- Dem_reportErrorStatus with status DEM_EVENT_STATUS_PREFAILED called
      -- CanIf_SetControllerMode with mode CANIF_CS_STARTED called
      -- CanIf_SetPduMode with mode CANIF_TX_OFFLINE called
      -- ComM_BusSM_ModeIndication with mode COMM_SILENT_COMMUNICATION called
      -- BswM_CanSM_CurrentState with mode CANSM_BSWM_BUS_OFF called

    Stage 5:
    For net1, net2, net4 and net5:
    - On CANSM_BOR_TIME_L2+1 ticks:
      -- CanIf_SetPduMode with mode CANIF_TX_ONLINE called
      -- ComM_BusSM_ModeIndication with mode COMM_FULL_COMMUNICATION called
      -- BswM_CanSM_CurrentState with mode CANSM_BSWM_FULL_COMMUNICATION called
    For all nets:
    - On CANSM_BOR_TIME_TX_ENSURED ticks or after CanIf_GetTxConfirmationState stub returned
      CANIF_TX_RX_NOTIFICATION:
      -- DEM called with status DEM_EVENT_STATUS_PASSED

    Stage 6:
    - CanSM_GetCurrentComMode returns ComM_ModeType = COMM_SILENT_COMMUNICATION
    - CanIf_GetTxConfirmationState called only for controllers of networks with
      BorTxConfirmationPolling = 'true'
    - No calls to Det_ReportError
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.SWS_CanSM_00266</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>29</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00235</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>308</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>723</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANSM_30000</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance/source/application/Tests.c</sourcefile>
      <sourceline>55</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
  
Test Description: 
    TS_CANSM_30000 Test API function GetVersionInfo()
    Call before initialisation
    Call with null pointer
    Call after initialisation
  
Test Object: 
    GetVersionInfo()
  
Test Precondition: 
    Module uninit
    Configuration parameter CanSMVersionInfoApi enabled
  
Test Execution: 
    01: Call CanSM_GetVersionInfo() with pointer to VersionInfo structure
    02: VP (CanSM.ASR40.CANSM244):
        VersionInfo structure contains valid version info
    03: VP (CanSM.ASR40.CANSM244):
        No report to DET
    04: Call CanSM_Init()
    05: If Det enabled, call CanSM_GetVersionInfo() with null pointer
    06: VP (CanSM.ASR40.CANSM374):
        CanSM_GetVersionInfo() reports DET CANSM_E_PARAM_POINTER
    07: Call CanSM_GetVersionInfo() with pointer to VersionInfo structure
    08: VP (CanSM.ASR40.CANSM244):
        VersionInfo structure contains valid version info
    09: VP (CanSM.ASR40.CANSM244):
        No report to DET
  
Test Input: 
    - Det enabled/disabled
    - Single/multiple networks
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.SWS_CanSM_00244</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>25</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00374</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>319</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>724</internalId></specobject>
    <specobject>
      <id>TS_CANSM_30002</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance/source/application/Tests.c</sourcefile>
      <sourceline>219</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test API function GetCurrentComMode() (validation)
    - Call before initialisation
    - Call before initial transition is finished
    - Call with invalid network handle
    - Call with null pointer
    - Call with valid parameters
  
Test Object: 
    GetCurrentComMode()
  
Test Precondition: 
    Module uninit
  
Test Execution: 
    01: Initialize CanIf_SetTrcvMode stub callout for synchronous mode indications
    02: Call CanSM_GetCurrentComMode() with valid network handle, valid pointer
    03: VP (CanSM.ASR40.CANSM188, CanSM.ASR40.CANSM282):
        CanSM_GetCurrentComMode() returns E_NOT_OK
    04: VP (CanSM.ASR40.CANSM188):
        CanSM_GetCurrentComMode() reports DET error CANSM_E_UNINIT
    05: Call CanSM_Init() with valid config pointer as parameter
        Remark: Since test does not provide controller mode indications when CanSM_Init() is called,
        CanSM will remain in state S_RNOCO
    06: Call CanSM_GetCurrentComMode() with valid network handle, valid pointer
    07: VP (CanSM.ASR40.CANSM282):
        CanSM_GetCurrentComMode() returns E_NOT_OK
    08: VP (CanSM.ASR40.CANSM282):
        CanSM_GetCurrentComMode() does not report to DET (no DET error applicable)
    09: Initialize CanIf_SetControllerMode stub callout for synchronous mode indications
    10: Call respective CanSM_ControllerModeIndication() for each previous
        CanIf_SetControllerMode() call
    11: Call CanSM_MainFunction()
        Remark: Since test now provides all expected controller mode indications, CanSM moves to
        state S_NOCO
    12: Call CanSM_GetCurrentComMode() with invalid network handle, valid pointer
    13: VP (CanSM.ASR40.CANSM372):
        CanSM_GetCurrentComMode() returns E_NOT_OK
    14: VP (CanSM.ASR40.CANSM187):
        CanSM_GetCurrentComMode() reports DET error CANSM_E_INVALID_NETWORK_HANDLE
    15: If Det enabled: Call CanSM_GetCurrentComMode() with valid network handle, null pointer
    16: VP (CanSM.ASR40.CANSM360):
        If Det enabled: CanSM_GetCurrentComMode() returns E_NOT_OK
    17: VP (CanSM.ASR40.CANSM360):
        CanSM_GetCurrentComMode() reports DET error CANSM_E_PARAM_POINTER
    18: Call CanSM_GetCurrentComMode() with valid network handle, valid pointer
    19: VP (CanSM.ASR40.CANSM282, CanSM.ASR40.CANSM360):
        CanSM_GetCurrentComMode() returns E_OK
    20: VP (CanSM.ASR40.CANSM187, CanSM.ASR40.CANSM188, CanSM.ASR40.CANSM360)
        CanSM_GetCurrentComMode() does not report to DET
  
Test Input: 
    - Det enabled/disabled
    - Single/multiple networks
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00372</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>318</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.SWS_CanSM_00282</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>30</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00187</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>304</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00188</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>305</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00360</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>314</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>725</internalId></specobject>
    <specobject>
      <id>TS_CANSM_30003</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance/source/application/Tests.c</sourcefile>
      <sourceline>456</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test API function GetCurrentComMode() (valid, single net)
  
Test Object: 
    GetCurrentComMode()
  
Test Precondition: 
    Module uninit
  
Test Execution: 
    01: Initialize CanIf stub callouts for synchronous mode indications
    02: Call CanSM_Init() with NULL_PTR as parameter
    03: Call CanSM_GetCurrentComMode() for each network handle
    04: VP (CanSM.SWS_CanSM_00371):
        CanSM_GetCurrentComMode() returns E_OK
    05: VP (CanSM.SWS_CanSM_00371):
        CanSM_GetCurrentComMode() does not report to DET
  
Test Input: 
    - Det enabled/disabled
    - Single/multiple networks
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00371</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>317</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>726</internalId></specobject>
    <specobject>
      <id>TS_CANSM_30004</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance/source/application/Tests.c</sourcefile>
      <sourceline>550</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test API function RequestComMode() (validation)
    - Call before initialisation
    - Call before initial transition is finished
    - Call with invalid network handle
    - Call with invalid Com Mode
    - Call with valid parameters
  
Test Object: 
    RequestComMode()
  
Test Precondition: 
    Module uninit
  
Test Execution: 
    01: Initialize CanIf_SetTrcvMode stub callout for synchronous mode indications
    02: Call CanSM_RequestComMode() with valid network handle
    03: VP (CanSM.ASR40.CANSM278):
        CanSM_RequestComMode() returns E_NOT_OK
    04: VP (CanSM.ASR40.CANSM184):
        CanSM_RequestComMode() reports DET CANSM_E_UNINIT
    05: Call CanSM_Init() with NULL_PTR as parameter
        Remark: Since test does not provide controller mode indications when CanSM_Init() is called,
        CanSM will remain in state S_RNOCO
    06: Initialize CanIf_SetControllerMode stub callout for synchronous mode indications
    07: Call respective CanSM_ControllerModeIndication() for each previous
        CanIf_SetControllerMode() call
    08: Call CanSM_MainFunction()
        Remark: Since test now provides all expected controller mode indications, CanSM moves to
        state S_NOCO
    09: Call CanSM_RequestComMode() with invalid network handle
    10: VP (CanSM.ASR40.CANSM370):
        CanSM_RequestComMode() returns E_NOT_OK
    11: VP (CanSM.ASR40.CANSM183):
        CanSM_RequestComMode() reports DET CANSM_E_INVALID_NETWORK_HANDLE
    12: Call CanSM_RequestComMode() with invalid Com Mode
    13: VP (CanSM.EB.RequestComMode.InvalidMode):
        CanSM_RequestComMode() returns E_NOT_OK
    14: VP (CanSM.ASR40.CANSM403):
        CanSM_RequestComMode() reports DET CANSM_E_INVALID_COMM_REQUEST.
    15: Call CanSM_RequestComMode() with valid network handle
    16: VP (CanSM.SWS_CanSM_00369):
        CanSM_RequestComMode() returns E_OK
    17: VP (CanSM.SWS_CanSM_00369):
        CanSM_RequestComMode() does not report to Det
  
Test Input: 
    - Det enabled/disabled
    - Single/multiple networks
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00369</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>315</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00278</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>311</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00370</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>316</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00183</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>301</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00184</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>302</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00424</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>341</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.SWS_CanSM_00403</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>50</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.RequestComMode.InvalidMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>130</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>727</internalId></specobject>
    <specobject>
      <id>TS_CANSM_CONTROLLERMODEINDICATION</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance/source/application/Tests.c</sourcefile>
      <sourceline>776</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test requirements on API CanSM_ControllerModeIndication
  
Test Object: 
    CanSM_ControllerModeIndication
  
Test Precondition: 
    First test case in test sequence
  
Test Execution: 
    01: If Det enabled, call CanSM_ControllerModeIndication with valid ControllerId
    02: VP (CanSM.ASR40.CANSM398)
        CanSM_ControllerModeIndication reports DET CANSM_E_UNINIT
    03: Call CanSM_Init
    04: Call CanSM_ControllerModeIndication with valid ControllerId
    05: VP (CanSM.ASR40.CANSM397, CanSM.ASR40.CANSM398):
        CanSM_ControllerModeIndication does not report to Det
    06: If Det enabled, call CanSM_ControllerModeIndication with invalid ControllerId
    07: VP (CanSM.ASR40.CANSM397):
        CanSM_ControllerModeIndication reports DET CANSM_E_PARAM_CONTROLLER
  
Test Input: 
    - Det enabled/disabled
    - Single/multiple networks
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00397</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>322</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00398</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>323</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>728</internalId></specobject>
    <specobject>
      <id>TS_CANSM_TRANSCEIVERMODEINDICATION</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance/source/application/Tests.c</sourcefile>
      <sourceline>854</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test requirements on API CanSM_TransceiverModeIndication
  
Test Object: 
    CanSM_TransceiverModeIndication
  
Test Precondition: 
    First test case in test sequence
  
Test Execution: 
    01: If Det enabled, call CanSM_TransceiverModeIndication with valid TransceiverId
    02: VP (CanSM.ASR40.CANSM401)
        CanSM_TransceiverModeIndication reports DET CANSM_E_UNINIT
    03: Call CanSM_Init
    04: Call CanSM_TransceiverModeIndication with valid TransceiverId
    05: VP (CanSM.ASR40.CANSM400, CanSM.ASR40.CANSM401):
        CanSM_TransceiverModeIndication does not report to Det
    06: If Det enabled, call CanSM_TransceiverModeIndication with invalid TransceiverId
    07: VP (CanSM.ASR40.CANSM400):
        CanSM_TransceiverModeIndication reports DET CANSM_E_PARAM_TRANSCEIVER
  
Test Input: 
    - Det enabled/disabled
    - Single/multiple networks
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00400</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>325</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00401</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>326</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>729</internalId></specobject>
    <specobject>
      <id>TS_CANSM_DET_ERROR_VALUE</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance/source/application/Tests.c</sourcefile>
      <sourceline>932</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test data type of DET error id value.
  
Test Object: 
    DET Error Id Value
  
Test Precondition: 
  
Test Execution: 
    01: VP (CanSM.ASR40.SWS_CanSM_00069.Type):
        Check for the value of all DET error codes using macros.
  
Test Input: 
    - Det enabled/disabled
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.SWS_CanSM_00069.Type</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>250</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>730</internalId></specobject>
    <specobject>
      <id>TS_CANSM_CLEARTRCVWUFFLAGINDICATION</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance/source/application/Tests.c</sourcefile>
      <sourceline>983</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test requirements on API CanSM_ClearTrcvWufFlagIndication
  
Test Object: 
    CanSM_ClearTrcvWufFlagIndication
  
Test Precondition: 
    First test case in test sequence
  
Test Execution: 
    01: If Det enabled, call CanSM_ClearTrcvWufFlagIndication with valid TransceiverId
    02: VP (CanSM.ASR40.CANSM414)
        CanSM_ClearTrcvWufFlagIndication reports DET CANSM_E_UNINIT
    03: Call CanSM_Init
    04: Call CanSM_ClearTrcvWufFlagIndication with valid TransceiverId
    05: VP (CanSM.ASR40.CANSM415, CanSM.ASR40.CANSM414):
        CanSM_ClearTrcvWufFlagIndication does not report to Det
    06: If Det enabled, call CanSM_ClearTrcvWufFlagIndication with invalid TransceiverId
    07: VP (CanSM.ASR40.CANSM415):
        CanSM_ClearTrcvWufFlagIndication reports DET CANSM_E_PARAM_TRANSCEIVER
  
Test Input: 
    - Det enabled/disabled
    - Single/multiple networks
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00414</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>331</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00415</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>332</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>731</internalId></specobject>
    <specobject>
      <id>TS_CANSM_CHECKTRANSCEIVERWAKEFLAGINDICATION</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance/source/application/Tests.c</sourcefile>
      <sourceline>1061</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test requirements on API CanSM_CheckTransceiverWakeFlagIndication
  
Test Object: 
    CanSM_CheckTransceiverWakeFlagIndication
  
Test Precondition: 
    First test case in test sequence
  
Test Execution: 
    01: If Det enabled, call CanSM_CheckTransceiverWakeFlagIndication with valid TransceiverId
    02: VP (CanSM.ASR40.CANSM417)
        CanSM_CheckTransceiverWakeFlagIndication reports DET CANSM_E_UNINIT
    03: Call CanSM_Init
    04: Call CanSM_CheckTransceiverWakeFlagIndication with valid TransceiverId
    05: VP (CanSM.ASR40.CANSM418, CanSM.ASR40.CANSM417):
        CanSM_CheckTransceiverWakeFlagIndication does not report to Det
    06: If Det enabled, call CanSM_CheckTransceiverWakeFlagIndication with invalid TransceiverId
    07: VP (CanSM.ASR40.CANSM418):
        CanSM_CheckTransceiverWakeFlagIndication reports DET CANSM_E_PARAM_TRANSCEIVER
  
Test Input: 
    - Det enabled/disabled
    - Single/multiple networks
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00417</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>334</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00418</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>335</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>732</internalId></specobject>
    <specobject>
      <id>TS_CANSM_CONFIRMPNAVAILABILITY</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance/source/application/Tests.c</sourcefile>
      <sourceline>1139</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test requirements on API CanSM_ConfirmPnAvailability
  
Test Object: 
    CanSM_ConfirmPnAvailability
  
Test Precondition: 
    First test case in test sequence
  
Test Execution: 
    01: If Det enabled, call CanSM_ConfirmPnAvailability with valid TransceiverId
    02: VP (CanSM.ASR40.CANSM420)
        CanSM_ConfirmPnAvailability reports DET CANSM_E_UNINIT
    03: Call CanSM_Init
    04: Call CanSM_ConfirmPnAvailability with valid TransceiverId
    05: VP (CanSM.ASR40.CANSM422):
        verify if call to CanNm_ConfirmPnAvailability is made
    06: VP (CanSM.ASR40.CANSM422):
        CanSM uses the channel handle of the network where the underlying
        TransceiverId belongs to as parameter for CanNm_ConfirmPnAvailability().
    07: VP (CanSM.ASR40.CANSM421, CanSM.ASR40.CANSM420):
        CanSM_ConfirmPnAvailability does not report to Det
    08: If Det enabled, call CanSM_ConfirmPnAvailability with invalid TransceiverId
    09: VP (CanSM.ASR40.CANSM421):
        CanSM_ConfirmPnAvailability reports DET CANSM_E_PARAM_TRANSCEIVER
  
Test Input: 
    - Det enabled/disabled
    - Single/multiple networks
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00420</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>337</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00421</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>338</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00422</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>339</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>733</internalId></specobject>
    <specobject>
      <id>TS_CANSM_TXTIMEOUTEXCEPTION</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance/source/application/Tests.c</sourcefile>
      <sourceline>1231</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test requirements on API CanSM_TxTimeoutException
  
Test Object: 
    CanSM_TxTimeoutException
  
Test Precondition: 
    First test case in test sequence
  
Test Execution: 
    01: If Det enabled, call CanSM_TxTimeoutException with valid network handle
    02: VP (CanSM.ASR40.CANSM411)
        CanSM_TxTimeoutException reports DET CANSM_E_UNINIT
    03: Call CanSM_Init
    04: Call CanSM_TxTimeoutException with valid network handle
    05: VP (CanSM.ASR40.CANSM412, CanSM.ASR40.CANSM411):
        CanSM_TxTimeoutException does not report to Det
    06: If Det enabled, call CanSM_TxTimeoutException with invalid network handle
    07: VP (CanSM.ASR40.CANSM412):
        CanSM_TxTimeoutException reports DET CANSM_E_INVALID_NETWORK_HANDLE
  
Test Input: 
    - Det enabled/disabled
    - Single/multiple networks
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00411</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>328</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00412</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>329</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>734</internalId></specobject>
    <specobject>
      <id>TS_CANSM_SETBAUDRATE_DET_UNINIT</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance/source/application/Tests.c</sourcefile>
      <sourceline>1310</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test shall verify that CanSM_SetBaudrate() will report CANSM_E_UNINIT to Det_ReportError()
    if development error detection is enabled.
  
Test Object: 
    CanSM_SetBaudrate
  
Test Precondition: 
    - CanSM shall be uninitialized.
    - Det shall be enabled.
  
Test Execution: 
    01: If Det enabled, call CanSM_SetBaudrate() while module is uninitialized.
    02: VP(CanSM.SWS_CanSM_00530): E_NOT_OK shall be returned.
    03: VP(CanSM.SWS_CanSM_00506): Module shall call Det_ReportError() with error code
        CANSM_E_UNINIT.
  
Test Input: 
    - Det enabled/disabled
    - Single/multiple networks
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00506</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>417</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00530</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>438</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>735</internalId></specobject>
    <specobject>
      <id>TS_CANSM_SETBAUDRATE</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance/source/application/Tests.c</sourcefile>
      <sourceline>1365</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test shall verify that if the API CanSM_SetBaudrate() is called with invalid network handle
    parameter, a Det with error code CANSM_E_INVALID_NETWORK_HANDLE shall be reported and the API
    shall return E_NOT_OK.
    Furthermore if the API CanSM_SetBaudrate() is called with valid parameter but not in
    communication mode COMM_FULL_COMMUNICATION, the API shall return E_NOT_OK.
  
Test Object: 
    CanSM_SetBaudrate
  
Test Precondition: 
  
Test Execution: 
    01: Initialize CanSM.

    02: Call CanSM_SetBaudrate() with a invalid network handle parameter.
    03: VP(CanSM.SWS_CanSM_00502): API shall return E_NOT_OK.
    04: VP(CanSM.SWS_CanSM_00504): If Det is enabled Det_ReportError shall be reported with
        error code CANSM_E_INVALID_NETWORK_HANDLE.
    05: Call CanSM_SetBaudrate() with valid parameter.
    06: VP(CanSM.SWS_CanSM_00505): API shall return E_NOT_OK.
  
Test Input: 
    - Det enabled/disabled
    - Single/multiple networks
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00502</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>413</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00504</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>415</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00505</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>416</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>736</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANSM_30007</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance/source/application/tests_from_30007.c</sourcefile>
      <sourceline>37</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test bus off API CanSM_ControllerBusOff(), single network (validation)
    Test callback with invalid controller
  
Test Object: 
    Bus-off handling
  
Test Precondition: 
    Module uninit
  
Test Execution: 
    01: Initialize CanIf stub callouts for synchronous mode indications
    02: Call CanSM_ControllerBusOff with valid controller ID
    03: VP (CanSM.ASR40.CANSM190):
        CanSM_ControllerBusOff reports DET error CANSM_E_UNINIT
    04: Call CanSM_Init() with configuration pointer as parameter
    05: Call CanSM_RequestComMode with mode COMM_FULL_COMMUNICATION
    06: If Det enabled: Call CanSM_ControllerBusOff with invalid controller ID
    07: VP (CanSM.ASR40.CANSM189):
        CanSM_ControllerBusOff reports DET error CANSM_E_PARAM_CONTROLLER
    08: Call CanSM_ControllerBusOff with valid controller ID
    09: VP (CanSM.ASR40.CANSM190, CanSM.ASR40.CANSM189):
        CanSM_ControllerBusOff does not report to Det
  
Test Input: 
    - Det enabled/disabled
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00189</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>306</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00190</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>307</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>737</internalId></specobject>
    <specobject>
      <id>TS_CANSM_30057</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance/source/application/tests_from_30007.c</sourcefile>
      <sourceline>180</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test CanSM_MainFunction() (valid)
    Call before initialisation
  
Test Object: 
    CanSM_MainFunction()
  
Test Precondition: 
    Module uninitialized
  
Test Execution: 
    01: Call CanSM_MainFunction()
    02: VP (CanSM.EB.Api.CanSM_MainFunction.Uninitialized)
        CanSM_MainFunction() does not call any API functions
  
Test Input: 
    - Det enabled/disabled
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.EB.Api.CanSM_MainFunction.Uninitialized</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>112</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>738</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANSM_BSWMCURRENTSTATETYPE</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_MultiNetworkTest/source/application/Tst_CanSM_Conf_BswMCurrentStateType.c</sourcefile>
      <sourceline>19</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test CanSM_BswMCurrentStateType enumeration values
  
Test Object: 
    CanSM_BswMCurrentStateType enum
  
Test Precondition: 
    - CanSM_BswM.h is the only CanSM header included
  
Test Execution: 
    01: assign CANSM_BSWM_NO_COMMUNICATION to CanSM_BswMCurrentStateType variable
    02: VP:
        CanSM_BswMCurrentStateType variable equals 0
    03: assign CANSM_BSWM_SILENT_COMMUNICATION to CanSM_BswMCurrentStateType variable
    04: VP:
        CanSM_BswMCurrentStateType variable equals 1
    05: assign CANSM_BSWM_FULL_COMMUNICATION to CanSM_BswMCurrentStateType variable
    06: VP:
        CanSM_BswMCurrentStateType variable equals 2
    07: assign CANSM_BSWM_BUS_OFF to CanSM_BswMCurrentStateType variable
    08: VP:
        CanSM_BswMCurrentStateType variable equals 3
    09: assign CANSM_BSWM_CHANGE_BAUDRATE to CanSM_BswMCurrentStateType variable
    10: VP:
        CanSM_BswMCurrentStateType variable equals 4
    11: assign CANSM_BSWM_BUS_OFF_L1 to CanSM_BswMCurrentStateType variable
    12: VP:
        CanSM_BswMCurrentStateType variable equals 5
    13: assign CANSM_BSWM_BUS_OFF_L2 to CanSM_BswMCurrentStateType variable
    14: VP:
        CanSM_BswMCurrentStateType variable equals 6
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.DataTypes.CanSM_BswMCurrentStateType.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>263</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>739</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANSM_T_NOIN_NOCO_ASYNC</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_MultiNetworkTest/source/application/Tst_CanSM_Conf_MultiNetwork.c</sourcefile>
      <sourceline>74</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct Transition of communication mode from
    S_NOIN (state NOt INitialized) to S_NOCO (state NO COmmunication).
    All mode indications shall be asynchron.
  
Test Object: 
    Module initialization
  
Test Precondition: 
    - CanSM module is NOT initialized
  
Test Execution: 
    01: Initialize CanSM
    02: VP (CanSM.ASR40.BSM.T_NOT_INITIALIZED_PRE_NOCOM.NoPn):
        CanSM called the following API function in defined order:
        1. BswM_CanSM_CurrentState (NW0) with:
           CurrentState := CANSM_BSWM_NO_COMMUNICATION
           Network := &lt;id of nw0&gt;
        2. CanIf_SetControllerMode (twice) with:
           ControllerMode := CANIF_CS_STOPPED
           ControllerId := 6 (NW0), 4 (NW0)
        3. BswM_CanSM_CurrentState (NW1) with:
           CurrentState := CANSM_BSWM_NO_COMMUNICATION
           Network := &lt;id of nw1&gt;
        4. CanIf_SetControllerMode with:
           ControllerMode := CANIF_CS_STOPPED
           ControllerId := 1 (NW1)
    03: Call CanSM_ControllerModeInidcation for ControllerId 6, 4 and 1 with:
        ControllerMode := CANIF_CS_STOPPED
    04: Call the MainFunction of CanSM
    05: VP (CanSM.ASR40.BSMDeInitNoPn.T_S_CC_STOPPED_S_CC_SLEEP):
        CanSM calls CanIf_SetControllerMode thrice for ControllerId 6, 4 and 1 with:
        ControllerMode := CANIF_CS_SLEEP
    06: Call CanSM_ControllerModeInidcation for ControllerId 1, 6 and 4 with:
        ControllerMode := CANIF_CS_SLEEP
    07: Call the MainFunction of CanSM
    08: VP (CanSM.ASR40.BSMDeInitNoPn.T_S_CC_SLEEP_S_TRCV_NORMAL):
        CanSM called only the following API function:
        CanIf_SetTrcvMode for TransceiverId 2 and 0 with:
        TransceiverMode := CANTRCV_TRCVMODE_NORMAL
    09: Call CanSM_TransceiverModeInidcation for TransceiverId 2 and 0 with:
        TransceiverMode := CANTRCV_TRCVMODE_NORMAL
    10: Call the MainFunction of CanSM
    11: VP (CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_NORMAL_S_TRCV_STANDBY):
        CanSM called only the following API function:
        CanIf_SetTrcvMode for TransceiverId 2 and 0 with:
        TransceiverMode := CANTRCV_TRCVMODE_STANDBY
    12: Call CanSM_TransceiverModeInidcation for TransceiverId 2 and 0 with:
        TransceiverMode := CANTRCV_TRCVMODE_STANDBY
    13: Call the MainFunction of CanSM
    14: VP (CanSM.ASR40.BSM.T_PRE_NOCOM_NOCOM.NoPn.2):
        No other API function called
    15: Call CanSM_GetCurrentComMode to read the current CanSM mode
    16: VP:
        CanSM_GetCurrentComMode returns E_OK
    17: VP:
        CanSM is in state COMM_NO_COMMUNICATION
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_NOT_INITIALIZED_PRE_NOCOM.NoPn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>195</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_CC_STOPPED_S_CC_SLEEP</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>216</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_CC_SLEEP_S_TRCV_NORMAL</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>219</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_NORMAL_S_TRCV_STANDBY</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>222</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_PRE_NOCOM_NOCOM.NoPn.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>192</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>740</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_NOCO_FUCO_2CC</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_MultiNetworkTest/source/application/Tst_CanSM_Conf_MultiNetwork.c</sourcefile>
      <sourceline>264</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct Transition of communication mode from
    CANSM_BSM_S_NOCOM to CANSM_BSM_S_FULLCOM
    with multiple (2) controller for network 0 if only one
    controller calls the ModeIndication.
    All mode indications shall be asynchron.
  
Test Object: 
    Module initialization
  
Test Precondition: 
    - CanSM is in state S_NOCO
  
Test Execution: 
    01: Call CanSM_RequestComMode with:
        network := &lt;id of network 0&gt;
        ComM_Mode := COMM_FULL_COMMUNICATION.
    02: VP (CanSM.ASR40.BSM.T_NOCOM_PRE_FULLCOM):
        CanSM called the following API function:
        CanIf_SetTrcvMode for TransceiverId 2 with:
        TransceiverMode := CANTRCV_TRCVMODE_NORMAL
    03: Call CanSM_TransceiverModeIndication for each Transceiver with:
        TransceiverMode := CANTRCV_TRCVMODE_NORMAL
    04: Call the MainFunction of CanSM
    05: VP (CanSM.ASR40.BSMPreFull.T_S_TRCV_NORMAL_S_CC_STOPPED):
        CanSM called the following API function:
        CanIf_SetControllerMode for ControllerId 6 and 4 with:
        ControllerMode := CANIF_CS_STOPPED
    06: Call CanSM_ControllerModeIndication with:
        ControllerId := 4
        ControllerMode := CANIF_CS_STOPPED
    07: Call the MainFunction of CanSM 3 times
    08: VP (CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.NoPn.2):
          CanSM called Det_ReportError with:
          ErrorId: 10
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_NOCOM_PRE_FULLCOM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>175</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMPreFull.T_S_TRCV_NORMAL_S_CC_STOPPED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>227</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.NoPn.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>178</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>741</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_BUS_OFF_PASSIVE_POLL</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_MultiNetworkTest/source/application/Tst_CanSM_Conf_MultiNetwork.c</sourcefile>
      <sourceline>369</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct Transition from substate S_BUS_OFF_CHECK
    to substate S_NO_BUS_OFF in state CANSM_BSM_S_FULLCOM.
    Bus off detection is done via polling
  
Test Object: 
    Mode Transition
  
Test Precondition: 
    - Transition from CANSM_BSM_S_PRE_FULLCOM for network 0
    - CanSMBorTxConfirmationPolling := true
  
Test Execution: 
    01: Prepare the CanIf stub in a way that
        CanIf_GetTxConfirmationState returns CANIF_TX_RX_NOTIFICATION.
    02: Call the MainFunction of CanSM
    03: VP (CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_NO_BUS_OFF):
        CanSM called CanIf_GetTxConfirmationState two times with:
        ControllerId 6 and 4
    04: VP (CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_NO_BUS_OFF):
        - In case Dem reporting is enabled:
          CanSM called Dem_ReportErrorStatus with:
          EventId := CANSM_E_BUS_OFF
          EventStatus := DEM_EVENT_STATUS_PASSED
        - In case Dem reporting is forwarded to DET:
          Neither API function Dem_ReportErrorStatus nor Det_ReportError is called
        - In case Dem reporting is disabled:
          Neither API function Dem_ReportErrorStatus nor Det_ReportError is called
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_NO_BUS_OFF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>232</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>742</internalId></specobject>
    <specobject>
      <id>TS_CANSM_MULT_NETWORKS_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_MultiNetworkTest/source/application/Tst_CanSM_Conf_MultiNetwork.c</sourcefile>
      <sourceline>455</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the independence of multiple networks.
    Different Transitions of the networks shall have no influence to
    each other.
    Network 0 makes a Transition from S_NOCO to S_FUCO.
    Network 1 stays in state S_NOCO
  
Test Object: 
    Mode Transition
  
Test Precondition: 
    - Both CanSM networks are in state S_NOCO
  
Test Execution: 
    01: Prepare the CanIf stub to indicate the requested transceiver mode
        Transition from inside the context of CanIf_SetTrcvMode.
    02: Prepare the CanIf stub to indicate the requested controller mode
        Transition from inside the context of CanIf_SetControllerMode.
    03: Call CanSM_RequestComMode with:
        network := &lt;id of network 0&gt;
        ComM_Mode := COMM_FULL_COMMUNICATION.
    04: VP:
        CanSM called the following API functions in defined order.
        But each API function is only called once.
        1. CanIf_SetTrcvMode with:
           TransceiverMode := CANTRCV_TRCVMODE_NORMAL
        2. CanIf_SetControllerMode for ControllerId 6 and 4 with:
           ControllerMode := CANIF_CS_STOPPED
        3. CanIf_SetControllerMode for ControllerId 6 and 4 with:
           ControllerMode := CANIF_CS_STARTED

        4. CanIf_SetPduMode for ControllerId 6 and 4 with:
           PduModeRequest := CANIF_ONLINE
		5. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_FULL_COMMUNICATION
           Network := &lt;id of network 0&gt;
        6. ComM_BusSM_ModeIndication with:
           ComMode := COMM_FULL_COMMUNICATION
    05: Call CanSM_GetCurrentComMode to read the current CanSM mode
        network := &lt;id of network 0&gt;
    06: VP:
        CanSM_GetCurrentComMode returns E_OK
    07: VP (CanSM.ASR40.SWS_CanSM_00266):
        CanSM is in state COMM_FULL_COMMUNICATION
    08: Call CanSM_GetCurrentComMode to read the current CanSM mode
        network := &lt;id of network 1&gt;
    09: VP:
        CanSM_GetCurrentComMode returns E_OK
    10: VP (CanSM.ASR40.SWS_CanSM_00266):
        CanSM is in state COMM_NO_COMMUNICATION
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.SWS_CanSM_00266</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>29</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>743</internalId></specobject>
    <specobject>
      <id>TS_CANSM_MULT_NETWORKS_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_MultiNetworkTest/source/application/Tst_CanSM_Conf_MultiNetwork.c</sourcefile>
      <sourceline>600</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the independence of multiple networks.
    Different Transitions of the networks shall have no influence to
    each other.
    Network 0 makes a Transition from S_FUCO to S_SICO.
    Network 1 makes a Transition from S_FUCO to S_NOCO.
  
Test Object: 
    Mode Transition
  
Test Precondition: 
    - Both CanSM networks are in state S_FUCO; substate S_NO_BUS_OFF
      Tip: reference to test sequence TS_CANSM_T_BUS_OFF_PASSIVE_POLL
  
Test Execution: 
    01: Call CanSM_ControllerBusOff with:
        ControllerId := 1 (Controller 0 of network 1)
    02: Call the MainFunction of CanSM 3 times to elapse indication timeout
    03: Prepare the CanIf stub to indicate the requested transceiver mode
        Transition from inside the context of CanIf_SetTrcvMode.
    04: Prepare the CanIf stub to indicate the requested controller mode
        Transition from inside the context of CanIf_SetControllerMode.
    05: Call CanSM_RequestComMode with:
        network := &lt;id of network 0&gt;
        ComM_Mode := COMM_SILENT_COMMUNICATION.
    06: Call the MainFunction of CanSM
    07: Call CanSM_GetCurrentComMode to read the current CanSM mode
        network := &lt;id of network 0&gt;
    08: VP:
        CanSM_GetCurrentComMode returns E_OK
    09: VP (CanSM.ASR40.SWS_CanSM_00266):
        CanSM is in state COMM_SILENT_COMMUNICATION
    10: Call CanSM_GetCurrentComMode to read the current CanSM mode
        network := &lt;id of network 1&gt;
    11: VP:
        CanSM_GetCurrentComMode returns E_OK
    12: VP (CanSM.ASR40.SWS_CanSM_00266):
        CanSM is in state COMM_NO_COMMUNICATION
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.SWS_CanSM_00266</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>29</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>744</internalId></specobject>
    <specobject>
      <id>TS_CANSM_DEM2DET_BUS_OFF</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_MultiNetworkTest/source/application/Tst_CanSM_Conf_MultiNetwork.c</sourcefile>
      <sourceline>718</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct handling of DEM events for a failed
    bus-off event. Dem events may be reported to Dem, forwareded to
    Det or disabled.
  
Test Object: 
    Dem forwarding
  
Test Precondition: 
    - CanSM network with idx 0 is in state CANSM_BSM_S_FULLCOM
  
Test Execution: 
    01: Prepare the CanIf stub to indicate the requested controller mode
        transition from inside the context of CanIf_SetControllerMode.
    02: Repeat steps 03-06 3 times to to show Dem-Reporting happens with every BusOff event
    03: Call CanSM_ControllerBusOff with:
        ControllerId := 6 (Controller 0 of network idx 0)
    04: Call CanSM_MainFunction to process the bus-off indication
    05: VP (CanSM.ASR40.CANSM074, CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_RESTART_CC.BusOff):
        - In case Dem reporting is enabled:
          CanSM called Dem_ReportErrorStatus with:
          EventId: CANSM_E_BUS_OFF
          EventStatus: DEM_EVENT_STATUS_PREFAILED
        - In case Dem reporting is forwared to DET:
          CanSM called Det_ReportError with:
          ErrorId: 128 (config para CanSMBusOffReportToDemDetErrorId)
          ApiId: 0x05 (MainFunction SID)
          InstanceId: &lt;id of network 0&gt;
        - In case Dem reporting is disabled:
          Neither API function Dem_ReportErrorStatus nor Det_ReportError is called
      06: Call MainFunction 15 times to reach state S_BUS_OFF_CHECK (BorTimeL1).
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_RESTART_CC.BusOff</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>234</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.SWS_CanSM_00074</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>19</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>745</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANSM_T_NOIN_NOCO_SYNC_PN</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkPartialNwTest/source/application/Tst_CanSM_Conf_SingleNetworkPartialNw.c</sourcefile>
      <sourceline>78</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct transition of communication mode from
    CANSM_BSM_S_NOT_INITIALIZED to CANSM_BSM_S_NOCOM.
    All mode indications shall be synchron.
    Partial Networking is activated for the network under test.
    Note: Although this test validates only the network with index 0
    it shall be taken into account that during CanSM_Init API function
    calls for other configured networks happens.
  
Test Object: 
    Module initialization
  
Test Precondition: 
    - CanSM module is NOT initialized
  
Test Execution: 
    01: Prepare the CanIf stub to indicate the requested transceiver mode
        transition from inside the context of CanIf_SetTrcvMode.
    02: Prepare the CanIf stub to indicate the requested controller mode
        transition from inside the context of CanIf_SetControllerMode.
    03: Prepare the CanIf stub to indicate the clear transceiver WUF flag
        from inside the context of CanIf_ClearTrcvWufFlag.
    04: Prepare the CanIf stub to indicate the check transceiver wake flag
        from inside the context of CanIf_CheckTrcvWakeFlag.
    05: Initialize CanSM
    06: Call the MainFunction of CanSM
    07: VP:
        CanSM called the following API function in defined order:
        1. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_NO_COMMUNICATION
           Network := 3
           (CanSM.ASR40.BSM.T_NOT_INITIALIZED_PRE_NOCOM.Pn)
        2. CanIf_ClearTrcvWufFlag with:
           TransceiverId := 3
           (CanSM.ASR40.BSM.T_NOT_INITIALIZED_PRE_NOCOM.Pn)
        3. CanIf_SetControllerMode with:
           ControllerMode := CANIF_CS_STOPPED
           ControllerId := 5
           (CanSM.ASR40.BSMDeInitPn.T_S_PN_CLEAR_WUF_S_PN_CC_STOPPED)
        4. CanIf_SetTrcvMode with:
           TransceiverMode := CANTRCV_TRCVMODE_NORMAL
           TransceiverId := 3
           (CanSM.ASR40.BSMDeInitPn.T_S_PN_CC_STOPPED_S_TRCV_NORMAL)
        5. CanIf_SetTrcvMode with:
           TransceiverMode := CANTRCV_TRCVMODE_STANDBY
           TransceiverId := 3
           (CanSM.ASR40.BSMDeInitPn.T_S_TRCV_NORMAL_S_TRCV_STANDBY)
        6. CanIf_SetControllerMode with:
           ControllerMode := CANIF_CS_SLEEP
           ControllerId := 5
           (CanSM.ASR40.BSMDeInitPn.T_S_TRCV_STANDBY_S_CC_SLEEP)
        7. CanIf_CheckTrcvWakeFlag with:
           TransceiverId := 3
           (CanSM.ASR40.BSMDeInitPn.T_S_CC_SLEEP_S_CHECK_WFLAG_IN_CC_SLEEP)
           (CanSM.ASR40.BSM.T_PRE_NOCOM_NOCOM.Pn.2)
    08: Call CanSM_GetCurrentComMode to read the current CanSM mode
        network := &lt;id&gt; of network 0
    09: VP:
        CanSM_GetCurrentComMode return E_OK
    10: VP (CanSM.SWS_CanSM_00186):
        CanSM is in state COMM_NO_COMMUNICATION
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_NOT_INITIALIZED_PRE_NOCOM.Pn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>196</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_PN_CLEAR_WUF_S_PN_CC_STOPPED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>197</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_PN_CC_STOPPED_S_TRCV_NORMAL</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>200</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_TRCV_NORMAL_S_TRCV_STANDBY</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>203</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_TRCV_STANDBY_S_CC_SLEEP</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>206</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_CC_SLEEP_S_CHECK_WFLAG_IN_CC_SLEEP</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>209</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_PRE_NOCOM_NOCOM.Pn.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>194</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00186</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>303</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.CanSMActivatePN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>105</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00424</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>341</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>746</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_SICO_NOCO_ASYNC_PN</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkPartialNwTest/source/application/Tst_CanSM_Conf_SingleNetworkPartialNw.c</sourcefile>
      <sourceline>234</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct transition of communication mode from
    CANSM_BSM_S_SILENTCOM to CANSM_BSM_S_NOCOM.
    All mode indications shall be asynchron.
    Partial Networking is activated for the network under test.
    Note: Although this test validates only the network with index 0
    it shall be taken into account that API function
    calls for other configured networks happen.
  
Test Object: 
    Module initialization
    Self transition
  
Test Precondition: 
    - CanSM module is in COMM_SILENT_COMMUNICATION
    - All indications from CanIf stubs shall be asynchronous.
  
Test Execution: 
    01: Request S_NOCO
    02: Call the MainFunction of CanSM
    03: VP (CanSM.ASR40.BSM.T_SILENTCOM_PRE_NOCOM.Pn):
        CanSM calls the following API functions in defined order:
        1. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_NO_COMMUNICATION
           Network := 3
        2. CanIf_ClearTrcvWufFlag with:
           TransceiverId := 3
    04: Simulate CanSM_ClearTrcvWufFlagIndication after another MainFunction call
    05: Call the MainFunction of CanSM
    06: VP (CanSM.ASR40.BSMDeInitPn.T_S_PN_CLEAR_WUF_S_PN_CC_STOPPED):
        CanIf_SetControllerMode is called
    07: Simulate CanSM_ControllerModeIndication with CANIF_CS_STOPPED
        after another MainFunction call
    08: Call the MainFunction of CanSM
    09: VP (CanSM.ASR40.BSMDeInitPn.T_S_PN_CC_STOPPED_S_TRCV_NORMAL):
        CanIf_SetTrcvMode is called
    10: Simulate CanSM_TransceiverModeIndication with CANTRCV_TRCVMODE_NORMAL
        after another MainFunction call
    11: Call the MainFunction of CanSM
    12: VP (CanSM.ASR40.BSMDeInitPn.T_S_TRCV_NORMAL_S_TRCV_STANDBY):
        CanIf_SetTrcvMode is called
    13: Simulate CanSM_TransceiverModeIndication after another MainFunction call
    14: Call the MainFunction of CanSM
    15: VP (CanSM.ASR40.BSMDeInitPn.T_S_TRCV_STANDBY_S_CC_SLEEP):
        CanIf_SetControllerMode is called
    16: Simulate CanSM_ControllerModeIndication with CANIF_CS_SLEEP
        after another MainFunction call
    17: Call the MainFunction of CanSM
    18: VP (CanSM.ASR40.BSMDeInitPn.T_S_CC_SLEEP_S_CHECK_WFLAG_IN_CC_SLEEP):
        CanIf_CheckTrcvWakeFlag is called
    19: Call main function to expire CanSMModeRequestRepetitionTime
    20: VP (CanSM.ASR40.BSMDeInitPn.T_S_CHECK_WFLAG_IN_CC_SLEEP_S_CHECK_WFLAG_IN_CC_SLEEP):
        CanIf_CheckTrcvWakeFlag is called
    21: Simulate CanSM_CheckTransceiverWakeFlagIndication after another MainFunction call
    22: Call the MainFunction of CanSM
    23: VP (CanSM.ASR40.BSM.T_PRE_NOCOM_NOCOM.Pn.1):
        ComM_BusSM_ModeIndication is called with COMM_NO_COMMUNICATION
    24: Call CanSM_GetCurrentComMode to read the current CanSM mode
        network := &lt;id&gt; of network 0
    25: VP:
        CanSM_GetCurrentComMode returns E_OK
    26: VP:
        CanSM is in state COMM_NO_COMMUNICATION
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_SILENTCOM_PRE_NOCOM.Pn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>190</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_PN_CLEAR_WUF_S_PN_CC_STOPPED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>197</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_PN_CC_STOPPED_S_TRCV_NORMAL</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>200</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_TRCV_NORMAL_S_TRCV_STANDBY</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>203</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_TRCV_STANDBY_S_CC_SLEEP</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>206</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_CC_SLEEP_S_CHECK_WFLAG_IN_CC_SLEEP</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>209</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_CHECK_WFLAG_IN_CC_SLEEP_S_CHECK_WFLAG_IN_CC_SLEEP</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>211</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_PRE_NOCOM_NOCOM.Pn.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>193</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.CanSMActivatePN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>105</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>747</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_API_NEGATIVERETURN_PN</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkPartialNwTest/source/application/Tst_CanSM_Conf_SingleNetworkPartialNw.c</sourcefile>
      <sourceline>443</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct transition of communication mode from
    CANSM_BSM_S_SILENTCOM to CANSM_BSM_S_NOCOM when few CanIf stubs return E_NOT_OK.
    All mode indications shall be asynchron.
    Partial Networking is activated for the network under test.
    Note: Although this test validates only the network with index 0
    it shall be taken into account that API function
    calls for other configured networks happen.
  
Test Object: 
    Module initialization
    Self transition
  
Test Precondition: 
    - CanSM module is in COMM_SILENT_COMMUNICATION
    - All indications from CanIf stubs shall be asynchronous
    - Api calls return E_NOT_OK
  
Test Execution: 
    01: Request S_NOCO
    02: Call the MainFunction of CanSM
    03: VP (CanSM.ASR40.BSM.T_SILENTCOM_PRE_NOCOM.Pn):
        CanSM calls the following API functions in defined order:
        1. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_NO_COMMUNICATION
           Network := 3
        2. CanIf_ClearTrcvWufFlag with:
           TransceiverId := 3
    04: Simulate CanSM_ClearTrcvWufFlagIndication after another MainFunction call
    05: Call the MainFunction of CanSM
    06: VP (CanSM.ASR40.BSMDeInitPn.T_S_PN_CLEAR_WUF_S_PN_CC_STOPPED):
        CanIf_SetControllerMode is called
    07: Simulate CanSM_ControllerModeIndication with CANIF_CS_STOPPED
        after another MainFunction call
    08: Call the MainFunction of CanSM
    09: VP (CanSM.ASR40.BSMDeInitPn.T_S_PN_CC_STOPPED_S_TRCV_NORMAL):
        CanIf_SetTrcvMode is called
    10: Simulate CanSM_TransceiverModeIndication with CANTRCV_TRCVMODE_NORMAL
        after another MainFunction call
    11: Call the MainFunction of CanSM
    12: VP (CanSM.ASR40.BSMDeInitPn.T_S_TRCV_NORMAL_S_TRCV_STANDBY):
        CanIf_SetTrcvMode is called
    13: Simulate CanSM_TransceiverModeIndication after another MainFunction call
    14: Call the MainFunction of CanSM
    15: VP (CanSM.ASR40.BSMDeInitPn.T_S_TRCV_STANDBY_S_CC_SLEEP):
        CanIf_SetControllerMode is called
    16: Simulate CanSM_ControllerModeIndication with CANIF_CS_SLEEP
        after another MainFunction call
    17: Call the MainFunction of CanSM
    18: VP (CanSM.ASR40.BSMDeInitPn.T_S_CC_SLEEP_S_CHECK_WFLAG_IN_CC_SLEEP):
        CanIf_CheckTrcvWakeFlag is called
    19: Call main function to expire CanSMModeRequestRepetitionTime
    20: VP (CanSM.ASR40.BSMDeInitPn.T_S_CHECK_WFLAG_IN_CC_SLEEP_S_CHECK_WFLAG_IN_CC_SLEEP):
        CanIf_CheckTrcvWakeFlag is called
    21: Simulate CanSM_CheckTransceiverWakeFlagIndication after another MainFunction call
    22: Call the MainFunction of CanSM
    23: VP (CanSM.ASR40.BSM.T_PRE_NOCOM_NOCOM.Pn.1):
        ComM_BusSM_ModeIndication is called with COMM_NO_COMMUNICATION
    24: Call CanSM_GetCurrentComMode to read the current CanSM mode
        network := &lt;id&gt; of network 0
    25: VP:
        CanSM_GetCurrentComMode returns E_OK
    26: VP:
        CanSM is in state COMM_NO_COMMUNICATION
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.EB.Api.NegativeReturn.CanIf_CheckTrcvWakeFlag</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>117</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.Api.NegativeReturn.CanIf_ClearTrcvWufFlag</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>118</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.Api.NegativeReturn.CanIf_SetTrcvMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>119</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.Api.NegativeReturn.CanIf_SetControllerMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.CanSMActivatePN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>105</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>748</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_FUCO_NOCO_ASYNC_PN</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkPartialNwTest/source/application/Tst_CanSM_Conf_SingleNetworkPartialNw.c</sourcefile>
      <sourceline>656</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct transition of communication mode from
    CANSM_BSM_S_FULLCOM to CANSM_BSM_S_NOCOM.
    All mode indications shall be asynchron.
    Partial Networking is activated for the network under test.
    Note: Although this test validates only the network with index 0
    it shall be taken into account that API function
    calls for other configured networks happen.
  
Test Object: 
    Module initialization
  
Test Precondition: 
    - CanSM module is in COMM_FULL_COMMUNICATION (substate S_BUS_OFF_CHECK)
    - All indications from CanIf stubs shall be asynchronous.
  
Test Execution: 
    01: Request S_NOCO
    02: Call the MainFunction of CanSM
    03: VP (CanSM.ASR40.BSM.T_FULLCOM_SILENTCOM.BusOffCheck.2, CanSM.ASR40.BSM.T_SILENTCOM_PRE_NOCOM.Pn):
        CanSM calls the following API functions in defined order:
        ----- to silent com -----
        1. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_SILENT_COMMUNICATION
           Network := 3

        2. CanIf_SetPduMode with:
           PduModeRequest := CANIF_TX_OFFLINE
           ControllerId := 5
        3. ComM_BusSM_ModeIndication with:
           ComMode := COMM_SILENT_COMMUNICATION
        ----- to pre no-com -----
        4. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_NO_COMMUNICATION
           Network := 3

        5. CanIf_ClearTrcvWufFlag with:
           TransceiverId := 3
    04: Simulate CanSM_ClearTrcvWufFlagIndication after another MainFunction call
    05: Call the MainFunction of CanSM
    06: VP (CanSM.ASR40.BSMDeInitPn.T_S_PN_CLEAR_WUF_S_PN_CC_STOPPED):
        CanIf_SetControllerMode is called
    07: Simulate CanSM_ControllerModeIndication with CANIF_CS_STOPPED
        after another MainFunction call
    08: Call the MainFunction of CanSM
    09: VP (CanSM.ASR40.BSMDeInitPn.T_S_PN_CC_STOPPED_S_TRCV_NORMAL):
        CanIf_SetTrcvMode is called
    10: Simulate CanSM_TransceiverModeIndication with CANTRCV_TRCVMODE_NORMAL
        after another MainFunction call
    11: Call the MainFunction of CanSM
    12: VP (CanSM.ASR40.BSMDeInitPn.T_S_TRCV_NORMAL_S_TRCV_STANDBY):
        CanIf_SetTrcvMode is called
    13: Simulate CanSM_TransceiverModeIndication after another MainFunction call
    14: Call the MainFunction of CanSM
    15: VP (CanSM.ASR40.BSMDeInitPn.T_S_TRCV_STANDBY_S_CC_SLEEP):
        CanIf_SetControllerMode is called
    16: Simulate CanSM_ControllerModeIndication with CANIF_CS_SLEEP
        after another MainFunction call
    17: Call the MainFunction of CanSM
    18: VP (CanSM.ASR40.BSMDeInitPn.T_S_CC_SLEEP_S_CHECK_WFLAG_IN_CC_SLEEP):
        CanIf_CheckTrcvWakeFlag is called
    19: Simulate CanSM_CheckTransceiverWakeFlagIndication after another MainFunction call
    20: Call the MainFunction of CanSM
    21: VP (CanSM.ASR40.BSM.T_PRE_NOCOM_NOCOM.Pn.1):
        ComM_BusSM_ModeIndication is called with COMM_NO_COMMUNICATION
    22: Call CanSM_GetCurrentComMode to read the current CanSM mode
        network := &lt;id&gt; of network 0
    23: VP:
        CanSM_GetCurrentComMode returns E_OK
    24: VP:
        CanSM is in state COMM_NO_COMMUNICATION
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_FULLCOM_SILENTCOM.BusOffCheck.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>109</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_SILENTCOM_PRE_NOCOM.Pn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>190</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_PN_CLEAR_WUF_S_PN_CC_STOPPED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>197</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_PN_CC_STOPPED_S_TRCV_NORMAL</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>200</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_TRCV_NORMAL_S_TRCV_STANDBY</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>203</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_TRCV_STANDBY_S_CC_SLEEP</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>206</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_CC_SLEEP_S_CHECK_WFLAG_IN_CC_SLEEP</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>209</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_PRE_NOCOM_NOCOM.Pn.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>193</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.CanSMActivatePN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>105</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>749</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_NOCO_TIMEOUT_SYNC_PN_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkPartialNwTest/source/application/Tst_CanSM_Conf_SingleNetworkPartialNw.c</sourcefile>
      <sourceline>877</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct transition of communication mode in
    CANSM_BSM_S_NOCOM when the mode indications are synchronous after timeout.
    All mode indications shall be initially asynchron after timeout it will be synchron.
    Partial Networking is activated for the network under test.
    Note: Although this test validates only the network with index 0
    it shall be taken into account that API function
    calls for other configured networks happen.
  
Test Object: 
    Module transition
  
Test Precondition: 
    - CanSM module is in COMM_FULL_COMMUNICATION (substate S_BUS_OFF_CHECK)
    - All indications from CanIf stubs shall be asynchronous initially and synchronous after a timeout.
  
Test Execution: 
    01: Request S_NOCO
    02: Call the MainFunction of CanSM
    03: VP (CanSM.ASR40.BSM.T_FULLCOM_SILENTCOM.BusOffCheck.2,
            CanSM.ASR40.BSM.T_SILENTCOM_PRE_NOCOM.Pn):
        CanSM calls the following API functions in defined order:
        ----- to silent com -----
        1. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_SILENT_COMMUNICATION
           Network := 3

        2. CanIf_SetPduMode with:
           PduModeRequest := CANIF_TX_OFFLINE
           ControllerId := 5
        3. ComM_BusSM_ModeIndication with:
           ComMode := COMM_SILENT_COMMUNICATION
        ----- to pre no-com -----
        4. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_NO_COMMUNICATION
           Network := 3

        5. CanIf_ClearTrcvWufFlag with:
           TransceiverId := 3
    04: Call MainFunction CanSMModeRequestRepetitionTime-1 times
    05: Change ClearTrcvWufFlagIndication to be synchronous
    06: Call the MainFunction of CanSM
    07: VP (CanSM.ASR40.BSMDeInitPn.T_S_PN_CLEAR_WUF_S_PN_CLEAR_WUF.1):
        CanIf_ClearTrcvWufFlag is called with:
          TransceiverId := 3
    08: VP (CanSM.ASR40.BSMDeInitPn.T_S_PN_CLEAR_WUF_S_PN_CC_STOPPED):
        CanIf_SetControllerMode is called
    09: Call MainFunction CanSMModeRequestRepetitionTime-1 times
    10: Change ControllerModeIndication to be synchronous and restore ClearTrcvWufFlagIndication
    11: Call the MainFunction of CanSM
    12: VP (CanSM.ASR40.BSMDeInitPn.T_S_PN_CC_STOPPED_S_PN_CC_STOPPED):
        CanIf_SetControllerMode is called again
    13: VP (CanSM.ASR40.BSMDeInitPn.T_S_PN_CC_STOPPED_S_TRCV_NORMAL):
        CanIf_SetTrcvMode is called
    14: Call MainFunction CanSMModeRequestRepetitionTime-1 times
    15: Change TransceiverModeIndication to be synchronous and restore ControllerModeIndication
    16: Call the MainFunction of CanSM
    17: VP (CanSM.ASR40.BSMDeInitPn.T_S_TRCV_NORMAL_S_TRCV_NORMAL,
            CanSM.ASR40.BSMDeInitPn.T_S_TRCV_NORMAL_S_TRCV_STANDBY):
        CanIf_SetTrcvMode is called twice with:
          1. TransceiverMode = CANTRCV_TRCVMODE_NORMAL
          2. TransceiverMode = CANTRCV_TRCVMODE_STANDBY
    18: VP (CanSM.ASR40.BSMDeInitPn.T_S_TRCV_STANDBY_S_CC_SLEEP):
        CanIf_SetControllerMode is called
    19: Call MainFunction CanSMModeRequestRepetitionTime times to enter S_CHECK_WFLAG_IN_NOT_CC_SLEEP
    20: VP (CanSM.ASR40.BSMDeInitPn.T_S_CC_SLEEP_S_CHECK_WFLAG_IN_NOT_CC_SLEEP):
        CanIf_CheckTrcvWakeFlag is called
    21: Call MainFunction CanSMModeRequestRepetitionTime-1 times
    22: Change CheckTrcvWakeFlagIndication to be synchronous and restore TransceiverModeIndication
    23: Call the MainFunction of CanSM
    24: VP(CanSM.ASR40.BSMDeInitPn.T_S_CHECK_WFLAG_IN_NOT_CC_SLEEP_S_CHECK_WFLAG_IN_NOT_CC_SLEEP):
        CanIf_CheckTrcvWakeFlag is called again
    25: VP(CanSM.ASR40.BSMDeInitPn.T_S_CHECK_WFLAG_IN_NOT_CC_SLEEP_S_PN_CLEAR_WUF.1):
        CanIf_ClearTrcvWufFlag is called
    26: Change CheckTrcvWakeFlagIndication back to be asynchronous
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_FULLCOM_SILENTCOM.BusOffCheck.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>109</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_SILENTCOM_PRE_NOCOM.Pn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>190</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_PN_CLEAR_WUF_S_PN_CLEAR_WUF.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>198</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_PN_CLEAR_WUF_S_PN_CC_STOPPED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>197</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_PN_CC_STOPPED_S_PN_CC_STOPPED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>201</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_PN_CC_STOPPED_S_TRCV_NORMAL</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>200</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_TRCV_NORMAL_S_TRCV_NORMAL</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>204</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_TRCV_NORMAL_S_TRCV_STANDBY</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>203</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_TRCV_STANDBY_S_CC_SLEEP</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>206</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_CC_SLEEP_S_CHECK_WFLAG_IN_NOT_CC_SLEEP</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>210</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_CHECK_WFLAG_IN_NOT_CC_SLEEP_S_CHECK_WFLAG_IN_NOT_CC_SLEEP</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>214</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_CHECK_WFLAG_IN_NOT_CC_SLEEP_S_PN_CLEAR_WUF.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>213</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.CanSMActivatePN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>105</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>750</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_NOCO_TIMEOUT_SYNC_PN_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkPartialNwTest/source/application/Tst_CanSM_Conf_SingleNetworkPartialNw.c</sourcefile>
      <sourceline>1117</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct transition of communication mode in
    CANSM_BSM_S_NOCOM when the mode indications are synchronous after timeout
    for CanIf_SetTrcvMode from sub state S_TRCV_STANDBY and
    for CanIf_CheckTrcvWakeFlag from sub state S_CHECK_WFLAG_IN_CC_SLEEP.
    All mode indications shall be initially asynchron after timeout it will be synchron.
    Partial Networking is activated for the network under test.
    Note: Although this test validates only the network with index 0
    it shall be taken into account that API function
    calls for other configured networks happen.
  
Test Object: 
    Module initialization
  
Test Precondition: 
    - CanSM module is in COMM_FULL_COMMUNICATION (substate S_BUS_OFF_CHECK)
    - All indications from CanIf stubs shall be asynchronous initially
      and synchronous after a timeout.
  
Test Execution: 
    01: Request S_NOCO
    02: Call the MainFunction of CanSM
    03: VP (CanSM.ASR40.BSM.T_FULLCOM_SILENTCOM.BusOffCheck.2,
            CanSM.ASR40.BSM.T_SILENTCOM_PRE_NOCOM.Pn):
        CanSM calls the following API functions in defined order:
        ----- to silent com -----
        1. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_SILENT_COMMUNICATION
           Network := 3
        2. CanIf_SetPduMode with:
           PduModeRequest := CANIF_TX_OFFLINE
           ControllerId := 5
        3. ComM_BusSM_ModeIndication with:
           ComMode := COMM_SILENT_COMMUNICATION
        ----- to pre no-com -----
        4. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_NO_COMMUNICATION
           Network := 3
        5. CanIf_ClearTrcvWufFlag with:
           TransceiverId := 3
    04: Simulate CanSM_ClearTrcvWufFlagIndication after another MainFunction call
    05: Call the MainFunction of CanSM
    06: VP (CanSM.ASR40.BSMDeInitPn.T_S_PN_CLEAR_WUF_S_PN_CC_STOPPED):
        CanIf_SetControllerMode is called
    07: Simulate CanSM_ControllerModeIndication with CANIF_CS_STOPPED
        after another MainFunction call
    08: Call the MainFunction of CanSM
    09: VP (CanSM.ASR40.BSMDeInitPn.T_S_PN_CC_STOPPED_S_TRCV_NORMAL):
        CanIf_SetTrcvMode is called
    10: Simulate CanSM_TransceiverModeIndication with CANTRCV_TRCVMODE_NORMAL
        after another MainFunction call
    11: Call the MainFunction of CanSM
    12: VP (CanSM.ASR40.BSMDeInitPn.T_S_TRCV_NORMAL_S_TRCV_STANDBY):
        CanIf_SetTrcvMode is called
    13: Call MainFunction CanSMModeRequestRepetitionTime-1 times
    14: Change TransceiverModeIndication to be synchronous
    15: Call the MainFunction of CanSM
    16: VP (CanSM.ASR40.BSMDeInitPn.T_S_TRCV_STANDBY_S_TRCV_STANDBY):
        CanIf_SetTrcvMode is called again
    17: VP (CanSM.ASR40.BSMDeInitPn.T_S_TRCV_STANDBY_S_CC_SLEEP):
        CanIf_SetControllerMode is called
    18: Simulate CanSM_ControllerModeIndication with CANIF_CS_SLEEP
        after another MainFunction call
    19: Call the MainFunction of CanSM
    20: VP (CanSM.ASR40.BSMDeInitPn.T_S_CC_SLEEP_S_CHECK_WFLAG_IN_CC_SLEEP):
        CanIf_CheckTrcvWakeFlag is called
    21: Call MainFunction CanSMModeRequestRepetitionTime-1 times
    22: Change CheckTransceiverWakeFlagIndication to be synchronous and
        restore TransceiverModeIndication
    23: Call the MainFunction of CanSM
    24: VP (CanSM.ASR40.BSMDeInitPn.T_S_CHECK_WFLAG_IN_CC_SLEEP_S_CHECK_WFLAG_IN_CC_SLEEP):
        CanIf_CheckTrcvWakeFlag is called again
    25: VP (CanSM.ASR40.BSM.T_PRE_NOCOM_NOCOM.Pn.1):
        ComM_BusSM_ModeIndication is called with COMM_NO_COMMUNICATION
    26: Restore CheckTransceiverWakeFlagIndication to be ascnchronous
    27: Call CanSM_GetCurrentComMode to read the current CanSM mode
        network := &lt;id&gt; of network 0
    28: VP:
        CanSM_GetCurrentComMode returns E_OK
    29: VP:
        CanSM is in state COMM_NO_COMMUNICATION
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_FULLCOM_SILENTCOM.BusOffCheck.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>109</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_SILENTCOM_PRE_NOCOM.Pn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>190</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_PN_CLEAR_WUF_S_PN_CC_STOPPED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>197</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_PN_CC_STOPPED_S_TRCV_NORMAL</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>200</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_TRCV_NORMAL_S_TRCV_STANDBY</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>203</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_TRCV_STANDBY_S_TRCV_STANDBY</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>207</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_TRCV_STANDBY_S_CC_SLEEP</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>206</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_CC_SLEEP_S_CHECK_WFLAG_IN_CC_SLEEP</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>209</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_CHECK_WFLAG_IN_CC_SLEEP_S_CHECK_WFLAG_IN_CC_SLEEP</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>211</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_PRE_NOCOM_NOCOM.Pn.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>193</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.CanSMActivatePN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>105</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>751</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_CHECK_TRCV_WFLAG_SYNC_PN</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkPartialNwTest/source/application/Tst_CanSM_Conf_SingleNetworkPartialNw.c</sourcefile>
      <sourceline>1367</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct transition of communication mode from
    CANSM_BSM_S_FULLCOM to CANSM_BSM_S_NOCOM when S_CC_SLEEP is not indicated
    and CanSM enters CHECK_WFLAG_IN_NOT_CC_SLEEP with synchronous indication.
    All mode indications shall be asynchron except for CheckTrcvWakeFlag.
    Partial Networking is activated for the network under test.
    Note: Although this test validates only the network with index 0
    it shall be taken into account that API function
    calls for other configured networks happen.
  
Test Object: 
    Module initialization
  
Test Precondition: 
    - CanSM module is in COMM_FULL_COMMUNICATION (substate S_BUS_OFF_CHECK)
    - All indications from CanIf stubs except CheckTrcvWakeFlag shall be asynchronous.
  
Test Execution: 
    01: Request S_NOCO
    02: Call the MainFunction of CanSM
    03: VP (CanSM.ASR40.BSM.T_FULLCOM_SILENTCOM.BusOffCheck.2, CanSM.ASR40.BSM.T_SILENTCOM_PRE_NOCOM.Pn):
        CanSM calls the following API functions in defined order:
        ----- to silent com -----
        1. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_SILENT_COMMUNICATION
           Network := 3

        2. CanIf_SetPduMode with:
           PduModeRequest := CANIF_TX_OFFLINE
           ControllerId := 5
        3. ComM_BusSM_ModeIndication with:
           ComMode := COMM_SILENT_COMMUNICATION
        ----- to pre no-com -----
        4. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_NO_COMMUNICATION
           Network := 3

        5. CanIf_ClearTrcvWufFlag with:
           TransceiverId := 3
    04: Simulate CanSM_ClearTrcvWufFlagIndication after another MainFunction call
    05: Call the MainFunction of CanSM
    06: VP (CanSM.ASR40.BSMDeInitPn.T_S_PN_CLEAR_WUF_S_PN_CC_STOPPED):
        CanIf_SetControllerMode is called
    07: Simulate CanSM_ControllerModeIndication with CANIF_CS_STOPPED
        after another MainFunction call
    08: Call the MainFunction of CanSM
    09: VP (CanSM.ASR40.BSMDeInitPn.T_S_PN_CC_STOPPED_S_TRCV_NORMAL):
        CanIf_SetTrcvMode is called
    10: Simulate CanSM_TransceiverModeIndication with CANTRCV_TRCVMODE_NORMAL
        after another MainFunction call
    11: Call the MainFunction of CanSM
    12: VP (CanSM.ASR40.BSMDeInitPn.T_S_TRCV_NORMAL_S_TRCV_STANDBY):
        CanIf_SetTrcvMode is called
    13: Simulate CanSM_TransceiverModeIndication after another MainFunction call
    14: Call the MainFunction of CanSM
    15: VP (CanSM.ASR40.BSMDeInitPn.T_S_TRCV_STANDBY_S_CC_SLEEP):
        CanIf_SetControllerMode is called
    16: Simulate timeout to enter S_CHECK_WFLAG_IN_NOT_CC_SLEEP using MainFunction calls
    17: VP (CanSM.ASR40.BSMDeInitPn.T_S_CC_SLEEP_S_CHECK_WFLAG_IN_NOT_CC_SLEEP):
        CanIf_CheckTrcvWakeFlag is called
    18: VP (CanSM.ASR40.BSMDeInitPn.T_S_CHECK_WFLAG_IN_NOT_CC_SLEEP_S_PN_CLEAR_WUF.1):
        CanIf_ClearTrcvWufFlag is called
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_FULLCOM_SILENTCOM.BusOffCheck.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>109</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_SILENTCOM_PRE_NOCOM.Pn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>190</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_PN_CLEAR_WUF_S_PN_CC_STOPPED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>197</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_PN_CC_STOPPED_S_TRCV_NORMAL</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>200</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_TRCV_NORMAL_S_TRCV_STANDBY</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>203</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_TRCV_STANDBY_S_CC_SLEEP</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>206</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_CC_SLEEP_S_CHECK_WFLAG_IN_NOT_CC_SLEEP</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>210</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_CHECK_WFLAG_IN_NOT_CC_SLEEP_S_PN_CLEAR_WUF.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>213</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.CanSMActivatePN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>105</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>752</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_ASYNC_DEINITPN_TIMEOUTS</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkPartialNwTest/source/application/Tst_CanSM_Conf_SingleNetworkPartialNw.c</sourcefile>
      <sourceline>1556</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the different timeout conditions during the transition of communication
    mode from CANSM_BSM_S_SILENTCOM to CANSM_BSM_S_NOCOM.
    All mode indications shall be asynchron.
    Partial Networking is activated for the network under test.
    Note: Although this test validates only the network with index 0
    it shall be taken into account that API function
    calls for other configured networks happen.
  
Test Object: 
    Different timeouts in CANSM_BSM_DeinitPnSupported state
  
Test Precondition: 
    - CanSM module is in COMM_SILENT_COMMUNICATION
    - All indications from CanIf stubs shall be asynchronous.
    - CanIf_ClearTrcvWufFlag, CanIf_SetControllerMode, CanIf_SetTrcvMode and
      CanIf_CheckTrcvWakeFlag shall return E_OK
  
Test Execution: 
    01: Request S_NOCO
    02: Call the MainFunction of CanSM
    03: VP(CanSM.ASR40.BSM.T_SILENTCOM_PRE_NOCOM.Pn):
        CanSM calls the following API functions in defined order:
        1. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_NO_COMMUNICATION
           Network := 3
        2. CanIf_ClearTrcvWufFlag with:
           TransceiverId := 3
    04: Expiring CanSMModeRequestRepetitionTime
    05: VP(CanSM.ASR40.BSMDeInitPn.T_S_PN_CLEAR_WUF_S_PN_CLEAR_WUF.1):
        CanIf_ClearTrcvWufFlag get called again after ModeRequestRepetitionTime
    06: Simulate CanSM_ClearTrcvWufFlagIndication after another MainFunction call
    07: Call the MainFunction of CanSM
    08: VP(CanSM.ASR40.BSMDeInitPn.T_S_PN_CLEAR_WUF_S_PN_CC_STOPPED):
        CanIf_SetControllerMode is called with CANIF_CS_STOPPED
    09: Expiring CanSMModeRequestRepetitionTime
    10: VP(CanSM.ASR40.BSMDeInitPn.T_S_PN_CC_STOPPED_S_PN_CC_STOPPED):
        CanIf_SetControllerMode is called again with CANIF_CS_STOPPED
        after ModeRequestRepetitionTime
    11: Simulate CanSM_ControllerModeIndication with CANIF_CS_STOPPED
        after another MainFunction call
    12: Call the MainFunction of CanSM
    13: VP(CanSM.ASR40.BSMDeInitPn.T_S_PN_CC_STOPPED_S_TRCV_NORMAL):
        CanIf_SetTrcvMode is called with CANTRCV_TRCVMODE_NORMAL
    14: Expiring CanSMModeRequestRepetitionTime
    15: VP(CanSM.ASR40.BSMDeInitPn.T_S_TRCV_NORMAL_S_TRCV_NORMAL):
        CanIf_SetTrcvMode is again called with CANTRCV_TRCVMODE_NORMAL
    16: Simulate CanSM_TransceiverModeIndication with CANTRCV_TRCVMODE_NORMAL after
        another MainFunction
    17: Call the MainFunction of CanSM
    18: VP(CanSM.ASR40.BSMDeInitPn.T_S_TRCV_NORMAL_S_TRCV_STANDBY):
        CanIf_SetTrcvMode is called with CANTRCV_TRCVMODE_STANDBY
    19: Expiring CanSMModeRequestRepetitionTime
    20: VP(CanSM.ASR40.BSMDeInitPn.T_S_TRCV_STANDBY_S_TRCV_STANDBY):
        CanIf_SetTrcvMode is called again with CANTRCV_TRCVMODE_STANDBY
    21: Simulate CanSM_TransceiverModeIndication after another MainFunction call
    22: Call the MainFunction of CanSM
    23: VP(CanSM.ASR40.BSMDeInitPn.T_S_TRCV_STANDBY_S_CC_SLEEP):
        CanIf_SetControllerMode is called with CANIF_CS_SLEEP
    24: Expiring CanSMModeRequestRepetitionTime
    25: VP(CanSM.ASR40.BSMDeInitPn.T_S_CC_SLEEP_S_CHECK_WFLAG_IN_NOT_CC_SLEEP):
        CanIf_CheckTrcvWakeFlag is called
    26: Expiring CanSMModeRequestRepetitionTime
    27: VP(CanSM.ASR40.BSMDeInitPn.T_S_CHECK_WFLAG_IN_NOT_CC_SLEEP_S_CHECK_WFLAG_IN_NOT_CC_SLEEP):
        CanIf_CheckTrcvWakeFlag is called again
    28: Simulate CanSM_CheckTransceiverWakeFlagIndication after another MainFunction call
    29: Set the return value of CanIf_ClearTrcvWufFlag to E_NOT_OK
    30: Call the MainFunction of CanSM
    31: VP(CanSM.ASR40.BSMDeInitPn.T_S_CHECK_WFLAG_IN_NOT_CC_SLEEP_S_PN_CLEAR_WUF.1):
        CanIf_ClearTrcvWufFlag is called
    32: Expiring CanSMModeRequestRepetitionTime
    33: VP(CanSM.ASR40.BSMDeInitPn.T_S_PN_CLEAR_WUF_S_PN_CLEAR_WUF.1):
        CanIf_ClearTrcvWufFlag is called again
    34: Expiring CanSMModeRequestRepetitionTime
    35: VP(CanSM.ASR40.BSMDeInitPn.T_S_PN_CLEAR_WUF_S_PN_CLEAR_WUF.2):
        Check whether Det error CANSM_E_MODE_REQUEST_TIMEOUT is reported
    36: VP(CanSM.ASR40.BSMDeInitPn.T_S_PN_CLEAR_WUF_S_PN_CLEAR_WUF.2):
        CanIf_ClearTrcvWufFlag is called indicating that CanSM reached initial S_PN_CLEAR_WUF state
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_SILENTCOM_PRE_NOCOM.Pn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>190</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_PN_CLEAR_WUF_S_PN_CLEAR_WUF.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>198</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_PN_CLEAR_WUF_S_PN_CC_STOPPED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>197</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_PN_CC_STOPPED_S_PN_CC_STOPPED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>201</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_PN_CC_STOPPED_S_TRCV_NORMAL</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>200</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_TRCV_NORMAL_S_TRCV_NORMAL</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>204</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_TRCV_NORMAL_S_TRCV_STANDBY</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>203</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_TRCV_STANDBY_S_TRCV_STANDBY</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>207</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_TRCV_STANDBY_S_CC_SLEEP</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>206</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_CC_SLEEP_S_CHECK_WFLAG_IN_NOT_CC_SLEEP</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>210</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_CHECK_WFLAG_IN_NOT_CC_SLEEP_S_CHECK_WFLAG_IN_NOT_CC_SLEEP</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>214</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_CHECK_WFLAG_IN_NOT_CC_SLEEP_S_PN_CLEAR_WUF.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>213</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_PN_CLEAR_WUF_S_PN_CLEAR_WUF.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>199</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>753</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_REPEAT_MAX_DEINIT_PN_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkPartialNwTest/source/application/Tst_CanSM_Conf_SingleNetworkPartialNw.c</sourcefile>
      <sourceline>1886</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks if DET is reported when triggered with T_REPEAT_MAX in state S_PN_CC_STOPPED
    of CANSM_BSM_DeinitPnSupportedProceed.
    All mode indications shall be asynchron.
    Partial Networking is activated for the network under test.
    Note: Although this test validates only the network with index 0
    it shall be taken into account that API function
    calls for other configured networks happen.
  
Test Object: 
    T_REPEAT_MAX
  
Test Precondition: 
    - CanSM module is in COMM_SILENT_COMMUNICATION
    - All indications from CanIf stubs shall be asynchronous.
  
Test Execution: 
    01: Request S_NOCO
    02: Call the MainFunction of CanSM
    03: Simulate CanSM_ClearTrcvWufFlagIndication after another MainFunction call
    04: Call the MainFunction of CanSM 10 times
    05: VP (CanSM.ASR40.BSMDeInitPn.T_S_PN_CC_STOPPED_S_PN_CC_STOPPED):
        CanIf_SetControllerMode is called twice with
        ControllerMode = CANIF_CS_STOPPED
    06: VP:
        Verify if CanSM did not call Det_ReportError
    07: Call the MainFunction of CanSM
    08: VP (CanSM.ASR40.BSMDeInitPn.T_S_PN_CC_STOPPED_S_PN_CLEAR_WUF):
        If development error detection is enabled,
        CanSM called Det_ReportError with:
        ErrorId: CANSM_E_MODE_REQUEST_TIMEOUT
    09: VP (CanSM.ASR40.BSMDeInitPn.T_S_PN_CC_STOPPED_S_PN_CLEAR_WUF):
        CanSM calls CanIf_ClearTrcvWufFlag
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_PN_CC_STOPPED_S_PN_CLEAR_WUF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>202</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_PN_CC_STOPPED_S_PN_CC_STOPPED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>201</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.CanSMActivatePN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>105</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>754</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_REPEAT_MAX_DEINIT_PN_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkPartialNwTest/source/application/Tst_CanSM_Conf_SingleNetworkPartialNw.c</sourcefile>
      <sourceline>1997</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks if DET is reported when triggered with T_REPEAT_MAX in state S_TRCV_NORMAL
    of CANSM_BSM_DeinitPnSupportedProceed.
    All mode indications shall be asynchron.
    Partial Networking is activated for the network under test.
    Note: Although this test validates only the network with index 0
    it shall be taken into account that API function
    calls for other configured networks happen.
  
Test Object: 
    T_REPEAT_MAX
  
Test Precondition: 
    - CanSM module is in COMM_SILENT_COMMUNICATION
    - All indications from CanIf stubs shall be asynchronous.
  
Test Execution: 
    01: Request S_NOCO
    02: Call the MainFunction of CanSM
    03: Simulate CanSM_ClearTrcvWufFlagIndication
    04: Simulate CanSM_ControllerModeIndication with CANIF_CS_STOPPED
    05: Call the MainFunction of CanSM 10 times
    06: VP (CanSM.ASR40.BSMDeInitPn.T_S_TRCV_NORMAL_S_TRCV_NORMAL):
        CanIf_SetTrcvMode is called twice with
        TransceiverMode = CANTRCV_TRCVMODE_NORMAL
    07: VP:
        Verify if CanSM did not call Det_ReportError
    08: Call the MainFunction of CanSM
    09: VP (CanSM.ASR40.BSMDeInitPn.T_S_TRCV_NORMAL_S_PN_CLEAR_WUF):
        If development error detection is enabled,
        CanSM called Det_ReportError with:
        ErrorId: CANSM_E_MODE_REQUEST_TIMEOUT
    10: VP (CanSM.ASR40.BSMDeInitPn.T_S_TRCV_NORMAL_S_PN_CLEAR_WUF):
        CanSM calls CanIf_ClearTrcvWufFlag
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_TRCV_NORMAL_S_PN_CLEAR_WUF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>205</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_TRCV_NORMAL_S_TRCV_NORMAL</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>204</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.CanSMActivatePN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>105</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>755</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_REPEAT_MAX_DEINIT_PN_3</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkPartialNwTest/source/application/Tst_CanSM_Conf_SingleNetworkPartialNw.c</sourcefile>
      <sourceline>2116</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks if DET is reported when triggered with T_REPEAT_MAX in state S_TRCV_STANDBY
    of CANSM_BSM_DeinitPnSupportedProceed.
    All mode indications shall be asynchron.
    Partial Networking is activated for the network under test.
    Note: Although this test validates only the network with index 0
    it shall be taken into account that API function
    calls for other configured networks happen.
  
Test Object: 
    T_REPEAT_MAX
  
Test Precondition: 
    - CanSM module is in COMM_SILENT_COMMUNICATION
    - All indications from CanIf stubs shall be asynchronous.
  
Test Execution: 
    01: Request S_NOCO
    02: Call the MainFunction of CanSM
    03: Simulate CanSM_ClearTrcvWufFlagIndication
    04: Simulate CanSM_ControllerModeIndication with CANIF_CS_STOPPED
    05: Simulate CanSM_TransceiverModeIndication with CANTRCV_TRCVMODE_NORMAL
    06: Call the MainFunction of CanSM 10 times
    07: VP (CanSM.ASR40.BSMDeInitPn.T_S_TRCV_STANDBY_S_TRCV_STANDBY):
        CanIf_SetTrcvMode is called twice with
        TransceiverMode = CANTRCV_TRCVMODE_STANDBY
    08: VP:
        Verify if CanSM did not call Det_ReportError
    09: Call the MainFunction of CanSM
    10: VP (CanSM.ASR40.BSMDeInitPn.T_S_TRCV_STANDBY_S_PN_CLEAR_WUF):
        If development error detection is enabled,
        CanSM called Det_ReportError with:
        ErrorId: CANSM_E_MODE_REQUEST_TIMEOUT
    11: VP (CanSM.ASR40.BSMDeInitPn.T_S_TRCV_STANDBY_S_PN_CLEAR_WUF):
        CanSM calls CanIf_ClearTrcvWufFlag
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_TRCV_STANDBY_S_PN_CLEAR_WUF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>208</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_TRCV_STANDBY_S_TRCV_STANDBY</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>207</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.CanSMActivatePN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>105</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>756</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_REPEAT_MAX_DEINIT_PN_4</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkPartialNwTest/source/application/Tst_CanSM_Conf_SingleNetworkPartialNw.c</sourcefile>
      <sourceline>2240</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks if DET is reported when triggered with T_REPEAT_MAX in state S_CHECK_WFLAG_IN_CC_SLEEP
    of CANSM_BSM_DeinitPnSupportedProceed.
    All mode indications shall be asynchron.
    Partial Networking is activated for the network under test.
    Note: Although this test validates only the network with index 0
    it shall be taken into account that API function
    calls for other configured networks happen.
  
Test Object: 
    T_REPEAT_MAX
  
Test Precondition: 
    - CanSM module is in COMM_SILENT_COMMUNICATION
    - All indications from CanIf stubs shall be asynchronous.
  
Test Execution: 
    01: Request S_NOCO
    02: Call the MainFunction of CanSM
    03: Simulate CanSM_ClearTrcvWufFlagIndication
    04: Simulate CanSM_ControllerModeIndication with CANIF_CS_STOPPED
    05: Simulate CanSM_TransceiverModeIndication with CANTRCV_TRCVMODE_NORMAL
    06: Simulate CanSM_TransceiverModeIndication with CANTRCV_TRCVMODE_STANDBY
    07: Simulate CanSM_ControllerModeIndication with CANIF_CS_SLEEP
    08: Call the MainFunction of CanSM 10 times
    09: VP (CanSM.ASR40.BSMDeInitPn.T_S_CHECK_WFLAG_IN_CC_SLEEP_S_CHECK_WFLAG_IN_CC_SLEEP):
        CanIf_CheckTrcvWakeFlag is called twice
    10: VP:
        Verify if CanSM did not call Det_ReportError
    11: Call the MainFunction of CanSM
    12: VP (CanSM.ASR40.BSMDeInitPn.T_S_CHECK_WFLAG_IN_CC_SLEEP_S_PN_CLEAR_WUF):
        If development error detection is enabled,
        CanSM called Det_ReportError with:
        ErrorId: CANSM_E_MODE_REQUEST_TIMEOUT
    13: VP (CanSM.ASR40.BSMDeInitPn.T_S_CHECK_WFLAG_IN_CC_SLEEP_S_PN_CLEAR_WUF):
        CanSM calls CanIf_ClearTrcvWufFlag
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_CHECK_WFLAG_IN_CC_SLEEP_S_PN_CLEAR_WUF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>212</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_CHECK_WFLAG_IN_CC_SLEEP_S_CHECK_WFLAG_IN_CC_SLEEP</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>211</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.CanSMActivatePN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>105</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>757</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_REPEAT_MAX_DEINIT_PN_5</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkPartialNwTest/source/application/Tst_CanSM_Conf_SingleNetworkPartialNw.c</sourcefile>
      <sourceline>2370</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks if DET is reported when triggered with T_REPEAT_MAX in state S_CHECK_WFLAG_IN_NOT_CC_SLEEP
    of CANSM_BSM_DeinitPnSupportedProceed.
    All mode indications shall be asynchron.
    Partial Networking is activated for the network under test.
    Note: Although this test validates only the network with index 0
    it shall be taken into account that API function
    calls for other configured networks happen.
  
Test Object: 
    T_REPEAT_MAX
    Denial of CanSM_RequestComMode
  
Test Precondition: 
    - CanSM module is in COMM_SILENT_COMMUNICATION
    - All indications from CanIf stubs shall be asynchronous.
  
Test Execution: 
    01: Request S_NOCO
    02: Call the MainFunction of CanSM
    03: Simulate CanSM_ClearTrcvWufFlagIndication
    04: Simulate CanSM_ControllerModeIndication with CANIF_CS_STOPPED
    05: Simulate CanSM_TransceiverModeIndication with CANTRCV_TRCVMODE_NORMAL
    06: Simulate CanSM_TransceiverModeIndication with CANTRCV_TRCVMODE_STANDBY
    07: Simulate timeout when in CANIF_CS_SLEEP state to enter S_CHECK_WFLAG_IN_NOT_CC_SLEEP
    08: Call the MainFunction 5 times to simulate timeout when in S_CHECK_WFLAG_IN_NOT_CC_SLEEP
    09: VP (CanSM.ASR40.BSMDeInitPn.T_S_CHECK_WFLAG_IN_NOT_CC_SLEEP_S_CHECK_WFLAG_IN_NOT_CC_SLEEP):
        CanIf_CheckTrcvWakeFlag is called twice
    10: Call MainFunction 4 times and verify if CanSM did not call Det_ReportError
    11: Call the MainFunction of CanSM
    12: VP (CanSM.ASR40.BSMDeInitPn.T_S_CHECK_WFLAG_IN_NOT_CC_SLEEP_S_PN_CLEAR_WUF.2):
        If development error detection is enabled,
        CanSM called Det_ReportError with:
        ErrorId: CANSM_E_MODE_REQUEST_TIMEOUT
    13: VP (CanSM.ASR40.BSMDeInitPn.T_S_CHECK_WFLAG_IN_NOT_CC_SLEEP_S_PN_CLEAR_WUF.2):
        CanSM calls CanIf_ClearTrcvWufFlag
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_CHECK_WFLAG_IN_NOT_CC_SLEEP_S_PN_CLEAR_WUF.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>215</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_CHECK_WFLAG_IN_NOT_CC_SLEEP_S_CHECK_WFLAG_IN_NOT_CC_SLEEP</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>214</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.CanSMActivatePN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>105</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>758</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_REPEAT_MAX_PRE_FULLCOM_PN_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkPartialNwTest/source/application/Tst_CanSM_Conf_SingleNetworkPartialNw.c</sourcefile>
      <sourceline>2502</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks if DET is reported when triggered with T_REPEAT_MAX in state S_TRCV_NORMAL
    of CANSM_BSM_S_PRE_FULLCOM.
    All mode indications shall be asynchron.
    Partial Networking is activated for the network under test.
    Note: Although this test validates only the network with index 0
    it shall be taken into account that API function
    calls for other configured networks happen.
  
Test Object: 
    T_REPEAT_MAX
  
Test Precondition: 
    - CanSM module is in COMM_NO_COMMUNICATION
    - All indications from CanIf stubs shall be asynchronous.
  
Test Execution: 
    01: Call CanSM_RequestComMode with:
        ComM_Mode := COMM_FULL_COMMUNICATION.
    02: Call the MainFunction of CanSM 10 times
    03: VP (CanSM.ASR40.BSMPreFull.T_S_TRCV_NORMAL_S_TRCV_NORMAL):
        CanIf_SetControllerMode was called two times (once as initial call and once
        because of a CanSMModeRequestRepetitionMax of 1)
    04: VP:
        Verify if CanSM did not call Det_ReportError
    05: Call the MainFunction of CanSM
    06: VP (CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.Pn.1):
        If Development error detection is enabled,
        CanSM calls Det_ReportError with:
        ErrorId: CANSM_E_MODE_REQUEST_TIMEOUT
    07: VP (CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.Pn.1):
        CanSM called the following API function:
        CanIf_ClearTrcvWufFlag with:
        TransceiverId := 3
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.Pn.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>177</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMPreFull.T_S_TRCV_NORMAL_S_TRCV_NORMAL</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>228</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.CanSMActivatePN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>105</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>759</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_REPEAT_MAX_PRE_FULLCOM_PN_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkPartialNwTest/source/application/Tst_CanSM_Conf_SingleNetworkPartialNw.c</sourcefile>
      <sourceline>2599</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks if DET is reported when triggered with T_REPEAT_MAX in state S_CC_STOPPED
    of CANSM_BSM_S_PRE_FULLCOM.
    All mode indications shall be asynchron.
    Partial Networking is activated for the network under test.
    Note: Although this test validates only the network with index 0
    it shall be taken into account that API function
    calls for other configured networks happen.
  
Test Object: 
    T_REPEAT_MAX
  
Test Precondition: 
    - CanSM module is in COMM_NO_COMMUNICATION
    - All indications from CanIf stubs shall be asynchronous.
  
Test Execution: 
    01: Call CanSM_RequestComMode with:
        ComM_Mode := COMM_FULL_COMMUNICATION.
    02: Simulate CanSM_TransceiverModeIndication for CANTRCV_TRCVMODE_NORMAL
    03: Call the MainFunction of CanSM 10 times
    04: VP (CanSM.ASR40.BSMPreFull.T_S_CC_STOPPED_S_CC_STOPPED):
        CanIf_SetControllerMode was called two times (once as initial call and once
        because of a CanSMModeRequestRepetitionMax of 1)
    05: VP:
        Verify if CanSM did not call Det_ReportError
    06: Call the MainFunction of CanSM
    07: VP (CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.Pn.2):
        If Development error detection is enabled,
        CanSM calls Det_ReportError with:
        ErrorId: CANSM_E_MODE_REQUEST_TIMEOUT
    08: VP (CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.Pn.2):
        CanSM called the following API function:
        CanIf_ClearTrcvWufFlag with:
        TransceiverId := 3
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.Pn.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>179</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMPreFull.T_S_CC_STOPPED_S_CC_STOPPED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>230</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.CanSMActivatePN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>105</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>760</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_REPEAT_MAX_PRE_FULLCOM_PN_3</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkPartialNwTest/source/application/Tst_CanSM_Conf_SingleNetworkPartialNw.c</sourcefile>
      <sourceline>2701</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks if DET is reported when triggered with T_REPEAT_MAX in state S_CC_STARTED
    of CANSM_BSM_S_PRE_FULLCOM.
    All mode indications shall be asynchron.
    Partial Networking is activated for the network under test.
    Note: Although this test validates only the network with index 0
    it shall be taken into account that API function
    calls for other configured networks happen.
  
Test Object: 
    T_REPEAT_MAX
  
Test Precondition: 
    - CanSM module is in COMM_NO_COMMUNICATION
    - All indications from CanIf stubs shall be asynchronous.
  
Test Execution: 
    01: Call CanSM_RequestComMode with:
        ComM_Mode := COMM_FULL_COMMUNICATION.
    02: Simulate CanSM_TransceiverModeIndication for CANTRCV_TRCVMODE_NORMAL
    03: Simulate CanSM_ControllerModeIndication for CANIF_CS_STOPPED
    04: Call the MainFunction of CanSM 10 times
    05: VP (CanSM.ASR40.BSMPreFull.T_S_CC_STARTED_S_CC_STARTED):
        CanIf_SetControllerMode was called two times (once as initial call and once
        because of a CanSMModeRequestRepetitionMax of 1)
    06: VP:
        Verify if CanSM did not call Det_ReportError
    07: Call the MainFunction of CanSM
    08: VP (CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.Pn.3):
        If Development error detection is enabled,
        CanSM calls Det_ReportError with:
        ErrorId: CANSM_E_MODE_REQUEST_TIMEOUT
    09: VP (CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.Pn.3):
        CanSM called the following API function:
        CanIf_ClearTrcvWufFlag with:
        TransceiverId := 3
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.Pn.3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>181</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMPreFull.T_S_CC_STARTED_S_CC_STARTED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>231</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.CanSMActivatePN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>105</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>761</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_REPEAT_MAX_FULLCOM_PN_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkPartialNwTest/source/application/Tst_CanSM_Conf_SingleNetworkPartialNw.c</sourcefile>
      <sourceline>2808</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks if DET is reported when triggered with T_REPEAT_MAX in state S_RESTART_CC
    of CANSM_BSM_S_FULLCOM.
    All mode indications shall be asynchron.
    Partial Networking is activated for the network under test.
    Note: Although this test validates only the network with index 0
    it shall be taken into account that API function
    calls for other configured networks happen.
  
Test Object: 
    T_REPEAT_MAX
  
Test Precondition: 
    - CanSM module is in COMM_FULL_COMMUNICATION
    - All indications from CanIf stubs shall be asynchronous.
  
Test Execution: 
    01: Simulate bus-off to enter S_RESTART_CC
    02: Call the MainFunction of CanSM 10 times
    03: VP:
        CanSM called CanIf_SetControllerMode twice along with
        other calls due to T_BUS_OFF in the defined order:
        1. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_BUS_OFF
           Network := 3
        2. Dem_ReportErrorStatus with:
           EventId := CANSM_E_BUS_OFF
           EventStatus := DEM_EVENT_STATUS_PREFAILED
        3. CanIf_SetPduMode with:
           PduModeRequest := CANIF_TX_OFFLINE
           ControllerId := 5
        4. CanIf_SetControllerMode with:
           ControllerMode := CANIF_CS_STARTED
           ControllerId := 5
        5. CanIf_SetControllerMode with:
           ControllerMode := CANIF_CS_STARTED
           ControllerId := 5
           (CanSM.ASR40.BSMFull.T_S_RESTART_CC_S_RESTART_CC)
    04: VP:
        Verify if CanSM did not call Det_ReportError
    05: Call the MainFunction of CanSM
    06: VP (CanSM.ASR40.BSM.T_FULLCOM_PRE_NOCOM.Pn):
        If Development error detection is enabled,
        CanSM calls Det_ReportError with:
        ErrorId: CANSM_E_MODE_REQUEST_TIMEOUT
    07: VP (CanSM.ASR40.BSM.T_FULLCOM_PRE_NOCOM.Pn):
        CanSM called the following API function in defined order:
        1. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_NO_COMMUNICATION

        2. CanIf_ClearTrcvWufFlag with:
           TransceiverId := 3
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_FULLCOM_PRE_NOCOM.Pn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>169</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMFull.T_S_RESTART_CC_S_RESTART_CC</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>242</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.CanSMActivatePN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>105</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>762</internalId></specobject>
    <specobject>
      <id>TS_CANSM_S_RNOCOM_SYNC_PN</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkPartialNwTest/source/application/Tst_CanSM_Conf_SingleNetworkPartialNw.c</sourcefile>
      <sourceline>2940</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct behaviour of execution of the CANSM_BSM_S_PRE_NOCOM
    state (State Request NO COMmunication).
    All mode indications shall be synchron.
    Partial Networking is activated for the network under test.
    Note: Although this test validates only the network with index 0
    it shall be taken into account that during CanSM_Init API function
    calls for other configured networks happens.
  
Test Object: 
    Module initialization
  
Test Precondition: 
    - Transition to CANSM_BSM_S_PRE_NOCOM triggered
      (There are two possible trigger conditions:
       a) Maximum allowed wait time for a mode request expired
       b) A mode transition from silent to no communication was requested)
      This means that
      - the call to BswM_CanSM_CurrentState, CanIf_SetPduMode and CanIf_ClearTrcvWufFlag was done by CanSM and
         to be checked locally by test called
    - function trace buffer contains no unchecked function pointer (in counter equals out counter)
      when precondition above was triggered
  
Test Execution: 
    01: Prepare the CanIf stub to indicate the requested transceiver mode
        transition from inside the context of CanIf_SetTrcvMode.
    02: Prepare the CanIf stub to indicate the requested controller mode
        transition from inside the context of CanIf_SetControllerMode.
    03: Prepare the CanIf stub to indicate the clear transceiver WUF flag
        from inside the context of CanIf_ClearTrcvWufFlag.
    04: Prepare the CanIf stub to indicate the check transceiver wake flag
        from inside the context of CanIf_CheckTrcvWakeFlag.
    05: Simulate CanSM_ClearTrcvWufFlagIndication to start the transition synchronously
    06: VP:
        CanSM called the following API function in defined order:
        1. CanIf_SetControllerMode with:
           ControllerMode := CANIF_CS_STOPPED
           ControllerId := 5
           (CanSM.ASR40.BSMDeInitPn.T_S_PN_CLEAR_WUF_S_PN_CC_STOPPED)
        2. CanIf_SetTrcvMode with:
           TransceiverMode := CANTRCV_TRCVMODE_NORMAL
           TransceiverId := 3
           (CanSM.ASR40.BSMDeInitPn.T_S_PN_CC_STOPPED_S_TRCV_NORMAL)
        3. CanIf_SetTrcvMode with:
           TransceiverMode := CANTRCV_TRCVMODE_STANDBY
           TransceiverId := 3
           (CanSM.ASR40.BSMDeInitPn.T_S_TRCV_NORMAL_S_TRCV_STANDBY)
        4. CanIf_SetControllerMode with:
           ControllerMode := CANIF_CS_SLEEP
           ControllerId := 5
           (CanSM.ASR40.BSMDeInitPn.T_S_TRCV_STANDBY_S_CC_SLEEP)
        5. CanIf_CheckTrcvWakeFlag with:
           TransceiverId := 3
           (CanSM.ASR40.BSMDeInitPn.T_S_CC_SLEEP_S_CHECK_WFLAG_IN_CC_SLEEP)
        6  ComM_BusSM_ModeIndication with:
           ComMode := COMM_NO_COMMUNICATION
    07: Call CanSM_GetCurrentComMode to read the current CanSM mode
        network := &lt;id&gt; of network 0
    08: VP:
        CanSM_GetCurrentComMode return E_OK
    09: VP (CanSM.SWS_CanSM_00186):
        CanSM is in state COMM_NO_COMMUNICATION
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_PN_CLEAR_WUF_S_PN_CC_STOPPED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>197</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_PN_CC_STOPPED_S_TRCV_NORMAL</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>200</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_TRCV_NORMAL_S_TRCV_STANDBY</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>203</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_TRCV_STANDBY_S_CC_SLEEP</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>206</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_CC_SLEEP_S_CHECK_WFLAG_IN_CC_SLEEP</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>209</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00186</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>303</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.CanSMActivatePN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>105</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>763</internalId></specobject>
    <specobject>
      <id>TS_CANSM_NOCO_TXTIMEOUTEXCEPTION_SYNC</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkPartialNwTest/source/application/Tst_CanSM_Conf_SingleNetworkPartialNw.c</sourcefile>
      <sourceline>3085</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks that tx timeout recovery (CanSM_TxTimeoutException) does not
    have any effect if invoked in state "NO COMMUNICATION".
    All mode indications shall be synchron.
    Note: TxTimeoutException is implemented as specified in AUTOSAR SWS 4.1 rev3!
  
Test Object: 
    - Mode transition
    - CanSM_TxTimeoutException()
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_NOCOM
  
Test Execution: 
    01: Preparation of CanIf stub to be synchronous.
    02: Call CanSM_TxTimeoutException() with a valid network handle.
    03: Call main function once.
    04: VP (CanSM.EB.TxTimeoutException.Ignore):
        Verify that there were no state transition or recovery.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.EB.TxTimeoutException.Ignore</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>133</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00410</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>327</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>764</internalId></specobject>
    <specobject>
      <id>TS_CANSM_SICO_TXTIMEOUTEXCEPTION_SYNC</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkPartialNwTest/source/application/Tst_CanSM_Conf_SingleNetworkPartialNw.c</sourcefile>
      <sourceline>3164</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks that tx timeout recovery (CanSM_TxTimeoutException) does not
    have any effect if invoked in state "SILENT COMMUNICATION".
    All mode indications shall be synchron.
    Note: TxTimeoutException is implemented as specified in AUTOSAR SWS 4.1 rev3!
  
Test Object: 
    - Mode transition
    - CanSM_TxTimeoutException()
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_SILENTCOM
  
Test Execution: 
    01: Preparation of CanIf stub to be synchronous.
    02: Call CanSM_TxTimeoutException() with a valid network handle.
    03: Call main function once.
    04: VP (CanSM.EB.TxTimeoutException.Ignore):
        Verify that there were no state transition or recovery.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.EB.TxTimeoutException.Ignore</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>133</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00410</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>327</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>765</internalId></specobject>
    <specobject>
      <id>TS_CANSM_FUCO_TXTIMEOUTEXCEPTION_SYNC</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkPartialNwTest/source/application/Tst_CanSM_Conf_SingleNetworkPartialNw.c</sourcefile>
      <sourceline>3243</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks that tx timeout recovery (CanSM_TxTimeoutException) does not
    have any effect if invoked in state CANSM_S_BUSOFF_CHECK in "FULL COMMUNICATION".
    All mode indications shall be synchron.
    Note: TxTimeoutException is implemented as specified in AUTOSAR SWS 4.1 rev3!
  
Test Object: 
    - Mode transition
    - CanSM_TxTimeoutException()
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_FULLCOM, substate CANSM_S_BUSOFF_CHECK
  
Test Execution: 
    01: Preparation of CanIf stub to be synchronous.
    02: Call CanSM_TxTimeoutException() with a valid network handle.
    03: Call main function once.
    04: VP (CanSM.EB.TxTimeoutException.Ignore):
        Verify that there were no state transition or recovery.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00410</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>327</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.TxTimeoutException.Ignore</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>133</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>766</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_FUCO_NOCO_TXTIMEOUTEXCEPTION_PN</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkPartialNwTest/source/application/Tst_CanSM_Conf_SingleNetworkPartialNw.c</sourcefile>
      <sourceline>3324</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct transition of communication mode from CANSM_BSM_S_FULLCOM
     to CANSM_BSM_S_NOCOM by CanSM_RequestComMode(), which ignores invocation of
     CanSM_TxTimeoutException() as there is no further recovery process required.
    All mode indications shall be asynchron.
    Partial Networking is activated for the network under test.
    Note: Although this test validates only the network with index 0
    it shall be taken into account that API function
    calls for other configured networks happen.
  
Test Object: 
    - Module initialization
    - CanSM_TxTimeoutException()
  
Test Precondition: 
    - CanSM module is in COMM_FULL_COMMUNICATION (substate S_BUS_OFF_CHECK)
    - All indications from CanIf stubs shall be asynchronous.
  
Test Execution: 
    01: Request S_NOCO
    02: Call CanSM_TxTimeoutException() with a valid network handle
    03: Call the MainFunction of CanSM
    04: VP (CanSM.ASR40.BSM.T_FULLCOM_SILENTCOM.BusOffCheck.2,
            CanSM.ASR40.BSM.T_SILENTCOM_PRE_NOCOM.Pn):
        CanSM calls the following API functions in defined order:
        ----- to silent com -----
        1. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_SILENT_COMMUNICATION
           Network := 3

        2. CanIf_SetPduMode with:
           PduModeRequest := CANIF_TX_OFFLINE
           ControllerId := 5
        3. ComM_BusSM_ModeIndication with:
           ComMode := COMM_SILENT_COMMUNICATION
        ----- to pre no-com -----
        4. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_NO_COMMUNICATION
           Network := 3

        5. CanIf_ClearTrcvWufFlag with:
           TransceiverId := 3
    05: Simulate CanSM_ClearTrcvWufFlagIndication after another MainFunction call
    06: Call CanSM_TxTimeoutException() with a valid network handle
    07: Call the MainFunction of CanSM
    08: VP (CanSM.ASR40.BSMDeInitPn.T_S_PN_CLEAR_WUF_S_PN_CC_STOPPED):
        CanIf_SetControllerMode is called
    09: Simulate CanSM_ControllerModeIndication with CANIF_CS_STOPPED
        after another MainFunction call
    10: Call CanSM_TxTimeoutException() with a valid network handle
    11: Call the MainFunction of CanSM
    12: VP (CanSM.ASR40.BSMDeInitPn.T_S_PN_CC_STOPPED_S_TRCV_NORMAL):
        CanIf_SetTrcvMode is called
    13: Call CanSM_TxTimeoutException() with a valid network handle
    14: Simulate CanSM_TransceiverModeIndication with CANTRCV_TRCVMODE_NORMAL
        after another MainFunction call
    15: Call the MainFunction of CanSM
    16: VP (CanSM.ASR40.BSMDeInitPn.T_S_TRCV_NORMAL_S_TRCV_STANDBY):
        CanIf_SetTrcvMode is called
    17: Simulate CanSM_TransceiverModeIndication after another MainFunction call
    18: Call the MainFunction of CanSM
    19: VP (CanSM.ASR40.BSMDeInitPn.T_S_TRCV_STANDBY_S_CC_SLEEP):
        CanIf_SetControllerMode is called
    20: Call CanSM_TxTimeoutException() with a valid network handle
    21: Simulate CanSM_ControllerModeIndication with CANIF_CS_SLEEP
        after another MainFunction call
    22: Call the MainFunction of CanSM
    23: Call CanSM_TxTimeoutException() with a valid network handle
    24: VP (CanSM.ASR40.BSMDeInitPn.T_S_CC_SLEEP_S_CHECK_WFLAG_IN_CC_SLEEP):
        CanIf_CheckTrcvWakeFlag is called
    25: Simulate CanSM_CheckTransceiverWakeFlagIndication after another MainFunction call
    26: Call the MainFunction of CanSM
    27: VP (CanSM.ASR40.BSM.T_PRE_NOCOM_NOCOM.Pn.1):
        ComM_BusSM_ModeIndication is called with COMM_NO_COMMUNICATION
    28: Call CanSM_GetCurrentComMode to read the current CanSM mode
        network := &lt;id&gt; of network 0
    29: VP:
        CanSM_GetCurrentComMode returns E_OK
    30: VP(CanSM.SWS_CanSM_00410):
        CanSM is in state COMM_NO_COMMUNICATION
    31: One MainFunction call to ensure no change in states.
    32: VP(CanSM.EB.TxTimeoutException.NoCom):
        Verify if CanSM_TxTimeoutException() is ignored and there were no other state transition.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_FULLCOM_SILENTCOM.BusOffCheck.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>109</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_SILENTCOM_PRE_NOCOM.Pn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>190</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_PN_CLEAR_WUF_S_PN_CC_STOPPED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>197</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_PN_CC_STOPPED_S_TRCV_NORMAL</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>200</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_TRCV_NORMAL_S_TRCV_STANDBY</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>203</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_TRCV_STANDBY_S_CC_SLEEP</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>206</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitPn.T_S_CC_SLEEP_S_CHECK_WFLAG_IN_CC_SLEEP</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>209</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_PRE_NOCOM_NOCOM.Pn.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>193</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.CanSMActivatePN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>105</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.TxTimeoutException.Ignore</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>133</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00410</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>327</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>767</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_NOCO_FUCO_TXTIMEOUTEXCEPTION_PN</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkPartialNwTest/source/application/Tst_CanSM_Conf_SingleNetworkPartialNw.c</sourcefile>
      <sourceline>3594</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks that tx timeout recovery (CanSM_TxTimeoutException) does not
    have any effect if invoked during a transition from state "NO COMMUNICATION"
    towards state "FULL COMMUNICATION".
    Note: TxTimeoutException is implemented as specified in AUTOSAR SWS 4.1 rev3!
  
Test Object: 
    - Module initialization
    - CanSM_TxTimeoutException
  
Test Precondition: 
    - CanSM is in state S_NOCO
    - All indications from CanIf stubs shall be asynchronous.
  
Test Execution: 
    01: Call CanSM_RequestComMode with:
        network := &lt;id&gt; of network 0
        ComM_Mode := COMM_FULL_COMMUNICATION.
    02: CanSM called only the following API function:
        CanIf_SetTrcvMode with:
        TransceiverMode := CANTRCV_TRCVMODE_NORMAL
    03: VP(CanSM.EB.TxTimeoutException.RFUCO):
        Call CanSM_TxTimeoutException() with a valid network handle
    04: Call CanSM_TransceiverModeIndication with:
        TransceiverId := 3
        TransceiverMode := CANTRCV_TRCVMODE_NORMAL
    05: Call the MainFunction of CanSM
    06: CanSM_MainFunction called only the following API function:
        CanIf_SetControllerMode with:
        ControllerMode := CANIF_CS_STOPPED
    07: VP(CanSM.EB.TxTimeoutException.RFUCO):
        Call CanSM_TxTimeoutException() with a valid network handle
    08: Call CanSM_ControllerModeIndication with:
        ControllerId := 5
        ControllerMode := CANIF_CS_STOPPED
    09: Call the MainFunction of CanSM
    10: CanSM_MainFunction called only the following API function:
        CanIf_SetControllerMode with:
        ControllerMode := CANIF_CS_STARTED
    11: VP(CanSM.EB.TxTimeoutException.RFUCO):
        Call CanSM_TxTimeoutException() with a valid network handle
    12: Call CanSM_ControllerModeIndication with:
        ControllerId := 5
        ControllerMode := CANIF_CS_STARTED
    13: VP(CanSM.EB.TxTimeoutException.RFUCO):
        Call CanSM_TxTimeoutException() with a valid network handle
    14: Call the MainFunction of CanSM
    15: CanSM called the following API functions in defined order:
        1. CanIf_SetPduMode with:
           PduModeRequest := CANIF_ONLINE
        2. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_FULL_COMMUNICATION
           Network := 3
        3. ComM_BusSM_ModeIndication with:
           ComMode := COMM_FULL_COMMUNICATION
    16: Call CanSM_GetCurrentComMode to read the current CanSM mode
        network := &lt;id&gt; of network 0
    17: CanSM_GetCurrentComMode returns E_OK
    18: VP (CanSM.SWS_CanSM_00410, CanSM.EB.TxTimeoutException.RFUCO):
        CanSM is in state COMM_FULL_COMMUNICATION
    19: One MainFunction call to ensure no change in states
    20: VP (CanSM.EB.TxTimeoutException.Ignore):
        Verify that there were no state transition or recovery.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.EB.TxTimeoutException.Ignore</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>133</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00410</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>327</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>768</internalId></specobject>
    <specobject>
      <id>TS_CANSM_TXTIMEOUTEXCEPTION_ASYNC</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkPartialNwTest/source/application/Tst_CanSM_Conf_SingleNetworkPartialNw.c</sourcefile>
      <sourceline>3778</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct transitions (good-case) of the state machine
    CANSM_BSM_S_TX_TIMEOUT_EXCEPTION when all Indications are done asynchronous.
    Note: TxTimeoutException is implemented as specified in AUTOSAR SWS 4.1 rev3!
  
Test Object: 
    - Mode transition
    - CanSM_TxTimeoutException
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_FULLCOM, substate CANSM_S_NO_BUS_OFF
  
Test Execution: 
    01: Trigger Tx-Timeout-Exception
    02: VP (CanSM.ASR41.BSM.T_FULLCOM_TX_TIMEOUT_EXCEPTION):
        CanSM calls CanIf_SetControllerMode with
        ControllerMode := CANIF_CS_STOPPED
        ControllerId := 5
    03: Trigger indication for the controller
    04: VP:
        No transition takes place, since all transition are done asynchronous
    05: Trigger on MainFunction period.
    06: VP (CanSM.ASR41.TX_TIMEOUT_EXCEPTION.T_S_CC_STOPPED_S_CC_STARTED):
        CanSM calls CanIf_SetControllerMode with
        ControllerMode := CANIF_CS_STARTED
        ControllerId := 5
    07: Trigger indication for the controller
    08: VP:
        No transition takes place, since all transition are done asynchronous
    09: Trigger on MainFunction period.
    10: VP (CanSM.SWS_CanSM_00655):
        CanSM sets the Pdu mode back to ONLINE
    11: VP (CanSM.ASR41.BSM.T_TX_TIMEOUT_EXCEPTION_FULLCOM):
        CanSM enters state CANSM_S_NO_BUS_OFF
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00410</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>327</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR41.BSM.T_FULLCOM_TX_TIMEOUT_EXCEPTION</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>96</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR41.TX_TIMEOUT_EXCEPTION.T_S_CC_STOPPED_S_CC_STARTED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>99</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR41.BSM.T_TX_TIMEOUT_EXCEPTION_FULLCOM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>97</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00655</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>526</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>769</internalId></specobject>
    <specobject>
      <id>TS_CANSM_TXTIMEOUTEXCEPTION_SYNC</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkPartialNwTest/source/application/Tst_CanSM_Conf_SingleNetworkPartialNw.c</sourcefile>
      <sourceline>3906</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct transitions (good-case) of the state machine
    CANSM_BSM_S_TX_TIMEOUT_EXCEPTION when all Indications are done synchronous.
    Note: TxTimeoutException is implemented as specified in AUTOSAR SWS 4.1 rev3!
  
Test Object: 
    - Mode transition
    - CanSM_TxTimeoutException
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_FULLCOM, substate CANSM_S_NO_BUS_OFF
  
Test Execution: 
    01: Prepare the CanIf stub (controller functions) to make all indications synchronous
    02: Trigger Tx-Timeout-Exception
    03: VP (CanSM.ASR41.BSM.T_FULLCOM_TX_TIMEOUT_EXCEPTION):
        CanSM calls CanIf_SetControllerMode with
        ControllerMode := CANIF_CS_STOPPED
        ControllerId := 5
    04: VP (CanSM.ASR41.TX_TIMEOUT_EXCEPTION.T_S_CC_STOPPED_S_CC_STARTED):
        CanSM calls CanIf_SetControllerMode with
        ControllerMode := CANIF_CS_STARTED
        ControllerId := 5
    05: VP (CanSM.SWS_CanSM_00655):
           CanSM sets the Pdu mode back to ONLINE
    06: VP (CanSM.ASR41.BSM.T_TX_TIMEOUT_EXCEPTION_FULLCOM):
        CanSM enters state CANSM_S_NO_BUS_OFF
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00410</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>327</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR41.BSM.T_FULLCOM_TX_TIMEOUT_EXCEPTION</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>96</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR41.TX_TIMEOUT_EXCEPTION.T_S_CC_STOPPED_S_CC_STARTED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>99</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR41.BSM.T_TX_TIMEOUT_EXCEPTION_FULLCOM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>97</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00655</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>526</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>770</internalId></specobject>
    <specobject>
      <id>TS_CANSM_TXTIMEOUTEXCEPTION_ASYNC_SYNC_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkPartialNwTest/source/application/Tst_CanSM_Conf_SingleNetworkPartialNw.c</sourcefile>
      <sourceline>4012</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct transitions of the state machine
    CANSM_BSM_S_TX_TIMEOUT_EXCEPTION when the first retry of setting the
    controller mode (S_CC_STOPPED) after a timeout gets a synchronous indication.
    Note: TxTimeoutException is implemented as specified in AUTOSAR SWS 4.1 rev3!
  
Test Object: 
    - Mode transition
    - CanSM_TxTimeoutException
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_FULLCOM, substate CANSM_S_NO_BUS_OFF
  
Test Execution: 
    01: Trigger Tx-Timeout-Exception
    02: VP:
        CanSM calls CanIf_SetControllerMode with
        ControllerMode := CANIF_CS_STOPPED
        ControllerId := 5
    03: Let time CanSMModeRequestRepetitionTime-1 elapse
    04: Set the CanIf stub to give a synchronous indication
    05: Let an additional MainFunction cycle pass
    06: VP (CanSM.ASR41.TX_TIMEOUT_EXCEPTION.T_S_CC_STOPPED_S_CC_STARTED):
        CanSM calls CanIf_SetControllerMode with
        ControllerMode := CANIF_CS_STARTED
        ControllerId := 5
    07: VP (CanSM.SWS_CanSM_00655):
        CanSM sets the Pdu mode back to ONLINE
    08: VP:
        CanSM enters state CANSM_S_NO_BUS_OFF
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR41.TX_TIMEOUT_EXCEPTION.T_S_CC_STOPPED_S_CC_STARTED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>99</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00655</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>526</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>771</internalId></specobject>
    <specobject>
      <id>TS_CANSM_TXTIMEOUTEXCEPTION_ASYNC_SYNC_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkPartialNwTest/source/application/Tst_CanSM_Conf_SingleNetworkPartialNw.c</sourcefile>
      <sourceline>4128</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct transitions of the state machine
    CANSM_BSM_S_TX_TIMEOUT_EXCEPTION when the first retry of setting the
    controller mode S_CC_STARTED) after a timeout gets a synchronous indication.
    Note: TxTimeoutException is implemented as specified in AUTOSAR SWS 4.1 rev3!
  
Test Object: 
    - Mode transition
    - CanSM_TxTimeoutException
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_FULLCOM, substate CANSM_S_NO_BUS_OFF
  
Test Execution: 
    01: Trigger Tx-Timeout-Exception
    02: Continue with Tx-Timeout-Exception until CanSM reaches state S_CC_STARTED
    03: Let time CanSMModeRequestRepetitionTime-1 elapse
    04: Set the CanIf stub to give a synchronous indication
    05: Let an additional MainFunction cycle pass
    06: VP (CanSM.SWS_CanSM_00655):
        CanSM sets the Pdu mode back to ONLINE
    07: VP (CanSM.ASR41.BSM.T_TX_TIMEOUT_EXCEPTION_FULLCOM):
        CanSM enters state CANSM_S_NO_BUS_OFF
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR41.BSM.T_TX_TIMEOUT_EXCEPTION_FULLCOM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>97</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00655</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>526</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>772</internalId></specobject>
    <specobject>
      <id>TS_CANSM_TXTIMEOUTEXCEPTION_TIMEOUT_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkPartialNwTest/source/application/Tst_CanSM_Conf_SingleNetworkPartialNw.c</sourcefile>
      <sourceline>4234</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the behavior of the CANSM_BSM_S_TX_TIMEOUT_EXCEPTION
    state machine if a timeout for the controller mode indication (stop) occurs.
    Note: TxTimeoutException is implemented as specified in AUTOSAR SWS 4.1 rev3!
  
Test Object: 
    - CanSM_TxTimeoutException
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_FULLCOM, substate CANSM_S_NO_BUS_OFF
  
Test Execution: 
    01: Trigger Tx-Timeout-Exception
    02: VP:
        CanSM calls CanIf_SetControllerMode with
        ControllerMode := CANIF_CS_STOPPED
        ControllerId := 5
    03: Let time CanSMModeRequestRepetitionTime elapse
    04: VP (CanSM.ASR41.TX_TIMEOUT_EXCEPTION.T_S_CC_STOPPED_S_CC_STOPPED):
        CanSM repeated the call to CanIf_SetControllerMode because of
        the elapsed timeout with
        ControllerMode := CANIF_CS_STOPPED
        ControllerId := 5
    05: Finish Tx-Timeout-Exception
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR41.TX_TIMEOUT_EXCEPTION.T_S_CC_STOPPED_S_CC_STOPPED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>98</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>773</internalId></specobject>
    <specobject>
      <id>TS_CANSM_TXTIMEOUTEXCEPTION_TIMEOUT_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkPartialNwTest/source/application/Tst_CanSM_Conf_SingleNetworkPartialNw.c</sourcefile>
      <sourceline>4321</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the behavior of the CANSM_BSM_S_TX_TIMEOUT_EXCEPTION
    state machine if a timeout for the controller mode indication (start) occurs.
    Note: TxTimeoutException is implemented as specified in AUTOSAR SWS 4.1 rev3!
  
Test Object: 
    - CanSM_TxTimeoutException
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_FULLCOM, substate CANSM_S_NO_BUS_OFF
  
Test Execution: 
    01: Trigger Tx-Timeout-Exception
    02: Simulate mode indication for the CanIf_SetControllerMode request with
        ControllerMode := CANIF_CS_STOPPED
    03: VP:
        CanSM calls CanIf_SetControllerMode with
        ControllerMode := CANIF_CS_STARTED
        ControllerId := 5
    04: Let time CanSMModeRequestRepetitionTime elapse
    05: VP (CanSM.ASR41.TX_TIMEOUT_EXCEPTION.T_S_CC_STARTED_S_CC_STARTED):
        CanSM repeated the call to CanIf_SetControllerMode because of
        the elapsed timeout with
        ControllerMode := CANIF_CS_STARTED
        ControllerId := 5
    06: Finish Tx-Timeout-Exception
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR41.TX_TIMEOUT_EXCEPTION.T_S_CC_STARTED_S_CC_STARTED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>100</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>774</internalId></specobject>
    <specobject>
      <id>TS_CANSM_TXTIMEOUTEXCEPTION_TIMEOUT_3</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkPartialNwTest/source/application/Tst_CanSM_Conf_SingleNetworkPartialNw.c</sourcefile>
      <sourceline>4413</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the behavior of the state machine CANSM_BSM_S_TX_TIMEOUT_EXCEPTION
    if CanSM gets no indication for the request of setting the controller to mode
    CANIF_CS_STOPPED ( = timeout elapses)
    If DET is enabled, CanSM shall report DET error CANSM_E_MODE_REQUEST_TIMEOUT
    and make a transition to CANSM_BSM_S_NOCOM.
    Mode indications shall happen asynchronous.
  
Test Object: 
    - CanSM_TxTimeoutException
    - T_REPEAT_MAX
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_FULLCOM, substate CANSM_S_NO_BUS_OFF
  
Test Execution: 
    01: Trigger Tx-Timeout-Exception
    02: Triger MainFunctions to continue in time until one Mainfunction
        before trigger T_REPEAT_MAX occurs.
    03: VP:
        CanSM must not call Det_ReportError
    04: Trigger T_REPEAT_MAX
    05: VP (CanSM.ASR41.TX_TIMEOUT_EXCEPTION.T_S_CC_STOPPED_PRE_NOCOM.Pn):
        If development error detection is enabled,
        CanSM called Det_ReportError with:
        ErrorId: CANSM_E_MODE_REQUEST_TIMEOUT
    06: VP (CanSM.ASR41.TX_TIMEOUT_EXCEPTION.T_S_CC_STOPPED_PRE_NOCOM.Pn):
        CanSM shall start a transition to CANSM_BSM_S_NOCOM
    07: VP (CanSM.SWS_CanSM_00655):
        CanSM must not call CanSM_SetPduMode after Tx-Timeout-Exception 
        was triggered and T_REPEAT_MAX was reached
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR41.TX_TIMEOUT_EXCEPTION.T_S_CC_STOPPED_PRE_NOCOM.Pn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>101</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00655</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>526</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>775</internalId></specobject>
    <specobject>
      <id>TS_CANSM_TXTIMEOUTEXCEPTION_TIMEOUT_4</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkPartialNwTest/source/application/Tst_CanSM_Conf_SingleNetworkPartialNw.c</sourcefile>
      <sourceline>4512</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the behavior of the state machine CANSM_BSM_S_TX_TIMEOUT_EXCEPTION
    if CanSM gets no indication for the request of setting the controller to mode
    CANIF_CS_STARTED ( = timeout elapses)
    If DET is enabled, CanSM shall report DET error CANSM_E_MODE_REQUEST_TIMEOUT
    and make a transition to CANSM_BSM_S_NOCOM.
    Mode indications shall happen asynchronous.
  
Test Object: 
    - CanSM_TxTimeoutException
    - T_REPEAT_MAX
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_FULLCOM, substate CANSM_S_NO_BUS_OFF
  
Test Execution: 
    01: Trigger Tx-Timeout-Exception
    02: Continue until CanSM makes a controller mode request with
        mode CANIF_CS_STARTED.
    03: Triger MainFunctions to continue in time until one Mainfunction
        before trigger T_REPEAT_MAX occurs.
    04: VP:
        CanSM must not call Det_ReportError
    05: Trigger T_REPEAT_MAX
    06: VP (CanSM.ASR41.TX_TIMEOUT_EXCEPTION.T_S_CC_STARTED_PRE_NOCOM.Pn):
        If development error detection is enabled,
        CanSM called Det_ReportError with:
        ErrorId: CANSM_E_MODE_REQUEST_TIMEOUT
    07: VP (CanSM.ASR41.TX_TIMEOUT_EXCEPTION.T_S_CC_STARTED_PRE_NOCOM.Pn):
        CanSM shall start a transition to CANSM_BSM_S_NOCOM
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR41.TX_TIMEOUT_EXCEPTION.T_S_CC_STARTED_PRE_NOCOM.Pn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>102</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>776</internalId></specobject>
    <specobject>
      <id>TS_CANSM_TXTIMEOUTEXCEPTION_TIMEOUT_5</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkPartialNwTest/source/application/Tst_CanSM_Conf_SingleNetworkPartialNw.c</sourcefile>
      <sourceline>4610</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the behavior of the state machine CANSM_BSM_S_TX_TIMEOUT_EXCEPTION
    if CanSM gets no indication for the request of setting the controller to mode
    CANIF_CS_STARTED ( = timeout elapses)
    If DET is enabled, CanSM shall report DET error CANSM_E_MODE_REQUEST_TIMEOUT
    and make a transition to CANSM_BSM_S_NOCOM.
    Mode indications shall happen asynchronous.
  
Test Object: 
    - CanSM_TxTimeoutException
    - T_REPEAT_MAX
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_FULLCOM, substate CANSM_S_NO_BUS_OFF
  
Test Execution: 
    01: Trigger Tx-Timeout-Exception
    02: Simulate mode indication for the CanIf_SetControllerMode request with
        ControllerMode := CANIF_CS_STOPPED.
    03: Triger MainFunctions to continue in time until one Mainfunction
        before trigger T_REPEAT_MAX occurs.
    04: VP:
        CanSM must not call Det_ReportError
    05: Trigger T_REPEAT_MAX
    06: VP (CanSM.ASR41.TX_TIMEOUT_EXCEPTION.T_S_CC_STARTED_PRE_NOCOM.Pn):
        If development error detection is enabled,
        CanSM called Det_ReportError with:
        ErrorId: CANSM_E_MODE_REQUEST_TIMEOUT
    07: VP (CanSM.ASR41.TX_TIMEOUT_EXCEPTION.T_S_CC_STARTED_PRE_NOCOM.Pn):
        CanSM shall start a transition to CANSM_BSM_S_NOCOM
    08: VP(CanSM.SWS_CanSM_00655):
        CanSM must not call CanSM_SetPduMode
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR41.TX_TIMEOUT_EXCEPTION.T_S_CC_STARTED_PRE_NOCOM.Pn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>102</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00655</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>526</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>777</internalId></specobject>
    <specobject>
      <id>TS_CANSM_REPEATED_TXTIMEOUTEXCEPTION</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkPartialNwTest/source/application/Tst_CanSM_Conf_SingleNetworkPartialNw.c</sourcefile>
      <sourceline>4724</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test performs 2 subsequent Tx-Timeout-exception recoveries.
    There must no be any differences between both recoveries.
    Note: TxTimeoutException is implemented as specified in AUTOSAR SWS 4.1 rev3!
  
Test Object: 
    - Mode transition
    - CanSM_TxTimeoutException()
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_SILENTCOM
  
Test Execution: 
    01: Trigger Tx-Timeout-Exception
    02: VP:
        Check that Tx-Timeout recovery works
        (analog to TS_CANSM_TXTIMEOUTEXCEPTION_SYNC or TS_CANSM_TXTIMEOUTEXCEPTION_ASYNC)
    03: Trigger a second Tx-Timeout-Exception
    04: VP:
        Check that Tx-Timeout recovery works again
        (analog to TS_CANSM_TXTIMEOUTEXCEPTION_SYNC or TS_CANSM_TXTIMEOUTEXCEPTION_ASYNC)
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00410</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>327</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>778</internalId></specobject>
    <specobject>
      <id>TS_CANSM_TXTIMEOUTEXCEPTION_2ND_CALL</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkPartialNwTest/source/application/Tst_CanSM_Conf_SingleNetworkPartialNw.c</sourcefile>
      <sourceline>4788</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks that a call to CanSM_TxTimeoutException has no effect
    if there is already an ongoing Tx-Timeout-Exception recovery.
  
Test Object: 
    - CanSM_TxTimeoutException
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_FULLCOM, substate CANSM_S_NO_BUS_OFF
  
Test Execution: 
    01: Trigger Tx-Timeout-Exception
    02: VP:
        CanSM calls CanIf_SetControllerMode with
        ControllerMode := CANIF_CS_STOPPED
        ControllerId := 5
    03: Trigger Tx-Timeout-Exception a 2nd time
    04: Finish Tx-Timeout-Exception
    05: VP (CanSM.SWS_CanSM_00655):
        CanSM sets the Pdu mode back to ONLINE
    06: VP (CanSM.EB.TxTimeoutException.OngoingRecovery):
        CanSM shall be in state COMM_FULL_COMMUNICATION
    07: Trigger a MainFunction cycle
    08: VP (CanSM.EB.TxTimeoutException.OngoingRecovery):
        No additional transition shall happen.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.EB.TxTimeoutException.OngoingRecovery</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>132</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00655</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>526</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>779</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_CC_STARTED_INDICATED_CHANGE_BR_NOCO_PN_ASYNC</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkPartialNwTest/source/application/Tst_CanSM_Conf_SingleNetworkPartialNw.c</sourcefile>
      <sourceline>4889</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test shall verify the transition T_CC_STARTED_INDICATED from state S_CC_STARTED of
    CANSM_BSM_S_CHANGE_BAUDRATE to CANSM_BSM_S_PRE_NOCOM with following constraints:
    - CanSM_ControllerModeIndications() are asynchronous
    - CanSM_RequestComMode() shall put the COM mode to COMM_NO_COMMUNICATION
    - Partial network supported
  
Test Object: 
    Mode transition
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_FULLCOM; substate S_NO_BUS_OFF
  
Test Execution: 
    01: Disable synchronous controller mode indication and clear wake-up flag indication.
    02: Trigger transition T_CHANGE_BR_REQUEST (S_NO_BUS_OFF to S_CC_STOPPED). Call
        CanSM_SetBaudrate() with new baud rate for corresponding CAN network.

    03: Perform controller mode indication.
    04: Call CanSM_MainFunction() to continue.
    05: Call CanSM_RequestComMode() with ComM_Mode set to COMM_NO_COMMUNICATION for the
        corresponding CAN network.
    06: Perform controller mode indication.
    07: Call CanSM_MainFunction() to continue.
    08: VP(CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.Pn.3): Verify that effect E_PRE_NOCOM is
        executed. BswM_CanSM_CurrentState() is called with CurrentState set to
        CANSM_BSWM_SILENT_COMMUNICATION for the corresponding CAN network.

    9: VP(CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.Pn.3): Verify that do operation
        DO_CLEAR_TRCV_WUF is executed (Guard G_NO_COM_MODE_REQUESTED and CANSM_BSM_G_PN_SUPPORTED
        passed). CanIf_ClearTrcvWufFlag() is called for corresponding transceiver.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.Pn.3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>187</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>780</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_REPEAT_MAX_CHANGE_BR_S_CC_STOPPED_PN</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkPartialNwTest/source/application/Tst_CanSM_Conf_SingleNetworkPartialNw.c</sourcefile>
      <sourceline>5025</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks if DET is reported when triggered with T_REPEAT_MAX in state S_CC_STOPPED
    of CANSM_BSM_S_CHANGE_BAUDRATE and verify the correctness of the triggered transition with
    following constraints:
    - CanSM_ControllerModeIndications() are asynchronous
    - Partial network supported
  
Test Object: 
    T_REPEAT_MAX
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_FULLCOM; substate S_NO_BUS_OFF
  
Test Execution: 
    01: Disable synchronous controller mode indication and clear wake-up flag indication.
    02: Trigger transition T_CHANGE_BR_REQUEST (S_NO_BUS_OFF to S_CC_STOPPED). Call
        CanSM_SetBaudrate() with new baud rate for corresponding CAN network.

    03: Call the MainFunction of CanSM 10 times
    04: VP(CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.Pn.1): CanIf_SetControllerMode was called
        second time with controller mode CANIF_CS_STOPPED (once as initial call and once because of
        a CanSMModeRequestRepetitionMax of 1).
    05: Call the MainFunction to continue.
    06: VP(CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.Pn.1): If development error detection is
        enabled, CanSM called Det_ReportError() with error code CANSM_E_MODE_REQUEST_TIMEOUT.
    07: VP(CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.Pn.1): Verify that effect E_PRE_NOCOM is
        executed. BswM_CanSM_CurrentState() is called with CurrentState set to
        CANSM_BSWM_SILENT_COMMUNICATION for the corresponding CAN network.

    08: VP(CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.Pn.1): Verify that do operation
        DO_CLEAR_TRCV_WUF is executed (Guard CANSM_BSM_G_PN_SUPPORTED passed).
        CanIf_ClearTrcvWufFlag() is called for corresponding transceiver.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.Pn.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>183</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>781</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_REPEAT_MAX_CHANGE_BR_S_CC_STARTED_PN</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkPartialNwTest/source/application/Tst_CanSM_Conf_SingleNetworkPartialNw.c</sourcefile>
      <sourceline>5165</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks if DET is reported when triggered with T_REPEAT_MAX in state S_CC_STARTED
    of CANSM_BSM_S_CHANGE_BAUDRATE and verify the correctness of the triggered transition with
    following constraints:
    - CanSM_ControllerModeIndications() are asynchronous
    - Partial network supported
  
Test Object: 
    T_REPEAT_MAX
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_FULLCOM; substate S_NO_BUS_OFF
  
Test Execution: 
    01: Disable synchronous controller mode indication and clear wake-up flag indication.
    02: Trigger transition T_CHANGE_BR_REQUEST (S_NO_BUS_OFF to S_CC_STOPPED). Call
        CanSM_SetBaudrate() with new baud rate for corresponding CAN network.

    03: Perform controller mode indication.
    04: Call CanSM_MainFunction() to continue.

    05: Call the MainFunction of CanSM 10 times
    06: VP(CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.Pn.2): CanIf_SetControllerMode was called
        second time with controller mode CANIF_CS_STOPPED (once as initial call and once because of
        a CanSMModeRequestRepetitionMax of 1).
    07: Call the MainFunction to continue.
    08: VP(CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.Pn.2): If development error detection is
        enabled, CanSM called Det_ReportError() with error code CANSM_E_MODE_REQUEST_TIMEOUT.
    09: VP(CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.Pn.2): Verify that effect E_PRE_NOCOM is
        executed. BswM_CanSM_CurrentState() is called with CurrentState set to
        CANSM_BSWM_SILENT_COMMUNICATION for the corresponding CAN network.

    10: VP(CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.Pn.2): Verify that do operation
        DO_CLEAR_TRCV_WUF is executed (Guard CANSM_BSM_G_PN_SUPPORTED passed).
        CanIf_ClrTrcvWufFlag() is called for corresponding transceiver.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.Pn.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>185</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>782</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANSM_T_NOIN_NOCO_SYNC</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkTest/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>80</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct transition of communication mode from
    CANSM_BSM_S_NOT_INITIALIZED to CANSM_BSM_S_NOCOM.
    All mode indications shall be synchron.
    Note: Although this test validates only the first network
    it shall be taken into account that during CanSM_Init API function
    calls for other configured networks happens.
  
Test Object: 
    Module initialization
  
Test Precondition: 
    - CanSM module is NOT initialized
    - Test is executed for a configuration with and one without a transceiver
  
Test Execution: 
    IF transceiver is configured
        01: Prepare the CanIf stub to indicate the requested transceiver mode
            transition from inside the context of CanIf_SetTrcvMode.
    ENDIF
    02: Prepare the CanIf stub to indicate the requested controller mode
        transition from inside the context of CanIf_SetControllerMode.
    03: Initialize CanSM
    04: VP:
        CanSM called the following API function in defined order:
        1. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_NO_COMMUNICATION
           Network := 3
           (CanSM.ASR40.BSM.T_NOT_INITIALIZED_PRE_NOCOM.NoPn)
        2. CanIf_SetControllerMode with:
           ControllerMode := CANIF_CS_STOPPED
           ControllerId := 5
           (CanSM.ASR40.BSM.T_NOT_INITIALIZED_PRE_NOCOM.NoPn)
        3. CanIf_SetControllerMode with:
           ControllerMode := CANIF_CS_SLEEP
           ControllerId := 5
           (CanSM.ASR40.BSMDeInitNoPn.T_S_CC_STOPPED_S_CC_SLEEP)
        IF transceiver is configured
            4. CanIf_SetTrcvMode with:
               TransceiverMode := CANTRCV_TRCVMODE_NORMAL
               TransceiverId := 3
               (CanSM.ASR40.BSMDeInitNoPn.T_S_CC_SLEEP_S_TRCV_NORMAL)
            5. CanIf_SetTrcvMode with:
               TransceiverMode := CANTRCV_TRCVMODE_STANDBY
               TransceiverId := 3
               (CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_NORMAL_S_TRCV_STANDBY)
            (CanSM.EB.Transitions.NoTransceiver.2)
        ENDIF
    05: VP (CanSM.ASR40.BSM.T_PRE_NOCOM_NOCOM.NoPn.2):
        CanSM does not indicate ComM_BusSM_ModeIndication
    06: Call CanSM_GetCurrentComMode to read the current CanSM mode
        network := &lt;id&gt; of network 0
    07: VP (CanSM.SWS_CanSM_00371):
        CanSM_GetCurrentComMode returns E_OK
    08: VP (CanSM.SWS_CanSM_00186):
        CanSM is in state COMM_NO_COMMUNICATION
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_NOT_INITIALIZED_PRE_NOCOM.NoPn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>195</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_CC_STOPPED_S_CC_SLEEP</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>216</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_CC_SLEEP_S_TRCV_NORMAL</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>219</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_NORMAL_S_TRCV_STANDBY</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>222</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_PRE_NOCOM_NOCOM.NoPn.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>192</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.Transitions.NoTransceiver.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>106</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00371</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>317</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00424</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>341</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>783</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_NOCO_FUCO_SYNC</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkTest/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>228</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct transition of communication mode from
    CANSM_BSM_S_NOCOM to CANSM_BSM_S_FULLCOM.
    All mode indications shall be synchron.
  
Test Object: 
    Mode transition
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_NOCOM
    - Test is executed for a configuration with and one without a transceiver
  
Test Execution: 
    IF transceiver is configured
        01: Prepare the CanIf stub to indicate the requested transceiver mode
            transition from inside the context of CanIf_SetTrcvMode.
    ENDIF
    02: Prepare the CanIf stub to indicate the requested controller mode
        transition from inside the context of CanIf_SetControllerMode.
    03: Call CanSM_RequestComMode with:
        network := &lt;id&gt; of network 0
        ComM_Mode := COMM_FULL_COMMUNICATION.
    04: VP (CanSM.SWS_CanSM_00369):
        CanSM_RequestComMode returned E_OK
    05: VP:
        CanSM called the following API functions in defined order:
        IF transceiver is configured
            1. CanIf_SetTrcvMode with:
               TransceiverMode := CANTRCV_TRCVMODE_NORMAL
               TransceiverId := 3
               (CanSM.ASR40.BSM.T_NOCOM_PRE_FULLCOM)
               (CanSM.EB.Transitions.NoTransceiver.3)
        ENDIF
        2. CanIf_SetControllerMode with:
           ControllerMode := CANIF_CS_STOPPED
           ControllerId := 5
           (CanSM.ASR40.BSMPreFull.T_S_TRCV_NORMAL_S_CC_STOPPED)
        3. CanIf_SetControllerMode with:
           ControllerMode := CANIF_CS_STARTED
           ControllerId := 5
           (CanSM.ASR40.BSMPreFull.T_S_CC_STOPPED_S_CC_STARTED)
        4. CanIf_SetPduMode with:
           PduModeRequest := CANIF_ONLINE
           ControllerId := 5
           (CanSM.ASR40.BSM.T_PRE_FULLCOM_FULLCOM)
        5. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_FULL_COMMUNICATION
           Network := 3
           (CanSM.ASR40.BSM.T_PRE_FULLCOM_FULLCOM) 
		6. ComM_BusSM_ModeIndication with:
           ComMode := COMM_FULL_COMMUNICATION
           (CanSM.ASR40.BSM.T_PRE_FULLCOM_FULLCOM)
    06: Call CanSM_GetCurrentComMode to read the current CanSM mode
        network := &lt;id&gt; of network 0
    07: VP (CanSM.SWS_CanSM_00371):
        CanSM_GetCurrentComMode returns E_OK
    08: VP (CanSM.SWS_CanSM_00186):
        CanSM is in state COMM_FULL_COMMUNICATION
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_NOCOM_PRE_FULLCOM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>175</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMPreFull.T_S_TRCV_NORMAL_S_CC_STOPPED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>227</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMPreFull.T_S_CC_STOPPED_S_CC_STARTED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>229</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_PRE_FULLCOM_FULLCOM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>167</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00369</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>315</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00371</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>317</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00186</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>303</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>784</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_NOCO_FUCO_ASYNC</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkTest/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>375</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct transition of communication mode from
    CANSM_BSM_S_NOCOM to CANSM_BSM_S_FULLCOM.
    All mode indications shall be asynchron.
  
Test Object: 
    Module initialization
  
Test Precondition: 
    - CanSM is in state S_NOCO
    - Test is executed for a configuration with and one without a transceiver
  
Test Execution: 
    01: Call CanSM_RequestComMode with:
        network := &lt;id&gt; of network 0
        ComM_Mode := COMM_FULL_COMMUNICATION.
    IF transceiver is configured:
        02: VP (CanSM.ASR40.BSM.T_NOCOM_PRE_FULLCOM, CanSM.EB.Transitions.NoTransceiver.3):
            CanSM called only the following API function:
            CanIf_SetTrcvMode with:
            TransceiverMode := CANTRCV_TRCVMODE_NORMAL
        03: Call CanSM_TransceiverModeIndication with:
            TransceiverId := 3
            TransceiverMode := CANTRCV_TRCVMODE_NORMAL
        04: Call the MainFunction of CanSM
    ENDIF
    05: VP (CanSM.ASR40.BSMPreFull.T_S_TRCV_NORMAL_S_CC_STOPPED):
        CanSM_MainFunction called only the following API function:
        CanIf_SetControllerMode with:
        ControllerMode := CANIF_CS_STOPPED
    06: Call CanSM_ControllerModeIndication with:
        ControllerId := 5
        ControllerMode := CANIF_CS_STOPPED
    07: Call the MainFunction of CanSM
    08: VP (CanSM.ASR40.BSMPreFull.T_S_CC_STOPPED_S_CC_STARTED):
        CanSM_MainFunction called only the following API function:
        CanIf_SetControllerMode with:
        ControllerMode := CANIF_CS_STARTED
    09: Call CanSM_ControllerModeIndication with:
        ControllerId := 5
        ControllerMode := CANIF_CS_STARTED
    10: Call the MainFunction of CanSM
    11: VP (CanSM.ASR40.BSM.T_PRE_FULLCOM_FULLCOM):
        CanSM called the following API functions in defined order:
        1. CanIf_SetPduMode with:
           PduModeRequest := CANIF_ONLINE
        2. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_FULL_COMMUNICATION
           Network := 3
		3. ComM_BusSM_ModeIndication with:
           ComMode := COMM_FULL_COMMUNICATION
    12: Call CanSM_GetCurrentComMode to read the current CanSM mode
        network := &lt;id&gt; of network 0
    13: VP:
        CanSM_GetCurrentComMode returns E_OK
    14: VP:
        CanSM is in state COMM_FULL_COMMUNICATION
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_NOCOM_PRE_FULLCOM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>175</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMPreFull.T_S_TRCV_NORMAL_S_CC_STOPPED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>227</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMPreFull.T_S_CC_STOPPED_S_CC_STARTED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>229</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_PRE_FULLCOM_FULLCOM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>167</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.Transitions.NoTransceiver.3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>107</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>785</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_FUCO_TIMEOUT_SYNC_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkTest/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>534</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct transition of communication mode from
    CANSM_BSM_S_NOCOM to CANSM_BSM_S_FULLCOM when the mode indications are
    synchronous after timeout for CanIf_SetTrcvMode and CanIf_SetControllerMode.
    All mode indications shall be initially asynchron after timeout it will be synchron.
  
Test Object: 
    Module transition
  
Test Precondition: 
    - CanSM is in state S_NOCO
    - Test is executed for a configuration with and one without a transceiver
  
Test Execution: 
    01: Call CanSM_RequestComMode with:
        network := &lt;id&gt; of network 0
        ComM_Mode := COMM_FULL_COMMUNICATION.
    IF transceiver is configured:
        02: VP (CanSM.ASR40.BSM.T_NOCOM_PRE_FULLCOM, CanSM.EB.Transitions.NoTransceiver.3):
            CanSM called only the following API function:
            CanIf_SetTrcvMode with:
            TransceiverMode := CANTRCV_TRCVMODE_NORMAL
        03: Call MainFunction 5 times to simulate timeout
        04: Change TrcvModeIndication to be synchronous
        05: Call the MainFunction of CanSM
        06: VP (CanSM.ASR40.BSM.T_NOCOM_PRE_FULLCOM):
            CanSM called only the following API function after timeout cycle:
            CanIf_SetTrcvMode with:
            TransceiverMode := CANTRCV_TRCVMODE_NORMAL
    ENDIF
    07: VP (CanSM.ASR40.BSMPreFull.T_S_TRCV_NORMAL_S_CC_STOPPED):
        CanSM_MainFunction called only the following API function:
        CanIf_SetControllerMode with:
        ControllerMode := CANIF_CS_STOPPED
    IF transceiver is configured:
        08: Call MainFunction 4 times to simulate timeout
    ELSE:
        09: Call MainFunction 5 times to simulate timeout
    ENDIF
    10: Change ControllerModeIndication to be synchronous
    11: Call the MainFunction of CanSM
    12: VP (CanSM.ASR40.BSMPreFull.T_S_TRCV_NORMAL_S_CC_STOPPED):
        CanSM_MainFunction called the following API function:
        CanIf_SetControllerMode with:
        ControllerMode := CANIF_CS_STOPPED
    13: VP (CanSM.ASR40.BSMPreFull.T_S_CC_STOPPED_S_CC_STARTED):
        CanSM_MainFunction called the following API function:
        CanIf_SetControllerMode with:
        ControllerMode := CANIF_CS_STARTED
    14: VP (CanSM.ASR40.BSM.T_PRE_FULLCOM_FULLCOM):
        CanSM called the following API functions in defined order:
        1. CanIf_SetPduMode with:
           PduModeRequest := CANIF_ONLINE
		2. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_FULL_COMMUNICATION
           Network := 3
        3. ComM_BusSM_ModeIndication with:
           ComMode := COMM_FULL_COMMUNICATION
    IF transceiver is configured:
        15: Restore TrcvModeIndication to be asynchronous
    ENDIF
    16: Restore ControllerModeIndication to be asynchronous
    17: Call CanSM_GetCurrentComMode to read the current CanSM mode
        network := &lt;id&gt; of network 0
    18: VP:
        CanSM_GetCurrentComMode returns E_OK
    19: VP:
        CanSM is in state COMM_FULL_COMMUNICATION
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_NOCOM_PRE_FULLCOM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>175</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMPreFull.T_S_TRCV_NORMAL_S_CC_STOPPED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>227</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMPreFull.T_S_CC_STOPPED_S_CC_STARTED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>229</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_PRE_FULLCOM_FULLCOM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>167</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.Transitions.NoTransceiver.3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>107</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>786</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_FUCO_TIMEOUT_SYNC_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkTest/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>718</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct transition of communication mode from
    CANSM_BSM_S_NOCOM to CANSM_BSM_S_FULLCOM when the mode indications are
    synchronous after timeout for CanIf_SetControllerMode from sub state S_CC_STARTED.
    All mode indications shall be initially asynchron after timeout it can be synchron.
  
Test Object: 
    Module initialization
  
Test Precondition: 
    - CanSM is in state S_NOCO
    - Test is executed for a configuration with and one without a transceiver
  
Test Execution: 
    01: Call CanSM_RequestComMode with:
        network := &lt;id&gt; of network 0
        ComM_Mode := COMM_FULL_COMMUNICATION.
    IF transceiver is configured:
        02: VP (CanSM.ASR40.BSM.T_NOCOM_PRE_FULLCOM, CanSM.EB.Transitions.NoTransceiver.3):
            CanSM called only the following API function:
            CanIf_SetTrcvMode with:
            TransceiverMode := CANTRCV_TRCVMODE_NORMAL
        03: Call CanSM_TransceiverModeIndication with:
            TransceiverId := 3
            TransceiverMode := CANTRCV_TRCVMODE_NORMAL
        04: Call the MainFunction of CanSM
    ENDIF
    05: VP (CanSM.ASR40.BSMPreFull.T_S_TRCV_NORMAL_S_CC_STOPPED):
        CanSM_MainFunction called only the following API function:
        CanIf_SetControllerMode with:
        ControllerMode := CANIF_CS_STOPPED
    06: Call CanSM_ControllerModeIndication with:
        ControllerId := 5
        ControllerMode := CANIF_CS_STOPPED
    07: Call MainFunction 5 times to simulate timeout
    08: Change ControllerModeIndication to be synchronous
    09: Call the MainFunction of CanSM
    10: VP (CanSM.ASR40.BSMPreFull.T_S_CC_STOPPED_S_CC_STARTED):
        CanSM_MainFunction called twice the following API function:
        CanIf_SetControllerMode with:
        ControllerMode := CANIF_CS_STARTED
    11: VP (CanSM.ASR40.BSM.T_PRE_FULLCOM_FULLCOM):
        CanSM called the following API functions in defined order:
        1. CanIf_SetPduMode with:
           PduModeRequest := CANIF_ONLINE
	    2. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_FULL_COMMUNICATION
           Network := 3
        3. ComM_BusSM_ModeIndication with:
           ComMode := COMM_FULL_COMMUNICATION
    12: Restore to asynchronous ControllerModeIndication
    13: Call CanSM_GetCurrentComMode to read the current CanSM mode
        network := &lt;id&gt; of network 0
    14: VP:
        CanSM_GetCurrentComMode returns E_OK
    15: VP:
        CanSM is in state COMM_FULL_COMMUNICATION
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_NOCOM_PRE_FULLCOM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>175</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMPreFull.T_S_TRCV_NORMAL_S_CC_STOPPED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>227</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMPreFull.T_S_CC_STOPPED_S_CC_STARTED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>229</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_PRE_FULLCOM_FULLCOM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>167</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.Transitions.NoTransceiver.3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>107</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>787</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_NOCO_FUCO_FAILED_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkTest/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>878</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the transition of communication mode from
    CANSM_BSM_S_NOCOM to CANSM_BSM_S_FULLCOM
    if the mode request timeout expires during requesting transceiver
    mode Normal and the maximum number of mode request repetitions is reached.
  
Test Object: 
    Module initialization
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_NOCOM
  
Test Execution: 
    01: Call CanSM_RequestComMode with:
        network := &lt;id&gt; of network 0
        ComM_Mode := COMM_FULL_COMMUNICATION.
    02: Call the MainFunction of CanSM 10 times
    IF transceiver is configured
        03: VP (CanSM.ASR40.BSMPreFull.T_S_TRCV_NORMAL_S_TRCV_NORMAL):
            Verify if No API service except the retry of CanIf_SetTrcvMode was called
    ELSE
        03: VP (CanSM.ASR40.BSMPreFull.T_S_CC_STOPPED_S_CC_STOPPED):
            Verify if No API service except the retry of CanIf_SetControllerMode was called
    ENDIF
    04: Call the MainFunction of CanSM
    05: VP (CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.NoPn.1,
            CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.NoPn.2):
        If development error detection is enabled,
        CanSM calls Det_ReportError with:
        ErrorId: CANSM_E_MODE_REQUEST_TIMEOUT
    06: VP (CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.NoPn.1,
            CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.NoPn.2):
        CanSM called the following API function:
        CanIf_SetControllerMode with:
        ControllerMode := CANIF_CS_STOPPED
        ControllerId := 5
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSMPreFull.T_S_TRCV_NORMAL_S_TRCV_NORMAL</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>228</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMPreFull.T_S_CC_STOPPED_S_CC_STOPPED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>230</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.NoPn.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>176</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.NoPn.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>178</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>788</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_NOCO_FUCO_FAILED_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkTest/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>985</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the transition of communication mode from
    CANSM_BSM_S_NOCOM (state NO COmmunication) to CANSM_BSM_S_FULLCOM (state FUll COmmunication)
    if the mode request timeout expires during requesting controller
    mode Stopped and the maximum number of mode request repetitions is reached.
  
Test Object: 
    Module initialization
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_NOCOM
  
Test Execution: 
    01: Call CanSM_RequestComMode with:
        network := &lt;id&gt; of network 0
        ComM_Mode := COMM_FULL_COMMUNICATION.
    IF transceiver is configured
        02: Call CanSM_TransceiverModeIndication with:
            TransceiverId := 3
            TransceiverMode := CANTRCV_TRCVMODE_NORMAL
    ENDIF
    03: Call the MainFunction of CanSM 10 times
    04: VP (CanSM.ASR40.BSMPreFull.T_S_CC_STOPPED_S_CC_STOPPED):
        CanIf_SetControllerMode was called two times (once as initial call and once
        because of a CanSMModeRequestRepetitionMax of 1)
    05: VP:
        Verify if CanSM did not call Det_ReportError
    06: Call the MainFunction of CanSM
    07: VP (CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.NoPn.2):
        If development error detection is enabled,
        CanSM called Det_ReportError with:
        ErrorId: CANSM_E_MODE_REQUEST_TIMEOUT
    08: VP (CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.NoPn.2):
        CanSM called the following API function:
        CanIf_SetControllerMode with:
        ControllerMode := CANIF_CS_STOPPED
        ControllerId := 5
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSMPreFull.T_S_CC_STOPPED_S_CC_STOPPED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>230</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.NoPn.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>178</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>789</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_NOCO_FUCO_FAILED_3</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkTest/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>1092</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the transition of communication mode from
    CANSM_BSM_S_NOCOM (state NO COmmunication) to CANSM_BSM_S_FULLCOM (state FUll COmmunication)
    if the mode request timeout expires during requesting controller
    mode Started and the maximum number of mode request repetitions is reached.
  
Test Object: 
    Module initialization
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_NOCOM
  
Test Execution: 
    01: Call CanSM_RequestComMode with:
        network := &lt;id&gt; of network 0
        ComM_Mode := COMM_FULL_COMMUNICATION.
    IF transceiver is configured
        02: Call CanSM_TransceiverModeIndication with:
            TransceiverId := 3
            TransceiverMode := CANTRCV_TRCVMODE_NORMAL
    ENDIF
    03: Call the MainFunction of CanSM
    04: Call CanSM_ControllerModeIndication with:
        ControllerId := 5
        ControllerMode := CANIF_CS_STOPPED
    05: Call the MainFunction of CanSM 10 times
    06: VP (CanSM.ASR40.BSMPreFull.T_S_CC_STARTED_S_CC_STARTED):
        CanIf_SetControllerMode was called two times (once as initial call and once
        because of a CanSMModeRequestRepetitionMax of 1)
    07: VP:
        Verify if CanSM did not call Det_ReportError
    08: Call the MainFunction of CanSM
    09: VP (CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.NoPn.3):
        If Development error detection is enabled,
        CanSM calls Det_ReportError with:
        ErrorId: CANSM_E_MODE_REQUEST_TIMEOUT
    10: VP (CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.NoPn.3):
        CanSM called the following API function:
        CanIf_SetControllerMode with:
        ControllerMode := CANIF_CS_STOPPED
        ControllerId := 5
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSMPreFull.T_S_CC_STARTED_S_CC_STARTED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>231</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_PRE_FULLCOM_PRE_NOCOM.NoPn.3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>180</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>790</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_NOCO_FUCO_TRCV_IND</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkTest/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>1207</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks behavior of CanSM_TransceiverModeIndication if called
    with a wrong transceiver mode after a mode request.
    In test configurations without transceiver support it just performs a
    transition to FULL communication.
  
Test Object: 
    Module initialization
  
Test Precondition: 
    - CanSM is in state S_NOCO
  
Test Execution: 
    01: Call CanSM_RequestComMode with:
        network := &lt;id&gt; of network 0
        ComM_Mode := COMM_FULL_COMMUNICATION.
    IF transceiver is configured
        02: VP:
            CanSM called the following API function:
            CanIf_SetTrcvMode with:
            TransceiverMode := CANTRCV_TRCVMODE_NORMAL
        03: Call CanSM_TransceiverModeIndication with:
            TransceiverId := 3
            TransceiverMode := CANTRCV_TRCVMODE_STANDBY (= wrong mode indication)
        04: Call the MainFunction of CanSM 5 times (once to apply the indication,
            confer CanSM.Design.20122, and 4 times as long as timer does not elapse)
        05: VP:
            Main function does not not call any API function
        06: Call MainFunction to elapse timer
        07: VP (CanSM.ASR40.BSMPreFull.T_S_TRCV_NORMAL_S_CC_STOPPED):
            CanSM repeats its request and calls:
            CanIf_SetTrcvMode with:
            TransceiverMode := CANTRCV_TRCVMODE_NORMAL
        08: Call CanSM_TransceiverModeIndication with:
            TransceiverId := 3
            TransceiverMode := CANTRCV_TRCVMODE_NORMAL
        09: Call the MainFunction of CanSM
    ENDIF
    10: VP if CanSM called the following API function:
        CanIf_SetControllerMode with:
        ControllerMode := CANIF_CS_STOPPED
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSMPreFull.T_S_TRCV_NORMAL_S_CC_STOPPED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>227</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>791</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_NOCO_FUCO_CC_IND</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkTest/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>1322</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks behavior of CanSM_ControllerModeIndication if indication
    a wrong controller mode after a mode request.
  
Test Object: 
    Module initialization
  
Test Precondition: 
    - CanSM is in state S_NOCO
  
Test Execution: 
    IF transceiver is configured
        01: Prepare the CanIf stub to indicate the requested transceiver mode
            transition from inside the context of CanIf_SetTrcvMode.
    ENDIF
    02: Call CanSM_RequestComMode with:
        network := &lt;id&gt; of network 0
        ComM_Mode := COMM_FULL_COMMUNICATION.
    03: VP:
        CanSM called the following API functions in defined order:
        IF transceiver is configured
            1. CanIf_SetTrcvMode with TransceiverMode := CANTRCV_TRCVMODE_NORMAL
        ENDIF
        2. CanIf_SetControllerMode with ControllerMode := CANIF_CS_STOPPED
    04: Call CanSM_ControllerModeIndication with:
        ControllerId := 5
        ControllerMode := CANIF_CS_STARTED
    05: Call the MainFunction of CanSM
    06: VP (CanSM.ASR40.BSMPreFull.T_S_CC_STOPPED_S_CC_STARTED):
        CanSM called no API function
    07: Call CanSM_ControllerModeIndication with:
        ControllerId := 5
        ControllerMode := CANIF_CS_STOPPED
    08: Call the MainFunction of CanSM
    09: VP:
        CanSM called the following API function:
        CanIf_SetControllerMode with:
        ControllerMode := CANIF_CS_STARTED
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSMPreFull.T_S_CC_STOPPED_S_CC_STARTED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>229</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>792</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_SICO_NOCO_SYNC</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkTest/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>1437</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct transition of communication mode from
    S_SICO (state SIlent COmmunication) to S_NOCO (state NO COmmunication).
    All mode indications shall be synchron.
  
Test Object: 
    Mode transition
  
Test Precondition: 
    - CanSM is in state S_SICO
    - Test is executed for a configuration with and one without a transceiver
  
Test Execution: 
    IF transceiver is configured
        01: Prepare the CanIf stub to indicate the requested transceiver mode
            transition from inside the context of CanIf_SetTrcvMode.
    ENDIF
    02: Prepare the CanIf stub to indicate the requested controller mode
        transition from inside the context of CanIf_SetControllerMode.
    03: Call CanSM_RequestComMode with:
        network := &lt;id&gt; of network 0
        ComM_Mode := COMM_NO_COMMUNICATION.
    04: VP:
        CanSM_RequestComMode returned E_OK
    05: VP:
        CanSM called the following API function in defined order:
        1. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_NO_COMMUNICATION
           Network := 3
           (CanSM.ASR40.BSM.T_SILENTCOM_PRE_NOCOM.NoPn)
        2. CanIf_SetControllerMode with:
           ControllerMode := CANIF_CS_STOPPED
           ControllerId := 5
           (CanSM.ASR40.BSM.T_SILENTCOM_PRE_NOCOM.NoPn)
        3. CanIf_SetControllerMode with:
           ControllerMode := CANIF_CS_SLEEP
           ControllerId := 5
           (CanSM.ASR40.BSMDeInitNoPn.T_S_CC_STOPPED_S_CC_SLEEP)
        IF transceiver is configured
            4. CanIf_SetTrcvMode with:
               TransceiverMode := CANTRCV_TRCVMODE_NORMAL
               TransceiverId := 3
               (CanSM.ASR40.BSMDeInitNoPn.T_S_CC_SLEEP_S_TRCV_NORMAL)
            5. CanIf_SetTrcvMode with:
               TransceiverMode := CANTRCV_TRCVMODE_STANDBY
               TransceiverId := 3
               (CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_NORMAL_S_TRCV_STANDBY)
               (CanSM.EB.Transitions.NoTransceiver.2)
        ENDIF
        7. ComM_BusSM_ModeIndication with:
           ComMode := COMM_NO_COMMUNICATION
           (CanSM.ASR40.BSM.T_PRE_NOCOM_NOCOM.NoPn.1)
    06: Call CanSM_GetCurrentComMode to read the current CanSM mode
        network := &lt;id&gt; of network 0
    07: VP:
        CanSM_GetCurrentComMode returns E_OK
    08: VP:
        CanSM is in state COMM_NO_COMMUNICATION
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_SILENTCOM_PRE_NOCOM.NoPn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>189</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_CC_STOPPED_S_CC_SLEEP</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>216</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_CC_SLEEP_S_TRCV_NORMAL</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>219</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_NORMAL_S_TRCV_STANDBY</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>222</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_PRE_NOCOM_NOCOM.NoPn.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>191</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.Transitions.NoTransceiver.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>106</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>793</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_SICO_NOCO_ASYNC</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkTest/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>1585</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct transition of communication mode from
    CANSM_BSM_S_SILENTCOM to CANSM_BSM_S_NOCOM and also test the self transition
    for all states when CanSM is in CANSM_BSM_DeinitPnNotSupportedProceed.
    All mode indications shall be asynchron.
  
Test Object: 
    Mode transition
    Self transition
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_SILENTCOM
    - Test is executed for a configuration with and one without a transceiver
  
Test Execution: 
    01: Call CanSM_RequestComMode with:
        network := &lt;id&gt; of network 0
        ComM_Mode := COMM_NO_COMMUNICATION.
    02: VP (CanSM.ASR40.BSM.T_NOT_INITIALIZED_PRE_NOCOM.NoPn):
        CanSM called the following API function in defined order:
        1. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_NO_COMMUNICATION
           Network := 3
        2. CanIf_SetControllerMode with:
           ControllerMode := CANIF_CS_STOPPED
           ControllerId := 5
    03: Call main function to expire CanSMModeRequestRepetitionTime
    04: VP (CanSM.ASR40.BSMDeInitNoPn.T_S_CC_STOPPED_S_CC_STOPPED.1):
        CanSM called only the following API function:
        CanIf_SetControllerMode with:
        ControllerMode := CANIF_CS_STOPPED
    05: Call CanSM_ControllerModeIndication with:
        ControllerId := 5
        ControllerMode := CANIF_CS_STOPPED
    06: Call the MainFunction of CanSM
    07: VP (CanSM.ASR40.BSMDeInitNoPn.T_S_CC_STOPPED_S_CC_SLEEP):
        CanSM called only the following API function:
        CanIf_SetControllerMode with:
        ControllerMode := CANIF_CS_SLEEP
    08: Call main function to expire CanSMModeRequestRepetitionTime
    09: VP (CanSM.ASR40.BSMDeInitNoPn.T_S_CC_SLEEP_S_CC_SLEEP):
        CanSM called only the following API function:
        CanIf_SetControllerMode with:
        ControllerMode := CANIF_CS_SLEEP
    10: Call CanSM_ControllerModeIndication with:
        ControllerId := 5
        ControllerMode := CANIF_CS_SLEEP
    11: Call the MainFunction of CanSM
    IF transceiver is configured
        12: VP (CanSM.ASR40.BSMDeInitNoPn.T_S_CC_SLEEP_S_TRCV_NORMAL):
            CanSM called only the following API function:
            CanIf_SetTrcvMode with:
            TransceiverMode := CANTRCV_TRCVMODE_NORMAL
        13: Call main function to expire CanSMModeRequestRepetitionTime
        14: VP (CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_NORMAL_S_TRCV_NORMAL):
            CanSM called only the following API function:
            CanIf_SetTrcvMode with:
            TransceiverMode := CANTRCV_TRCVMODE_NORMAL
        15: Call CanSM_TransceiverModeIndication with:
            TransceiverId := 3
            TransceiverMode := CANTRCV_TRCVMODE_NORMAL
        16: Call the MainFunction of CanSM
        17: VP (CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_NORMAL_S_TRCV_STANDBY):
            CanSM called only the following API function:
            CanIf_SetTrcvMode with:
            TransceiverMode := CANTRCV_TRCVMODE_STANDBY
        18: Call main function to expire CanSMModeRequestRepetitionTime
        19: VP (CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_STANDBY_S_TRCV_STANDBY):
            CanSM called only the following API function:
            CanIf_SetTrcvMode with:
            TransceiverMode := CANTRCV_TRCVMODE_STANDBY
        20: Call CanSM_TransceiverModeIndication with:
            TransceiverId := 3
            TransceiverMode := CANTRCV_TRCVMODE_STANDBY
        21: Call the MainFunction of CanSM
    ENDIF
    22: VP (CanSM.ASR40.BSM.T_PRE_NOCOM_NOCOM.NoPn.1):
        CanSM called the following API function:
        ComM_BusSM_ModeIndication with:
           ComMode := COMM_NO_COMMUNICATION
    23: Call CanSM_GetCurrentComMode to read the current CanSM mode
        network := &lt;id&gt; of network 0
    24: VP:
        CanSM_GetCurrentComMode return E_OK
    25: VP:
        CanSM is in state COMM_NO_COMMUNICATION
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_NOT_INITIALIZED_PRE_NOCOM.NoPn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>195</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_CC_STOPPED_S_CC_STOPPED.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>217</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_CC_STOPPED_S_CC_SLEEP</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>216</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_CC_SLEEP_S_CC_SLEEP</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>220</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_CC_SLEEP_S_TRCV_NORMAL</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>219</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_NORMAL_S_TRCV_NORMAL</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>223</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_NORMAL_S_TRCV_STANDBY</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>222</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_STANDBY_S_TRCV_STANDBY</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>225</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_PRE_NOCOM_NOCOM.NoPn.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>191</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>794</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_NOCO_TIMEOUT_SYNC_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkTest/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>1808</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct transition of communication mode from
    CANSM_BSM_S_SILENTCOM to CANSM_BSM_S_NOCOM when the mode indications are
    synchronous after timeout for CanIf_SetTrcvMode and CanIf_SetControllerMode.
    All mode indications shall be initially asynchron after timeout it will be synchron.
  
Test Object: 
    Mode transition
    Self transition
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_SILENTCOM
    - Test is executed for a configuration with and one without a transceiver
  
Test Execution: 
    01: Call CanSM_RequestComMode with:
        network := &lt;id&gt; of network 0
        ComM_Mode := COMM_NO_COMMUNICATION.
    02: VP (CanSM.ASR40.BSM.T_NOT_INITIALIZED_PRE_NOCOM.NoPn):
        CanSM called the following API function in defined order:
        1. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_NO_COMMUNICATION
           Network := 3
        2. CanIf_SetControllerMode with:
           ControllerMode := CANIF_CS_STOPPED
           ControllerId := 5
    03: Call main function to expire CanSMModeRequestRepetitionTime
    04: Change ControllerModeIndication to be synchronous
    05: Call the MainFunction of CanSM
    06: VP (CanSM.ASR40.BSMDeInitNoPn.T_S_CC_STOPPED_S_CC_STOPPED.1,
            CanSM.ASR40.BSMDeInitNoPn.T_S_CC_STOPPED_S_CC_SLEEP):
        CanSM called the following API function in defined order:
        1.  CanIf_SetControllerMode with:
            ControllerMode := CANIF_CS_STOPPED
        2.  CanIf_SetControllerMode with:
            ControllerMode := CANIF_CS_SLEEP
    IF transceiver is configured
        07: Call main function CanSMModeRequestRepetitionTime -1 times
        08: Change TransceiverModeIndication to be synchronous
        09: Call the MainFunction of CanSM
        10: VP (CanSM.ASR40.BSMDeInitNoPn.T_S_CC_SLEEP_S_TRCV_NORMAL,
                CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_NORMAL_S_TRCV_NORMAL,
                CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_NORMAL_S_TRCV_STANDBY):
            CanSM called the following API function in defined order:
            1.  CanIf_SetTrcvMode with:
                TransceiverMode := CANTRCV_TRCVMODE_NORMAL
            2.  CanIf_SetTrcvMode with:
                TransceiverMode := CANTRCV_TRCVMODE_NORMAL
            3.  CanIf_SetTrcvMode with:
                TransceiverMode := CANTRCV_TRCVMODE_STANDBY
    ENDIF
    11: VP (CanSM.ASR40.BSM.T_PRE_NOCOM_NOCOM.NoPn.1):
        CanSM called the following API function:
        ComM_BusSM_ModeIndication with:
           ComMode := COMM_NO_COMMUNICATION
    IF transceiver is configured:
        12: Restore TrcvModeIndication to be asynchronous
    ENDIF
    13: Restore ControllerModeIndication to be asynchronous
    14: Call CanSM_GetCurrentComMode to read the current CanSM mode
        network := &lt;id&gt; of network 0
    15: VP:
        CanSM_GetCurrentComMode return E_OK
    16: VP:
        CanSM is in state COMM_NO_COMMUNICATION
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_NOT_INITIALIZED_PRE_NOCOM.NoPn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>195</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_CC_STOPPED_S_CC_STOPPED.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>217</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_CC_STOPPED_S_CC_SLEEP</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>216</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_CC_SLEEP_S_TRCV_NORMAL</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>219</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_NORMAL_S_TRCV_NORMAL</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>223</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_NORMAL_S_TRCV_STANDBY</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>222</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_PRE_NOCOM_NOCOM.NoPn.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>191</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>795</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_NOCO_TIMEOUT_SYNC_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkTest/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>1980</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct transition of communication mode from
    CANSM_BSM_S_SILENTCOM to CANSM_BSM_S_NOCOM when the mode indications are
    synchronous after timeout for CanIf_SetTrcvMode from sub state S_TRCV_STANDBY
    and for CanIf_SetControllerMode from substate S_CC_SLEEP.
    All mode indications shall be initially asynchron after timeout it will be synchron.
  
Test Object: 
    Mode transition
    Self transition
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_SILENTCOM
    - Test is executed for a configuration with and one without a transceiver
  
Test Execution: 
    01: Call CanSM_RequestComMode with:
        network := &lt;id&gt; of network 0
        ComM_Mode := COMM_NO_COMMUNICATION.
    02: VP (CanSM.ASR40.BSM.T_NOT_INITIALIZED_PRE_NOCOM.NoPn):
        CanSM called the following API function in defined order:
        1. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_NO_COMMUNICATION
           Network := 3
        2. CanIf_SetControllerMode with:
           ControllerMode := CANIF_CS_STOPPED
           ControllerId := 5
    03: Call CanSM_ControllerModeIndication with after a MainFunction call:
        ControllerId := 5
        ControllerMode := CANIF_CS_STOPPED
    04: Call the MainFunction of CanSM to process the indication
    05: Call main function CanSMModeRequestRepetitionTime - 1 times
    06: Change ControllerModeIndication to be synchronous
    07: Call the MainFunction of CanSM
    08: VP (CanSM.ASR40.BSMDeInitNoPn.T_S_CC_STOPPED_S_CC_SLEEP,
            CanSM.ASR40.BSMDeInitNoPn.T_S_CC_SLEEP_S_CC_SLEEP):
        CanSM called twice the following API function:
        CanIf_SetControllerMode with:
        ControllerMode := CANIF_CS_SLEEP
    IF transceiver is configured
        09: VP (CanSM.ASR40.BSMDeInitNoPn.T_S_CC_SLEEP_S_TRCV_NORMAL):
            CanSM called only the following API function:
            CanIf_SetTrcvMode with:
            TransceiverMode := CANTRCV_TRCVMODE_NORMAL
        10: Call CanSM_TransceiverModeIndication after a MainFunction call with:
            TransceiverId := 3
            TransceiverMode := CANTRCV_TRCVMODE_NORMAL
        11: Call the MainFunction of CanSM to process the indication
        12: Call main function CanSMModeRequestRepetitionTime - 1 times
        13: Change TransceiverModeIndication to be synchronous
        14: Call the MainFunction of CanSM
        15: VP (CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_NORMAL_S_TRCV_STANDBY,
                CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_STANDBY_S_TRCV_STANDBY):
            CanSM called twice the following API function:
            CanIf_SetTrcvMode with:
            TransceiverMode := CANTRCV_TRCVMODE_STANDBY
    ENDIF
    16: VP (CanSM.ASR40.BSM.T_PRE_NOCOM_NOCOM.NoPn.1):
        CanSM called the following API function:
        ComM_BusSM_ModeIndication with:
           ComMode := COMM_NO_COMMUNICATION
    IF transceiver is configured:
        17: Restore TrcvModeIndication to be asynchronous
    ENDIF
    18: Restore ControllerModeIndication to be asynchronous
    19: Call CanSM_GetCurrentComMode to read the current CanSM mode
        network := &lt;id&gt; of network 0
    20: VP:
        CanSM_GetCurrentComMode return E_OK
    21: VP:
        CanSM is in state COMM_NO_COMMUNICATION
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_NOT_INITIALIZED_PRE_NOCOM.NoPn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>195</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_CC_STOPPED_S_CC_SLEEP</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>216</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_CC_SLEEP_S_CC_SLEEP</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>220</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_CC_SLEEP_S_TRCV_NORMAL</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>219</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_NORMAL_S_TRCV_STANDBY</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>222</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_STANDBY_S_TRCV_STANDBY</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>225</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_PRE_NOCOM_NOCOM.NoPn.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>191</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>796</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_REPEAT_MAX_DEINIT_NOPN_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkTest/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>2173</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks if DET is reported when triggered with T_REPEAT_MAX in state S_CC_STOPPED
    of CANSM_BSM_DeinitPnNotSupportedProceed.
    All mode indications shall be asynchron.
  
Test Object: 
    T_REPEAT_MAX
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_SILENTCOM
  
Test Execution: 
    01: Call CanSM_RequestComMode with:
        network := &lt;id&gt; of network 0
        ComM_Mode := COMM_NO_COMMUNICATION.
    02: VP:
        CanSM called the following API function in defined order:
        1. BswM_CanSM_CurrentState
        2. CanIf_SetControllerMode with:
           ControllerMode := CANIF_CS_STOPPED
    03: Call the MainFunction of CanSM 10 times
    04: VP (CanSM.ASR40.BSMDeInitNoPn.T_S_CC_STOPPED_S_CC_STOPPED.1):
        CanIf_SetControllerMode was called second time with controller mode CANIF_CS_STOPPED
        (once as initial call and once because of a CanSMModeRequestRepetitionMax of 1)
    05: VP:
        Verify if CanSM did not call Det_ReportError
    06: Call the MainFunction of CanSM
    07: VP (CanSM.ASR40.BSMDeInitNoPn.T_S_CC_STOPPED_S_CC_STOPPED.2):
        If development error detection is enabled,
        CanSM called Det_ReportError with:
        ErrorId: CANSM_E_MODE_REQUEST_TIMEOUT
    08: VP (CanSM.ASR40.BSMDeInitNoPn.T_S_CC_STOPPED_S_CC_STOPPED.2):
        CanSM called CanIf_SetControllerMode with:
        ControllerMode := CANIF_CS_STOPPED
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_CC_STOPPED_S_CC_STOPPED.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>217</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_CC_STOPPED_S_CC_STOPPED.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>218</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>797</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_REPEAT_MAX_DEINIT_NOPN_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkTest/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>2277</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks if DET is reported when triggered with T_REPEAT_MAX in state S_CC_SLEEP
    of CANSM_BSM_DeinitPnNotSupportedProceed.
    All mode indications shall be asynchron.
  
Test Object: 
    T_REPEAT_MAX
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_SILENTCOM
  
Test Execution: 
    01: Call CanSM_RequestComMode with:
        network := &lt;id&gt; of network 0
        ComM_Mode := COMM_NO_COMMUNICATION.
    02: Call CanSM_ControllerModeIndication with:
        ControllerId := 5
        ControllerMode := CANIF_CS_STOPPED
    03: Call the MainFunction of CanSM 10 times
    04: VP (CanSM.ASR40.BSMDeInitNoPn.T_S_CC_SLEEP_S_CC_SLEEP):
        CanIf_SetControllerMode was called two times (once as initial call and once
        because of a CanSMModeRequestRepetitionMax of 1)
    05: VP:
        Verify if CanSM did not call Det_ReportError
    06: Call the MainFunction of CanSM
    07: VP (CanSM.ASR40.BSMDeInitNoPn.T_S_CC_SLEEP_S_CC_STOPPED):
        If development error detection is enabled,
        CanSM called Det_ReportError with:
        ErrorId: CANSM_E_MODE_REQUEST_TIMEOUT
    08: VP (CanSM.ASR40.BSMDeInitNoPn.T_S_CC_SLEEP_S_CC_STOPPED):
        CanSM called CanIf_SetControllerMode with:
        ControllerMode := CANIF_CS_STOPPED
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_CC_SLEEP_S_CC_SLEEP</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>220</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_CC_SLEEP_S_CC_STOPPED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>221</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>798</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_REPEAT_MAX_DEINIT_NOPN_3</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkTest/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>2378</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks if DET is reported when triggered with T_REPEAT_MAX in state S_TRCV_NORMAL
    of CANSM_BSM_DeinitPnNotSupportedProceed.
    All mode indications shall be asynchron.
  
Test Object: 
    T_REPEAT_MAX
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_SILENTCOM
    - Test is executed only for a configuration with a transceiver
      for configuration without transceiver it returns SUCCESS as default
  
Test Execution: 
    IF transceiver is configured
      01: Call CanSM_RequestComMode with:
          network := &lt;id&gt; of network 0
          ComM_Mode := COMM_NO_COMMUNICATION.
      02: Call CanSM_ControllerModeIndication with:
          ControllerId := 5
          ControllerMode := CANIF_CS_STOPPED
      03: Call MainFunction once to process the indication and
          call CanSM_ControllerModeIndication with:
          ControllerId := 5
          ControllerMode := CANIF_CS_SLEEP
      04: Call the MainFunction of CanSM 10 times
      05: VP (CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_NORMAL_S_TRCV_NORMAL):
          CanIf_SetTrcvMode was called twice (once as initial call and once
          because of a CanSMModeRequestRepetitionMax of 1)
      06: VP:
          Verify if CanSM did not call Det_ReportError
      07: Call the MainFunction of CanSM
      08: VP (CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_NORMAL_S_CC_STOPPED):
          If development error detection is enabled,
          CanSM called Det_ReportError with:
          ErrorId: CANSM_E_MODE_REQUEST_TIMEOUT
      09: VP (CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_NORMAL_S_CC_STOPPED):
          CanSM called CanIf_SetControllerMode with:
          ControllerMode := CANIF_CS_STOPPED
    ENDIF
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_NORMAL_S_TRCV_NORMAL</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>223</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_NORMAL_S_CC_STOPPED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>224</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>799</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_REPEAT_MAX_DEINIT_NOPN_4</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkTest/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>2493</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks if DET is reported when triggered with T_REPEAT_MAX in state S_TRCV_STANDBY
    of CANSM_BSM_DeinitPnNotSupportedProceed.
    All mode indications shall be asynchron.
  
Test Object: 
    T_REPEAT_MAX
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_SILENTCOM
    - Test is executed only for a configuration with a transceiver
      for configuration without transceiver it returns SUCCESS as default
  
Test Execution: 
    IF transceiver is configured
      01: Call CanSM_RequestComMode with:
          network := &lt;id&gt; of network 0
          ComM_Mode := COMM_NO_COMMUNICATION.
      02: Call CanSM_ControllerModeIndication with:
          ControllerId := 5
          ControllerMode := CANIF_CS_STOPPED
      03: Call MainFunction once to process the indication and
          call CanSM_ControllerModeIndication with:
          ControllerId := 5
          ControllerMode := CANIF_CS_SLEEP
      04: Call MainFunction once to process the indication and
          call CanSM_TransceiverModeIndication with:
            TransceiverId := 3
            TransceiverMode := CANTRCV_TRCVMODE_NORMAL
      05: Call the MainFunction of CanSM 10 times
      06: VP (CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_STANDBY_S_TRCV_STANDBY):
          CanIf_SetTrcvMode was called twice (once as initial call and once
          because of a CanSMModeRequestRepetitionMax of 1)
      07: VP:
          Verify if CanSM did not call Det_ReportError
      08: Call the MainFunction of CanSM
      09: VP (CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_STANDBY_S_CC_STOPPED):
          If development error detection is enabled,
          CanSM called Det_ReportError with:
          ErrorId: CANSM_E_MODE_REQUEST_TIMEOUT
      10: VP (CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_STANDBY_S_CC_STOPPED):
          CanSM called CanIf_SetControllerMode with:
          ControllerMode := CANIF_CS_STOPPED
    ENDIF
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_STANDBY_S_TRCV_STANDBY</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>225</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_STANDBY_S_CC_STOPPED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>226</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>800</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_SICO_FUCO</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkTest/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>2618</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct transition of communication mode from
    CANSM_BSM_S_SILENTCOM to CANSM_BSM_S_FULLCOM.
  
Test Object: 
    Mode transition
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_SILENTCOM
  
Test Execution: 
    01: Call CanSM_RequestComMode with:
        network := &lt;id&gt; of network 0
        ComM_Mode := COMM_FULL_COMMUNICATION.
    02: VP (CCanSM.SWS_CanSM_00369):
        CanSM_RequestComMode returned E_OK
    03: VP (CanSM.ASR40.BSM.T_SILENTCOM_FULLCOM):
        CanSM called the following API function in defined order:
        1. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_FULL_COMMUNICATION
           Network := 3
        2. CanIf_SetPduMode with:
           PduModeRequest := CANIF_ONLINE
        3. ComM_BusSM_ModeIndication with:
           ComMode := COMM_FULL_COMMUNICATION
    04: Call CanSM_GetCurrentComMode to read the current CanSM mode
        network := &lt;id&gt; of network 0
    05: VP:
        CanSM_GetCurrentComMode return E_OK
    06: VP:
        CanSM is in state COMM_FULL_COMMUNICATION
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_SILENTCOM_FULLCOM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>174</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00369</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>315</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>801</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_CHANGE_BR_REQUEST_SYNC</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkTest/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>2705</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test shall verify the transition T_CHANGE_BR_REQUEST from state S_NO_BUS_OFF of
    CANSM_BSM_S_FULLCOM to S_CC_STOPPED of CANSM_BSM_S_CHANGE_BAUDRATE with following constraints:
    - CanSM_ControllerModeIndications() are synchronous
    - No CanSM_RequestComMode() call while processing
  
Test Object: 
    Mode transition
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_FULLCOM; substate S_NO_BUS_OFF
  
Test Execution: 
    01: Enable synchronous controller mode indication. Effect: CanSM_ControllerModeIndication() will
        called in the callout of CanIf_SetControllerMode().
    02: Trigger transition T_CHANGE_BR_REQUEST (S_NO_BUS_OFF to S_CC_STOPPED). Call
        CanSM_SetBaudrate() with new baud rate for corresponding CAN network successfully.
    03 VP(CanSM.ASR41.SWS_CanSM_00503): API shall return E_OK.
    04: VP(CanSM.ASR40.BSM.T_FULLCOM_CHANGE_BAUDRATE): Verify that effect E_CHANGE_BR_BSWM_MODE is
        executed. BswM_CanSM_CurrentState() is called with CurrentState set to CANIF_CS_STOPPED for
        the corresponding CAN network.
    05: VP(CanSM.ASR40.BSM.T_FULLCOM_CHANGE_BAUDRATE): Verify that do action DO_SET_CC_MODE_STOPPED
        is executed. CanIf_SetControllerMode() is called with controller mode CANIF_CS_STOPPED for
        the corresponding CAN network.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_FULLCOM_CHANGE_BAUDRATE</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>170</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR41.SWS_CanSM_00503</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>91</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>802</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_CC_STOPPED_INDICATED_CHANGE_BR_SYNC</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkTest/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>2797</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test shall verify the transition T_CC_STOPPED_INDICATED from state S_CC_STOPPED to
    S_CC_STARTED within CANSM_BSM_S_CHANGE_BAUDRATE with following constraints:
    - CanSM_ControllerModeIndications() are synchronous
    - No CanSM_RequestComMode() call while processing
  
Test Object: 
    Mode transition
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_FULLCOM; substate S_NO_BUS_OFF
  
Test Execution: 
    01: Enable synchronous controller mode indication. Effect: CanSM_ControllerModeIndication() will
        called in the callout of CanIf_SetControllerMode().
    02: Trigger transition T_CHANGE_BR_REQUEST (S_NO_BUS_OFF to S_CC_STOPPED). Call
        CanSM_SetBaudrate() with new baud rate for corresponding CAN network.
    03: VP(CanSM.ASR40.BSMBr.T_S_CC_STOPPED_S_CC_STARTED) Verify that do action
        DO_SET_CC_MODE_STOPPED is executed. CanIf_SetControllerMode() is called with controller mode
        CANIF_CS_STOPPED for the corresponding CAN network which will trigger the transition
        T_CC_STOPPED_INDICATED (S_CC_STOPPED to S_CC_STARTED) in its callout function.
    04: VP(CanSM.ASR40.BSMBr.T_S_CC_STOPPED_S_CC_STARTED): Verify that effect E_CHANGE_BAUDRATE is
        executed. ComM_BusSM_ModeIndication() is called with ComMode set to COMM_NO_COMMUNICATION.
    05: VP(CanSM.ASR40.BSMBr.T_S_CC_STOPPED_S_CC_STARTED): Verify that effect E_CHANGE_BAUDRATE is
        executed. CanIf_SetBaudrate() is called with new baud rate for corresponding CAN network.
    06: VP(CanSM.ASR40.BSMBr.T_S_CC_STOPPED_S_CC_STARTED): Verify that do action
        DO_SET_CC_MODE_STARTED is executed. CanIf_SetControllerMode is called with controller mode
        CANIF_CS_STARTED for the corresponding CAN network.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSMBr.T_S_CC_STOPPED_S_CC_STARTED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>247</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>803</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_CC_STOPPED_INDICATED_CHANGE_BR_ASYNC</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkTest/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>2900</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test shall verify the transition T_CC_STOPPED_INDICATED from state S_CC_STOPPED to
    S_CC_STARTED within CANSM_BSM_S_CHANGE_BAUDRATE with following constraints:
    - CanSM_ControllerModeIndications() are asynchronous
    - No CanSM_RequestComMode() call while processing
  
Test Object: 
    Mode transition
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_FULLCOM; substate S_NO_BUS_OFF
  
Test Execution: 
    01: Disable synchronous controller mode indication.
    02: Trigger transition T_CHANGE_BR_REQUEST (S_NO_BUS_OFF to S_CC_STOPPED). Call
        CanSM_SetBaudrate() with new baud rate for corresponding CAN network.
    03: Call CanSM_MainFunction() to simulate time passing.
    04: Call CanSM_ControllerModeIndication() to perform controller mode indication.
    05: Call CanSM_MainFunction() continue.
    06: VP(CanSM.ASR40.BSMBr.T_S_CC_STOPPED_S_CC_STARTED): Verify that effect E_CHANGE_BAUDRATE is
        executed. ComM_BusSM_ModeIndication() is called with ComMode set to COMM_NO_COMMUNICATION.
    07: VP(CanSM.ASR40.BSMBr.T_S_CC_STOPPED_S_CC_STARTED): Verify that effect E_CHANGE_BAUDRATE is
        executed. CanIf_SetBaudrate() is called with new baud rate for corresponding CAN network.
    08: VP(CanSM.ASR40.BSMBr.T_S_CC_STOPPED_S_CC_STARTED): Verify that do action
        DO_SET_CC_MODE_STARTED is executed. CanIf_SetControllerMode is called with controller mode
        CANIF_CS_STARTED for the corresponding CAN network.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSMBr.T_S_CC_STOPPED_S_CC_STARTED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>247</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>804</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_CC_STOPPED_TIMEOUT_CHANGE_BR</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkTest/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>3006</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test shall verify the transition T_CC_STOPPED_TIMEOUT from state S_CC_STOPPED_WAIT to
    S_CC_STOPPED within CANSM_BSM_S_CHANGE_BAUDRATE with following constraints:
    - No CanSM_RequestComMode() call while processing

    Note: After the timeout the controller mode indication shall be provided synchronously to
    trigger transition to next state.
  
Test Object: 
    Mode transition
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_FULLCOM; substate S_NO_BUS_OFF
  
Test Execution: 
    01: Disable synchronous controller mode indication.
    02: Trigger transition T_CHANGE_BR_REQUEST (S_NO_BUS_OFF to S_CC_STOPPED). Call
        CanSM_SetBaudrate() with new baud rate for corresponding CAN network.
    03: Call CanSM_MainFunction() CANSM_MODEREQ_REPEAT_TIME times.
    04: Enable synchronous controller mode indication.
    05: Call CanSM_MainFunction() to let timeout CANSM_MODEREQ_REPEAT_TIME elapse.
    06: VP: Verify that do action DO_SET_CC_MODE_STOPPED is executed. CanIf_SetControllerMode() is
        called with controller mode CANIF_CS_STOPPED for the corresponding CAN network.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSMBr.T_S_CC_STOPPED_S_CC_STOPPED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>248</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>805</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_CC_STARTED_TIMEOUT_CHANGE_BR</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkTest/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>3121</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test shall verify the transition T_CC_STARTED_TIMEOUT from state S_CC_STARTED_WAIT to
    S_CC_STARTED within CANSM_BSM_S_CHANGE_BAUDRATE with following constraints:
    - No CanSM_RequestComMode() call while processing

    Note: After the timeout the controller mode indication shall be provided synchronously to
    trigger transition to next state.
  
Test Object: 
    Mode transition
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_FULLCOM; substate S_NO_BUS_OFF
  
Test Execution: 
    01: Disable synchronous controller mode indication.
    02: Trigger transition T_CHANGE_BR_REQUEST (S_NO_BUS_OFF to S_CC_STOPPED). Call
        CanSM_SetBaudrate() with new baud rate for corresponding CAN network.
    03: Call CanSM_ControllerModeIndication() to trigger transition T_CC_STOPPED_INDICATED.
    04: Call CanSM_MainFunction() to continue.
    05: Call CanSM_MainFunction() CANSM_MODEREQ_REPEAT_TIME times.
    06: Enable synchronous controller mode indication.
    07: Call CanSM_MainFunction() to let timeout CANSM_MODEREQ_REPEAT_TIME elapse.
    08: VP: Verify that do action DO_SET_CC_MODE_STARTED is executed. CanIf_SetControllerMode() is
        called with controller mode CANIF_CS_STARTED for the corresponding CAN network.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSMBr.T_S_CC_STARTED_S_CC_STARTED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>249</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>806</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_CC_STARTED_INDICATED_CHANGE_BR_FUCO_SYNC</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkTest/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>3250</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test shall verify the transition T_CC_STARTED_INDICATED from state S_CC_STARTED of
    CANSM_BSM_S_CHANGE_BAUDRATE to CANSM_BSM_S_FULLCOM with following constraints:
    - CanSM_ControllerModeIndications() are synchronous
    - No CanSM_RequestComMode() call while processing
  
Test Object: 
    Mode transition
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_FULLCOM; substate S_NO_BUS_OFF
  
Test Execution: 
    01: Enable synchronous controller mode indication. Effect: CanSM_ControllerModeIndication() will
        called in the callout of CanIf_SetControllerMode().
    02: Trigger transition T_CHANGE_BR_REQUEST (S_NO_BUS_OFF to S_CC_STOPPED). Call
        CanSM_SetBaudrate() with new baud rate for corresponding CAN network.
    03: VP(CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_FULLCOM) Verify that CanIf_SetControllerMode() is
        called with controller mode CANIF_CS_STARTED for the corresponding CAN network which will
        trigger the transition T_CC_STARTED_INDICATED (S_CC_STOPPED to CANSM_BSM_S_FULLCOM) in its
        callback function.
    04: VP(CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_FULLCOM): Verify that guarding condition
        G_NO_COM_MODE_NOT_REQUESTED and G_FULL_COM_MODE_REQUESTED applies.
    05: VP(CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_FULLCOM): Verify that effect E_BR_END_FULL_COM is
        executed. CanIf_SetPduMode() is called with PduModeRequest set to
        CANIF_ONLINE for the corresponding CAN network.
    06: VP(CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_FULLCOM): Verify that effect E_BR_END_FULL_COM is
        executed. BswM_CanSM_CurrentState() is called with CurrentState set to
        CANSM_BSWM_FULL_COMMUNICATION for the corresponding CAN network.
    07: VP(CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_FULLCOM): Verify that effect E_BR_END_FULL_COM is
        executed. ComM_BusSM_ModeIndication() is called with ComMode set to
        COMM_FULL_COMMUNICATION for the corresponding CAN network.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_FULLCOM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>171</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>807</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_CC_STARTED_INDICATED_CHANGE_BR_SICO_ASYNC</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkTest/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>3367</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test shall verify the transition T_CC_STARTED_INDICATED from state S_CC_STARTED of
    CANSM_BSM_S_CHANGE_BAUDRATE to CANSM_BSM_S_SILENTCOM with following constraints:
    - CanSM_ControllerModeIndications() are asynchronous
    - CanSM_RequestComMode() shall put the COM mode to COMM_SILENT_COMMUNICATION
  
Test Object: 
    Mode transition
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_FULLCOM; substate S_NO_BUS_OFF
  
Test Execution: 
    01: Disable synchronous controller mode indication.
    02: Trigger transition T_CHANGE_BR_REQUEST (S_NO_BUS_OFF to S_CC_STOPPED). Call
        CanSM_SetBaudrate() with new baud rate for corresponding CAN network.

    03: Perform controller mode indication.
    04: Call CanSM_MainFunction() to continue.
    05: Call CanSM_RequestComMode() with ComM_Mode set to COMM_SILENT_COMMUNICATION for the
        corresponding CAN network.
    06: Perform controller mode indication.
    07: Call CanSM_MainFunction() to continue.

    08: VP(CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_SILENTCOM): Verify that guarding condition
        G_NO_COM_MODE_NOT_REQUESTED and G_SILENT_COM_MODE_REQUESTED applies.
    09: VP(CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_FULLCOM): Verify that effect E_BR_END_SILENT_COM is
        executed. BswM_CanSM_CurrentState() is called with CurrentState set to
        CANSM_BSWM_SILENT_COMMUNICATION for the corresponding CAN network.
    10: VP(CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_FULLCOM): Verify that effect E_BR_END_SILENT_COM is
        executed. CanIf_SetPduMode() is called with PduModeRequest set to CANIF_TX_OFFLINE for the
       corresponding CAN network.
    11: VP(CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_FULLCOM): Verify that effect E_BR_END_SILENT_COM is
        executed. ComM_BusSM_ModeIndication() is called with ComMode set to
        COMM_SILENT_COMMUNICATION for the corresponding CAN network.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_SILENTCOM</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>188</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>808</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_CC_STARTED_INDICATED_CHANGE_BR_NOCO_NOPN_ASYNC</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkTest/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>3498</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test shall verify the transition T_CC_STARTED_INDICATED from state S_CC_STARTED of
    CANSM_BSM_S_CHANGE_BAUDRATE to CANSM_BSM_S_PRE_NOCOM with following constraints:
    - CanSM_ControllerModeIndications() are asynchronous
    - CanSM_RequestComMode() shall put the COM mode to COMM_NO_COMMUNICATION
    - Partial network not supported
  
Test Object: 
    Mode transition
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_FULLCOM; substate S_NO_BUS_OFF
  
Test Execution: 
    01: Disable synchronous controller mode indication.
    02: Trigger transition T_CHANGE_BR_REQUEST (S_NO_BUS_OFF to S_CC_STOPPED). Call
        CanSM_SetBaudrate() with new baud rate for corresponding CAN network.

    03: Perform controller mode indication.
    04: Call CanSM_MainFunction() to continue.
    05: Call CanSM_RequestComMode() with ComM_Mode set to COMM_NO_COMMUNICATION for the
        corresponding CAN network.
    06: Perform controller mode indication.
    07: Call CanSM_MainFunction() to continue.

    08: VP(CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.NoPn.3): Verify that effect E_PRE_NOCOM is
        executed. BswM_CanSM_CurrentState() is called with CurrentState set to
        CANSM_BSWM_SILENT_COMMUNICATION for the corresponding CAN network.

    09: VP(CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.NoPn.3): Verify that do operation
        DO_SET_CC_MODE_STOPPED is executed (Guard CANSM_BSM_G_PN_NOT_SUPPORTED and
        CANSM_BSM_G_PN_SUPPORTED passed). CanIf_SetControllerMode() is called with controller mode
        CANIF_CS_STOPPED for the corresponding CAN network.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.NoPn.3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>186</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>809</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_REPEAT_MAX_CHANGE_BR_S_CC_STOPPED_NOPN</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkTest/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>3613</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks if DET is reported when triggered with T_REPEAT_MAX in state S_CC_STOPPED
    of CANSM_BSM_S_CHANGE_BAUDRATE and verify the correctness of the triggered transition with
    following constraints:
    - CanSM_ControllerModeIndications() are asynchronous
    - Partial network not supported
  
Test Object: 
    T_REPEAT_MAX
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_FULLCOM; substate S_NO_BUS_OFF
  
Test Execution: 
    01: Disable synchronous controller mode indication.
    02: Trigger transition T_CHANGE_BR_REQUEST (S_NO_BUS_OFF to S_CC_STOPPED). Call
        CanSM_SetBaudrate() with new baud rate for corresponding CAN network.

    03: Call the MainFunction of CanSM 10 times
    04: VP(CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.NoPn.1): CanIf_SetControllerMode was called
        second time with controller mode CANIF_CS_STOPPED (once as initial call and once because of
        a CanSMModeRequestRepetitionMax of 1).
    05: Call the MainFunction to continue.
    06: VP(CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.NoPn.1): If development error detection is
        enabled, CanSM called Det_ReportError() with error code CANSM_E_MODE_REQUEST_TIMEOUT.
    07: VP(CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.NoPn.1): Verify that effect E_PRE_NOCOM is
        executed. BswM_CanSM_CurrentState() is called with CurrentState set to
        CANSM_BSWM_SILENT_COMMUNICATION for the corresponding CAN network.

    08: VP(CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.NoPn.1): Verify that do operation
        DO_SET_CC_MODE_STOPPED is executed (Guard CANSM_BSM_G_PN_NOT_SUPPORTED is passed).
        CanIf_SetControllerMode() is called with controller mode CANIF_CS_STOPPED for the
         corresponding CAN network.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.NoPn.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>182</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>810</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_REPEAT_MAX_CHANGE_BR_S_CC_STARTED_NOPN</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkTest/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>3727</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks if DET is reported when triggered with T_REPEAT_MAX in state S_CC_STARTED
    of CANSM_BSM_S_CHANGE_BAUDRATE and verify the correctness of the triggered transition with
    following constraints:
    - CanSM_ControllerModeIndications() are asynchronous
    - Partial network not supported
  
Test Object: 
    T_REPEAT_MAX
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_FULLCOM; substate S_NO_BUS_OFF
  
Test Execution: 
    01: Disable synchronous controller mode indication.
    02: Trigger transition T_CHANGE_BR_REQUEST (S_NO_BUS_OFF to S_CC_STOPPED). Call
        CanSM_SetBaudrate() with new baud rate for corresponding CAN network.

    03: Perform controller mode indication.
    04: Call CanSM_MainFunction() to continue.

    05: Call the MainFunction of CanSM 10 times
    06: VP(CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.NoPn.2): CanIf_SetControllerMode was called
        second time with controller mode CANIF_CS_STOPPED (once as initial call and once because of
        a CanSMModeRequestRepetitionMax of 1).
    07: Call the MainFunction to continue.
    08: VP(CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.NoPn.2): If development error detection is
        enabled, CanSM called Det_ReportError() with error code CANSM_E_MODE_REQUEST_TIMEOUT.
    09: VP(CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.NoPn.2): Verify that effect E_PRE_NOCOM is
        executed with respect to the corresponding deviation. BswM_CanSM_CurrentState() is called
        with CurrentState set to CANSM_BSWM_SILENT_COMMUNICATION for the corresponding CAN network.
    10: VP(CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.NoPn.2): Verify that do operation
        DO_SET_CC_MODE_STOPPED is executed (Guard CANSM_BSM_G_PN_NOT_SUPPORTED is passed).
        CanIf_SetControllerMode() is called with controller mode CANIF_CS_STOPPED for the
        corresponding CAN network.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_CHANGE_BAUDRATE_PRE_NOCOM.NoPn.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>184</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>811</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_FUCO_SICO_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkTest/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>3857</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct transition of communication mode from
    CANSM_BSM_S_FULLCOM to CANSM_BSM_S_SILENTCOM.
  
Test Object: 
    Mode transition
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_FULLCOM; substate S_NO_BUS_OFF
  
Test Execution: 
    01: Call CanSM_RequestComMode with:
        network := &lt;id&gt; of network 0
        ComM_Mode := COMM_SILENT_COMMUNICATION.
    02: VP (CanSM.ASR40.BSM.T_FULLCOM_SILENTCOM.1):
        CanSM called the following API function in defined order:
        1. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_SILENT_COMMUNICATION
           Network := 3
        2. CanIf_SetPduMode with:
           PduModeRequest := CANIF_TX_OFFLINE
           ControllerId := 5
        3. ComM_BusSM_ModeIndication with:
           ComMode := COMM_SILENT_COMMUNICATION
    03: Call CanSM_GetCurrentComMode to read the current CanSM mode
        network := &lt;id&gt; of network 0
    04: VP:
        CanSM_GetCurrentComMode return E_OK
    05: VP:
        CanSM is in state COMM_SILENT_COMMUNICATION
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_FULLCOM_SILENTCOM.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>172</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>812</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_FUCO_SICO_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkTest/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>3945</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct transition of communication mode from
    CANSM_BSM_S_FULLCOM to CANSM_BSM_S_SILENTCOM upon a request for COMM_NO_COMMUNICATION.
    Note: The transition to silent communication happens instanly.
    To trigger the subsequent transition to no communication a MainFunction cycle
    is necessary.
  
Test Object: 
    Mode transition
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_FULLCOM; substate S_NO_BUS_OFF
  
Test Execution: 
    01: Call CanSM_RequestComMode with:
        network := &lt;id&gt; of network 0
        ComM_Mode := COMM_NO_COMMUNICATION.
    02: VP (CanSM.ASR40.BSM.T_FULLCOM_SILENTCOM.2):
        CanSM called the following API function in defined order:
        1. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_SILENT_COMMUNICATION
           Network := 3
        2. CanIf_SetPduMode with:
           PduModeRequest := CANIF_TX_OFFLINE
           ControllerId := 5
        3. ComM_BusSM_ModeIndication with:
           ComMode := COMM_SILENT_COMMUNICATION
    03: Perform one MainFunction cycle
    04: VP (CanSM.ASR40.BSM.T_FULLCOM_SILENTCOM.2):
        CanSM called the following API function in defined order:
        1. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_NO_COMMUNICATION
           Network := 3
        2. CanIf_SetControllerMode with:
           ControllerMode := CANIF_CS_STOPPED
           ControllerId := 5
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_FULLCOM_SILENTCOM.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>173</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>813</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_FUCO_SICO_3</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkTest/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>4043</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct transition of communication mode from
    CANSM_BSM_S_FULLCOM to CANSM_BSM_S_SILENTCOM.
  
Test Object: 
    Mode transition
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_FULLCOM; substate S_BUS_OFF_CHECK
  
Test Execution: 
    01: Call CanSM_RequestComMode with:
        network := &lt;id&gt; of network 0
        ComM_Mode := COMM_SILENT_COMMUNICATION.
    02: VP (CanSM.ASR40.BSM.T_FULLCOM_SILENTCOM.BusOffCheck.1):
        CanSM called the following API function in defined order:
        1. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_SILENT_COMMUNICATION
           Network := 3
        2. CanIf_SetPduMode with:
           PduModeRequest := CANIF_TX_OFFLINE
           ControllerId := 5
        3. ComM_BusSM_ModeIndication with:
           ComMode := COMM_SILENT_COMMUNICATION
    03: Call CanSM_GetCurrentComMode to read the current CanSM mode
        network := &lt;id&gt; of network 0
    04: VP:
        CanSM_GetCurrentComMode return E_OK
    05: VP:
        CanSM is in state COMM_SILENT_COMMUNICATION
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_FULLCOM_SILENTCOM.BusOffCheck.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>108</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>814</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_FUCO_SICO_4</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkTest/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>4130</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks if CanSM does a transition to CANSM_BSM_S_SILENTCOM
    upon a request for COMM_SILENT_COMMUNICATION if the actual (sub-)state is
    S_TX_OFF.
    Note: This transition is implemented in addition to the Autosar SWS.
  
Test Object: 
    Mode transition
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_FULLCOM; substate S_TX_OFF
  
Test Execution: 
    01: Call CanSM_RequestComMode with:
        network := &lt;id&gt; of network 0
        ComM_Mode := COMM_SILENT_COMMUNICATION.
    02: VP (CanSM.EB.BSM.T_FULLCOM_SILENTCOM.S_TX_OFF.1):
        CanSM shall call the following API function in defined order:
        1. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_SILENT_COMMUNICATION
           Network := 3
        2. CanIf_SetPduMode with:
           PduModeRequest := CANIF_TX_OFFLINE
           ControllerId := 5
        3. ComM_BusSM_ModeIndication with:
           ComMode := COMM_SILENT_COMMUNICATION
    03: VP (CanSM.EB.BSM.T_FULLCOM_SILENTCOM.S_TX_OFF.1):
        CanSM is in state COMM_SILENT_COMMUNICATION
    04: Perform one MainFunction cycle
    05: VP:
        No additional transition shall happen.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.EB.BSM.T_FULLCOM_SILENTCOM.S_TX_OFF.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>110</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>815</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_FUCO_SICO_5</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkTest/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>4223</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks if CanSM does a transition to CANSM_BSM_S_NOCOM
    upon a request for COMM_NO_COMMUNICATION if the actual (sub-)state is
    S_TX_OFF.
    Note: This transition is implemented in addition to the Autosar SWS.
    Note: The transition to silent communication happens instanly.
    To trigger the subsequent transition to no communication a MainFunction cycle
    is necessary.
  
Test Object: 
    Mode transition
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_FULLCOM; substate S_TX_OFF
  
Test Execution: 
    01: Call CanSM_RequestComMode with:
        network := &lt;id&gt; of network 0
        ComM_Mode := COMM_NO_COMMUNICATION.
    02: VP (CanSM.EB.BSM.T_FULLCOM_SILENTCOM.S_TX_OFF.2):
        CanSM called the following API function in defined order:
        1. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_SILENT_COMMUNICATION
           Network := 3
        2. CanIf_SetPduMode with:
           PduModeRequest := CANIF_TX_OFFLINE
           ControllerId := 5
        3. ComM_BusSM_ModeIndication with:
           ComMode := COMM_SILENT_COMMUNICATION
    03: Perform one MainFunction cycle
    04: VP (CanSM.EB.BSM.T_FULLCOM_SILENTCOM.S_TX_OFF.2):
        CanSM called the following API function in defined order:
        1. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_NO_COMMUNICATION
           Network := 3
        2. CanIf_SetControllerMode with:
           ControllerMode := CANIF_CS_STOPPED
           ControllerId := 5
    05: VP (CanSM.EB.BSM.T_FULLCOM_SILENTCOM.S_TX_OFF.2):
        CanSM is in state COMM_NO_COMMUNICATION
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.EB.BSM.T_FULLCOM_SILENTCOM.S_TX_OFF.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>111</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>816</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_NOCO_SICO</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkTest/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>4330</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks if CanSM does a transition to CANSM_BSM_S_SILENTCOM
    upon a request for COMM_SILENT_COMMUNICATION if the actual state is
    CANSM_BSM_S_NOCOM.
    Note: This transition is implemented in addition to the Autosar SWS.
  
Test Object: 
    Mode transition
  
Test Precondition: 
    - CanSM is in state CANSM_BSM_S_NOCOM
    - Controller and Transceiver indications are synchroneous
  
Test Execution: 
    01: Call CanSM_RequestComMode with:
        network := &lt;id&gt; of network 0
        ComM_Mode := COMM_SILENT_COMMUNICATION.
    02: VP (CanSM.EB.NoComToSilentCom):
        CanSM shall accept the request.
    03: VP (CanSM.EB.NoComToSilentCom):
        CanSM shall be in state CANSM_BSM_S_FULLCOM
    04: Perform one MainFunction cycle
    05: VP (CanSM.EB.NoComToSilentCom):
        CanSM shall be in state CANSM_BSM_S_SILENTCOM
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.EB.NoComToSilentCom</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>136</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>817</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_BUS_OFF_PASSIVE_TIMER</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkTest/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>4434</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct transition from substate S_BUS_OFF_CHECK
    to substate S_NO_BUS_OFF in state CANSM_BSM_S_FULLCOM.
    Bus-off detection is done via timeout
  
Test Object: 
    Mode transition
  
Test Precondition: 
    - Transition from S_RFUCO to S_FUCO just happened
    - Dem reporting forwarded to Dem
    - CanSMBorTxConfirmationPolling := false
    - CanSMBorTimeTxEnsured := 20,5x CanSMMainFunctionTimePeriod
  
Test Execution: 
    01: Call the MainFunction of CanSM 20 times
    02: VP:
        CanSM called no API functions
    03: Call the MainFunction of CanSM
    04: VP (CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_NO_BUS_OFF):
        CanSM called Dem_ReportErrorStatus with:
        EventId := CANSM_E_BUS_OFF
        EventStatus := DEM_EVENT_STATUS_PASSED
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_NO_BUS_OFF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>232</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>818</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_DEBOUNCE</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkTest/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>4506</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct transition from substate S_BUS_OFF_CHECK
    to substate S_RESTART_CC in state CANSM_BSM_S_FULLCOM
    via trigger T_BUS_OFF.
  
Test Object: 
    Mode transition
  
Test Precondition: 
    - CanSM is in substate S_BUS_OFF_CHECK
  
Test Execution: 
    01: Call CanSM_ControllerBusOff with:
        ControllerId := 5
    02: Call the MainFunction of CanSM
    03: VP (CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_RESTART_CC.BusOff,
            CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_RESTART_CC.BusOffL1):
        CanSM called the following API functions in defined order:
        1. BswM_CanSM_CurrentState with:
    IF CANSM_ENHANCED_BUSOFF_REPORTING enabled
           CurrentState := CANSM_BSWM_BUS_OFF_L1
    ELSE
           CurrentState := CANSM_BSWM_BUS_OFF
    ENDIF
           Network := 3
        2. Dem_ReportErrorStatus with:
           EventId := CANSM_E_BUS_OFF
           EventStatus := DEM_EVENT_STATUS_PREFAILED
        3. CanIf_SetPduMode with:
           PduModeRequest := CANIF_TX_OFFLINE
           ControllerId := 5
        4. CanIf_SetControllerMode with:
        ControllerMode := CANIF_CS_STARTED
           ControllerId := 5
    04: Call CanSM_GetCurrentComMode to read the current CanSM mode
        network := &lt;id&gt; of network 0
    05: VP:
        CanSM_GetCurrentComMode return E_OK
    06: VP:
        CanSM is in state COMM_FULL_COMMUNICATION
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_RESTART_CC.BusOff</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>234</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_RESTART_CC.BusOffL1</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>235</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00235</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>308</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>819</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_DEBOUNCE_SYNC</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkTest/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>4615</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct transition from substate S_BUS_OFF_CHECK
    to substate S_RESTART_CC in state CANSM_BSM_S_FULLCOM
    via trigger T_BUS_OFF.
    All mode indications shall be synchron.
  
Test Object: 
    Mode transition
  
Test Precondition: 
    - CanSM is in substate S_BUS_OFF_CHECK
    - CanSM is in bus-off recovery level 2
  
Test Execution: 
    01: Prepare the CanIf stub to indicate the requested controller mode
        transition from inside the context of CanIf_SetControllerMode.
    02: Call CanSM_ControllerBusOff with:
        ControllerId := 5
    03: Call the MainFunction of CanSM
    04: VP (CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_RESTART_CC.BusOff,
            CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_RESTART_CC.BusOffL2,
            CanSM.ASR40.BSMFull.T_S_RESTART_CC_S_TX_OFF.2):
        CanSM called the following API functions in defined order:
        1. BswM_CanSM_CurrentState with:
    IF CANSM_ENHANCED_BUSOFF_REPORTING enabled
           CurrentState := CANSM_BSWM_BUS_OFF_L2
    ELSE
           CurrentState := CANSM_BSWM_BUS_OFF
    ENDIF
           Network := 3
        2. Dem_ReportErrorStatus with:
           EventId := CANSM_E_BUS_OFF
           EventStatus := DEM_EVENT_STATUS_PREFAILED
        3. CanIf_SetPduMode with:
           PduModeRequest := CANIF_TX_OFFLINE
           ControllerId := 5
        4. CanIf_SetControllerMode with:
           ControllerMode := CANIF_CS_STARTED
           ControllerId := 5
        5. ComM_BusSM_ModeIndication with:
           ComMode := COMM_SILENT_COMMUNICATION
    05: Call CanSM_GetCurrentComMode to read the current CanSM mode
        network := &lt;id&gt; of network 0
    06: VP:
        CanSM_GetCurrentComMode returns E_OK
    07: VP (CanSM.EB.BusOffRecovery.SetNetworkModeSilentCommunication):
        CanSM is in state COMM_SILENT_COMMUNICATION
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_RESTART_CC.BusOff</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>234</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_RESTART_CC.BusOffL2</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>236</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMFull.T_S_RESTART_CC_S_TX_OFF.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>241</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.BusOffRecovery.SetNetworkModeSilentCommunication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>124</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00235</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>308</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>820</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_TX_OFF</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkTest/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>4747</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct transition from substate S_RESTART_CC
    to substate S_TX_OFF in state CANSM_BSM_S_FULLCOM and if CanSM denies a mode request
    when CanSM waits for CanSM_ControllerModeIndication in state S_RESTART_CC.
  
Test Object: 
    Mode transition
    Denial of CanSM_RequestComMode
  
Test Precondition: 
    - CanSM is in substate S_RESTART_CC
  
Test Execution: 
    01: Call CanSM_ControllerModeIndication with:
        ControllerId := 5
        ControllerMode := CANIF_CS_STARTED
    02: Call the MainFunction of CanSM
    03: VP (CanSM.ASR40.BSMFull.T_S_RESTART_CC_S_TX_OFF.2):
        CanSM called the following API function:
        ComM_BusSM_ModeIndication with:
           ComMode := COMM_SILENT_COMMUNICATION
    04: Call CanSM_GetCurrentComMode to read the current CanSM mode
        network := &lt;id&gt; of network 0
    05: VP:
        CanSM_GetCurrentComMode return E_OK
    06: VP (CanSM.EB.BusOffRecovery.SetNetworkModeSilentCommunication):
        CanSM is in state COMM_SILENT_COMMUNICATION
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.EB.BusOffRecovery.SetNetworkModeSilentCommunication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>124</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMFull.T_S_RESTART_CC_S_TX_OFF.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>241</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>821</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_FUCO_SRNOCO</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkTest/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>4833</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct transition from substate S_RESTART_CC
    in state CANSM_BSM_S_FULLCOM to CANSM_BSM_S_PRE_NOCOM.
  
Test Object: 
    Mode transition
  
Test Precondition: 
    - CanSM is in substate S_RESTART_CC
  
Test Execution: 
    01: Call the MainFunction of CanSM 4 times
        (equates CanSMModeRequestRepetitionTime - 1 in MainFunction periods)
    02: VP:
        No API function was called (CanSMModeRequestRepetitionTime not elapsed)
    03: Call the MainFunction of CanSM
    04: VP (CanSM.ASR40.BSMFull.T_S_RESTART_CC_S_RESTART_CC):
        CanSM calls CanIf_SetControllerMode
        (first and last retry, because CanSMModeRequestRepetitionMax equals 1) with:
        ControllerMode := CANIF_CS_STARTED
        ControllerId := 5
    05: Call the MainFunction of CanSM 4 times
        (equates CanSMModeRequestRepetitionTime - 1 in MainFunction periods)
    06: VP:
        CanSM did not call neither Dem_ReportErrorStatus nor CanIf_SetControllerMode
    07: Call the MainFunction of CanSM
    08: VP (CanSM.ASR40.BSM.T_FULLCOM_PRE_NOCOM.NoPn):
        If development error detection is enabled,
        CanSM called Det_ReportError with:
        ErrorId: CANSM_E_MODE_REQUEST_TIMEOUT
    09: VP (CanSM.ASR40.BSM.T_FULLCOM_PRE_NOCOM.NoPn):
            CanIf_SetControllerMode was called with
            ControllerMode := CANIF_CS_STOPPED
            ControllerId := 5
    10: Call CanSM_GetCurrentComMode to read the current CanSM mode
        network := &lt;id&gt; of network 0
    11: VP:
        CanSM_GetCurrentComMode return E_OK
    12: VP:
        CanSM is in state COMM_FULL_COMMUNICATION
    13: Finish transition to no communication by running through state S_RNOCO
        Hint: Use function TS_CANSM_S_RNOCO_SYNC for transition to S_NOCO
    14: VP:
        CanSM is in state COMM_NO_COMMUNICATION
        Hint: check is part of function TS_CANSM_S_RNOCO_SYNC (see step 13)
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSMFull.T_S_RESTART_CC_S_RESTART_CC</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>242</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_FULLCOM_PRE_NOCOM.NoPn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>168</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>822</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_BUS_OFF</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkTest/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>4967</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct transition from substate S_NO_BUS_OFF
    to substate S_RESTART_CC in state CANSM_BSM_S_FULLCOM.
  
Test Object: 
    Mode transition
  
Test Precondition: 
    - CanSM is in substate S_NO_BUS_OFF
  
Test Execution: 
    01: Call CanSM_ControllerBusOff with:
        ControllerId := 5
    02: Call the MainFunction of CanSM
    03: VP (CanSM.ASR40.BSMFull.T_S_NO_BUS_OFF_S_RESTART_CC.BusOff,
            CanSM.ASR40.BSMFull.T_S_NO_BUS_OFF_S_RESTART_CC.BusOffL1):
        CanSM called the following API functions in defined order:
        1. BswM_CanSM_CurrentState with:
    IF CANSM_ENHANCED_BUSOFF_REPORTING enabled
           CurrentState := CANSM_BSWM_BUS_OFF_L1
    ELSE
           CurrentState := CANSM_BSWM_BUS_OFF
    ENDIF
           Network := 3
        2. Dem_ReportErrorStatus with:
           EventId := CANSM_E_BUS_OFF
           EventStatus := DEM_EVENT_STATUS_PREFAILED
        3. CanIf_SetPduMode with:
           PduModeRequest := CANIF_TX_OFFLINE
           ControllerId := 5
        4. CanIf_SetControllerMode with:
           ControllerMode := CANIF_CS_STARTED
           ControllerId := 5
    04: Call CanSM_GetCurrentComMode to read the current CanSM mode
        network := &lt;id&gt; of network 0
    05: VP:
        CanSM_GetCurrentComMode return E_OK
    06: VP:
        CanSM is in state COMM_FULL_COMMUNICATION
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSMFull.T_S_NO_BUS_OFF_S_RESTART_CC.BusOff</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>238</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMFull.T_S_NO_BUS_OFF_S_RESTART_CC.BusOffL1</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>239</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00235</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>308</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>823</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_TX_ON_L1</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkTest/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>5078</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct transition from substate S_TX_OFF
    to substate S_BUS_OFF_CHECK in state CANSM_BSM_S_FULLCOM.
    The bus-off event counter is below CanSMBorCounterL1ToL2.
    Note: CanSMBorTimeL1 elapses after 15 MainFunction periods (see precondition).
    But remember that CanSMBorTimeL1 begins with a indication of a bus-off event.
    If this test begins the state machine is in substate S_TX_OFF (precondition) and
    therefore already ran through the state S_RESTART_CC (sequence TS_CANSM_T_TX_OFF)
    which lasts one MainFunction period.
    Which means, when this test sequence starts CanSMBorTimeL1 shall elapse after 14
    MainFunction periods.
  
Test Object: 
    Mode transition
  
Test Precondition: 
    - CanSM is in substate S_TX_OFF
    - CanSMBorTimeL1 := 14,5x CanSMMainFunctionTimePeriod
  
Test Execution: 
    01: Call the MainFunction of CanSM 13 times
        (Time until CanSMBorTimeL1 elapsed - 1 MainFunction period)
    02: VP:
        CanSM called no API functions
    03: Call the MainFunction of CanSM (CanSMBorTimeL1 elapses now)
    04: VP (CanSM.ASR40.BSMFull.T_S_TX_OFF_S_BUS_OFF_CHECK):
        CanSM called the following API functions in defined order:
        1. CanIf_SetPduMode with:
           PduModeRequest := CANIF_ONLINE
           ControllerId := 5
        2. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_FULL_COMMUNICATION
           Network := 3
        3. ComM_BusSM_ModeIndication with:
           ComMode := COMM_FULL_COMMUNICATION
    05: Call CanSM_GetCurrentComMode to read the current CanSM mode
        network := &lt;id&gt; of network 0
    06: VP:
        CanSM_GetCurrentComMode return E_OK
    07: Verify if CanSM is in state COMM_FULL_COMMUNICATION
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSMFull.T_S_TX_OFF_S_BUS_OFF_CHECK</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>243</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>824</internalId></specobject>
    <specobject>
      <id>TS_CANSM_L1_TO_L2</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkTest/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>5181</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct transition from substate S_BUS_OFF_CHECK
    (initial after S_RFUCO) to substate S_BUS_OFF_CHECK in error level 2.
  
Test Object: 
    Mode transition
  
Test Precondition: 
    - Transition from CANSM_BSM_S_PRE_FULLCOM to CANSM_BSM_S_FULLCOM just happened
    - CanSMBorTimeL1 := 14,5x CanSMMainFunctionTimePeriod
  
Test Execution: 
    01: Repeat steps 02 - 09 for (CanSMBorCounterL1ToL2) times:
    02: Call CanSM_ControllerBusOff with:
        ControllerId := 5
    03: Call the MainFunction of CanSM to start recovery counter
    04: VP (CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_RESTART_CC.BusOff,
            CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_RESTART_CC.BusOffL1):
        CanSM called the following API functions in defined order:
        1. BswM_CanSM_CurrentState with:
    IF CANSM_ENHANCED_BUSOFF_REPORTING enabled
           CurrentState := CANSM_BSWM_F_BUS_OFF_L1
    ELSE
           CurrentState := CANSM_BSWM_F_BUS_OFF
    ENDIF
           Network := 3
        2. Dem_ReportErrorStatus with:
           EventId := CANSM_E_BUS_OFF
           EventStatus := DEM_EVENT_STATUS_PREFAILED
        3. CanIf_SetPduMode with:
           PduModeRequest := CANIF_TX_OFFLINE
           ControllerId := 5
        4. CanIf_SetControllerMode with:
           ControllerMode := CANIF_CS_STARTED
           ControllerId := 5
    05: Call CanSM_ControllerModeIndication with:
        ControllerId := 5
        ControllerMode := CANIF_CS_STARTED
    06: Call the MainFunction of CanSM to trigger state machine
    07: VP (CanSM.ASR40.BSMFull.T_S_RESTART_CC_S_TX_OFF.2):
        CanSM called the following API function:
        ComM_BusSM_ModeIndication with:
           ComMode := COMM_SILENT_COMMUNICATION
    08: Call the MainFunction of CanSM 14 times
    09: VP (CanSM.ASR40.BSMFull.T_S_TX_OFF_S_BUS_OFF_CHECK):
        CanSM called the following API functions in defined order:
        1. CanIf_SetPduMode with:
           PduModeRequest := CANIF_ONLINE
           ControllerId := 5
        2. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_FULL_COMMUNICATION
           Network := 3
        3. ComM_BusSM_ModeIndication with:
           ComMode := COMM_FULL_COMMUNICATION
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_RESTART_CC.BusOff</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>234</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_RESTART_CC.BusOffL1</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>235</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMFull.T_S_RESTART_CC_S_TX_OFF.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>241</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMFull.T_S_TX_OFF_S_BUS_OFF_CHECK</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>243</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00235</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>308</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>825</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_TX_ON_L2</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkTest/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>5331</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct transition from substate S_TX_OFF
    to substate S_BUS_OFF_CHECK in state CANSM_BSM_S_FULLCOM.
    The bus-off event counter is greater than or equal to CanSMBorCounterL1ToL2.
  
Test Object: 
    Mode transition
  
Test Precondition: 
    - CanSM is in substate S_TX_OFF
    - CanSM has reached error level 2
    - CanSMBorTimeL2 := 25x CanSMMainFunctionTimePeriod
  
Test Execution: 
    01: Call the MainFunction of CanSM 24 times
        (Time until CanSMBorTimeL2 elapsed minus 1 MainFunction period)
    02: VP:
        CanSM called no API functions
    03: Call the MainFunction of CanSM (CanSMBorTimeL2 elapsed now)
    04: VP (CanSM.ASR40.BSMFull.T_S_TX_OFF_S_BUS_OFF_CHECK):
        CanSM called the following API functions in defined order:
        1. CanIf_SetPduMode with:
           PduModeRequest := CANIF_ONLINE
           ControllerId := 5
        2. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_FULL_COMMUNICATION
           Network := 3
        3. ComM_BusSM_ModeIndication with:
           ComMode := COMM_FULL_COMMUNICATION
    05: Call CanSM_GetCurrentComMode to read the current CanSM mode
        network := &lt;id&gt; of network 0
    06: VP:
        CanSM_GetCurrentComMode returns E_OK
    07: VP (CanSM.EB.BusOffRecovery.SetTxOnline):
        CanSM is in state COMM_FULL_COMMUNICATION
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSMFull.T_S_TX_OFF_S_BUS_OFF_CHECK</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>243</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.BusOffRecovery.SetTxOnline</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>125</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>826</internalId></specobject>
    <specobject>
      <id>TS_CANSM_TIME_TX_ENSURE_VIO</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkTest/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>5434</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the behavior of CanSM if a bus-off event during
    time CanSMBorTimeTxEnsured is reported.
  
Test Object: 
    Mode transition
  
Test Precondition: 
    - Transition from CANSM_BSM_S_PRE_FULLCOM to CANSM_BSM_S_FULLCOM just happened
    - Dem reporting forwarded to Dem
    - CanSMBorTxConfirmationPolling := false
    - CanSMBorTimeTxEnsured := 20,5x CanSMMainFunctionTimePeriod
  
Test Execution: 
    01: Execute following test sequences in consecutive order:
        1. TS_CANSM_T_DEBOUNCE
        2. TS_CANSM_T_TX_OFF
        3. TS_CANSM_T_TX_ON_L1
    02: Call the MainFunction of CanSM 20 times
    03: Call CanSM_ControllerBusOff with:
        ControllerId := 5
    04: Call the MainFunction of CanSM
    05: VP (CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_NO_BUS_OFF,
            CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_RESTART_CC.BusOff,
            CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_RESTART_CC.BusOff):
        CanSM called the following API functions in defined order:
        1. BswM_CanSM_CurrentState with:
    IF CANSM_ENHANCED_BUSOFF_REPORTING enabled
           CurrentState := CANSM_BSWM_BUS_OFF_L1
    ELSE
           CurrentState := CANSM_BSWM_BUS_OFF
    ENDIF
           Network := 3
        2. Dem_ReportErrorStatus with:
           EventId := CANSM_E_BUS_OFF
           EventStatus := DEM_EVENT_STATUS_PREFAILED
        3. CanIf_SetPduMode with:
           PduModeRequest := CANIF_TX_OFFLINE
           ControllerId := 5
        4. CanIf_SetControllerMode with:
        ControllerMode := CANIF_CS_STARTED
           ControllerId := 5
    06: VP:
        CanSM did not call Dem_ReportErrorStatus
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_NO_BUS_OFF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>232</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_RESTART_CC.BusOff</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>234</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_RESTART_CC.BusOffL1</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>235</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>827</internalId></specobject>
    <specobject>
      <id>TS_CANSM_L1_TO_RECOVERY</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkTest/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>5547</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct handling of short recovery from
    bus-off in level 1.
  
Test Object: 
    Mode transition
  
Test Precondition: 
    - Transition from CANSM_BSM_S_PRE_FULLCOM to CANSM_BSM_S_FULLCOM just happened
    - CanSMBorTimeTxEnsured := 20,5x CanSMMainFunctionTimePeriod
  
Test Execution: 
    01: Execute following test sequences in consecutive order:
        1. TS_CANSM_T_DEBOUNCE
        2. TS_CANSM_T_TX_OFF
        3. TS_CANSM_T_TX_ON_L1
    02: Call the MainFunction of CanSM 20 times
    03: Verify if CanSM called no API functions
    04: Call the MainFunction of CanSM
    05: VP (CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_NO_BUS_OFF):
        CanSM called Dem_ReportErrorStatus with:
        EventId := CANSM_E_BUS_OFF
        EventStatus := DEM_EVENT_STATUS_PASSED
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_NO_BUS_OFF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>232</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>828</internalId></specobject>
    <specobject>
      <id>TS_CANSM_L2_TO_RECOVERY</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkTest/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>5622</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct handling of long recovery from
    bus-off in level 2.
  
Test Object: 
    Mode transition
  
Test Precondition: 
    - Transition from CANSM_BSM_S_PRE_FULLCOM to CANSM_BSM_S_FULLCOM just happened
    - CanSMBorTimeTxEnsured := 20,5x CanSMMainFunctionTimePeriod
  
Test Execution: 
    01: Execute following test sequences in consecutive order
        for (CanSMBorCounterL1ToL2) times:
        1. TS_CANSM_T_DEBOUNCE
        2. TS_CANSM_T_TX_OFF
        3. TS_CANSM_T_TX_ON_L1
    02: Execute following test sequences in consecutive order:
        1. TS_CANSM_T_DEBOUNCE_SYNC
        2. TS_CANSM_T_TX_ON_L2
    03: Call the MainFunction of CanSM 20 times
    04: VP:
        CanSM called no API functions
    05: Call the MainFunction of CanSM
    06: VP (CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_NO_BUS_OFF):
        CanSM called Dem_ReportErrorStatus with:
        EventId := CANSM_E_BUS_OFF
        EventStatus := DEM_EVENT_STATUS_PASSED
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_NO_BUS_OFF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>232</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>829</internalId></specobject>
    <specobject>
      <id>TS_CANSM_BUSOFF_COUNT_RESET</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkTest/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>5714</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the reset of the BusOffEvent counter to '0', when there is a transition
    from CANSM_BSM_S_NOCOM to CANSM_BSM_S_FULLCOM.
    Note: 1. Done by checking if bus-off enters level 2 only after 128 (CanSMBorCounterL1ToL2)
    times the BusOffEvent occurs(This could happen only if the counter is reset to '0').
          2. BusOffEvent is called more than 255 times initially before the rest condition occurs, just to
    ensure it was reset to 0 when having some initial value.
  
Test Object: 
    Mode transition
  
Test Precondition: 
    - CanSMBorTimeTxEnsured := 20,5x CanSMMainFunctionTimePeriod
    - CanSMBorCounterL1ToL2 := 128
  
Test Execution: 
    01: Execute following test sequences in consecutive order
        for (CanSMBorCounterL1ToL2) times to make BusOffCount = 127:
        1. TS_CANSM_T_DEBOUNCE
        2. TS_CANSM_T_TX_OFF
        3. TS_CANSM_T_TX_ON_L1
    02: Execute following test sequences in consecutive order
        for (CanSMBorCounterL1ToL2) times to make BusOffCount = 255:
        1. TS_CANSM_T_DEBOUNCE_SYNC
        2. TS_CANSM_T_TX_ON_L2
    03: Make transition from S_NOCOM to S_FULLCOM that will reset the BusOffCounter
    04: Execute following test sequences in consecutive order
        for (CanSMBorCounterL1ToL2) times:
        1. TS_CANSM_T_DEBOUNCE
        2. TS_CANSM_T_TX_OFF
        3. TS_CANSM_T_TX_ON_L1
    05: Execute following test sequences in consecutive order:
        1. TS_CANSM_T_DEBOUNCE_SYNC
        2. TS_CANSM_T_TX_ON_L2
    06: Call the MainFunction of CanSM 20 times
    07: VP (CanSM.EB.BusOffEventsCount.NOCO_FUCO):
        CanSM called no API functions
    08: Call the MainFunction of CanSM
    09: VP (CanSM.EB.BusOffEventsCount.NOCO_FUCO):
        CanSM called Dem_ReportErrorStatus with:
        EventId := CANSM_E_BUS_OFF
        EventStatus := DEM_EVENT_STATUS_PASSED
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.EB.BusOffEventsCount.NOCO_FUCO</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>114</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>830</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_FUCO_NOCO_SYNC</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkTest/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>5845</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct transition of communication mode from
    S_FUCO (state FUll COmmunication) to S_NOCO (state NO COmmunication).
    All mode indications shall be synchron.
  
Test Object: 
    Module initialization
  
Test Precondition: 
    - Transition from CANSM_BSM_S_PRE_FULLCOM to CANSM_BSM_S_FULLCOM just happened
    - Test is executed for a configuration with and one without a transceiver
  
Test Execution: 
    01: Call TS_CANSM_T_DEBOUNCE to go to substate S_RESTART_CC
    02: Call the MainFunction of CanSM 10 times (to trigger T_FUCO_SRNOCO)
    03: VP:
        CanSM called the following API function in defined order:
        1. CanIf_SetControllerMode with:
           ControllerMode := CANIF_CS_STARTED
           ControllerId := 5
           NOTE: This call is the retry after CANSM_MODEREQ_REPEAT_TIME in state S_RESTART_CC
        2. If CanSMDevErrorDetect is enbled:
           CanSM called Det_ReportError with:
           ErrorId: 0x0A (CANSM_E_MODE_REQUEST_TIMEOUT)
           ApiId: 0x05
           If CanSMDevErrorDetect is disbled:
           CanSM does not call Det_ReportError
        3. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_NO_COMMUNICATION
           Network := 3
           (CanSM.ASR40.BSM.T_SILENTCOM_PRE_NOCOM.NoPn)
        4. CanIf_SetControllerMode with:
           ControllerMode := CANIF_CS_STOPPED
           ControllerId := 5
           (CanSM.ASR40.BSM.T_SILENTCOM_PRE_NOCOM.NoPn)
    IF transceiver is configured
        04: Prepare the CanIf stub to indicate the requested transceiver mode
            transition from inside the context of CanIf_SetTrcvMode.
    ENDIF
    05: Prepare the CanIf stub to indicate the requested controller mode
        transition from inside the context of CanIf_SetControllerMode.
    06: Call CanSM_ControllerModeIndication to confirm CanSM_SetControllerMode
            (sent because of the timeout) with:
            ControllerMode := CANIF_CS_STOPPED
            ControllerId := 5
    07: Call the MainFunction of CanSM
    08: VP:
        CanSM called the following API function in defined order:
        1. CanIf_SetControllerMode with:
           ControllerMode := CANIF_CS_SLEEP
           ControllerId := 5
           (CanSM.ASR40.BSMDeInitNoPn.T_S_CC_STOPPED_S_CC_SLEEP)
        IF transceiver is configured
            2. CanIf_SetTrcvMode with:
               TransceiverMode := CANTRCV_TRCVMODE_NORMAL
               TransceiverId := 3
               (CanSM.ASR40.BSMDeInitNoPn.T_S_CC_SLEEP_S_TRCV_NORMAL)
            3. CanIf_SetTrcvMode with:
               TransceiverMode := CANTRCV_TRCVMODE_STANDBY
               TransceiverId := 3
               (CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_NORMAL_S_TRCV_STANDBY)
               (CanSM.EB.Transitions.NoTransceiver.2)
        ENDIF
        4. ComM_BusSM_ModeIndication with:
           ComMode := COMM_NO_COMMUNICATION
           (CanSM.ASR40.BSM.T_PRE_NOCOM_NOCOM.NoPn.1)
    09: Call CanSM_GetCurrentComMode to read the current CanSM mode
        network := &lt;id&gt; of network 0
    10: VP:
        CanSM_GetCurrentComMode returns E_OK
    11: VP:
        CanSM is in state COMM_NO_COMMUNICATION
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_SILENTCOM_PRE_NOCOM.NoPn</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>189</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_CC_STOPPED_S_CC_SLEEP</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>216</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_CC_SLEEP_S_TRCV_NORMAL</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>219</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_NORMAL_S_TRCV_STANDBY</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>222</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.Transitions.NoTransceiver.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>106</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_PRE_NOCOM_NOCOM.NoPn.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>191</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>831</internalId></specobject>
    <specobject>
      <id>TS_CANSM_S_RNOCO_SYNC</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkTest/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>6028</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct behavior of execution of the CANSM_BSM_S_PRE_NOCOM
    state (State Request NO COmmunication).
    All mode indications shall be synchron.
  
Test Object: 
    Module initialization
  
Test Precondition: 
    - Transition to CANSM_BSM_S_PRE_NOCOM triggered
      (There are two possible trigger conditions:
       a) Maximum allowed wait time for a mode request expired
       b) A mode transition from silent to no communication was requested)
      This means that
      - the call to BswM_CanSM_CurrentState, CanIf_SetPduMode and CanIf_SetControllerMode
        was done by CanSM and traces were checked
    - function trace buffer contains no unchecked function pointer (in counter equals out counter)
      when precondition above was triggered
    - Test is executed for a configuration with and one without a transceiver
  
Test Execution: 
    IF transceiver is configured
        01: Prepare the CanIf stub to indicate the requested transceiver mode
            transition from inside the context of CanIf_SetTrcvMode.
    ENDIF
    02: Prepare the CanIf stub to indicate the requested controller mode
        transition from inside the context of CanIf_SetControllerMode.
    03: Call CanSM_ControllerModeIndication to confirm CanSM_SetControllerMode which
        was the precondition for this test sequence (CanSM_ControllerMode was called
        when entering S_RNOCO). Use following arguments:
        ControllerMode := CANIF_CS_STOPPED
        ControllerId := 5
    04: Call the MainFunction of CanSM
    05: VP:
        CanSM called the following API function in defined order:
        1. CanIf_SetControllerMode with:
           ControllerMode := CANIF_CS_SLEEP
           ControllerId := 5
           (CanSM.ASR40.BSMDeInitNoPn.T_S_CC_STOPPED_S_CC_SLEEP)
        IF transceiver is configured
            2. CanIf_SetTrcvMode with:
               TransceiverMode := CANTRCV_TRCVMODE_NORMAL
               TransceiverId := 3
               (CanSM.ASR40.BSMDeInitNoPn.T_S_CC_SLEEP_S_TRCV_NORMAL)
            3. CanIf_SetTrcvMode with:
               TransceiverMode := CANTRCV_TRCVMODE_STANDBY
               TransceiverId := 3
               (CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_NORMAL_S_TRCV_STANDBY)
               (CanSM.EB.Transitions.NoTransceiver.2)
        ENDIF
        4. ComM_BusSM_ModeIndication with:
           ComMode := COMM_NO_COMMUNICATION
           (CanSM.ASR40.BSM.T_PRE_NOCOM_NOCOM.NoPn.1)
    06: Call CanSM_GetCurrentComMode to read the current CanSM mode
        network := &lt;id&gt; of network 0
    07: VP (CanSM.SWS_CanSM_00371):
        CanSM_GetCurrentComMode returns E_OK
    08: VP (CanSM.SWS_CanSM_00186):
        CanSM is in state COMM_NO_COMMUNICATION
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_CC_STOPPED_S_CC_SLEEP</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>216</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_CC_SLEEP_S_TRCV_NORMAL</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>219</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMDeInitNoPn.T_S_TRCV_NORMAL_S_TRCV_STANDBY</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>222</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.Transitions.NoTransceiver.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>106</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSM.T_PRE_NOCOM_NOCOM.NoPn.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>191</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00371</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>317</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00186</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>303</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>832</internalId></specobject>
    <specobject>
      <id>TS_CANSM_SETPDUMODE_FAILURE_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkTest/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>6171</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct behavior of CanSm when the call to CanIf_SetPduMode fails.
    Mode transition is from S_NOCO to S_FUCO.
  
Test Object: 
    Failed call to CanIf_SetPduMode
  
Test Precondition: 
    - CanSM is in state S_NOCO
  
Test Execution: 
    01: Prepare the CanIf stub so that CanIf_SetPduMode returns E_NOT_OK
    IF transceiver is configured
        02: Prepare the CanIf stub to indicate the requested transceiver mode
            transition from inside the context of CanIf_SetTrcvMode.
    ENDIF
    03: Prepare the CanIf stub to indicate the requested controller mode
        transition from inside the context of CanIf_SetControllerMode.
    04: Call CanSM_RequestComMode with:
        network := &lt;id&gt; of network 0
        ComM_Mode := COMM_FULL_COMMUNICATION.
    05: VP (CanSM.EB.Api.NegativeReturn.CanIf_SetPduMode):
        CanSM shall not call Det_ReportError
    06: Call CanSM_GetCurrentComMode to read the current CanSM mode
        network := &lt;id&gt; of network 0
    07: VP (CanSM.EB.Api.NegativeReturn.CanIf_SetPduMode):
        CanSM_GetCurrentComMode returns E_OK
    08: VP (CanSM.EB.Api.NegativeReturn.CanIf_SetPduMode):
        CanSM is in state COMM_FULL_COMMUNICATION
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.EB.Api.NegativeReturn.CanIf_SetPduMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>116</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>833</internalId></specobject>
    <specobject>
      <id>TS_CANSM_SUBSEQUENT_BUSOFF</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkTest/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>6264</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct behavior of CanSM when a new bus-off event is detected
    immediately after restart of the CC (state S_RESTART_CC) and before finishing with
    bus-off recovery.
    CanSM shall store the 2nd bus-off event and start another recovery cycle after
    the first one finishes.
    This test belongs to bugticket ASCCANSM-366.
  
Test Object: 
    busoff
  
Test Precondition: 
    - CanSM just finished to restart the communication controller in state S_RESTART_CC
      (this means that all mode indication and the consecutive MainFunction are executed)
  
Test Execution: 
    01: Call CanSM_ControllerBusOff with:
        ControllerId := 5
    02: Call the MainFunction of CanSM
    03: VP:
        CanSM does not report any DET error.
    04: Finishing bus-off recovery by waiting Bor time for L1.
    05: VP:
        CanSM finishes bus-off recovery by calling the following API functions in defined order:
        1. CanIf_SetPduMode with:
           PduModeRequest := CANIF_ONLINE
           ControllerId := 5
        2. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_FULL_COMMUNICATION
           Network := 3
        3. ComM_BusSM_ModeIndication with:
           ComMode := COMM_FULL_COMMUNICATION
    06: Call the MainFunction of CanSM to trigger the 2nd recovery.
    07: VP:
        CanSM starts a 2nd bus-off recovery.
        This means CanSM calls the following API functions in defined order:
        1. BswM_CanSM_CurrentState with:
    IF CANSM_ENHANCED_BUSOFF_REPORTING enabled
           CurrentState := CANSM_BSWM_BUS_OFF_L1
    ELSE
           CurrentState := CANSM_BSWM_BUS_OFF
    ENDIF
           Network := 3
        2. Dem_ReportErrorStatus with:
           EventId := CANSM_E_BUS_OFF
           EventStatus := DEM_EVENT_STATUS_PREFAILED
        3. CanIf_SetPduMode with:
           PduModeRequest := CANIF_TX_OFFLINE
           ControllerId := 5
        4. CanIf_SetControllerMode with:
        ControllerMode := CANIF_CS_STARTED
           ControllerId := 5
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00235</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>308</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>834</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_NOCO_FUCO_LATE_IND</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkTest/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>6400</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct transition of communication mode from
    CANSM_BSM_S_NOCOM to CANSM_BSM_S_FULLCOM.
    The first controller mode indication for the mode request is received
    at the same time as the mode request repetition timeout expires.
  
Test Object: 
    Module initialization
  
Test Precondition: 
    - CanSM is in state S_NOCO
    - Test is executed for a configuration with and one without a transceiver
  
Test Execution: 
    01: Call CanSM_RequestComMode with:
        network := &lt;id&gt; of network 0
        ComM_Mode := COMM_FULL_COMMUNICATION.
    IF transceiver is configured
        02: VP:
            CanSM called only the following API function:
            CanIf_SetTrcvMode with:
            TransceiverMode := CANTRCV_TRCVMODE_NORMAL
    ELSE
        02: VP:
            CanSM called only the following API function:
            CanIf_SetControllerMode with:
            ControllerMode := CANIF_CS_STOPPED
    ENDIF
    03: Call the MainFunction of CanSM several times (i.e. one time less than
        CanSMModeRequestRepetitionTime expires)
    IF transceiver is configured
        04: Call CanSM_TransceiverModeIndication with:
            TransceiverId := 3
            TransceiverMode := CANTRCV_TRCVMODE_NORMAL
    ELSE
        04: Call CanSM_ControllerModeIndication with:
            ControllerId := 5
            ControllerMode := CANIF_CS_STOPPED
    ENDIF
    IF transceiver is configured
        05: Prepare the CanIf stub to indicate the requested transceiver mode
            transition from inside the context of CanIf_SetTrcvMode.
    ENDIF
    06: Prepare the CanIf stub to indicate the requested controller mode
        transition from inside the context of CanIf_SetControllerMode.
    07: Call the MainFunction of CanSM (i.e. let CanSMModeRequestRepetitionTime
        expire together with previous mode indication)
    08: VP ():
        CanSM called the following API functions in defined order:
        IF transceiver is configured
            1. CanIf_SetControllerMode with:
               ControllerMode := CANIF_CS_STOPPED
               ControllerId := 5
        ENDIF
        2. CanIf_SetControllerMode with:
           ControllerMode := CANIF_CS_STARTED
           ControllerId := 5
        3. CanIf_SetPduMode with:
           PduModeRequest := CANIF_ONLINE
           ControllerId := 5
           (CanSM.ASR40.BSM.T_PRE_FULLCOM_FULLCOM)
		4. BswM_CanSM_CurrentState with:
           CurrentState := CANSM_BSWM_FULL_COMMUNICATION
           Network := 3
           (CanSM.ASR40.BSM.T_PRE_FULLCOM_FULLCOM)

        5. ComM_BusSM_ModeIndication with:
           ComMode := COMM_FULL_COMMUNICATION
           (CanSM.ASR40.BSM.T_PRE_FULLCOM_FULLCOM)
    09: Call CanSM_GetCurrentComMode to read the current CanSM mode
        network := &lt;id&gt; of network 0
    10: VP:
        CanSM_GetCurrentComMode return E_OK
    11: VP:
        CanSM is in state COMM_FULL_COMMUNICATION
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSMPreFull.T_S_TRCV_NORMAL_S_CC_STOPPED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>227</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMPreFull.T_S_CC_STOPPED_S_CC_STARTED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>229</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>835</internalId></specobject>
    <specobject>
      <id>TS_CANSM_T_BUS_OFF_LATE_BUS_OFF</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkTest/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>6589</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the correct transition from substate S_BUS_OFF_CHECK
    to substate S_RESTART_CC in state S_FUCO (state FUll COmmunication), if
    the bus-off event is recognized and handled during the main function
    call, during which CanSMBorTimeTxEnsured would expire for the transition
    T_BUS_OFF_PASSIVE.
  
Test Object: 
    Mode transition
  
Test Precondition: 
    - Transition from S_RFUCO to S_FUCO just happened
  
Test Execution: 
    01: Call CanSM_MainFunction several times, i.e. as often, that the next
        call would trigger the transition T_BUS_OFF_PASSIVE.
    02: VP:
        No APIs called
    03: Call CanSM_ControllerBusOff with:
        ControllerId := 5
    04: Call CanSM_MainFunction
    05: VP (CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_RESTART_CC.BusOff,
            CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_RESTART_CC.BusOffL1):
        CanSM called the following API functions in defined order:
        1. BswM_CanSM_CurrentState with:
    IF CANSM_ENHANCED_BUSOFF_REPORTING enabled
           CurrentState := CANSM_BSWM_BUS_OFF_L1
    ELSE
           CurrentState := CANSM_BSWM_BUS_OFF
    ENDIF
           Network := 3
        2. Dem_ReportErrorStatus with:
           EventId := CANSM_E_BUS_OFF
           EventStatus := DEM_EVENT_STATUS_PREFAILED
        3. CanIf_SetPduMode with:
           PduModeRequest := CANIF_TX_OFFLINE
           ControllerId := 5
        4. CanIf_SetControllerMode with:
           ControllerMode := CANIF_CS_STARTED
           ControllerId := 5
    06: Call CanSM_GetCurrentComMode to read the current CanSM mode
        network := &lt;id&gt; of network 0
    07: VP:
        CanSM_GetCurrentComMode return E_OK
    08: VP:
        CanSM is in state COMM_FULL_COMMUNICATION
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_RESTART_CC.BusOff</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>234</internalId></provcov>
        <provcov>
          <linksto>CanSM.ASR40.BSMFull.T_S_BUS_OFF_CHECK_S_RESTART_CC.BusOffL1</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>235</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00235</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>308</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>836</internalId></specobject>
    <specobject>
      <id>TS_CANSM_WRONG_INDICATION</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkTest/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>6721</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the behavior of:
    a) an indication done with a wrong controller mode as reaction to CanIf_SetControllerMode
    b) an indication done with a wrong transceiver mode as reaction to CanIf_SetTrcvMode
    In both cases the wrong indication shall be silently ignored.
  
Test Object: 
    Indication APIs CanSM_ControllerModeIndication and CanSM_TransceiverModeIndication.
  
Test Precondition: 
    - CanSM is in state S_NOCO
  
Test Execution: 
    01: Call CanSM_RequestComMode with:
        network := &lt;id&gt; of network 0
        ComM_Mode := COMM_FULL_COMMUNICATION.
    IF transceiver is configured:
        02: Call CanSM_TransceiverModeIndication with:
            TransceiverId := 3
            TransceiverMode := CANTRCV_TRCVMODE_SLEEP
        03: Call the MainFunction of CanSM
        04: VP (CanSM.EB.TransceiverModeIndication.WrongIndication):
            CanSM does not continue its transition (no call to CanIf_SetControllerMode)
        05: Call CanSM_TransceiverModeIndication with:
            TransceiverId := 3
            TransceiverMode := CANTRCV_TRCVMODE_NORMAL
        06: Call the MainFunction of CanSM
    ENDIF
    07: VP (CanSM.EB.TransceiverModeIndication.WrongIndication):
        CanSM continues with transition by calling CanIf_SetControllerMode
    08: VP (CanSM.SWS_CanSM_00638):
        Call CanSM_ControllerModeIndication with:
        ControllerId := 5
        ControllerMode := CANIF_CS_UNINIT
    09: Call the MainFunction of CanSM
    10: VP (CanSM.EB.ControllerModeIndication.WrongIndication):
        CanSM does not continue its transition (no further call to CanIf_SetControllerMode)
    11: Call CanSM_ControllerModeIndication with:
        ControllerId := 5
        ControllerMode := CANIF_CS_STOPPED
    12: Call the MainFunction of CanSM
    13: VP (CanSM.EB.ControllerModeIndication.WrongIndication):
        CanSM continues with transition by calling CanIf_SetControllerMode
    14: Continue with the (correct) transition to mode FULLCOM.
    15: VP:
        CanSM reached FULLCOM mode
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.EB.ControllerModeIndication.WrongIndication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>127</internalId></provcov>
        <provcov>
          <linksto>CanSM.EB.TransceiverModeIndication.WrongIndication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>128</internalId></provcov>
        <provcov>
          <linksto>CanSM.SWS_CanSM_00638</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>512</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>837</internalId></specobject>
    <specobject>
      <id>TS_CANSM_STAY_IN_MODE</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Conformance_40/CanSM_SingleNetworkTest/source/application/Tst_CanSM_Conf_SingleNetwork.c</sourcefile>
      <sourceline>6860</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks that CanSM silently ignores a mode request
    if the requested mode equals the current state.
  
Test Object: 
    CanSM_RequestComMode
  
Test Precondition: 
    - CanSM is in state S_NOCO
  
Test Execution: 
    01: Call CanSM_RequestComMode with:
        network := &lt;id&gt; of network 0
        ComM_Mode := COMM_NO_COMMUNICATION.
    02: Call the MainFunction of CanSM
    03: VP (CanSM.EB.RequestComMode.NoTransition):
        CanSM does not call any API function
    04: VP (CanSM.EB.RequestComMode.NoTransition):
        CanSM is in state COMM_NO_COMMUNICATION
    05: Enter state COMM_FULL_COMMUNICATION
    06: Call CanSM_RequestComMode with:
        network := &lt;id&gt; of network 0
        ComM_Mode := COMM_FULL_COMMUNICATION.
    07: Call the MainFunction of CanSM
    08: VP (CanSM.EB.RequestComMode.NoTransition):
        CanSM does not call any API function
    09: VP (CanSM.EB.RequestComMode.NoTransition):
        CanSM is in state COMM_FULL_COMMUNICATION
    10: Enter state COMM_SILENT_COMMUNICATION
    11: Call CanSM_RequestComMode with:
        network := &lt;id&gt; of network 0
        ComM_Mode := COMM_SILENT_COMMUNICATION.
    12: Call the MainFunction of CanSM
    13: VP (CanSM.EB.RequestComMode.NoTransition):
        CanSM does not call any API function
    14: VP (CanSM.EB.RequestComMode.NoTransition):
        CanSM is in state COMM_SILENT_COMMUNICATION
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.EB.RequestComMode.NoTransition</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>129</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>838</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANSM_CONFIG_ACCESS</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Implementation_40/source/application/ImplementationTests_40.c</sourcefile>
      <sourceline>42</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the access to several configuration elements.
    This test is designed to run with a single and multiple network configurations.
  
Test Object: 
    Module initialization
  
Test Precondition: 
    - CanSM module is NOT initialized
  
Test Execution: 
    01: VP:
        Test access to configuration parameter CanSMBorTimeTxEnsured for all networks
        and check its value
    02: VP:
        Test access to configuration parameter CanSMBorTimeL1 for all networks
        and check its value
    03: VP:
        Test access to configuration parameter CanSMBorTimeL2 for all networks
        and check its value
    04: VP:
        Test access to configuration parameter CanSMBorCounterL1ToL2 for all networks
        and check its value
    05: VP:
        Test access to configuration parameter CanSMTransceiverId for all networks
        and check its value
    06: VP:
        Test access to the configuration which holds the number of controller per
        network and check its value
    07: VP:
        Test access to configuration parameter CanSMControllerId for all controller
        of all networks and check its value
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.SWS_CanSM_00252</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>26</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>839</internalId></specobject>
    <specobject>
      <id>TS_CANSM_GLOBALINIT_VARIABLE</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanSM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanSM/test/ts5/Include/CanSM_Implementation_40/source/application/ImplementationTests_40.c</sourcefile>
      <sourceline>145</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test variable CanSM_GlobalInit is set to CANSM_GLOBAL_UNINIT on startup,
    set to CANSM_GLOBAL_INIT by successful CanSM_Init() call
  
Test Object: 
    CanSM_GlobalInit variable
  
Test Precondition: 
    Module is not initialized
  
Test Execution: 
    01: VP:
        CanSM_GlobalInit equals CANSM_GLOBAL_UNINIT
    02: Valid CanSM_Init call
    03: VP:
        CanSM_GlobalInit equals CANSM_GLOBAL_INIT
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanSM.ASR40.SWS_CanSM_00252</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>26</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>840</internalId></specobject>
  </specobjects>
  </specdocument>
  <violations/>
  <oreqmViolations/>
</tracingresults>
