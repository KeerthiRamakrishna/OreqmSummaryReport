<?xml version="1.0" encoding="UTF-8"?>
<tracingresults>
  <environment>
    <toolname>ReqM2</toolname>
    <toolversion>1.30.0 (stable)</toolversion>
    <toolcopyright>Copyright 2010 - 2018 Elektrobit Automotive GmbH</toolcopyright>
    <libxmlversion>2.0207</libxmlversion>
    <libxml2compileversion>2.9.10</libxml2compileversion>
    <libxml2runtimeversion>20912</libxml2runtimeversion>
    <perlversion>v5.32.1</perlversion>
    <perlptrsize>64</perlptrsize>
    <commandline>-t -q -o asc_MemIf_tracing_cmdb.oreqm -O /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/TestProtocols/LogBase/requirements -c /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_PluginBuildEnv/common/config/AutoCoreReqM2Rules_RMP4_0.xml -s approved,rejected --wfatal WDUPLICATEID,WDUPLICATEIDANDVER /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/build/reqm/ReqM2_Native/asc_MemIf_requirements_AUTOSAR_SWS_MemoryAbstractionInterface_4_0_3.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/build/reqm/ReqM2_Native/asc_MemIf_requirements_AUTOSAR_SWS_MemoryAbstractionInterface_R21-11.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/build/reqm/ReqM2_Native/asc_MemIf_requirements_EB_Refinements.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/build/reqm/ReqM2_Native/asc_MemIf_requirements_EB_Requirements.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/build/reqm/ReqM2_Native/asc_MemIf_test_manTest_ResourceConsumption.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/build/reqm/common_req/MemIf_DbgInst_EB_Extension.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/build/reqm/common_req/MemIf_VerifyStub_EB_Extension.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/build/reqm/ReqM2_GenericImporter/reqm_DEV.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/build/reqm/ReqM2_GenericImporter/reqm_IMPL.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/build/reqm/ReqM2_GenericImporter/reqm_IMPLXML.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/build/reqm/ReqM2_DocBookImporter/reqm_SWDD.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/build/reqm/ReqM2_OldCImporter/reqm_SWUTS_LEGACY.reqm</commandline>
    <timestamp>Mon Jun 17 19:33:21 2024</timestamp>
  </environment>
  <cmdline>
    <cmdparam>
      <name>I</name>
      <values>
        <value>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/TestProtocols/LogBase/requirements</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>O</name>
      <values>
        <value>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/TestProtocols/LogBase/requirements</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>c</name>
      <values>
        <value>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_PluginBuildEnv/common/config/AutoCoreReqM2Rules_RMP4_0.xml</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>o</name>
      <values>
        <value>asc_MemIf_tracing_cmdb.oreqm</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>q</name>
    </cmdparam>
    <cmdparam>
      <name>s</name>
      <values>
        <value>approved</value>
        <value>rejected</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>t</name>
    </cmdparam>
    <cmdparam>
      <name>wfatal</name>
      <values>
        <value>WDUPLICATEID</value>
        <value>WDUPLICATEIDANDVER</value>
      </values>
    </cmdparam>
  </cmdline>
  <inputfiles>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/build/reqm/ReqM2_Native/asc_MemIf_requirements_AUTOSAR_SWS_MemoryAbstractionInterface_4_0_3.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/build/reqm/ReqM2_Native/asc_MemIf_requirements_AUTOSAR_SWS_MemoryAbstractionInterface_R21-11.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/build/reqm/ReqM2_Native/asc_MemIf_requirements_EB_Refinements.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/build/reqm/ReqM2_Native/asc_MemIf_requirements_EB_Requirements.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/build/reqm/ReqM2_Native/asc_MemIf_test_manTest_ResourceConsumption.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/build/reqm/common_req/MemIf_DbgInst_EB_Extension.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/build/reqm/common_req/MemIf_VerifyStub_EB_Extension.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/build/reqm/ReqM2_GenericImporter/reqm_DEV.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/build/reqm/ReqM2_GenericImporter/reqm_IMPL.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/build/reqm/ReqM2_GenericImporter/reqm_IMPLXML.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/build/reqm/ReqM2_DocBookImporter/reqm_SWDD.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/build/reqm/ReqM2_OldCImporter/reqm_SWUTS_LEGACY.reqm</inputfile>
  </inputfiles>
  <configuration>
    <doctypes>
    <regexs>
      <!-- external level -->
      <regex>creq</regex>       <!-- since 10/1018: introduced for updated tracing model-->

      <!-- product line level -->
      <regex>fea</regex>
      <regex>swpad</regex>      <!-- since 10/1018: introduced for updated tracing model-->
      <regex>swts</regex>

      <!-- bundle level -->
      <regex>swrs</regex>
      <regex>swad</regex>
      <regex>swintts</regex>

      <!-- module level -->
      <regex>swdd</regex>
      <regex>swurs</regex>      <!-- since 10/1018: introduced for updated tracing model-->
      <regex>swmts</regex>      <!-- since 01/1010: introduced for updated tracing model RMP4.0-->
      <regex>swuts</regex>
      <regex>impl</regex>

      <!-- legacy items -->
      <regex>dev</regex>
      <regex>man</regex>
      <regex>lim</regex>
    </regexs>
  </doctypes>
    <rules>
    <!-- The Ruleset for RMP4.0 is currently identical to the previous rule set. This rule is
        intoduce to show that the right file is uses. It will be removed when the RMP4.0 rule set is
    reworked -->
    <rule>
      <name>INFO.Rule set RMP4.0</name>
      <description>This rules indicates that RMP4.0 rule set is used.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(./status!='approved') and (./status!='rejected')]</applyto>
          <condition>false()</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>WRN.general.doctypes</name>
      <description>The used doctype is not part of the tracing model</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobjects/@doctype</applyto>
          <condition>((. != 'creq') or (. != 'fea') or (. != 'swpad') or (. != 'swts') or (. != 'swrs') or (. !='swad') or (. != 'swintts') or (.!= 'swdd') or (. != 'swurs') or (. != 'swmts') or (. != 'swuts') or (. != 'impl') or (. != 'dev') or (. != 'man') or (. != 'lim'))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.general.status</name>
      <description>All specification objects must be either in status=approved or in status=rejected. Other
        statuses are not allowed. How to fix: Set status to rejected or approved.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(./status!='approved') and (./status!='rejected')]</applyto>
          <condition>false()</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.general.rejected</name>
      <description>Status status=rejected is only allowed for requirements. How to fix: set to approved for specification object that are not requirements.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype!='swrs')  and (../@doctype!='swmrs') and (../@doctype!='swurs') and (./status='rejected')]</applyto>
          <condition>false()</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.general.comment</name>
      <description>Specification objects with status=rejected shall have a comment or rationale that
        starts with on of the following texts: "This requirement is informational only", "This requirement is not applicable".
        How to fix: Add some text starting with "This requirement is informational only"
        or "This requirement is not applicable" to either the comment or to the rationale.
        Comment: Implementation of check checks for contains instead of starts-with since there is
        no trim function in the used XPATH engine.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(./status='rejected')]</applyto>
          <condition>contains(./comment,"This requirement is informational only") or contains(./rationale,"This requirement is informational only") or contains(./comment,"This requirement is not applicable") or contains(./rationale,"This requirement is not applicable")</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.general.rejected.coverage</name>
      <description>Specification objects with status=rejected shall not need coverage. How to fix: remove need for coverage.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(./status='rejected')]</applyto>
          <condition>count(./needscoverage)=0</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swurs.needscoverage.count</name>
      <description>Unit requirements with status=approved need to be covered, exceptions from
      this rule: configuration requirements (postfix "_CONF" or "_Conf" or prefix "ECUC_") and requirements with
      a comment starting with "The adherence to this requirement is ensured by the following
      release check (URL to the checklist template plus ID of the check):".
      How to fix: Provide a needsobj element for those specobjects or comment according to the rule.
      </description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swurs') and (./status='approved') and count(./needscoverage/needsobj)=0 and count(./fulfilledby/ffbObj)=0]</applyto>
          <!--This condition is false if the id of a specification object does not end with '_Conf' or '_CONF' or does not start with ECUC_ -->
          <condition>substring-after(./id,"ECUC_")!="" or substring-before(./id,"_Conf")!="" or substring-before(./id,"_CONF")!="" or contains(./comment,"The adherence to this requirement is ensured by the following release check (URL to the checklist template plus ID of the check):")</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swurs.needscoverage.rationale</name>
      <description>Requirements with status=approved and without coverage needs that are
        configuration requirements (postfix "_CONF" or "_Conf" or prefix "ECUC_") shall have a comment or rationale
        with the following text: "This is a configuration parameter requirement without functional
        specification.". How to fix: Add some text starting with "This is a configuration parameter
        requirements without functional specification" to either the comment or to the rationale.</description>
      <regexchecks>
        <regexcheck>
          <applyto>//specobject[(../@doctype='swurs') and (./status='approved') and count(./needscoverage/needsobj)=0 and (substring-after(./id,"ECUC_")!="" or substring-before(./id,"_CONF")!="" or substring-before(./id,"_Conf")!="")]</applyto>
          <regex>This is a configuration parameter requirement without functional specification.</regex>
        </regexcheck>
      </regexchecks>
    </rule>

    <rule>
      <name>ERR.swrs.needscoverage.rationale</name>
      <description>Requirements with status=approved and without coverage needs that are
        configuration requirements (postfix "_CONF" or "_Conf" or prefix "ECUC_") shall have a comment or rationale
        with the following text: "This is a configuration parameter requirement without functional
        specification.". How to fix: Add some text starting with "This is a configuration parameter
        requirements without functional specification" to either the comment or to the rationale.</description>
      <regexchecks>
        <regexcheck>
          <applyto>//specobject[(../@doctype='swrs') and (./status='approved') and count(./needscoverage/needsobj)=0 and (substring-after(./id,"ECUC_")!="" or substring-before(./id,"_CONF")!="" or substring-before(./id,"_Conf")!="")]</applyto>
          <regex>This is a configuration parameter requirement without functional specification.</regex>
        </regexcheck>
      </regexchecks>
    </rule>

    <rule>
      <name>ERR.swurs.releases</name>
      <description>Requirements which originates from AUTOSAR (source tag contains term 'AUTOSAR_SWS', 'AUTOSAR_TPS',
        'AUTOSAR_ASWS' or 'AUTOSAR_TR') shall have their release tag set to 'AUTOSAR {major}.{minor}.{patch}' (e.g. 'AUTOSAR 4.3.0').
        Other requirements (including refinements of AUTOSAR requirements) must not contain any of the listed prefixes as
        part of the source tag.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swurs') and (contains(./source,'AUTOSAR_SWS') or contains(./source,'AUTOSAR_TPS') or contains(./source,'AUTOSAR_ASWS') or contains(./source,'AUTOSAR_TR'))]</applyto>
          <condition>contains(./releases/release,'AUTOSAR')</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swrs.releases</name>
      <description>Requirements which originates from AUTOSAR (source tag contains term 'AUTOSAR_SWS', 'AUTOSAR_TPS',
        'AUTOSAR_ASWS' or 'AUTOSAR_TR') shall have their release tag set to 'AUTOSAR {major}.{minor}.{patch}' (e.g. 'AUTOSAR 4.3.0').
        Other requirements (including refinements of AUTOSAR requirements) must not contain any of the listed prefixes as
        part of the source tag.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swrs') and (contains(./source,'AUTOSAR_SWS') or contains(./source,'AUTOSAR_TPS') or contains(./source,'AUTOSAR_ASWS') or contains(./source,'AUTOSAR_TR'))]</applyto>
          <condition>contains(./releases/release,'AUTOSAR')</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swdd.needscoverage.count</name>
      <description>Design elements with status=approved need to be covered.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swdd') and (./status='approved') and count(./needscoverage/needsobj)=0]</applyto>
          <condition>false()</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swurs.needscoverage.doctypes</name>
      <description>Requirements can be covered only by swurs, swad, dev, lim, swdd, impl, swuts, swmts, or man</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swurs')]</applyto>
          <condition>(./needscoverage/needsobj="swurs" or ./needscoverage/needsobj="swad" or ./needscoverage/needsobj="dev" or ./needscoverage/needsobj="lim" or ./needscoverage/needsobj="swdd" or ./needscoverage/needsobj="impl" or ./needscoverage/needsobj="swuts" or ./needscoverage/needsobj="swmts" or ./needscoverage/needsobj="man" or (count(./needscoverage/needsobj)=0))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swrs.needscoverage.doctypes</name>
      <description>Requirements of type swrs can be covered only by swrs, swurs, swad, swintts or man</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swrs')]</applyto>
          <condition>(./needscoverage/needsobj="swrs" or ./needscoverage/needsobj="swurs" or ./needscoverage/needsobj="swad" or ./needscoverage/needsobj="swuts" or ./needscoverage/needsobj="swintts" or ./needscoverage/needsobj="man" or (count(./needscoverage/needsobj)=0))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swdd.needscoverage.doctypes</name>
      <description>Design elements of type swdd can only be covered by swdd, swurs, impl, swuts, lim or man</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swdd')]</applyto>
          <condition>(./needscoverage/needsobj="swdd" or ./needscoverage/needsobj="swurs" or ./needscoverage/needsobj="impl" or ./needscoverage/needsobj="swuts" or ./needscoverage/needsobj="swmts" or ./needscoverage/needsobj="lim" or ./needscoverage/needsobj="man" or (count(./needscoverage/needsobj)=0))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.dev.needscoverage.count</name>
      <description>Deviations shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='dev')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swuts.needscoverage.count</name>
      <description>Test case sepecifications shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swuts')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swmts.needscoverage.count</name>
      <description>Test case sepecifications shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swmts')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swintts.needscoverage.count</name>
      <description>Test case sepecifications shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swintts')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swts.needscoverage.count</name>
      <description>Test case sepecifications shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swts')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.man.needscoverage.count</name>
      <description>Manual test cases shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='man')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.impl.needscoverage.count</name>
      <description>Source code shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='impl')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.lim.needscoverage.count</name>
      <description>Limitations shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='lim')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.fea.needscoverage.test</name>
      <description>Features shall be tested by software test ('swts') or manuel test ('man'). If no test is planned a justification shall be given.
                   A justification can be given in the futherinfo tag. The justification shall start with this rule name.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='fea')]</applyto>
          <condition>(
               ./needscoverage/needsobj="swts" or ./needscoverage/needsobj="man" or ./fulfilledby/ffbObj/ffbType="swts" or ./fulfilledby/ffbObj/ffbType="man" or contains(./furtherinfo,"fea.needscoverage.test") or contains(./furtherinfo,"fea.needscoverage.doctypes"))</condition>
        </conditioncheck>
      </conditionchecks>
          </rule>

    <rule>
      <name>WRN.fea.needscoverage.impl</name>
      <description>Features shall be covered by implementation fea, swrs, swad, swpad, swurs, man and swts. For lagacy features a justification is acceppted. A justification can be given in the futherinfo tag. The justification shall start with this rule name.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='fea')]</applyto>
          <condition>( ./needscoverage/needsobj="swrs" or ./fulfilledby/ffbObj/ffbType="swrs" or ./fulfilledby/ffbObj/ffbType="swad" or ./needscoverage/needsobj="swpad" or ./fulfilledby/ffbObj/ffbType="swpad" or ./needscoverage/needsobj="swurs" or ./fulfilledby/ffbObj/ffbType="swurs" or ./needscoverage/needsobj="fea" or ./fulfilledby/ffbObj/ffbType="fea" or contains(./furtherinfo,"fea.needscoverage.impl"))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>


    <rule>
      <name>ERR.swad.fulfilledby.doctypes</name>
      <description>Architectural design objects of type swad can only be covered by swurs, swad, swdd, swintts, man, otherwise they should be refined with swrs</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swad')]</applyto>
          <condition>(./fulfilledby/ffbObj/ffbType="swurs" or ./needscoverage/needsobj="swurs" or ./fulfilledby/ffbObj/ffbType="req" or ./needscoverage/needsobj="req" or ./fulfilledby/ffbObj/ffbType="swad" or ./needscoverage/needsobj="swad" or ./fulfilledby/ffbObj/ffbType="swdd" or ./fulfilledby/ffbObj/ffbType="swintts" or ./needscoverage/needsobj="swintts" or ./fulfilledby/ffbObj/ffbType="man" or ./needscoverage/needsobj="man") </condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swmts.providescoverage.doctypes</name>
      <description>Test case specifications (tcs) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='tcs')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.man.providescoverage.doctypes</name>
      <description>Manual test case specification (man) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='man')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

   <rule>
      <name>ERR.swuts.providescoverage.doctypes</name>
      <description>Software unit test case specification (swuts) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swuts')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

   <rule>
      <name>ERR.swintts.providescoverage.doctypes</name>
      <description>Software integration test case specification (swintts) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swintts')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

   <rule>
      <name>ERR.swts.providescoverage.doctypes</name>
      <description>Software test case specification (swts) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swts')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

  </rules>
    <oreqmRules>

        <rule>
            <name>WRN.swts.needscoverage.count</name>
            <description>Violated if there are more than 10 swts specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swts']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swts']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swts.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>
        <rule>
            <name>WRN.man.needscoverage.count</name>
            <description>Violated if there are more than 10 man specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='man']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='man']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>man.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>
        <rule>
            <name>WRN.swintts.needscoverage.count</name>
            <description>Violated if there are more than 10 swintts specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swintts']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swintts']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swintts.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>
        <rule>
            <name>WRN.swmts.needscoverage.count</name>
            <description>Violated if there are more than 10 swmts specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swmts']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swmts']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swmts.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swuts.needscoverage.count</name>
            <description>Violated if there are more than 10 swuts specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swuts']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swuts']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swuts.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swpad.needscoverage.count</name>
            <description>Violated if there are more than 10 swpad specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swpad']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swpad']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swpad.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swrs.needscoverage.count</name>
            <description>Violated if there are more than 10 swrs specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swrs']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swrs']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swrs.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swad.needscoverage.count</name>
            <description>Violated if there are more than 10 swad specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swad']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swad']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swad.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swurs.needscoverage.count</name>
            <description>Violated if there are more than 10 swurs specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swurs']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swurs']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swurs.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swdd.needscoverage.count</name>
            <description>Violated if there are more than 10 swdd specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swdd']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swdd']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swdd.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.impl.needscoverage.count</name>
            <description>Violated if there are more than 10 impl specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='impl']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='impl']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>impl.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swrs.fulfilledby.count</name>
            <description>Violated if there are more than 10 swrs specobjects as fulfilledby link to one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swrs'])) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swrs'])) &gt; 10]/furtherinfo</applyto>
                                        <regex>swrs.fulfilledby.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swad.fulfilledby.count</name>
            <description>Violated if there are more than 10 swad specobjects as fulfilledby link to one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swad'])) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swad'])) &gt; 10]/furtherinfo</applyto>
                                        <regex>swad.fulfilledby.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swurs.fulfilledby.count</name>
            <description>Violated if there are more than 10 swurs specobjects as fulfilledby link to one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swurs'])) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swurs'])) &gt; 10]/furtherinfo</applyto>
                                        <regex>swurs.fulfilledby.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swdd.fulfilledby.count</name>
            <description>Violated if there are more than 10 swdd specobjects as fulfilledby link to one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swdd'])) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swdd'])) &gt; 10]/furtherinfo</applyto>
                                        <regex>swdd.fulfilledby.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>
  </oreqmRules>
  </configuration>
  <specdocument>
    <specobjects doctype="swurs">
    <specobject>
      <id>MemIf.ASR40.SWS_MemIf_00002</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAbstractionInterface.pdf, V1.4.0</source>
      <version>1</version>
      <description>
        The file include structure shall be as follows:
      </description>
      <comment>
        NONE: file struture is defined by EB coding guidelines
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemIf.HeaderInclusionHierarchy</srcid><srcstatus/><internalId>69</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>0</internalId></specobject>

    <specobject>
      <id>MemIf.ASR40.SWS_MemIf_00007</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAbstractionInterface.pdf, V1.4.0</source>
      <version>1</version>
      <description>
        The detection of development errors shall be configurable (on/off) at pre-compile time. The 
        switch MEMIF_DEV_ERROR_DETECT  shall activate or deactivate the detection of all development 
        errors.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMIF_30031</srcid><srcstatus/><internalId>124</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30017</srcid><srcstatus/><internalId>125</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30034</srcid><srcstatus/><internalId>126</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30035</srcid><srcstatus/><internalId>127</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30033</srcid><srcstatus/><internalId>128</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30036</srcid><srcstatus/><internalId>129</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30032</srcid><srcstatus/><internalId>130</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1</internalId></specobject>

    <specobject>
      <id>MemIf.ASR40.SWS_MemIf_00009</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAbstractionInterface.pdf, V1.4.0</source>
      <version>1</version>
      <description>
        The types specified in this chapter shall be located in the file MemIf_Types.h.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/MemIf_Types.h_14</srcid><srcstatus/><internalId>85</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2</internalId></specobject>

    <specobject>
      <id>MemIf.ASR40.SWS_MemIf_00029</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_MemoryAbstractionInterface.pdf, V1.4.0</source>
      <version>1</version>
      <description>
        Values for production code Event Ids are assigned externally by the configuration of the Dem. 
        They are published in the file Dem_IntErrId.h and included via Dem.h.
      </description>
      <comment>
        This requirement is not applicable as the MemIf module does not have
        any production relevant errors.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>3</internalId></specobject>

    <specobject>
      <id>MemIf.ASR40.SWS_MemIf_00030</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAbstractionInterface.pdf, V1.4.0</source>
      <version>1</version>
      <description>
        Development error values are of type uint8.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/MemIf.h_47</srcid><srcstatus/><internalId>84</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>4</internalId></specobject>

    <specobject>
      <id>MemIf.ASR40.SWS_MemIf_00033</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_MemoryAbstractionInterface.pdf, V1.4.0</source>
      <version>1</version>
      <description>
        The code file structure shall not be defined within this specification.
      </description>
      <comment>
        This requirement is informational only.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>5</internalId></specobject>

    <specobject>
      <id>MemIf.ASR40.SWS_MemIf_00034</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_MemoryAbstractionInterface.pdf, V1.4.0</source>
      <version>1</version>
      <description>
        The module shall include the Dem.h file. By this inclusion the APIs to report errors as well as 
        the required Event Id symbols are included. This specification defines the name of the Event Id 
        symbols which are provided by XML to the DEM configuration tool. The DEM configuration tool 
        assigns ECU dependent values to the Event Id symbols and publishes the symbols in Dem_IntErrId.
        h.
      </description>
      <comment>
        This requirement is not applicable as the MemIf module does not have
        any production relevant errors.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>6</internalId></specobject>

    <specobject>
      <id>MemIf.ASR40.SWS_MemIf_00057</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAbstractionInterface.pdf, V1.4.0</source>
      <version>1</version>
      <description>
        Configurations: The function MemIf_GetVersionInfo is only available if enabled by the pre-
        processor switch MEMIF_VERSION_INFO_API.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMIF_30024</srcid><srcstatus/><internalId>143</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>7</internalId></specobject>

    <specobject>
      <id>MemIf.ASR40.SWS_MemIf_00058</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAbstractionInterface.pdf, V1.4.0</source>
      <version>1</version>
      <description>
        Detected development errors shall be reported to the Det_ReportError service of the Development 
        Error Tracer (DET) if the pre-processor switch MEMIF_DEV_ERROR_DETECT is set 
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMIF_30031</srcid><srcstatus/><internalId>124</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30017</srcid><srcstatus/><internalId>125</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30034</srcid><srcstatus/><internalId>126</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30035</srcid><srcstatus/><internalId>127</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30033</srcid><srcstatus/><internalId>128</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30036</srcid><srcstatus/><internalId>129</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30032</srcid><srcstatus/><internalId>130</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>8</internalId></specobject>

    <specobject>
      <id>MemIf.ASR40.SWS_MemIf_00059</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_MemoryAbstractionInterface.pdf, V1.4.0</source>
      <version>1</version>
      <description>
        The error codes shall not be used as return values for the called function.
      </description>
      <comment>
        This requirement is informational only.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>9</internalId></specobject>

    <specobject>
      <id>MemIf.ASR40.SWS_MemIf_00060</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAbstractionInterface.pdf, V1.4.0</source>
      <version>1</version>
      <description>
        Only parameters with "Pre-compile time" configuration are allowed in this variant.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/MemIf.xdm.m4_110</srcid><srcstatus/><internalId>94</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/config/MemIf.xdm.m4_139</srcid><srcstatus/><internalId>96</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/config/MemIf.xdm.m4_194</srcid><srcstatus/><internalId>99</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>10</internalId></specobject>

    <specobject>
      <id>MemIf.ASR40.SWS_MemIf_00061</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAbstractionInterface.pdf, V1.4.0</source>
      <version>1</version>
      <description>
        All pre-compile time configuration parameters shall be checked statically (at least during 
        compile time) for correctness.
      </description>
      <comment>
        MEMIF_NUMBER_OF_DEVICES is checked by the config tool.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/MemIf.xdm.m4_148</srcid><srcstatus/><internalId>97</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>11</internalId></specobject>

    <specobject>
      <id>MemIf.ASR40.SWS_MemIf_00062</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_MemoryAbstractionInterface.pdf, V1.4.0</source>
      <version>1</version>
      <description>
        The MemIf module shall perform inter module checks to avoid integration of incompatible files: 
        all included header files shall be checked by pre-processing directives. The MemIf module shall 
        thereby verify that &lt;MODULENAME&gt;_AR_RELEASE_MAJOR_VERSION and &lt;MODULENAME&gt;
        _AR_RELEASE_MINOR_VERSION are identical to the expected values, where &lt;MODULENAME&gt; is the 
        module abbreviation of the external module, which provides the included header file. If the 
        values are not identical, an error shall be raised at compile time.
      </description>
      <comment>
        This requirement is not applicable.
        [BSWM_CHK_401] Inter module version check, Although
        required by the SRS General, BSW004, inter-module version-checks
        SHALL NOT be done. A deviation is documented globally for all
        BSW modules within the release notes and SHALL NOT be documented
        for each module.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>12</internalId></specobject>

    <specobject>
      <id>MemIf.ASR40.SWS_MemIf_00063</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAbstractionInterface.pdf, V1.4.0</source>
      <version>1</version>
      <description>
        If development error detection for the module MemIf is enabled: the function 
        MemIf_GetVersionInfo shall raise the development error MemIf_E_PARAM_POINTER if the argument is 
        a NULL pointer and return without any action.
      </description>
      <comment>
        new in AR4.0
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMIF_30165</srcid><srcstatus/><internalId>145</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>13</internalId></specobject>

    <specobject>
      <id>MemIf.ASR40.SWS_MemIf_00064</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAbstractionInterface.pdf, V1.4.0</source>
      <version>1</version>
      <description>
        The standardized common published parameters as required by
        BSW00402 in the General Requirements on Basic Software Modules [3] shall be published within
        the header file of this module and need to be provided in the BSW Module Description.
        The according module abbreviation can be found in the List of Basic Software Modules [1]].
        </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/MemIf_Version.h.m4_2</srcid><srcstatus/><internalId>89</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/generate_swcd/swcd/MemIf_Bswmd.arxml.m4_273</srcid><srcstatus/><internalId>101</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>14</internalId></specobject>

    <specobject>
      <id>MemIf.ASR40.SWS_MemIf_00038</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAbstractionInterface.pdf, V1.4.0</source>
      <version>1</version>
      <description>
        Service name: MemIf_SetMode  Syntax: void MemIf_SetMode(  MemIf_ModeType Mode
        )  Service ID[hex]: 0x01  Sync/Async: Synchronous  Reentrancy: Non
        Reentrant  Parameters (in): Mode - Parameters None  (inout):  Parameters
        (out): None  Return value: None  Description: Invokes the "SetMode"
        functions of all underlying memory abstraction modules.
        </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMIF_30177</srcid><srcstatus/><internalId>146</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30305</srcid><srcstatus/><internalId>159</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>15</internalId></specobject>

    <specobject>
      <id>MemIf.ASR40.SWS_MemIf_00047</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_MemoryAbstractionInterface.pdf, V1.4.0</source>
      <version>1</version>
      <description>
        API function Description  Ea_Cancel Cancels the ongoing asynchronous operation.
        Ea_EraseImmediateBlock Erases the block BlockNumber.  Ea_GetJobResult
        Service to return the JobResult.  Ea_GetStatus Service to return the
        Status.  Ea_InvalidateBlock Invalidates the block BlockNumber.  Ea_Read
        Reads Length bytes of block Blocknumber at offset BlockOffset into the
        buffer DataBufferPtr.  Ea_SetMode Sets the mode.  Ea_Write Writes the
        contents of the DataBufferPtr to the block BlockNumber.  Fee_Cancel
        Service to call the cancel function of the underlying flash driver.
        Fee_EraseImmediateBlock Service to erase a logical block.
        Fee_GetJobResult Service to query the result of the last accepted job
        issued by the upper  layer software.  Fee_GetStatus Service to return the
        status.  Fee_InvalidateBlock Service to invalidate a logical block.
        Fee_Read Service to initiate a read job.  Fee_SetMode Service to call the
        Fls_SetMode function of the underlying flash driver.  Fee_Write Service
        to initiate a write job.
        </description>
      <comment>
        This requirement is informational only. It is a description of mandatory interfaces to
        other modules used by the MemIf.
        </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>16</internalId></specobject>

    <specobject>
      <id>MemIf.ASR40.SWS_MemIf_00023</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAbstractionInterface.pdf, V1.4.0</source>
      <version>1</version>
      <description>
        The functions of the Memory Abstraction Interface API shall report detected
        errors attributed to an illegal parameter DeviceIndex to the Development
        Error Tracer (DET) with the error code MEMIF_E_PARAM_DEVICE and the
        called service shall not be executed. (BSW00386, BSW12448)
        </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMIF_30031</srcid><srcstatus/><internalId>124</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30017</srcid><srcstatus/><internalId>125</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30034</srcid><srcstatus/><internalId>126</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30035</srcid><srcstatus/><internalId>127</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30033</srcid><srcstatus/><internalId>128</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30036</srcid><srcstatus/><internalId>129</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30032</srcid><srcstatus/><internalId>130</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>17</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs">
    <specobject>
      <id>MemIf.ECUC_MemIf_00032</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAbstractionInterface.pdf, R21-11</source>
      <version>1</version>
      <description>
        Name: MemIfVersionInfoApi
        Parameter Type: Boolean
        Parent Containers: MemIfGeneral,
        Description: Pre-processor switch to enable / disable the API to read out the modules version 
        information.
        Introduction: true: Version info API enabled. false: Version info API disabled.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/MemIf.xdm.m4_171</srcid><srcstatus/><internalId>98</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>18</internalId></specobject>

    <specobject>
      <id>MemIf.ECUC_MemIf_00033</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAbstractionInterface.pdf, R21-11</source>
      <version>1</version>
      <description>
        Name: MemIfNumberOfDevices
        Parameter Type: Integer
        Parent Containers: MemIfGeneral,
        Description: Concrete number of underlying memory abstraction modules.
        Introduction: Calculation Formula: Count number of configured EA and FEE modules.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Max-Value: 2 (Type:
        Min-Value: 1 (Type:
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/MemIf.xdm.m4_118</srcid><srcstatus/><internalId>95</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemIf.NumberOfDevices</srcid><srcstatus/><internalId>74</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>19</internalId></specobject>

    <specobject>
      <id>MemIf.ECUC_MemIf_00034</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAbstractionInterface.pdf, R21-11</source>
      <version>1</version>
      <description>
        Name: MemIfGeneral
        Container Type: Container
        Description: Configuration of the memory abstraction interface (Memif) module.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/MemIf.xdm.m4_53</srcid><srcstatus/><internalId>92</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>20</internalId></specobject>

    <specobject>
      <id>MemIf.ECUC_MemIf_00035</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAbstractionInterface.pdf, R21-11</source>
      <version>1</version>
      <description>
        Name: MemIfDevErrorDetect
        Parameter Type: Boolean
        Parent Containers: MemIfGeneral,
        Description: Switches the development error detection and notification on or off.
        Introduction: * true: detection and notification is enabled. * false: detection and 
        notification is disabled.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/MemIf.xdm.m4_88</srcid><srcstatus/><internalId>93</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>21</internalId></specobject>

    <specobject>
      <id>MemIf.SWS_MemIf_00006</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAbstractionInterface.pdf, R21-11</source>
      <version>1</version>
      <description>
        Type of error | Related error code | Error value 
        API service called with wrong device index parameter | MEMIF_E_PARAM_DEVICEMemIf.
        MEMIF_E_PARAM_DEVICE | 0x01 
        API service called with NULL pointer argument | MEMIF_E_PARAM_POINTERMemIf.
        MEMIF_E_PARAM_POINTER | 0x02 
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMIF_30031</srcid><srcstatus/><internalId>124</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30017</srcid><srcstatus/><internalId>125</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30034</srcid><srcstatus/><internalId>126</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30035</srcid><srcstatus/><internalId>127</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30033</srcid><srcstatus/><internalId>128</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30036</srcid><srcstatus/><internalId>129</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30032</srcid><srcstatus/><internalId>130</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>22</internalId></specobject>

    <specobject>
      <id>MemIf.SWS_MemIf_00010</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_MemoryAbstractionInterface.pdf, R21-11</source>
      <version>1</version>
      <description>
        The types specified in this chapter shall not be changed or extended for a specific memory 
        abstraction module or hardware platform.
      </description>
      <comment>
        This requirement is informational only.
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>23</internalId></specobject>

    <specobject>
      <id>MemIf.SWS_MemIf_00011</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAbstractionInterface.pdf, R21-11</source>
      <version>1</version>
      <description>
        The data type for the memory device index shall be uint8. The lowest value to be used for this 
        device index shall be 0. The allowed range of indices thus shall be 0..MEMIF_NUMBER_OF_DEVICES-
        1.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMIF_30031</srcid><srcstatus/><internalId>124</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30017</srcid><srcstatus/><internalId>125</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30034</srcid><srcstatus/><internalId>126</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30035</srcid><srcstatus/><internalId>127</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30033</srcid><srcstatus/><internalId>128</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30036</srcid><srcstatus/><internalId>129</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30032</srcid><srcstatus/><internalId>130</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>24</internalId></specobject>

    <specobject>
      <id>MemIf.SWS_MemIf_00017</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_MemoryAbstractionInterface.pdf, R21-11</source>
      <version>1</version>
      <description>
        The API specified in this chapter shall be mapped to the API of the underlying memory 
        abstraction modules. For functional behavior refer to the specification of those modules 
        respectively to that of the underlying memory drivers.
      </description>
      <comment>
        This requirement is informational only.
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>25</internalId></specobject>

    <specobject>
      <id>MemIf.SWS_MemIf_00018</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAbstractionInterface.pdf, R21-11</source>
      <version>1</version>
      <description>
        The parameter DeviceIndex shall be used for selection of memory abstraction modules (and thus 
        memory devices). If only one memory abstraction module is configured, the parameter DeviceIndex 
        shall be ignored.
      </description>
      <comment>
        split into two, the second part can be tested - no DET if invalid
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>MemIf.MEMIF_018_1</srcid><srcstatus/><internalId>47</internalId></linkedfrom><linkedfrom><srcid>MemIf.MEMIF_018_1_MemAcc</srcid><srcstatus/><internalId>48</internalId></linkedfrom><linkedfrom><srcid>MemIf.MEMIF_018_2</srcid><srcstatus/><internalId>49</internalId></linkedfrom><linkedfrom><srcid>MemIf.MEMIF_018_3</srcid><srcstatus/><internalId>50</internalId></linkedfrom><linkedfrom><srcid>MemIf.MEMIF_018_3_MemAcc</srcid><srcstatus/><internalId>51</internalId></linkedfrom><linkedfrom><srcid>MemIf.MEMIF_018_4</srcid><srcstatus/><internalId>52</internalId></linkedfrom><linkedfrom><srcid>MemIf.MEMIF_018_4_MemAcc</srcid><srcstatus/><internalId>53</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>26</internalId></specobject>

    <specobject>
      <id>MemIf.SWS_MemIf_00019</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAbstractionInterface.pdf, R21-11</source>
      <version>1</version>
      <description>
        If only one memory abstraction module is configured, the Memory Abstraction Interface shall be 
        implemented as a set of macros mapping the Memory Abstraction Interface API to the API of the 
        corresponding memory abstraction module.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate/include/MemIf_InternalCfg.h_25</srcid><srcstatus/><internalId>81</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemIf.OneMemoryAbstractionMapping</srcid><srcstatus/><internalId>71</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>27</internalId></specobject>

    <specobject>
      <id>MemIf.SWS_MemIf_00020</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAbstractionInterface.pdf, R21-11</source>
      <version>1</version>
      <description>
        If more than one memory abstraction module is configured, the Memory Abstraction Interface 
        shall use efficient mechanisms to map the API calls to the appropriate memory abstraction 
        module.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate/include/MemIf_InternalCfg.h_79</srcid><srcstatus/><internalId>82</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/MemIf.c.m4_61</srcid><srcstatus/><internalId>91</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>28</internalId></specobject>

    <specobject>
      <id>MemIf.SWS_MemIf_00022</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAbstractionInterface.pdf, R21-11</source>
      <version>1</version>
      <description>
        If more than one memory abstraction module is configured and development error detection is 
        enabled for this module, the functions of the Memory Abstraction Interface API shall check the 
        parameter DeviceIndex for being an existing device or the broadcast identifier within the 
        module's services.
      </description>
      <comment>
        This means, that the DET checks shall not be performed if the
        number of devices is 1. This enables the macro implementation
        for all cases in which the number of devices is 1.
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMIF_30031</srcid><srcstatus/><internalId>124</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30017</srcid><srcstatus/><internalId>125</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30034</srcid><srcstatus/><internalId>126</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30035</srcid><srcstatus/><internalId>127</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30033</srcid><srcstatus/><internalId>128</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30036</srcid><srcstatus/><internalId>129</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30032</srcid><srcstatus/><internalId>130</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>29</internalId></specobject>

    <specobject>
      <id>MemIf.SWS_MemIf_00024</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAbstractionInterface.pdf, R21-11</source>
      <version>1</version>
      <description>
        If a called function of the Memory Abstraction Interface API has detected an error attributed 
        to an illegal parameter DeviceIndex and has a return value, it shall be set as follows: 
        MemIf_GetStatus: MEMIF_UNINIT MemIf_GetJobResult: MEMIF_JOB_FAILED All other functions: 
        E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMIF_30031</srcid><srcstatus/><internalId>124</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30017</srcid><srcstatus/><internalId>125</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30034</srcid><srcstatus/><internalId>126</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30035</srcid><srcstatus/><internalId>127</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30033</srcid><srcstatus/><internalId>128</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30036</srcid><srcstatus/><internalId>129</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30032</srcid><srcstatus/><internalId>130</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30044</srcid><srcstatus/><internalId>140</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>30</internalId></specobject>

    <specobject>
      <id>MemIf.SWS_MemIf_00035</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAbstractionInterface.pdf, R21-11</source>
      <version>1</version>
      <description>
        If the function MemIf_GetStatus is called with the device index denoting a broadcast to all 
        configured devices (MEMIF_BROADCAST_ID), the Memory Abstraction Interface module shall call the 
        GetStatus" functions of all underlying devices in turn. It shall return the value
        MEMIF_IDLE - if all underlying devices have returned this state
        MEMIF_UNINIT - if at least one device returned this state, all other returned states shall be 
        ignored
        MEMIF_BUSY - if at least one configured device returned this state and no other device returned 
        MEMIF_UNINIT
        MEMIF_BUSY_INTERNAL - if at least one configured device returned this state and no other device 
        returned MEMIF_BUSY or MEMIF_UNINIT
      </description>
      <comment>
        the value 255 is used for MEMIF_BROADCAST_ID since a device
        with index 255 does not exist.
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMIF_30019</srcid><srcstatus/><internalId>135</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30041</srcid><srcstatus/><internalId>136</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30040</srcid><srcstatus/><internalId>137</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30042</srcid><srcstatus/><internalId>138</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30043</srcid><srcstatus/><internalId>139</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30185</srcid><srcstatus/><internalId>150</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30188</srcid><srcstatus/><internalId>151</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30189</srcid><srcstatus/><internalId>152</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30221</srcid><srcstatus/><internalId>153</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30259</srcid><srcstatus/><internalId>154</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>31</internalId></specobject>

    <specobject>
      <id>MemIf.SWS_MemIf_00037</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAbstractionInterface.pdf, R21-11</source>
      <version>1</version>
      <description>
        Module | Header File | Imported Type 
        MemAcc | MemAcc.h | MemAcc_AddressAreaIdType (draft)
        MemAcc.h | MemAcc_AddressType (draft)
        MemAcc.h | MemAcc_DataType (draft)
        MemAcc.h | MemAcc_JobResultType (draft)
        MemAcc.h | MemAcc_LengthType (draft)
        Std | Std_Types.h | Std_ReturnType 
        Std_Types.h | Std_VersionInfoType 
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate/include/MemIf_Cfg.h_8</srcid><srcstatus/><internalId>75</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/generate/include/MemIf_InternalCfg.h_9</srcid><srcstatus/><internalId>80</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/include/MemIf.h_23</srcid><srcstatus/><internalId>83</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/MemIf.c.m4_25</srcid><srcstatus/><internalId>90</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>32</internalId></specobject>

    <specobject>
      <id>MemIf.SWS_MemIf_00039</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAbstractionInterface.pdf, R21-11</source>
      <version>1</version>
      <description>
        Service Name | MemIf_Read 
        Syntax 
        Std_ReturnType MemIf_Read (uint16 DeviceIndex, uint16 BlockNumber, uint16 BlockOffset, uint8* 
        DataBufferPtr, uint16 Length)
        Service ID [hex] | 0x02 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | DeviceIndex 
        BlockNumber 
        BlockOffset 
        Length 
        Parameters (inout) | None 
        Parameters (out) | DataBufferPtr 
        Return value | Std_ReturnType | In case development error detection is enabled for the Memory 
        Abstraction Interface and a development error is detected according to SWS_MemIf_00022 the 
        function shall return E_NOT_OK else it shall return the value of the called function of the 
        underlying module.
        Description | Invokes the "Read" function of the underlying memory abstraction module selected 
        by the parameter DeviceIndex.
        Available via | MemIf.h 
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMIF_30179</srcid><srcstatus/><internalId>147</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30307</srcid><srcstatus/><internalId>160</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>33</internalId></specobject>

    <specobject>
      <id>MemIf.SWS_MemIf_00040</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAbstractionInterface.pdf, R21-11</source>
      <version>1</version>
      <description>
        Service Name | MemIf_Write 
        Syntax 
        Std_ReturnType MemIf_Write (uint16 DeviceIndex, uint16 BlockNumber, const uint8* DataBufferPtr)
        Service ID [hex] | 0x03 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | DeviceIndex 
        BlockNumber 
        DataBufferPtr 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | Std_ReturnType | In case development error detection is enabled for the Memory 
        Abstraction Interface and a development error is detected according to SWS_MemIf_00022 the 
        function shall return E_NOT_OK else it shall return the value of the called function of the 
        underlying module.
        Description | Invokes the "Write" function of the underlying memory abstraction module selected 
        by the parameter DeviceIndex.
        Available via | MemIf.h 
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>MemIf.MemIf_Write.Service</srcid><srcstatus/><internalId>54</internalId></linkedfrom><linkedfrom><srcid>MemIf.MemIf_Write.DataBufferPtr.type</srcid><srcstatus/><internalId>55</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>34</internalId></specobject>

    <specobject>
      <id>MemIf.SWS_MemIf_00041</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAbstractionInterface.pdf, R21-11</source>
      <version>1</version>
      <description>
        Service Name | MemIf_Cancel 
        Syntax 
        void MemIf_Cancel (uint16 DeviceIndex)
        Service ID [hex] | 0x04 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | DeviceIndex 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | None 
        Description | Invokes the "Cancel" function of the underlying memory abstraction module 
        selected by the parameter DeviceIndex.
        Available via | MemIf.h 
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMIF_30311</srcid><srcstatus/><internalId>149</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30183</srcid><srcstatus/><internalId>162</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>35</internalId></specobject>

    <specobject>
      <id>MemIf.SWS_MemIf_00042</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAbstractionInterface.pdf, R21-11</source>
      <version>1</version>
      <description>
        Service Name | MemIf_GetStatus 
        Syntax 
        MemIf_StatusType MemIf_GetStatus (uint16 DeviceIndex)
        Service ID [hex] | 0x05 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | DeviceIndex 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | MemIf_StatusType 
        Description | Invokes the "GetStatus" function of the underlying memory abstraction module 
        selected by the parameter DeviceIndex.
        Available via | MemIf.h 
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMIF_30044</srcid><srcstatus/><internalId>140</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30185</srcid><srcstatus/><internalId>150</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30188</srcid><srcstatus/><internalId>151</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30189</srcid><srcstatus/><internalId>152</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30221</srcid><srcstatus/><internalId>153</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30259</srcid><srcstatus/><internalId>154</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_GetStatus</srcid><srcstatus/><internalId>158</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30313</srcid><srcstatus/><internalId>163</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>36</internalId></specobject>

    <specobject>
      <id>MemIf.SWS_MemIf_00043</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAbstractionInterface.pdf, R21-11</source>
      <version>1</version>
      <description>
        Service Name | MemIf_GetJobResult 
        Syntax 
        MemIf_JobResultType MemIf_GetJobResult (uint16 DeviceIndex)
        Service ID [hex] | 0x06 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | DeviceIndex 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | MemIf_JobResultType | In case development error detection is enabled for the 
        Memory Abstraction Interface and a development error is detected according to SWS_MemIf_00022 
        the function shall return MEMIF_JOB_FAILED else it shall return the value of the called 
        function of the underlying module.
        Description | Invokes the "GetJobResult" function of the underlying memory abstraction module 
        selected by the parameter DeviceIndex.
        Available via | MemIf.h 
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMIF_30298</srcid><srcstatus/><internalId>155</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30426</srcid><srcstatus/><internalId>164</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>37</internalId></specobject>

    <specobject>
      <id>MemIf.SWS_MemIf_00044</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAbstractionInterface.pdf, R21-11</source>
      <version>1</version>
      <description>
        Service Name | MemIf_InvalidateBlock 
        Syntax 
        Std_ReturnType MemIf_InvalidateBlock (uint16 DeviceIndex, uint16 BlockNumber)
        Service ID [hex] | 0x07 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | DeviceIndex 
        BlockNumber 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | Std_ReturnType | In case development error detection is enabled for the Memory 
        Abstraction Interface and a development error is detected according to SWS_MemIf_00022 the 
        function shall return E_NOT_OK else it shall return the value of the called function of the 
        underlying module.
        Description | Invokes the "InvalidateBlock" function of the underlying memory abstraction 
        module selected by the parameter DeviceIndex.
        Available via | MemIf.h 
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMIF_30300</srcid><srcstatus/><internalId>156</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30428</srcid><srcstatus/><internalId>165</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>38</internalId></specobject>

    <specobject>
      <id>MemIf.SWS_MemIf_00045</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAbstractionInterface.pdf, R21-11</source>
      <version>1</version>
      <description>
        Service Name | MemIf_GetVersionInfo 
        Syntax 
        void MemIf_GetVersionInfo (Std_VersionInfoType* VersionInfoPtr)
        Service ID [hex] | 0x08 
        Sync/Async | Synchronous 
        Reentrancy | Reentrant 
        Parameters (in) | None 
        Parameters (inout) | None 
        Parameters (out) | VersionInfoPtr | Pointer to standard version information structure.
        Return value | None 
        Description | Returns version information.
        Available via | MemIf.h 
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMIF_30024</srcid><srcstatus/><internalId>143</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30165</srcid><srcstatus/><internalId>145</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>39</internalId></specobject>

    <specobject>
      <id>MemIf.SWS_MemIf_00046</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAbstractionInterface.pdf, R21-11</source>
      <version>1</version>
      <description>
        Service Name | MemIf_EraseImmediateBlock 
        Syntax 
        Std_ReturnType MemIf_EraseImmediateBlock (uint16 DeviceIndex, uint16 BlockNumber)
        Service ID [hex] | 0x09 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | DeviceIndex 
        BlockNumber 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | Std_ReturnType | In case development error detection is enabled for the Memory 
        Abstraction Interface and a development error is detected according to SWS_MemIf_00022 the 
        function shall return E_NOT_OK else it shall return the value of the called function of the 
        underlying module.
        Description | Invokes the "EraseImmediateBlock" function of the underlying memory abstraction 
        module selected by the parameter DeviceIndex.
        Available via | MemIf.h 
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMIF_30302</srcid><srcstatus/><internalId>157</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30430</srcid><srcstatus/><internalId>166</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>40</internalId></specobject>

    <specobject>
      <id>MemIf.SWS_MemIf_00047</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_MemoryAbstractionInterface.pdf, R21-11</source>
      <version>2</version>
      <description>
        API Function | Header File | Description 
        Ea_EraseImmediateBlock | Ea.h | Erases the block BlockNumber.
        Ea_GetStatus | Ea.h | Service to return the Status.
        Ea_InvalidateBlock | Ea.h | Invalidates the block BlockNumber.
        Fee_EraseImmediateBlock | Fee.h | Service to erase a logical block.
        Fee_GetStatus | Fee.h | Service to return the status.
        Fee_InvalidateBlock | Fee.h | Service to invalidate a logical block.
        MemAcc_Cancel (draft) | MemAcc.h | Triggers a cancel operation of the pending job for the 
        address area referenced by the addressAreaId. Cancelling affects only jobs in pending state. 
        For any other states, the request will be ignored. Tags: atp.Status=draft 
        MemAcc_GetJobResult (draft) | MemAcc.h | Returns the consolidated job result of the address 
        area referenced by addressAreaId. Tags: atp.Status=draft 
        MemAcc_Read (draft) | MemAcc.h | Triggers a read job to copy data from the source address into 
        the referenced destination data buffer. The result of this service can be retrieved using the 
        MemAcc_GetJobResult API. If the read operation was successful, the result of the job is 
        MEMACC_MEM_OK. If the read operation failed, the result of the job is either MEMACC_MEM_FAILED 
        in case of a general error or MEMACC_MEM_ECC_CORRECTED/MEMACC_MEM_ECC_UNCORRECTED in case of a 
        correctable/uncorrectable ECC error. Tags: atp.Status=draft 
        MemAcc_Write (draft) | MemAcc.h | Triggers a write job to store the passed data to the provided 
        address area with given address and length. The result of this service can be retrieved using 
        the MemAcc_GetJobResult API. If the write operation was successful, the job result is 
        MEMACC_MEM_OK. If there was an issue writing the data, the result is MEMACC_MEM_FAILED. Tags: 
        atp.Status=draft 
      </description>
      <comment>
        This requirement is informational only. It is a description of mandatory interfaces to
        other modules used by the MemIf.
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>41</internalId></specobject>

    <specobject>
      <id>MemIf.SWS_MemIf_00048</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_MemoryAbstractionInterface.pdf, R21-11</source>
      <version>2</version>
      <description>
        API Function | Header File | Description 
        Det_ReportError | Det.h | Service to report development errors.
      </description>
      <comment>
        This requirement is informational only. This is a description of optional interfaces to other
        modules used by the MemIf.
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>42</internalId></specobject>

    <specobject>
      <id>MemIf.SWS_MemIf_00999</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_MemoryAbstractionInterface.pdf, R21-11</source>
      <version>2</version>
      <description>
        These requirements are not applicable to this specification.
      </description>
      <comment>
        This requirement is informational only.
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>43</internalId></specobject>

    <specobject>
      <id>MemIf.SWS_MemIf_00064</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAbstractionInterface.pdf, R21-11</source>
      <version>1</version>
      <description>
        Name | MemIf_StatusType 
        Kind | Enumeration 
        Range | MEMIF_UNINIT | -- | The underlying abstraction module or device driver has not been 
        initialized (yet)
        MEMIF_IDLE | -- | The underlying abstraction module or device driver is currently idle.
        MEMIF_BUSY | -- | The underlying abstraction module or device driver is currently busy.
        MEMIF_BUSY_INTERNAL | -- | The underlying abstraction module is busy with internal management 
        operations. The underlying device driver can be busy or idle.
        Description | Denotes the current status of the underlying abstraction module and device drive.
        Available via | MemIf.h 
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemIf.DeviceDriverMapping</srcid><srcstatus/><internalId>73</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>MemIf.Dsn.Types.MemIf_StatusType</srcid><srcstatus/><internalId>104</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>44</internalId></specobject>

    <specobject>
      <id>MemIf.SWS_MemIf_00065</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAbstractionInterface.pdf, R21-11</source>
      <version>1</version>
      <description>
        Name | MemIf_JobResultType (obsolete)
        Kind | Enumeration 
        Range | MEMIF_JOB_OK | -- | The job has been finished successfully.
        MEMIF_JOB_FAILED | -- | The job has not been finished successfully.
        MEMIF_JOB_PENDING | -- | The job has not yet been finished.
        MEMIF_JOB_CANCELED | -- | The job has been canceled.
        MEMIF_BLOCK_INCONSISTENT | -- | 1. The requested block is inconsistent, it may contain 
        corrupted data. 2. Block is NOT found.
        MEMIF_BLOCK_INVALID | -- | The requested block has been marked as invalid, the requested 
        operation can not be performed.
        Description | Denotes the result of the last job. Tags: atp.Status=obsolete 
        Available via | MemIf.h 
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemIf.BlockMapping</srcid><srcstatus/><internalId>72</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/MemIf_Types.h_23</srcid><srcstatus/><internalId>87</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/generate_swcd/swcd/MemIf_Bswmd.arxml.m4_191</srcid><srcstatus/><internalId>100</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>45</internalId></specobject>

    <specobject>
      <id>MemIf.ECUC_MemIf_00025</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAbstractionInterface.pdf, R21-11</source>
      <version>1</version>
      <description>
        Module Name | MemIf 
        Module Description | Configuration of the MemIf (Memory Abstraction Interface) module.
        Post-Build Variant Support | false 
        Supported Config Variants | VARIANT-PRE-COMPILE 
        Included Containers 
        Container Name | Multiplicity | Scope / Dependency 
        MemIfGeneral | 1 | Configuration of the memory abstraction interface (Memif) module.
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>46</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs">
    <specobject>
      <id>MemIf.MEMIF_018_1</id>
      <status>approved</status>
      <source>EB Refinement</source>
      <version>2</version>
      <description>
        If MemIfMemAccUsage is set to false, the parameter DeviceIndex shall be used for selection of memory
        abstraction modules (and thus memory devices).
        </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>MemIf_GenTest_01_InvalidConfiguration_EepDriverIndex</srcid><srcstatus/><internalId>108</internalId></linkedfrom><linkedfrom><srcid>MemIf_GenTest_01_InvalidConfiguration_FlsDriverIndex</srcid><srcstatus/><internalId>109</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30152</srcid><srcstatus/><internalId>131</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30154</srcid><srcstatus/><internalId>132</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30156</srcid><srcstatus/><internalId>133</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30158</srcid><srcstatus/><internalId>134</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30160</srcid><srcstatus/><internalId>141</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30022</srcid><srcstatus/><internalId>142</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30164</srcid><srcstatus/><internalId>144</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00018</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>26</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>47</internalId></specobject>

    <specobject>
      <id>MemIf.MEMIF_018_1_MemAcc</id>
      <status>approved</status>
      <source>EB Refinement</source>
      <version>1</version>
      <description>
        If MemIfMemAccUsage is set to true, the parameter DeviceIndex shall be used for the selection of memory 
        abstraction modules that reference a MemAcc AreaId equal to the DeviceIndex.
        </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>MemIf_GenTest_01_InvalidConfiguration_MemAccAddressAreaId</srcid><srcstatus/><internalId>110</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30154</srcid><srcstatus/><internalId>132</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30156</srcid><srcstatus/><internalId>133</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30158</srcid><srcstatus/><internalId>134</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30160</srcid><srcstatus/><internalId>141</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30022</srcid><srcstatus/><internalId>142</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30164</srcid><srcstatus/><internalId>144</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00018</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>26</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>48</internalId></specobject>

    <specobject>
      <id>MemIf.MEMIF_018_2</id>
      <status>approved</status>
      <source>EB Refinement</source>
      <version>1</version>
      <description>
        If only one memory abstraction module is configured, the
        parameter DeviceIndex shall be ignored.
        </description>
      <comment>
        REVIEW the API should be mapped directly using MACROS if DET is
        OFF
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMIF_30307</srcid><srcstatus/><internalId>160</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30309</srcid><srcstatus/><internalId>161</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30183</srcid><srcstatus/><internalId>162</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30313</srcid><srcstatus/><internalId>163</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30426</srcid><srcstatus/><internalId>164</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30428</srcid><srcstatus/><internalId>165</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30430</srcid><srcstatus/><internalId>166</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00018</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>26</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>49</internalId></specobject>

    <specobject>
      <id>MemIf.MEMIF_018_3</id>
      <status>approved</status>
      <source>EB Refinement</source>
      <version>2</version>
      <description>
        If MemIfMemAccUsage is set to false, the generator shall check that references to Fls/Eep 
        shall be identical for all blocks of the same abstraction module.
      </description>
      <comment>
        Can be checked manually that the generator identifies error.
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate/include/MemIf_CommonCfg.m_96</srcid><srcstatus/><internalId>76</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>MemIf_GenTest_02_InvalidConfiguration_EaBlocksEepDriverIndex</srcid><srcstatus/><internalId>111</internalId></linkedfrom><linkedfrom><srcid>MemIf_GenTest_02_InvalidConfiguration_FeeBlocksFlsDriverIndex</srcid><srcstatus/><internalId>112</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00018</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>26</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>50</internalId></specobject>

    <specobject>
      <id>MemIf.MEMIF_018_3_MemAcc</id>
      <status>approved</status>
      <source>EB Refinement</source>
      <version>1</version>
      <description>
        If MemIfMemAccUsage is set to true, the generator shall check that references to memory areas 
        shall be identical for all blocks of the same abstraction module.
      </description>
      <comment>
        Can be checked manually that the generator identifies error.
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate/include/MemIf_CommonCfg.m_167</srcid><srcstatus/><internalId>78</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>MemIf_GenTest_02_InvalidConfiguration_EaBlocksMemAccAddressArea</srcid><srcstatus/><internalId>113</internalId></linkedfrom><linkedfrom><srcid>MemIf_GenTest_02_InvalidConfiguration_FeeBlocksMemAccAddressArea</srcid><srcstatus/><internalId>114</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00018</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>26</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>51</internalId></specobject>

    <specobject>
      <id>MemIf.MEMIF_018_4</id>
      <status>approved</status>
      <source>EB Refinement</source>
      <version>2</version>
      <description>
        If MemIfMemAccUsage is set to false, the generator shall check that Fls/Eep Driver indexes shall be distinct, 
        and that no two Memory abstraction modules may link the same Driver index.
        </description>
      <comment>
        Can be checked manually that the generator identifies error.
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate/include/MemIf_CommonCfg.m_97</srcid><srcstatus/><internalId>77</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>MemIf_GenTest_03_InvalidConfiguration_EaEepMapping</srcid><srcstatus/><internalId>115</internalId></linkedfrom><linkedfrom><srcid>MemIf_GenTest_03_InvalidConfiguration_FeeFlsMapping</srcid><srcstatus/><internalId>116</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00018</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>26</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>52</internalId></specobject>

    <specobject>
      <id>MemIf.MEMIF_018_4_MemAcc</id>
      <status>approved</status>
      <source>EB Refinement</source>
      <version>1</version>
      <description>
        If MemIfMemAccUsage is set to true, the generator shall check that memory area IDs shall be distinct,
        and that no two Memory abstraction modules may link the same memory area ID.
        </description>
      <comment>
        Can be checked manually that the generator identifies error.
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate/include/MemIf_CommonCfg.m_168</srcid><srcstatus/><internalId>79</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>MemIf_GenTest_03_InvalidConfiguration_EaMemAccAddressAreaMapping</srcid><srcstatus/><internalId>117</internalId></linkedfrom><linkedfrom><srcid>MemIf_GenTest_03_InvalidConfiguration_FeeMemAccAddressAreaMapping</srcid><srcstatus/><internalId>118</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00018</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>26</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>53</internalId></specobject>

    <specobject>
      <id>MemIf.MemIf_Write.Service</id>
      <status>approved</status>
      <source>Bugzilla #55397</source>
      <version>1</version>
      <description>
        Service name: MemIf_Write Service ID[hex]: 0x03
        Sync/Async: Synchronous  Reentrancy: Non Reentrant
        Parameters (in): DeviceIndex - BlockNumber - DataBufferPtr - Parameters (inout):
        None Parameters (out): None  Return value: Std_ReturnType In case
        development error detection is enabled for the Memory  Abstraction
        Interface and a development error is detected according to
        MemIf022 the function shall return E_NOT_OK else  it shall return the
        value of the called function of the underlying  module.  Description:
        Invokes the "Write" function of the underlying memory abstraction module
        selected  by the parameter DeviceIndex.
        </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMIF_30181</srcid><srcstatus/><internalId>148</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30309</srcid><srcstatus/><internalId>161</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00040</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>34</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>54</internalId></specobject>

    <specobject>
      <id>MemIf.MemIf_Write.DataBufferPtr.type</id>
      <status>approved</status>
      <source>Bugzilla #55397</source>
      <version>1</version>
      <description>
        Service name: MemIf_Write  Syntax: Std_ReturnType MemIf_Write(  uint8
        DeviceIndex,  uint16 BlockNumber,  uint8* DataBufferPtr).
        </description>
      <comment>
        In NvM R4.0.3 the parameter NvM_SrcPtr of NvM_WriteBlock() is changed
        to const uint8*. In order to make MemIf_Write() compatible with NvM_WriteBlock(),
        the DataBufferPtr type must be const uint8*.
        </comment>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemIf.MemIf_WriteDataBufferPtrType</srcid><srcstatus/><internalId>70</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00040</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>34</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>55</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs">
    <specobject>
      <id>MemIf.EB.BSWMDGeneration_1</id>
      <status>rejected</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The MemIf module's generator shall generate a basic software
        module description (BSWMD) based on the MemIf module's
        configuration containing information on the exclusive areas
        required by the MemIf module's implementation.
        </description>
      <comment>
        This requirement is not applicable as MemIf module does not use any exclusive areas.
        </comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>56</internalId></specobject>

    <specobject>
      <id>MemIf.EB.BSWMDGeneration_2</id>
      <status>rejected</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The MemIf module's generator shall generate a basic software
        module description (BSWMD) based on the MemIf module's
        configuration containing information on the scheduled
        MainFunctions together with the scheduling period.
        </description>
      <comment>
        This requirement is not applicable as MemIf module does not have any scheduled MainFunctions.
        </comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>57</internalId></specobject>

    <specobject>
      <id>MemIf.EB.BSWMDGeneration_3</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The MemIf module's BSWMD shall be generated using a generator
        mode named "generate_swcd".
        </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMIF_30174</srcid><srcstatus/><internalId>123</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>58</internalId></specobject>

    <specobject>
      <id>MemIf.EB.MEMIF_900</id>
      <status>approved</status>
      <source>AUTOSAR</source>
      <version>1</version>
      <description>
        Name MemIfDevErrorDetect {MEMIF_DEV_ERROR_DETECT}
        Description Pre-processor switch to enable / disable development
        error detection.
        true: Development error detection enabled.
        false: Development error detection disabled.
        Multiplicity 1
        Type BooleanParamDef
        Default value -
        ConfigurationClass Pre-compile time X All Variants Link time -
        Post-build time -Scope / Dependency
      </description>
      <furtherinfo>
        WRN.swuts.needscoverage.count -  valid for each API function
      </furtherinfo>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMIF_30170</srcid><srcstatus/><internalId>107</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30171</srcid><srcstatus/><internalId>119</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30172</srcid><srcstatus/><internalId>120</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30173</srcid><srcstatus/><internalId>121</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30174</srcid><srcstatus/><internalId>123</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30031</srcid><srcstatus/><internalId>124</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30017</srcid><srcstatus/><internalId>125</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30034</srcid><srcstatus/><internalId>126</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30035</srcid><srcstatus/><internalId>127</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30033</srcid><srcstatus/><internalId>128</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30036</srcid><srcstatus/><internalId>129</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30032</srcid><srcstatus/><internalId>130</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>59</internalId></specobject>

    <specobject>
      <id>MemIf.EB.MEMIF_901</id>
      <status>approved</status>
      <source>AUTOSAR</source>
      <version>1</version>
      <description>
        Name MemIfNUmberOfDevices {MEMIF_NUMBER_OF_DEVICES}
        Concrete number of underlying memory abstraction
        modules.
        Multiplicity 1
        Type BooleanParamDef
        Default value -
        ConfigurationClass Pre-compile time X All Variants Link time -
        Post-build time -Scope / Dependency
        </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMIF_30170</srcid><srcstatus/><internalId>107</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30171</srcid><srcstatus/><internalId>119</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30172</srcid><srcstatus/><internalId>120</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30173</srcid><srcstatus/><internalId>121</internalId></linkedfrom><linkedfrom><srcid>TS_MEMIF_30174</srcid><srcstatus/><internalId>123</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>60</internalId></specobject>

    <specobject>
      <id>MemIf.EB.CustomReturnTypes</id>
      <status>approved</status>
      <source>AUTOSAR</source>
      <version>1</version>
      <description>
        MemIf shall support two new return types, MEMIF_JOB_OK_SIZE_INCREASED and MEMIF_JOB_OK_SIZE_DECREASED.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/MemIf_Types.h_114</srcid><srcstatus/><internalId>88</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>61</internalId></specobject>
  </specobjects>
    <specobjects doctype="man">
    <specobject>
      <id>TS_MemIf_ResourceConsumption</id>
      <status>approved</status>
      <source>EB manual test</source>
      <version>1</version>
      <description>
        01: Get RAM/ROM consumption of MemIf_ComTest_ResourceConsumption
        02 VP(MemIf.swdd.ROMConsumption_RefCfg1): Check the ROM consumption of
           the test run against the threshold specified in the requirement.
        03 VP(MemIf.swdd.RAMConsumption_RefCfg1): Check the RAM consumption of
           the test run against the threshold specified in the requirement.
        Action if test any verification point is not fulfilled:
        If the consumption exceeds the threshold, an analysis shall be started to find the cause
        of the additional resource consumption.
        The result of the analysis shall trigger either:
        * an update of the resource view in the design and the existing threshold if there is a
          rationale for the additional resource consumption.
        OR
        * measurements to reduce the additional resource consumption below the existing threshold
          if there is no rationale for the additional resource consumption.
      </description>
      <providescoverage>
        <provcov>
          <linksto>MemIf.swdd.ROMConsumption_RefCfg1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>102</internalId></provcov>
        <provcov>
          <linksto>MemIf.swdd.RAMConsumption_RefCfg1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>103</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>62</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs">

    <specobject>
      <id>MemIf.EB.DBGINST001</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Every public API of the module shall have debug instrumentation.
      </description>
      <comment> </comment>
      <!-- Can be tested by an conformance and a compile test -->
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MemIf_DBGINST_001</srcid><srcstatus/><internalId>105</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>63</internalId></specobject>

    <specobject>
      <id>MemIf.EB.DBGINST002</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The parameter of a API shall be available in the entry instrumentation.
      </description>
      <comment> </comment>
      <!-- Can be tested by an conformance and a compile test -->
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MemIf_DBGINST_001</srcid><srcstatus/><internalId>105</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>64</internalId></specobject>

    <specobject>
      <id>MemIf.EB.DBGINST003</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The parameter of a API shall be available in the exit instrumentation.
        If the API has a return value, the very first parameter of the macro shall contain the expected return value.
      </description>
      <comment> </comment>
      <!-- Can be tested by an conformance and a compile test -->
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MemIf_DBGINST_001</srcid><srcstatus/><internalId>105</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>65</internalId></specobject>

    <specobject>
      <id>MemIf.EB.DBGINST004</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The default implementation of the debug instrumentation shall be an empty macro.
      </description>
      <comment> </comment>
      <!-- Can be tested by an conformance and a compile test -->
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MemIf_DBGINST_001</srcid><srcstatus/><internalId>105</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>66</internalId></specobject>

    <specobject>
      <id>MemIf.EB.DBGINST005</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The module shall include the header files Base_Dbg.h in order to allow changing the default implementation of the debug instrumentation.
      </description>
      <comment> </comment>
      <!-- Can be tested by an conformance and a compile test -->
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MemIf_DBGINST_001</srcid><srcstatus/><internalId>105</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>67</internalId></specobject>

  </specobjects>
    <specobjects doctype="swurs">

    <specobject>
      <id>MemIf.EB.Interface.Consistency</id>
       <status>approved</status>
       <source>EB</source>
       <version>1</version>
       <description>
        The module shall provide a mechanism to guarantee consistency of interfaces and
        types between its implementation and its code stub.
       </description>
       <comment>
        The code stub of a module shall provide the same external view than the module itself.
        This is mandatory because unit test of modules test against the code stubs of
        adjacent modules. Inconsistent stubs may result in the situation that incompatible
        interfaces are not detected as unit test stage.
       </comment>
       <verifycrit>
        Create a compile test with two permutations that call all interfaces of a module
        (in both permutations).
        p0: Behave like a regular compile test; call the module generator and compile against
        the implementation of the module.
        p1: Do not generate module code and do not compile the implementation of the module.
        Instead the module shall be replaced with its own code stub.
       </verifycrit>
       <needscoverage>
          <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MemIf_VerifyCodeStub</srcid><srcstatus/><internalId>106</internalId></linkedfrom></coveredby></needscov>
       <containerCovstatus>covered</containerCovstatus></needscoverage>
       
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>68</internalId></specobject>

  </specobjects>
    <specobjects doctype="dev">
    <specobject>
      <id>dev.MemIf.HeaderInclusionHierarchy</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>69</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemIf.ASR40.SWS_MemIf_00002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>0</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>69</internalId></specobject>
    <specobject>
      <id>dev.MemIf.MemIf_WriteDataBufferPtrType</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>92</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemIf.MemIf_Write.DataBufferPtr.type</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>55</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>70</internalId></specobject>
    <specobject>
      <id>dev.MemIf.OneMemoryAbstractionMapping</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>113</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00019</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>27</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>71</internalId></specobject>
    <specobject>
      <id>dev.MemIf.BlockMapping</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>132</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00065</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>45</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>72</internalId></specobject>
    <specobject>
      <id>dev.MemIf.DeviceDriverMapping</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>151</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00064</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>44</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>73</internalId></specobject>
    <specobject>
      <id>dev.MemIf.NumberOfDevices</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>167</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemIf.ECUC_MemIf_00033</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>19</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>74</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/generate/include/MemIf_Cfg.h_8</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/src/Autosar/generate/include/MemIf_Cfg.h</sourcefile>
      <sourceline>8</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00037</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>32</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>75</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/generate/include/MemIf_CommonCfg.m_96</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/src/Autosar/generate/include/MemIf_CommonCfg.m</sourcefile>
      <sourceline>96</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemIf.MEMIF_018_3</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>50</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>76</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate/include/MemIf_CommonCfg.m_97</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/src/Autosar/generate/include/MemIf_CommonCfg.m</sourcefile>
      <sourceline>97</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemIf.MEMIF_018_4</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>52</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>77</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate/include/MemIf_CommonCfg.m_167</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/src/Autosar/generate/include/MemIf_CommonCfg.m</sourcefile>
      <sourceline>167</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemIf.MEMIF_018_3_MemAcc</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>51</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>78</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate/include/MemIf_CommonCfg.m_168</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/src/Autosar/generate/include/MemIf_CommonCfg.m</sourcefile>
      <sourceline>168</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemIf.MEMIF_018_4_MemAcc</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>53</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>79</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/generate/include/MemIf_InternalCfg.h_9</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/src/Autosar/generate/include/MemIf_InternalCfg.h</sourcefile>
      <sourceline>9</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00037</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>32</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>80</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate/include/MemIf_InternalCfg.h_25</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/src/Autosar/generate/include/MemIf_InternalCfg.h</sourcefile>
      <sourceline>25</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00019</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>27</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>81</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate/include/MemIf_InternalCfg.h_79</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/src/Autosar/generate/include/MemIf_InternalCfg.h</sourcefile>
      <sourceline>79</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00020</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>28</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>82</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/include/MemIf.h_23</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/src/Autosar/include/MemIf.h</sourcefile>
      <sourceline>23</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00037</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>32</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>83</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/MemIf.h_47</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/src/Autosar/include/MemIf.h</sourcefile>
      <sourceline>47</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemIf.ASR40.SWS_MemIf_00030</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>4</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>84</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/include/MemIf_Types.h_14</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/src/Autosar/include/MemIf_Types.h</sourcefile>
      <sourceline>14</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemIf.ASR40.SWS_MemIf_00009</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>2</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>85</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/MemIf_Types.h_15</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/src/Autosar/include/MemIf_Types.h</sourcefile>
      <sourceline>15</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemIf.Dsn.Types.MemIf_StatusType</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>104</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>86</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/MemIf_Types.h_23</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/src/Autosar/include/MemIf_Types.h</sourcefile>
      <sourceline>23</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00065</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>45</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>87</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/MemIf_Types.h_114</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/src/Autosar/include/MemIf_Types.h</sourcefile>
      <sourceline>114</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemIf.EB.CustomReturnTypes</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>61</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>88</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/include/MemIf_Version.h.m4_2</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/src/Autosar/include/MemIf_Version.h.m4</sourcefile>
      <sourceline>2</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemIf.ASR40.SWS_MemIf_00064</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>14</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>89</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/src/MemIf.c.m4_25</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/src/Autosar/src/MemIf.c.m4</sourcefile>
      <sourceline>25</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00037</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>32</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>90</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemIf.c.m4_61</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/src/Autosar/src/MemIf.c.m4</sourcefile>
      <sourceline>61</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00020</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>28</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>91</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/config/MemIf.xdm.m4_53</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/src/Autosar/config/MemIf.xdm.m4</sourcefile>
      <sourceline>53</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemIf.ECUC_MemIf_00034</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>20</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>92</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/MemIf.xdm.m4_88</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/src/Autosar/config/MemIf.xdm.m4</sourcefile>
      <sourceline>88</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemIf.ECUC_MemIf_00035</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>21</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>93</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/MemIf.xdm.m4_110</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/src/Autosar/config/MemIf.xdm.m4</sourcefile>
      <sourceline>110</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemIf.ASR40.SWS_MemIf_00060</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>10</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>94</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/MemIf.xdm.m4_118</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/src/Autosar/config/MemIf.xdm.m4</sourcefile>
      <sourceline>118</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemIf.ECUC_MemIf_00033</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>19</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>95</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/MemIf.xdm.m4_139</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/src/Autosar/config/MemIf.xdm.m4</sourcefile>
      <sourceline>139</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemIf.ASR40.SWS_MemIf_00060</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>10</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>96</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/MemIf.xdm.m4_148</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/src/Autosar/config/MemIf.xdm.m4</sourcefile>
      <sourceline>148</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemIf.ASR40.SWS_MemIf_00061</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>11</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>97</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/MemIf.xdm.m4_171</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/src/Autosar/config/MemIf.xdm.m4</sourcefile>
      <sourceline>171</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemIf.ECUC_MemIf_00032</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>18</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>98</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/MemIf.xdm.m4_194</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/src/Autosar/config/MemIf.xdm.m4</sourcefile>
      <sourceline>194</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemIf.ASR40.SWS_MemIf_00060</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>10</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>99</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/generate_swcd/swcd/MemIf_Bswmd.arxml.m4_191</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/src/Autosar/generate_swcd/swcd/MemIf_Bswmd.arxml.m4</sourcefile>
      <sourceline>191</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00065</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>45</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>100</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate_swcd/swcd/MemIf_Bswmd.arxml.m4_273</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/src/Autosar/generate_swcd/swcd/MemIf_Bswmd.arxml.m4</sourcefile>
      <sourceline>273</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemIf.ASR40.SWS_MemIf_00064</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>14</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>101</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd">
    <specobject>
      <id>MemIf.swdd.ROMConsumption_RefCfg1</id>
      <status>approved</status>
      <source>Elektrobit Automotive GmbH</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/doc/project/design/pdf/MemIf_Design-profiled.xml</sourcefile>
      <sourceline>4365</sourceline>
      <version>1</version>
      <description>
                        The ROM consumption for reference configuration must not exceed 300 bytes.
                      </description>
      <rationale>
                        The defined ROM consumption is the result of all analysed configuration
                        parameters of reference configuration 1.
                      </rationale>
      <needscoverage>
        <needscov><needsobj>man</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MemIf_ResourceConsumption</srcid><srcstatus/><internalId>62</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>MemIf_ComTest_ResourceConsumption</srcid><srcstatus/><internalId>122</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>102</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd">
    <specobject>
      <id>MemIf.swdd.RAMConsumption_RefCfg1</id>
      <status>approved</status>
      <source>Elektrobit Automotive GmbH</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/doc/project/design/pdf/MemIf_Design-profiled.xml</sourcefile>
      <sourceline>4393</sourceline>
      <version>1</version>
      <description>
                        The RAM consumption for reference configuration must not exceed 0 bytes.
                      </description>
      <rationale>
                        The defined RAM consumption is the result of all analysed configuration
                        parameters of reference configuration 1.
                      </rationale>
      <needscoverage>
        <needscov><needsobj>man</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MemIf_ResourceConsumption</srcid><srcstatus/><internalId>62</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>MemIf_ComTest_ResourceConsumption</srcid><srcstatus/><internalId>122</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>103</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd">
    <specobject>
      <id>MemIf.Dsn.Types.MemIf_StatusType</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/doc/project/design/pdf/MemIf_Design-profiled.xml</sourcefile>
      <sourceline>4498</sourceline>
      <version>1</version>
      <description>&lt;description/&gt;</description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/MemIf_Types.h_15</srcid><srcstatus/><internalId>86</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00064</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>44</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>104</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_MemIf_DBGINST_001</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/build/reqm/common_req/MemIf_DbgInst_Trace_APIs.c</sourcefile>
      <sourceline>40</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
   Test Dbg
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
  VP: Successful compilation test.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemIf.EB.DBGINST001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>63</internalId></provcov>
        <provcov>
          <linksto>MemIf.EB.DBGINST002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>64</internalId></provcov>
        <provcov>
          <linksto>MemIf.EB.DBGINST003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>65</internalId></provcov>
        <provcov>
          <linksto>MemIf.EB.DBGINST004</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>66</internalId></provcov>
        <provcov>
          <linksto>MemIf.EB.DBGINST005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>67</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>105</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_MemIf_VerifyCodeStub</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/build/reqm/common_req/MemIf_VerifyStub_testspec.h</sourcefile>
      <sourceline>7</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that the code stub of the module is consistent with the
    implementation.
  
Test Object: 
    Relocatable post-build configuration macros generation.
  
Test Precondition: 
    Permutation [VerifyStub == true]:
      - Unit test contains its own code stub
      - Module is excluded from generation and compilation
    Permutation [VerifyStub == false]:
      - unit test excludes its own code stub
  
Test Execution: 
    01: Invoke all module APIs
    02: VP(MemIf.EB.Interface.Consistency):
        Unit test compiles (implicitly tested)
  
Test Input: 
  
Test Output: 
    Test is correctly generated and compiled.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemIf.EB.Interface.Consistency</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>68</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>106</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_MEMIF_30170</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/test/ts5/Compile/IN/MemIf_ComTest_2/source/application/Appl.c</sourcefile>
      <sourceline>40</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Compile test 2:
Compilation with the following configuration:
MemIfDevErrorDetect = false
MemIfVersionInfoApi = false
MemIfNumberOfDevices = 1
&lt;/para&gt;

Test Object: None.
Test Precondition: None.
Test Execution: None.
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemIf.EB.MEMIF_900</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>59</internalId></provcov>
        <provcov>
          <linksto>MemIf.EB.MEMIF_901</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>60</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>107</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>MemIf_GenTest_01_InvalidConfiguration_EepDriverIndex</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/test/ts5/Generic/IN/MemIf_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>27</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test will check that MemIf shall not allow more than one memory driver with the same Id
  (configured) memory drivers.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
  The following error must be issued:
 There may not be two Eep memory drivers with the same device ID. Please check EepGeneral/EepDriverIndex

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemIf.MEMIF_018_1</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>47</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>108</internalId></specobject>
    <specobject>
      <id>MemIf_GenTest_01_InvalidConfiguration_FlsDriverIndex</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/test/ts5/Generic/IN/MemIf_GenTest_01_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>52</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test will check that MemIf shall not allow more than one memory driver with the same Id
  (configured) memory drivers.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
  The following error must be issued:
 There may not be two Fls memory drivers with the same device ID. Please check FlsGeneral/FlsDriverIndex

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemIf.MEMIF_018_1</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>47</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>109</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>MemIf_GenTest_01_InvalidConfiguration_MemAccAddressAreaId</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/test/ts5/Generic/IN/MemIf_GenTest_01_InvalidConfiguration_MemAcc/source/application/testspec.h</sourcefile>
      <sourceline>27</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test will check that MemIf shall not allow more than one memory area with the same Id
  (configured) memory drivers.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
  The following error must be issued:
 There may not be two memory areas with the same area ID. Please check MemAcc/MemAccAddressAreaConfiguration

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemIf.MEMIF_018_1_MemAcc</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>48</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>110</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>MemIf_GenTest_02_InvalidConfiguration_EaBlocksEepDriverIndex</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/test/ts5/Generic/IN/MemIf_GenTest_02_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>27</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test will check that MemIf shall not allow more than one Eep driver for an Ea hardware abstraction.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
  The following error must be issued:
 A hardware abstraction module may not have blocks in two EEP driver modules. References unequal

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemIf.MEMIF_018_3</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>50</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>111</internalId></specobject>
    <specobject>
      <id>MemIf_GenTest_02_InvalidConfiguration_FeeBlocksFlsDriverIndex</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/test/ts5/Generic/IN/MemIf_GenTest_02_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>51</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test will check that MemIf shall not allow more than one Fls driver for an Fee hardware abstraction.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
  The following error must be issued:
 A hardware abstraction module may not have blocks in two Fls driver modules. References unequal

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemIf.MEMIF_018_3</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>50</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>112</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>MemIf_GenTest_02_InvalidConfiguration_EaBlocksMemAccAddressArea</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/test/ts5/Generic/IN/MemIf_GenTest_02_InvalidConfiguration_MemAcc/source/application/testspec.h</sourcefile>
      <sourceline>27</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test will check that MemIf shall not allow more than one memory area for an Ea hardware abstraction.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
  The following error must be issued:
 A hardware abstraction module may not have blocks in two memory areas. References unequal

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemIf.MEMIF_018_3_MemAcc</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>51</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>113</internalId></specobject>
    <specobject>
      <id>MemIf_GenTest_02_InvalidConfiguration_FeeBlocksMemAccAddressArea</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/test/ts5/Generic/IN/MemIf_GenTest_02_InvalidConfiguration_MemAcc/source/application/testspec.h</sourcefile>
      <sourceline>51</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test will check that MemIf shall not allow more than one memory area for an Fee hardware abstraction.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
  The following error must be issued:
 A hardware abstraction module may not have blocks in two memory areas. References unequal

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemIf.MEMIF_018_3_MemAcc</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>51</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>114</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>MemIf_GenTest_03_InvalidConfiguration_EaEepMapping</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/test/ts5/Generic/IN/MemIf_GenTest_03_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>27</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test will check that MemIf shall not allow more than one memory abstraction modules linked to the same driver
  (configured) memory drivers.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: None.
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemIf.MEMIF_018_4</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>52</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>115</internalId></specobject>
    <specobject>
      <id>MemIf_GenTest_03_InvalidConfiguration_FeeFlsMapping</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/test/ts5/Generic/IN/MemIf_GenTest_03_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>51</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test will check that MemIf shall not allow more than one memory abstraction modules linked to the same driver
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
  The following error must be issued:
 MEMIF cannot map two hardware abstraction modules to the same driver!

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemIf.MEMIF_018_4</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>52</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>116</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>MemIf_GenTest_03_InvalidConfiguration_EaMemAccAddressAreaMapping</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/test/ts5/Generic/IN/MemIf_GenTest_03_InvalidConfiguration_MemAcc/source/application/testspec.h</sourcefile>
      <sourceline>27</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test will check that MemIf shall not allow more than one memory abstraction modules linked to the same memory area
  (configured) memory drivers.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
  The following error must be issued:
 MEMIF cannot map two hardware abstraction modules to the same memory area!

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>MemIf.MEMIF_018_4_MemAcc</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>53</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>117</internalId></specobject>
    <specobject>
      <id>MemIf_GenTest_03_InvalidConfiguration_FeeMemAccAddressAreaMapping</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/test/ts5/Generic/IN/MemIf_GenTest_03_InvalidConfiguration_MemAcc/source/application/testspec.h</sourcefile>
      <sourceline>52</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test will check that MemIf shall not allow more than one memory abstraction modules linked to the same memory area
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
  The following error must be issued:
 MEMIF cannot map two hardware abstraction modules to the same memory area!

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>MemIf.MEMIF_018_4_MemAcc</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>53</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>118</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_MEMIF_30171</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/test/ts5/Include/MemIf_Compile_Common/source/application/Appl.c</sourcefile>
      <sourceline>39</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Compile test 1:
Compilation with the following configuration:
MemIfDevErrorDetect = true
MemIfVersionInfoApi = true
MemIfNumberOfDevices = 1
&lt;/para&gt;

Test Object: None.
Test Precondition: None.
Test Execution: None.
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemIf.EB.MEMIF_900</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>59</internalId></provcov>
        <provcov>
          <linksto>MemIf.EB.MEMIF_901</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>60</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>119</internalId></specobject>
    <specobject>
      <id>TS_MEMIF_30172</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/test/ts5/Include/MemIf_Compile_Common/source/application/Appl.c</sourcefile>
      <sourceline>72</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Compile test 3:
Compilation with the following configuration:
MemIfDevErrorDetect = true
MemIfVersionInfoApi = true
MemIfNumberOfDevices = 2
&lt;/para&gt;

Test Object: None.
Test Precondition: None.
Test Execution: None.
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemIf.EB.MEMIF_900</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>59</internalId></provcov>
        <provcov>
          <linksto>MemIf.EB.MEMIF_901</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>60</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>120</internalId></specobject>
    <specobject>
      <id>TS_MEMIF_30173</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/test/ts5/Include/MemIf_Compile_Common/source/application/Appl.c</sourcefile>
      <sourceline>105</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Compile test 4:
Compilation with the following configuration:
MemIfDevErrorDetect = false
MemIfVersionInfoApi = true
MemIfNumberOfDevices = 2
&lt;/para&gt;

Test Object: None.
Test Precondition: None.
Test Execution: None.
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemIf.EB.MEMIF_900</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>59</internalId></provcov>
        <provcov>
          <linksto>MemIf.EB.MEMIF_901</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>60</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>121</internalId></specobject>
    <specobject>
      <id>MemIf_ComTest_ResourceConsumption</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/test/ts5/Include/MemIf_Compile_Common/source/application/Appl.c</sourcefile>
      <sourceline>138</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
      This test shall be used as a reference test to estimate the RAM and ROM consumption.
    
Test Object: 
      RAM/ROM consumption of reference configuration
    
Test Precondition: None.
Test Execution: 
        This test is intended as compile test only.
    
Test Input: 
    
Test Output: 
        A compiled module.
    &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemIf.swdd.ROMConsumption_RefCfg1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>102</internalId></provcov>
        <provcov>
          <linksto>MemIf.swdd.RAMConsumption_RefCfg1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>103</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>122</internalId></specobject>
    <specobject>
      <id>TS_MEMIF_30174</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/test/ts5/Include/MemIf_Compile_Common/source/application/Appl.c</sourcefile>
      <sourceline>172</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Compile test 5:
Compilation with the following configuration:
MemIfDevErrorDetect = true
MemIfVersionInfoApi = false
MemIfNumberOfDevices = 1
&lt;/para&gt;
&lt;para&gt;
This test checks that the MemIf module's generator generates a
syntactically and semantically valid basic software module
description (BSWMD) when the generator mode "generate_swcd" is
invoked. It further tests that the SchM exclusive area API is
correctly generated by the RTE generator based on the MemIf module's
generated BSWMD.
&lt;/para&gt;

Test Object: None.
Test Precondition: None.
Test Execution: 
Ts5 build environment steps:
The module configuration generator produces the BSWMD containing
the information on the required exclusive areas.  This information
is then used by the RTE generator to create the required SchM API
for these exclusive areas. This implicitly verifies that the BSWMD
is syntactically and semantically correct.  MemIf's static code
makes use of this API (and the respective #defines) thus causing
compile/link errors if the BSWMD does not contain the correct
information.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemIf.EB.MEMIF_900</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>59</internalId></provcov>
        <provcov>
          <linksto>MemIf.EB.MEMIF_901</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>60</internalId></provcov>
        <provcov>
          <linksto>MemIf.EB.BSWMDGeneration_3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>58</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>123</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_MEMIF_30031</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/test/ts5/Include/MemIf_ConTest_01_Common/source/application/Tests.c</sourcefile>
      <sourceline>77</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Detection of invalid device indices passed to API function MemIf_Read.
&lt;/para&gt;

Test Object: None.
Test Precondition: 


Test Execution: 
 Call function MemIf_Read thrice with first parameter DeviceIndex equal to:
MEM_IF_NUMBER_OF_DEVICES
0xFF
0x01 (not associated with an abstraction)

Test Input: 

Test Output: 
The function MemIf_Read detects the invalid value of parameter DeviceIndex and
reports an error.
In each of the two invokations of MemIf_Read the function reports error
MEMIF_E_PARAM_DEVICE to the Development Error Tracer (DET).
The function always returns E_NOT_OK.
No API function of any underlying memory abstraction module is invoked.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00006</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>22</internalId></provcov>
        <provcov>
          <linksto>MemIf.ASR40.SWS_MemIf_00007</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1</internalId></provcov>
        <provcov>
          <linksto>MemIf.ASR40.SWS_MemIf_00058</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>8</internalId></provcov>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00011</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>24</internalId></provcov>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00022</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>29</internalId></provcov>
        <provcov>
          <linksto>MemIf.ASR40.SWS_MemIf_00023</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>17</internalId></provcov>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00024</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>30</internalId></provcov>
        <provcov>
          <linksto>MemIf.EB.MEMIF_900</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>59</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>124</internalId></specobject>
    <specobject>
      <id>TS_MEMIF_30017</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/test/ts5/Include/MemIf_ConTest_01_Common/source/application/Tests.c</sourcefile>
      <sourceline>204</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Detection of invalid device indices passed to API function MemIf_Write.
&lt;/para&gt;

Test Object: None.
Test Precondition: 


Test Execution: 
 Call function MemIf_Write thrice with first parameter DeviceIndex equal to:
MEM_IF_NUMBER_OF_DEVICES
0xFF
0x01 (not associated with an abstraction)

Test Input: 

Test Output: 
The function MemIf_Write detects the invalid value of parameter DeviceIndex
and reports an error.
In each of the two invokations of MemIf_Write the function reports error
MEMIF_E_PARAM_DEVICE to the Development Error Tracer (DET).
The function always returns E_NOT_OK.
No API function of any underlying memory abstraction module is invoked.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00006</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>22</internalId></provcov>
        <provcov>
          <linksto>MemIf.ASR40.SWS_MemIf_00007</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1</internalId></provcov>
        <provcov>
          <linksto>MemIf.ASR40.SWS_MemIf_00058</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>8</internalId></provcov>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00011</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>24</internalId></provcov>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00022</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>29</internalId></provcov>
        <provcov>
          <linksto>MemIf.ASR40.SWS_MemIf_00023</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>17</internalId></provcov>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00024</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>30</internalId></provcov>
        <provcov>
          <linksto>MemIf.EB.MEMIF_900</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>59</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>125</internalId></specobject>
    <specobject>
      <id>TS_MEMIF_30034</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/test/ts5/Include/MemIf_ConTest_01_Common/source/application/Tests.c</sourcefile>
      <sourceline>328</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Detection of invalid device indices passed to API function MemIf_Cancel.
&lt;/para&gt;

Test Object: None.
Test Precondition: 


Test Execution: 
 Call function MemIf_Cancel thrice with parameter DeviceIndex equal to:
MEM_IF_NUMBER_OF_DEVICES
0xFF
0x01 (not associated with an abstraction)

Test Input: 

Test Output: 
The function MemIf_Cancel detects the invalid value of parameter DeviceIndex
and reports an error.
In each of the two invokations of MemIf_Cancel the function reports error
MEMIF_E_PARAM_DEVICE to the Development Error Tracer (DET).
No API function of any underlying memory abstraction module is invoked.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00006</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>22</internalId></provcov>
        <provcov>
          <linksto>MemIf.ASR40.SWS_MemIf_00007</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1</internalId></provcov>
        <provcov>
          <linksto>MemIf.ASR40.SWS_MemIf_00058</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>8</internalId></provcov>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00011</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>24</internalId></provcov>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00022</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>29</internalId></provcov>
        <provcov>
          <linksto>MemIf.ASR40.SWS_MemIf_00023</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>17</internalId></provcov>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00024</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>30</internalId></provcov>
        <provcov>
          <linksto>MemIf.EB.MEMIF_900</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>59</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>126</internalId></specobject>
    <specobject>
      <id>TS_MEMIF_30035</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/test/ts5/Include/MemIf_ConTest_01_Common/source/application/Tests.c</sourcefile>
      <sourceline>437</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Detection of invalid device indices passed to API function MemIf_GetStatus.
&lt;/para&gt;

Test Object: None.
Test Precondition: 


Test Execution: 
Call function MemIf_GetStatus with parameter DeviceIndex equal to
MEM_IF_NUMBER_OF_DEVICES.
Call function MemIf_GetStatus with parameter DeviceIndex greater than
MEM_IF_NUMBER_OF_DEVICES.

Test Input: 

Test Output: 
The function MemIf_GetStatus detects the invalid value of parameter
DeviceIndex and reports an error.
Function MemIf_GetStatus reports error MEMIF_E_PARAM_DEVICE to the Development
Error Tracer (DET).
The function returns MEMIF_UNINT.
No API function of any underlying memory abstraction module is invoked.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00006</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>22</internalId></provcov>
        <provcov>
          <linksto>MemIf.ASR40.SWS_MemIf_00007</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1</internalId></provcov>
        <provcov>
          <linksto>MemIf.ASR40.SWS_MemIf_00058</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>8</internalId></provcov>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00011</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>24</internalId></provcov>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00022</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>29</internalId></provcov>
        <provcov>
          <linksto>MemIf.ASR40.SWS_MemIf_00023</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>17</internalId></provcov>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00024</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>30</internalId></provcov>
        <provcov>
          <linksto>MemIf.EB.MEMIF_900</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>59</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>127</internalId></specobject>
    <specobject>
      <id>TS_MEMIF_30033</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/test/ts5/Include/MemIf_ConTest_01_Common/source/application/Tests.c</sourcefile>
      <sourceline>543</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Detection of invalid device indices passed to API function MemIf_GetJobResult.
&lt;/para&gt;

Test Object: None.
Test Precondition: 


Test Execution: 
 Call function MemIf_GetJobResult thrice with parameter DeviceIndex equal to:
MEM_IF_NUMBER_OF_DEVICES
0xFF
0x01 (not associated with an abstraction)

Test Input: 

Test Output: 
The function MemIf_GetJobresult detects the invalid value of parameter
DeviceIndex and reports an error.
In each of the two invokations of MemIf_GetJobResult the function reports
error MEMIF_E_PARAM_DEVICE to the Development Error Tracer (DET).
The function always returns MEMIF_JOB_FAILED.
No API function of any underlying memory abstraction module is invoked.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00006</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>22</internalId></provcov>
        <provcov>
          <linksto>MemIf.ASR40.SWS_MemIf_00007</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1</internalId></provcov>
        <provcov>
          <linksto>MemIf.ASR40.SWS_MemIf_00058</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>8</internalId></provcov>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00011</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>24</internalId></provcov>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00022</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>29</internalId></provcov>
        <provcov>
          <linksto>MemIf.ASR40.SWS_MemIf_00023</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>17</internalId></provcov>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00024</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>30</internalId></provcov>
        <provcov>
          <linksto>MemIf.EB.MEMIF_900</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>59</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>128</internalId></specobject>
    <specobject>
      <id>TS_MEMIF_30036</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/test/ts5/Include/MemIf_ConTest_01_Common/source/application/Tests.c</sourcefile>
      <sourceline>667</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Detection of invalid device indices passed to API function
MemIf_InvalidateBlock.
&lt;/para&gt;

Test Object: None.
Test Precondition: 


Test Execution: 
Call function MemIf_InvalidateBlock thrice with first parameter DeviceIndex
equal to:
MEM_IF_NUMBER_OF_DEVICES
0xFF
0x01

Test Input: 

Test Output: 
The function MemIf_InvalidateBlock detects the invalid value of parameter
DeviceIndex and reports an error.
In each of the two invokations of MemIf_InvalidateBlock the function reports
error MEMIF_E_PARAM_DEVICE to the Development Error Tracer (DET).
The function always returns E_NOT_OK.
No API function of any underlying memory abstraction module is invoked.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00006</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>22</internalId></provcov>
        <provcov>
          <linksto>MemIf.ASR40.SWS_MemIf_00007</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1</internalId></provcov>
        <provcov>
          <linksto>MemIf.ASR40.SWS_MemIf_00058</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>8</internalId></provcov>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00011</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>24</internalId></provcov>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00022</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>29</internalId></provcov>
        <provcov>
          <linksto>MemIf.ASR40.SWS_MemIf_00023</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>17</internalId></provcov>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00024</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>30</internalId></provcov>
        <provcov>
          <linksto>MemIf.EB.MEMIF_900</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>59</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>129</internalId></specobject>
    <specobject>
      <id>TS_MEMIF_30032</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/test/ts5/Include/MemIf_ConTest_01_Common/source/application/Tests.c</sourcefile>
      <sourceline>793</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Detection of invalid device indices passed to API function
MemIf_EraseImmediateBlock.
&lt;/para&gt;

Test Object: None.
Test Precondition: 


Test Execution: 
Call function MemIf_EraseImmediateBlock thrice with first parameter DeviceIndex
equal to:
MEM_IF_NUMBER_OF_DEVICES
0xFF
0x01 (not associated with an abstraction)

Test Input: 

Test Output: 
The function MemIf_EraseImmediateBlock detects the invalid value of parameter
DeviceIndex and reports an error.
In each of the two invokations of MemIf_EraseImmediateBlock the function
reports error MEMIF_E_PARAM_DEVICE to the Development Error Tracer (DET).
The function always returns E_NOT_OK.
No API function of any underlying memory abstraction module is invoked.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00006</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>22</internalId></provcov>
        <provcov>
          <linksto>MemIf.ASR40.SWS_MemIf_00007</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1</internalId></provcov>
        <provcov>
          <linksto>MemIf.ASR40.SWS_MemIf_00058</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>8</internalId></provcov>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00011</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>24</internalId></provcov>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00022</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>29</internalId></provcov>
        <provcov>
          <linksto>MemIf.ASR40.SWS_MemIf_00023</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>17</internalId></provcov>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00024</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>30</internalId></provcov>
        <provcov>
          <linksto>MemIf.EB.MEMIF_900</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>59</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>130</internalId></specobject>
    <specobject>
      <id>TS_MEMIF_30152</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/test/ts5/Include/MemIf_ConTest_01_Common/source/application/Tests.c</sourcefile>
      <sourceline>920</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
The API function MemIf_SetMode shall invoke the corresponding function for all
underlying modules.
&lt;/para&gt;

Test Object: None.
Test Precondition: 


Test Execution: 
Call function MemIf_SetMode once with parameter value MEMIF_MODE_SLOW, once
with MEMIF_MODE_FAST.

Test Input: 

Test Output: 

The corresponding function i.e. Fee_SetMode or Ea_SetMode is invoked for all
underlying modules with the parameter passed to MemIf_SetMode
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemIf.MEMIF_018_1</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>47</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>131</internalId></specobject>
    <specobject>
      <id>TS_MEMIF_30154</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/test/ts5/Include/MemIf_ConTest_01_Common/source/application/Tests.c</sourcefile>
      <sourceline>964</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
The API function MemIf_Read shall invoke the corresponding function of the
underlying module specified by parameter DeviceIndex.
&lt;/para&gt;

Test Object: None.
Test Precondition: 


Test Execution: 
 Call function
MemIf_Read (
    (uint8)( i ),  DeviceIndex
    (uint16)( 10*i + 1 ), BlockNumber
    (uint16)( 100*i + 2 ),  BlockOffset
    (uint8 *)( 1000*i + 3),  DataBufferReadPtr
    (uint16)( 1111*i  + 1) Length
)
for i in [0,3].


Test Input: 

Test Output: 

The corresponding function of underlying device [i] is invoked as
[Fee,Ea]_Read (
    (uint16)( 10*i + 1 ),  BlockNumber
    (uint16)( 100*i + 2 ),  BlockOffset
    (uint8 *)( 1000*i + 3),  DataBufferReadPtr
    (uint16)( 1111*i  + 1)  Length
).
MemIf_Read loops through the return value of the underlying module's read
function.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemIf.MEMIF_018_1</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>47</internalId></provcov>
        <provcov>
          <linksto>MemIf.MEMIF_018_1_MemAcc</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>48</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>132</internalId></specobject>
    <specobject>
      <id>TS_MEMIF_30156</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/test/ts5/Include/MemIf_ConTest_01_Common/source/application/Tests.c</sourcefile>
      <sourceline>1025</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
The API function MemIf_Write shall invoke the corresponding function of the
underlying module specified by parameter DeviceIndex.
&lt;/para&gt;

Test Object: None.
Test Precondition: 


Test Execution: 
 Call function
MemIf_Write (
    (uint8)( i ),  DeviceIndex
    (uint16)( 10*i + 1 ),  BlockNumber
    (uint8 *)( 1000*i + 3),  DataBufferWritePtr
)
for i in [0,3].


Test Input: 

Test Output: 

The corresponding function of underlying device [i] is invoked as
[Fee,Ea]_Write (
    (uint16)( 10*i + 1 ),  BlockNumber
    (uint8 *)( 1000*i + 3),  DataBufferWritePtr
).
MemIf_Write loops through the return value of the underlying module's write
function.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemIf.MEMIF_018_1</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>47</internalId></provcov>
        <provcov>
          <linksto>MemIf.MEMIF_018_1_MemAcc</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>48</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>133</internalId></specobject>
    <specobject>
      <id>TS_MEMIF_30158</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/test/ts5/Include/MemIf_ConTest_01_Common/source/application/Tests.c</sourcefile>
      <sourceline>1081</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
The API function MemIf_Cancel shall invoke the corresponding function of the
underlying module specified by parameter DeviceIndex.
&lt;/para&gt;

Test Object: None.
Test Precondition: 


Test Execution: 
 Call function
MemIf_Cancel( i ) for i in [0,3].

Test Input: 

Test Output: 

The corresponding function of underlying device [i] is invoked.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemIf.MEMIF_018_1</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>47</internalId></provcov>
        <provcov>
          <linksto>MemIf.MEMIF_018_1_MemAcc</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>48</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>134</internalId></specobject>
    <specobject>
      <id>TS_MEMIF_30019</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/test/ts5/Include/MemIf_ConTest_01_Common/source/application/Tests.c</sourcefile>
      <sourceline>1125</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Function MemIf_GetStatus shall interprete value 0xFF of parameter DeviceIndex
as "broadcast".
&lt;/para&gt;

Test Object: None.
Test Precondition: 


Test Execution: 
Call function MemIf_GetStatus with parameter DeviceIndex equal to 0xFF. All
underlying modules are controlled to return MEMIF_IDLE, because this is the
only case an invocation of all unlerlying modules' to be called.

Test Input: 

Test Output: 
Function MemIf_GetStatus interprets parameter DeviceIndex equal to 0xFF as
"all underlying devices".
The respective GetStatus function (Ea_getStatus or Fee_GetStatus) of all
underlying memory abstraction modules in invoked.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00035</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>31</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>135</internalId></specobject>
    <specobject>
      <id>TS_MEMIF_30041</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/test/ts5/Include/MemIf_ConTest_01_Common/source/application/Tests.c</sourcefile>
      <sourceline>1170</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Return value of function MemIf_GetStatus in case of a "broadcast call": All
underlying modules return MEMIF_IDLE.
&lt;/para&gt;

Test Object: None.
Test Precondition: 


Test Execution: 
Call function MemIf_GetStatus with parameter DeviceIndex equal to 0xFF and
generate the following responses of the underlying memory abstraction modules:
All underlying modules return MEMIF_IDLE.

Test Input: 

Test Output: 

MemIf_GetStatus returns MEMIF_IDLE.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00035</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>31</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>136</internalId></specobject>
    <specobject>
      <id>TS_MEMIF_30040</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/test/ts5/Include/MemIf_ConTest_01_Common/source/application/Tests.c</sourcefile>
      <sourceline>1214</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Return value of function MemIf_GetStatus in case of a "broadcast call": Only
one underlying module returns MEMIF_UNINIT.
&lt;/para&gt;

Test Object: None.
Test Precondition: 


Test Execution: 
Call function MemIf_GetStatus four times with parameter DeviceIndex equal to
0xFF. The return values of the underlying modules' functions are given in the
table below.

Test Input: 

Test Output: 

MemIf_GetStatus returns MEMIF_UNINIT.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00035</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>31</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>137</internalId></specobject>
    <specobject>
      <id>TS_MEMIF_30042</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/test/ts5/Include/MemIf_ConTest_01_Common/source/application/Tests.c</sourcefile>
      <sourceline>1258</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Return value of function MemIf_GetStatus in case of a "broadcast call": At
least one underlying module returns MEMIF_BUSY and none of them returns
MEMIF_UINIT.
&lt;/para&gt;

Test Object: None.
Test Precondition: 


Test Execution: 
Call function MemIf_GetStatus four times with parameter DeviceIndex equal to
0xFF. The return values of the underlying modules' functions are given in the
table below.

Test Input: 

Test Output: 

MemIf_GetStatus returns the value given in the table below.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00035</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>31</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>138</internalId></specobject>
    <specobject>
      <id>TS_MEMIF_30043</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/test/ts5/Include/MemIf_ConTest_01_Common/source/application/Tests.c</sourcefile>
      <sourceline>1303</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Return value of function MemIf_GetStatus in case of a "broadcast call": At
least one underlying module returns MEMIF_BUSY_INTERNAL and no other device
returns MEMIF_BUSY or MEMIF_UNINIT.
&lt;/para&gt;

Test Object: None.
Test Precondition: 


Test Execution: 
Call function MemIf_GetStatus four times with parameter DeviceIndex equal to
0xFF. The return values of the underlying modules' functions are given in the
table below.

Test Input: 

Test Output: 

MemIf_GetStatus returns the value given in the table below.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00035</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>31</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>139</internalId></specobject>
    <specobject>
      <id>TS_MEMIF_30044</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/test/ts5/Include/MemIf_ConTest_01_Common/source/application/Tests.c</sourcefile>
      <sourceline>1347</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Invokes the "GetStatus" function of the underlying memory abstraction module selected 
by the parameter DeviceIndex.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
01. VP (MemIf024):
The function MemIf_GetStatus detects the invalid value of parameter
DeviceIndex and reports an error.
In the invocation of MemIf_GetStatus the function
reports error MEMIF_E_PARAM_DEVICE to the Development Error Tracer (DET).
The function always returns MEMIF_UNINIT.
No API function of any underlying memory abstraction module is invoked.
02. Prescribe return value MEMIF_IDLE for all underlying modules.
03. Call function MemIf_GetStatus with parameter DeviceIndex equal to 2.
04. VP (MemIf042):
    Check the specified underlying module returns MEMIF_IDLE.


Test Input: 

Test Output: 
Function MemIf_GetStatus interprets parameter DeviceIndex equal to 2 and returns the status MEMIF_IDLE.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00042</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>36</internalId></provcov>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00024</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>30</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>140</internalId></specobject>
    <specobject>
      <id>TS_MEMIF_30160</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/test/ts5/Include/MemIf_ConTest_01_Common/source/application/Tests.c</sourcefile>
      <sourceline>1439</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
The API function MemIf_GetJobResult shall invoke the corresponding function of
the underlying module specified by parameter DeviceIndex.
&lt;/para&gt;

Test Object: None.
Test Precondition: 


Test Execution: 
Call function MemIf_GetJobResult( i ) for i in [0,3]. The implementation of
the corresponding underlying modules' replacement functions provide four
different return values:
device [0]: MEMIF_JOB_OK
device [1]: MEMIF_JOB_PENDING
device [2]: MEMIF_JOB_CANCELED
device [3]: MEMIF_JOB_FAILED.

Test Input: 

Test Output: 

The corresponding function of the underlying device module [i] is invoked.
MemIf_GetJobResult loops through the return value of the underlying module's
function.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemIf.MEMIF_018_1</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>47</internalId></provcov>
        <provcov>
          <linksto>MemIf.MEMIF_018_1_MemAcc</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>48</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>141</internalId></specobject>
    <specobject>
      <id>TS_MEMIF_30022</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/test/ts5/Include/MemIf_ConTest_01_Common/source/application/Tests.c</sourcefile>
      <sourceline>1490</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
The API function MemIf_InvalidateBlock shall invoke the corresponding function
of the underlying module specified by paramter DeviceIndex.
&lt;/para&gt;

Test Object: None.
Test Precondition: 


Test Execution: 
 Call function
MemIf_InvalidateBlock (
    i,  DeviceIndex
    10*i + 1  BlockNumber
)
for i in [0,3].
The underlying module's replacement functions provide return the following
values:
device [0]: E_OK
device [1]: E_OK
device [2]: E_NOT_OK
device [3]: E_OK

Test Input: 

Test Output: 

The corresponding function of the underlying device module [i] is invoked with
parameter (10*i +1).
MemIf_InvalidateBlock loops through the return value of the underlying
module's function.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemIf.MEMIF_018_1</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>47</internalId></provcov>
        <provcov>
          <linksto>MemIf.MEMIF_018_1_MemAcc</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>48</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>142</internalId></specobject>
    <specobject>
      <id>TS_MEMIF_30024</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/test/ts5/Include/MemIf_ConTest_01_Common/source/application/Tests.c</sourcefile>
      <sourceline>1547</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
The API function MemIf_GetVersionInfo shall be available, if preprocessor
switch MEMIF_VERSION_INFO_API is enabled, and shall provide the version info
for module MemIf.
&lt;/para&gt;

Test Object: None.
Test Precondition: 


Test Execution: 
 Call function MemIf_GetVersionInfo.
Compare the data provided by the function with the version values published as
MEMIF_VENDOR_ID, MEMIF_MODULE_ID, MEMIF_SW_MAJOR_VERSION,
MEMIF_SW_MINOR_VERSION,MEMIF_SW_PATCH_VERSION.

Test Input: 

Test Output: 

After the function call the values provided in the passed data structur
VersionInfoPtr correspond with the published data:
VersionInfoPtr-&amp;gt;vendorID == MEMIF_VENDOR_ID
VersionInfoPtr-&amp;gt;moduleID == MEMIF_MODULE_ID
VersionInfoPtr-&amp;gt;sw_major_version == MEMIF_SW_MAJOR_VERSION
VersionInfoPtr-&amp;gt;sw_minor_version == MEMIF_SW_MINOR_VERSION
VersionInfoPtr-&amp;gt;sw_patch_version == MEMIF_SW_PATCH_VERSION.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00045</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>39</internalId></provcov>
        <provcov>
          <linksto>MemIf.ASR40.SWS_MemIf_00057</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>7</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>143</internalId></specobject>
    <specobject>
      <id>TS_MEMIF_30164</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/test/ts5/Include/MemIf_ConTest_01_Common/source/application/Tests.c</sourcefile>
      <sourceline>1600</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
The API function MemIf_EraseImmediateBlock shall invoke the corresponding
function of the underlying module specified by parameter DeviceIndex.
&lt;/para&gt;

Test Object: None.
Test Precondition: 


Test Execution: 
 Call function
MemIf_EraseImmediateBlock (
    i,  DeviceIndex
    10*i + 1  BlockNumber
)
for i in [0,3].
The underlying module's replacement functions provide return the following
values:
device [0]: E_NOT_OK
device [1]: E_NOT_OK
device [2]: E_OK
device [3]: E_OK

Test Input: 

Test Output: 

The corresponding function of the underlying device module [i] is invoked with
parameter (10*i + 1).
MemIf_EraseImmediateBlock loops through the return value of the underlying
module's function.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemIf.MEMIF_018_1</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>47</internalId></provcov>
        <provcov>
          <linksto>MemIf.MEMIF_018_1_MemAcc</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>48</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>144</internalId></specobject>
    <specobject>
      <id>TS_MEMIF_30165</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/test/ts5/Include/MemIf_ConTest_01_Common/source/application/Tests.c</sourcefile>
      <sourceline>1656</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Check if an error is reported to the DET when the version info is requested passing a
NULL pointer for the VersionInfo
&lt;/para&gt;

Test Object: None.
Test Precondition: None.
Test Execution: None.
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00045</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>39</internalId></provcov>
        <provcov>
          <linksto>MemIf.ASR40.SWS_MemIf_00063</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>13</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>145</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_MEMIF_30177</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/test/ts5/Include/MemIf_ConTest_02_Common/source/application/Tests.c</sourcefile>
      <sourceline>51</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
The API function MemIf_SetMode shall invoke the corresponding function for all
underlying modules.
&lt;/para&gt;

Test Object: None.
Test Precondition: 


Test Execution: 
Call function MemIf_SetMode once with parameter value MEMIF_MODE_SLOW, once
with MEMIF_MODE_FAST.

Test Input: 

Test Output: 
The corresponding function i.e. Fee_SetMode or Ea_SetMode is invoked for all
underlying modules with the parameter passed to MemIf_SetMode
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemIf.ASR40.SWS_MemIf_00038</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>15</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>146</internalId></specobject>
    <specobject>
      <id>TS_MEMIF_30179</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/test/ts5/Include/MemIf_ConTest_02_Common/source/application/Tests.c</sourcefile>
      <sourceline>97</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
The API function MemIf_Read shall invoke the corresponding function of the
underlying module specified by parameter DeviceIndex.
&lt;/para&gt;

Test Object: None.
Test Precondition: 


Test Execution: 
 Call function
MemIf_Read (
    (uint8)( i ),  DeviceIndex
    (uint16)( 10*i + 1 ),  BlockNumber
    (uint16)( 100*i + 2 ),  BlockOffset
    (uint8 *)( 1000*i + 3),  DataBufferReadPtr
    (uint16)( 1111*i  + 1)  Length
)
for i in [0,3].


Test Input: 

Test Output: 

The corresponding function of underlying device [i] is invoked as
[Fee,Ea]_Read (
    (uint16)( 10*i + 1 ),  BlockNumber
    (uint16)( 100*i + 2 ),  BlockOffset
    (uint8 *)( 1000*i + 3),  DataBufferReadPtr
    (uint16)( 1111*i  + 1)  Length
).
MemIf_Read loops through the return value of the underlying module's read
function.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00039</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>33</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>147</internalId></specobject>
    <specobject>
      <id>TS_MEMIF_30181</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/test/ts5/Include/MemIf_ConTest_02_Common/source/application/Tests.c</sourcefile>
      <sourceline>161</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
The API function MemIf_Write shall invoke the corresponding function of the
underlying module specified by parameter DeviceIndex.
&lt;/para&gt;

Test Object: None.
Test Precondition: 


Test Execution: 
 Call function
MemIf_Write (
    (uint8)( i ), DeviceIndex
    (uint16)( 10*i + 1 ),  BlockNumber
    (uint8 *)( 1000*i + 3),  DataBufferWritePtr
)
for i in [0,3].


Test Input: 

Test Output: 

The corresponding function of underlying device [i] is invoked as
[Fee,Ea]_Write (
    (uint16)( 10*i + 1 ),  BlockNumber
    (uint8 *)( 1000*i + 3), DataBufferWritePtr
).
MemIf_Write loops through the return value of the underlying module's write
function.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemIf.MemIf_Write.Service</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>54</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>148</internalId></specobject>
    <specobject>
      <id>TS_MEMIF_30311</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/test/ts5/Include/MemIf_ConTest_02_Common/source/application/Tests.c</sourcefile>
      <sourceline>216</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
The API function MemIf_Cancel shall invoke the corresponding function of the
underlying module specified by parameter DeviceIndex.
&lt;/para&gt;

Test Object: None.
Test Precondition: 


Test Execution: 
 Call function
MemIf_Cancel( i ) for i in [0,3].

Test Input: 

Test Output: 

The corresponding function of underlying device [i] is invoked.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00041</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>35</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>149</internalId></specobject>
    <specobject>
      <id>TS_MEMIF_30185</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/test/ts5/Include/MemIf_ConTest_02_Common/source/application/Tests.c</sourcefile>
      <sourceline>259</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Function MemIf_GetStatus shall interprete value MEMIF_BROADCAST_ID (0xFF) of
parameter DeviceIndex as "broadcast".
&lt;/para&gt;

Test Object: None.
Test Precondition: 


Test Execution: 
Call function MemIf_GetStatus with parameter DeviceIndex equal to
MEMIF_BROADCAST_ID. All underlying modules are controlled to return
MEMIF_IDLE, because this is the only case an invocation of all unlerlying
modules' to be called.

Test Input: 

Test Output: 
Function MemIf_GetStatus interprets parameter DeviceIndex equal to
MEMIF_BROADCAST_ID as "all underlying devices".  The respective GetStatus
function (Ea_getStatus or Fee_GetStatus) of all underlying memory abstraction
modules in invoked.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00042</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>36</internalId></provcov>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00035</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>31</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>150</internalId></specobject>
    <specobject>
      <id>TS_MEMIF_30188</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/test/ts5/Include/MemIf_ConTest_02_Common/source/application/Tests.c</sourcefile>
      <sourceline>306</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Return value of function MemIf_GetStatus in case of a "broadcast call": All
underlying modules return MEMIF_IDLE.
&lt;/para&gt;

Test Object: None.
Test Precondition: 


Test Execution: 
Call function MemIf_GetStatus with parameter DeviceIndex equal to
MEMIF_BROADCAST_ID and generate the following responses of the underlying
memory abstraction modules: All underlying modules return MEMIF_IDLE.

Test Input: 

Test Output: 

MemIf_GetStatus returns MEMIF_IDLE.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00042</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>36</internalId></provcov>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00035</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>31</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>151</internalId></specobject>
    <specobject>
      <id>TS_MEMIF_30189</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/test/ts5/Include/MemIf_ConTest_02_Common/source/application/Tests.c</sourcefile>
      <sourceline>351</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Return value of function MemIf_GetStatus in case of a "broadcast call": Only
one underlying module returns MEMIF_UNINIT.
&lt;/para&gt;

Test Object: None.
Test Precondition: 


Test Execution: 
Call function MemIf_GetStatus four times with parameter DeviceIndex equal to
MEMIF_BROADCAST_ID. The return values of the underlying modules' functions are
given in the table below.

Test Input: 

Test Output: 

MemIf_GetStatus returns MEMIF_UNINIT.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00042</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>36</internalId></provcov>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00035</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>31</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>152</internalId></specobject>
    <specobject>
      <id>TS_MEMIF_30221</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/test/ts5/Include/MemIf_ConTest_02_Common/source/application/Tests.c</sourcefile>
      <sourceline>396</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Return value of function MemIf_GetStatus in case of a "broadcast call": At
least one underlying module returns MEMIF_BUSY and none of them returns
MEMIF_UINIT.
&lt;/para&gt;

Test Object: None.
Test Precondition: 


Test Execution: 
Call function MemIf_GetStatus four times with parameter DeviceIndex equal to
MEMIF_BROADCAST_ID. The return values of the underlying modules' functions are
given in the table below.

Test Input: 

Test Output: 

MemIf_GetStatus returns the value given in the table below.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00042</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>36</internalId></provcov>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00035</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>31</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>153</internalId></specobject>
    <specobject>
      <id>TS_MEMIF_30259</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/test/ts5/Include/MemIf_ConTest_02_Common/source/application/Tests.c</sourcefile>
      <sourceline>442</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Return value of function MemIf_GetStatus in case of a "broadcast call": At
least one underlying module returns MEMIF_BUSY_INTERNAL and no other device
returns MEMIF_BUSY or MEMIF_UNINIT.
&lt;/para&gt;

Test Object: None.
Test Precondition: 


Test Execution: 
Call function MemIf_GetStatus four times with parameter DeviceIndex equal to
MEMIF_BROADCAST_ID. The return values of the underlying modules' functions are
given in the table below.

Test Input: 

Test Output: 

MemIf_GetStatus returns the value given in the table below.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00042</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>36</internalId></provcov>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00035</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>31</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>154</internalId></specobject>
    <specobject>
      <id>TS_MEMIF_30298</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/test/ts5/Include/MemIf_ConTest_02_Common/source/application/Tests.c</sourcefile>
      <sourceline>488</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
The API function MemIf_GetJobResult shall invoke the corresponding function of
the underlying module specified by parameter DeviceIndex.
&lt;/para&gt;

Test Object: None.
Test Precondition: 


Test Execution: 
Call function MemIf_GetJobResult( i ) for i in [0,3]. The implementation of
the corresponding underlying modules' replacement functions provide four
different return values:
device [0]: MEMIF_JOB_OK
device [1]: MEMIF_JOB_PENDING
device [2]: MEMIF_JOB_CANCELED
device [3]: MEMIF_JOB_FAILED.

Test Input: 

Test Output: 

The corresponding function of the underlying device module [i] is invoked.
MemIf_GetJobResult loops through the return value of the underlying module's
function.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00043</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>37</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>155</internalId></specobject>
    <specobject>
      <id>TS_MEMIF_30300</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/test/ts5/Include/MemIf_ConTest_02_Common/source/application/Tests.c</sourcefile>
      <sourceline>538</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
The API function MemIf_InvalidateBlock shall invoke the corresponding function
of the underlying module specified by paramter DeviceIndex.
&lt;/para&gt;

Test Object: None.
Test Precondition: 


Test Execution: 
 Call function
MemIf_InvalidateBlock (
    i, DeviceIndex
    10*i + 1  BlockNumber
)
for i in [0,3].
The underlying module's replacement functions provide return the following
values:
device [0]: E_OK
device [1]: E_OK
device [2]: E_NOT_OK
device [3]: E_OK

Test Input: 

Test Output: 

The corresponding function of the underlying device module [i] is invoked with
parameter (10*i +1).  MemIf_InvalidateBlock loops through the return value of
the underlying module's function.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00044</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>38</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>156</internalId></specobject>
    <specobject>
      <id>TS_MEMIF_30302</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/test/ts5/Include/MemIf_ConTest_02_Common/source/application/Tests.c</sourcefile>
      <sourceline>593</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
The API function MemIf_EraseImmediateBlock shall invoke the corresponding
function of the underlying module specified by parameter DeviceIndex.
&lt;/para&gt;

Test Object: None.
Test Precondition: 


Test Execution: 
 Call function
MemIf_EraseImmediateBlock (
    i,  DeviceIndex
    10*i + 1 BlockNumber
)
for i in [0,3].
The underlying module's replacement functions provide return the following
values:
device [0]: E_NOT_OK
device [1]: E_NOT_OK
device [2]: E_OK
device [3]: E_OK

Test Input: 

Test Output: 

The corresponding function of the underlying device module [i] is invoked with
parameter (10*i + 1).  MemIf_EraseImmediateBlock loops through the return
value of the underlying module's function.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00046</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>40</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>157</internalId></specobject>
    <specobject>
      <id>TS_MEMIF_GetStatus</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/test/ts5/Include/MemIf_ConTest_02_Common/source/application/Tests.c</sourcefile>
      <sourceline>647</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Invokes the "GetStatus" function of the underlying memory abstraction module selected 
by the parameter DeviceIndex.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
01. Prescribe return value MEMIF_IDLE for all underlying modules.
02. Call function MemIf_GetStatus with parameter DeviceIndex equal to 2.
03. VP (MemIf042):
    Check the specified underlying module returns MEMIF_IDLE.

Test Input: 

Test Output: 
Function MemIf_GetStatus interprets parameter DeviceIndex equal to 2 and returns the status MEMIF_IDLE.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00042</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>36</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>158</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_MEMIF_30305</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/test/ts5/Include/MemIf_ConTest_03_Common/source/application/Tests.c</sourcefile>
      <sourceline>51</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
The API function MemIf_SetMode shall invoke the corresponding function for all
underlying modules.
&lt;/para&gt;

Test Object: None.
Test Precondition: 


Test Execution: 
Call function MemIf_SetMode once with parameter value MEMIF_MODE_SLOW, once
with MEMIF_MODE_FAST.

Test Input: 

Test Output: 
The corresponding function i.e. Fee_SetMode or Ea_SetMode is invoked for all
underlying modules with the parameter passed to MemIf_SetMode.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemIf.ASR40.SWS_MemIf_00038</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>15</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>159</internalId></specobject>
    <specobject>
      <id>TS_MEMIF_30307</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/test/ts5/Include/MemIf_ConTest_03_Common/source/application/Tests.c</sourcefile>
      <sourceline>98</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
The API function MemIf_Read shall ignore parameter DeviceIndex and invoke the
corresponding function of the underlying module.
&lt;/para&gt;

Test Object: None.
Test Precondition: 


Test Execution: 
 Call function
MemIf_Read (
    5,  DeviceIndex
    6,  BlockNumber
    7, BlockOffset
    (uint8 *)(8), DataBufferReadPtr
    9  Length
).


Test Input: 

Test Output: 

The corresponding function of the underlying device is invoked as
[Fee,Ea]_Read (
    6,  BlockNumber
    7, BlockOffset
    8, DataBufferReadPtr
    9  Length
).
MemIf_Read loops through the return value of the underlying module's read
function.

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00039</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>33</internalId></provcov>
        <provcov>
          <linksto>MemIf.MEMIF_018_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>49</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>160</internalId></specobject>
    <specobject>
      <id>TS_MEMIF_30309</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/test/ts5/Include/MemIf_ConTest_03_Common/source/application/Tests.c</sourcefile>
      <sourceline>209</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
The API function MemIf_Write shall ignore parameter DeviceIndex and invoke the
corresponding function of the underlying module.
&lt;/para&gt;

Test Object: None.
Test Precondition: 


Test Execution: 
 Call function
MemIf_Write (
    5, DeviceIndex
    6,  BlockNumber
    7,  DataBufferWritePtr
).

Test Input: 

Test Output: 

The corresponding function of the underlying device is invoked as
[Fee,Ea]_Write (
    6,  BlockNumber
    7,  DataBufferWritePtr
).
MemIf_Write loops through the return value of the underlying module's read
function.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemIf.MemIf_Write.Service</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>54</internalId></provcov>
        <provcov>
          <linksto>MemIf.MEMIF_018_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>49</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>161</internalId></specobject>
    <specobject>
      <id>TS_MEMIF_30183</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/test/ts5/Include/MemIf_ConTest_03_Common/source/application/Tests.c</sourcefile>
      <sourceline>306</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
The API function MemIf_Cancel shall ignore parameter DeviceIndex and invoke
the corresponding function of the underlying module.
&lt;/para&gt;

Test Object: None.
Test Precondition: 


Test Execution: 
 Call function MemIf_Cancel( 5 ).

Test Input: 

Test Output: 

The corresponding function of the underlying device is invoked.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00041</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>35</internalId></provcov>
        <provcov>
          <linksto>MemIf.MEMIF_018_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>49</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>162</internalId></specobject>
    <specobject>
      <id>TS_MEMIF_30313</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/test/ts5/Include/MemIf_ConTest_03_Common/source/application/Tests.c</sourcefile>
      <sourceline>382</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Function MemIf_GetStatus shall ignore parameter DeviceIndex and invoke the
corresponding function of the underlying module.
&lt;/para&gt;

Test Object: None.
Test Precondition: 


Test Execution: 
Call function MemIf_GetStatus( 5 ).  All underlying modules are controlled to
return MEMIF_IDLE, because this is the only case an invocation of all
unlerlying modules' to be called.

Test Input: 

Test Output: 
The respective GetStatus function of the underlying module is invoked.
MemIf_GetStatus loops through the return value of the underlying module's
function.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00042</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>36</internalId></provcov>
        <provcov>
          <linksto>MemIf.MEMIF_018_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>49</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>163</internalId></specobject>
    <specobject>
      <id>TS_MEMIF_30426</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/test/ts5/Include/MemIf_ConTest_03_Common/source/application/Tests.c</sourcefile>
      <sourceline>479</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
The API function MemIf_GetJobResult shall ignore parameter DeviceIndex and
invoke the corresponding function of the underlying module.
&lt;/para&gt;

Test Object: None.
Test Precondition: 


Test Execution: 
 Call function MemIf_GetJobResult( 5 ).

Test Input: 

Test Output: 
The corresponding function of the underlying device module is invoked.
MemIf_GetJobResult loops through the return value of the underlying module's
function.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00043</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>37</internalId></provcov>
        <provcov>
          <linksto>MemIf.MEMIF_018_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>49</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>164</internalId></specobject>
    <specobject>
      <id>TS_MEMIF_30428</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/test/ts5/Include/MemIf_ConTest_03_Common/source/application/Tests.c</sourcefile>
      <sourceline>575</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
The API function MemIf_InvalidateBlock shall ignore parameter DeviceIndex and
invoke the corresponding function of the underlying module.
&lt;/para&gt;

Test Object: None.
Test Precondition: 


Test Execution: 
 Call function
MemIf_InvalidateBlock (
    5,  DeviceIndex
    6   BlockNumber
)

Test Input: 

Test Output: 
The corresponding function of the underlying device module is invoked with
parameter 6.  MemIf_InvalidateBlock loops through the return value of the
underlying module's function.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00044</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>38</internalId></provcov>
        <provcov>
          <linksto>MemIf.MEMIF_018_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>49</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>165</internalId></specobject>
    <specobject>
      <id>TS_MEMIF_30430</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemIf/test/ts5/Include/MemIf_ConTest_03_Common/source/application/Tests.c</sourcefile>
      <sourceline>678</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
The API function MemIf_EraseImmediateBlock shall ignore parameter DeviceIndex
and invoke the corresponding function of the underlying module.
&lt;/para&gt;

Test Object: None.
Test Precondition: 


Test Execution: 
 Call function
MemIf_EraseImmediateBlock (
    5, DeviceIndex
    6  BlockNumber
)

Test Input: 

Test Output: 
The corresponding function of the underlying device module is invoked with
parameter 6.  MemIf_EraseImmediateBlock loops through the return value of the
underlying module's function.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemIf.SWS_MemIf_00046</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>40</internalId></provcov>
        <provcov>
          <linksto>MemIf.MEMIF_018_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>49</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>166</internalId></specobject>
  </specobjects>
  </specdocument>
  <violations/>
  <oreqmViolations/>
</tracingresults>
